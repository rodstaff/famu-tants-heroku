/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(152);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRedux = __webpack_require__(30);
	
	var _app = __webpack_require__(146);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: _store2.default },
	  _react2.default.createElement(_app2.default, null)
	), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(207);


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentFlags = __webpack_require__(103);
	
	var invariant = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(197);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(228);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var warning = __webpack_require__(3);
	var canDefineProperty = __webpack_require__(68);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactReconciler = __webpack_require__(29);
	var Transaction = __webpack_require__(35);
	
	var invariant = __webpack_require__(2);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(5);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(57);
	var setInnerHTML = __webpack_require__(48);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setTextContent = __webpack_require__(123);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(241);
	var ReactInstrumentation = __webpack_require__(11);
	
	var warning = __webpack_require__(3);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(153);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(154);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(58);
	var ReactErrorUtils = __webpack_require__(63);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var invariant = __webpack_require__(2);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var warning = __webpack_require__(3);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(128);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(287);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(286);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(285);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(180);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(194);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(24);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function (inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventConstants = __webpack_require__(17);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactEventEmitterMixin = __webpack_require__(231);
	var ViewportMetrics = __webpack_require__(115);
	
	var getVendorPrefixedEventName = __webpack_require__(263);
	var isEventSupported = __webpack_require__(74);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	var ViewportMetrics = __webpack_require__(115);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var DOMNamespaces = __webpack_require__(57);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(5);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _Actions = __webpack_require__(27);
	
	var _computeChangedRoutes2 = __webpack_require__(178);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(175);
	
	var _isActive2 = __webpack_require__(182);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(179);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(184);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  function createLocationFromRedirectInfo(location) {
	    return history.createLocation(location, _Actions.REPLACE);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, createLocationFromRedirectInfo(redirectInfo));
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.transitionTo(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(28);
	var Danger = __webpack_require__(202);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setInnerHTML = __webpack_require__(48);
	var setTextContent = __webpack_require__(123);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(63);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypes = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var canDefineProperty = __webpack_require__(68);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 69 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 71 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 75 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	
	var getIteratorFn = __webpack_require__(73);
	var invariant = __webpack_require__(2);
	var KeyEscapeUtils = __webpack_require__(59);
	var warning = __webpack_require__(3);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reduxLogger = __webpack_require__(281);
	
	var _reduxLogger2 = _interopRequireDefault(_reduxLogger);
	
	var _reduxThunk = __webpack_require__(284);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reduxPromiseMiddleware = __webpack_require__(282);
	
	var _reduxPromiseMiddleware2 = _interopRequireDefault(_reduxPromiseMiddleware);
	
	var _reducers = __webpack_require__(141);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var middleware = (0, _redux.applyMiddleware)((0, _reduxPromiseMiddleware2.default)(), _reduxThunk2.default, (0, _reduxLogger2.default)());
	
	exports.default = (0, _redux.createStore)(_reducers2.default);
	//export default createStore(reducer, middleware)

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * This action type will be dispatched by the history actions below.
	 * If you're writing a middleware to watch for navigation events, be sure to
	 * look for actions of this type.
	 */
	var CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';
	
	function updateLocation(method) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return {
	      type: CALL_HISTORY_METHOD,
	      payload: { method: method, args: args }
	    };
	  };
	}
	
	/**
	 * These actions correspond to the history API.
	 * The associated routerMiddleware will capture these events before they get to
	 * your reducer and reissue them as the matching function on your history.
	 */
	var push = exports.push = updateLocation('push');
	var replace = exports.replace = updateLocation('replace');
	var go = exports.go = updateLocation('go');
	var goBack = exports.goBack = updateLocation('goBack');
	var goForward = exports.goForward = updateLocation('goForward');
	
	var routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;
	
	var _reducer = __webpack_require__(84);
	
	Object.defineProperty(exports, 'LOCATION_CHANGE', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.LOCATION_CHANGE;
	  }
	});
	Object.defineProperty(exports, 'routerReducer', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.routerReducer;
	  }
	});
	
	var _actions = __webpack_require__(82);
	
	Object.defineProperty(exports, 'CALL_HISTORY_METHOD', {
	  enumerable: true,
	  get: function get() {
	    return _actions.CALL_HISTORY_METHOD;
	  }
	});
	Object.defineProperty(exports, 'push', {
	  enumerable: true,
	  get: function get() {
	    return _actions.push;
	  }
	});
	Object.defineProperty(exports, 'replace', {
	  enumerable: true,
	  get: function get() {
	    return _actions.replace;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _actions.go;
	  }
	});
	Object.defineProperty(exports, 'goBack', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goBack;
	  }
	});
	Object.defineProperty(exports, 'goForward', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goForward;
	  }
	});
	Object.defineProperty(exports, 'routerActions', {
	  enumerable: true,
	  get: function get() {
	    return _actions.routerActions;
	  }
	});
	
	var _sync = __webpack_require__(165);
	
	var _sync2 = _interopRequireDefault(_sync);
	
	var _middleware = __webpack_require__(164);
	
	var _middleware2 = _interopRequireDefault(_middleware);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	exports.syncHistoryWithStore = _sync2['default'];
	exports.routerMiddleware = _middleware2['default'];

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.routerReducer = routerReducer;
	/**
	 * This action type will be dispatched when your history
	 * receives a location change.
	 */
	var LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';
	
	var initialState = {
	  locationBeforeTransitions: null
	};
	
	/**
	 * This reducer will update the state with the most recent location history
	 * has transitioned to. This may not be in sync with the router, particularly
	 * if you have asynchronously-loaded routes, so reading from and relying on
	 * this state is discouraged.
	 */
	function routerReducer() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
	
	  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var type = _ref.type;
	  var payload = _ref.payload;
	
	  if (type === LOCATION_CHANGE) {
	    return _extends({}, state, { locationBeforeTransitions: payload });
	  }
	
	  return state;
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]).isRequired,
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	
	    if (router) {
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(190);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(92);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(20);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(51);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(26);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(173);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(85);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(167);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(186);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(168);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(169);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(86);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(171);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(166);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(170);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(172);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(185);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(38);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(174);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(183);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(92);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(176);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(177);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(181);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(88);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(191);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(24);
	
	var _AsyncUtils = __webpack_require__(187);
	
	var _Actions = __webpack_require__(27);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if (typeof action === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _PathUtils = __webpack_require__(24);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function () {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function (len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var quoteAttributeValueForBrowser = __webpack_require__(265);
	var warning = __webpack_require__(3);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(21);
	var ReactElement = __webpack_require__(13);
	
	var emptyFunction = __webpack_require__(14);
	var traverseAllChildren = __webpack_require__(76);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var keyMirror = __webpack_require__(49);
	var keyOf = __webpack_require__(22);
	var warning = __webpack_require__(3);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	
	var checkReactTypeSpec = __webpack_require__(117);
	
	var canDefineProperty = __webpack_require__(68);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 107 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var invariant = __webpack_require__(2);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(223);
	
	var containsNode = __webpack_require__(269);
	var focusNode = __webpack_require__(125);
	var getActiveElement = __webpack_require__(126);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var DOMProperty = __webpack_require__(25);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMContainerInfo = __webpack_require__(215);
	var ReactDOMFeatureFlags = __webpack_require__(218);
	var ReactElement = __webpack_require__(13);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMarkupChecksum = __webpack_require__(236);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdateQueue = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(16);
	
	var emptyObject = __webpack_require__(36);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(2);
	var setInnerHTML = __webpack_require__(48);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(14);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(12);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(112);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactCompositeComponent = __webpack_require__(211);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactHostComponent = __webpack_require__(108);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var setInnerHTML = __webpack_require__(48);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 127 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(292);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 130 */
[306, 288, 289, 291],
/* 131 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectTurtle = exports.selectTurtle = function selectTurtle(turtle) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "TURTLE_SELECTED",
	    payload: turtle
	  };
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectUser = exports.selectUser = function selectUser(user) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "USER_SELECTED",
	    payload: user
	  };
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _turtleList = __webpack_require__(137);
	
	var _turtleList2 = _interopRequireDefault(_turtleList);
	
	var _turtleDetail = __webpack_require__(136);
	
	var _turtleDetail2 = _interopRequireDefault(_turtleDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompTurtle = function CompTurtle() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Ninja Turtles List:'
	    ),
	    _react2.default.createElement(_turtleList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_turtleDetail2.default, null)
	  );
	};
	exports.default = CompTurtle;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _userList = __webpack_require__(139);
	
	var _userList2 = _interopRequireDefault(_userList);
	
	var _userDetail = __webpack_require__(138);
	
	var _userDetail2 = _interopRequireDefault(_userDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompUser = function CompUser() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Influential Persons List:'
	    ),
	    _react2.default.createElement(_userList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_userDetail2.default, null)
	  );
	};
	exports.default = CompUser;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var TurtleDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    turtle: state.activeTurtle
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(TurtleDetail, _React$Component);
	
	  function TurtleDetail() {
	    _classCallCheck(this, TurtleDetail);
	
	    return _possibleConstructorReturn(this, (TurtleDetail.__proto__ || Object.getPrototypeOf(TurtleDetail)).apply(this, arguments));
	  }
	
	  _createClass(TurtleDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.turtle) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite Ninja and click...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.turtle.image, width: '250', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.turtle.name,
	            ' aka "',
	            this.props.turtle.aka,
	            '"'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Age:   ',
	            this.props.turtle.age
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description:   ',
	            this.props.turtle.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Images and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return TurtleDetail;
	}(_react2.default.Component)) || _class);
	exports.default = TurtleDetail;
	// function mapStateToProps(state) {
	//   return {
	//     turtle: state.activeTurtle
	//   };
	// }
	// export default connect(mapStateToProps)(TurtleDetail);

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _turtle = __webpack_require__(132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TurtleList = function (_React$Component) {
	  _inherits(TurtleList, _React$Component);
	
	  function TurtleList() {
	    _classCallCheck(this, TurtleList);
	
	    return _possibleConstructorReturn(this, (TurtleList.__proto__ || Object.getPrototypeOf(TurtleList)).apply(this, arguments));
	  }
	
	  _createClass(TurtleList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.turtles.map(function (turtle) {
	        return _react2.default.createElement(
	          'li',
	          { key: turtle.id, onClick: function onClick() {
	              return _this2.props.selectTurtle(turtle);
	            } },
	          turtle.name
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return TurtleList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    turtles: state.turtles
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectTurtle: _turtle.selectTurtle }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(TurtleList);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var UserDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    user: state.activeUser
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(UserDetail, _React$Component);
	
	  function UserDetail() {
	    _classCallCheck(this, UserDetail);
	
	    return _possibleConstructorReturn(this, (UserDetail.__proto__ || Object.getPrototypeOf(UserDetail)).apply(this, arguments));
	  }
	
	  _createClass(UserDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.user) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite famous person and select...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.user.image, width: '300', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.user.name,
	            ' ',
	            this.props.user.last
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Born:   ',
	            this.props.user.bornMonth,
	            ' ',
	            this.props.user.bornDay,
	            ', ',
	            this.props.user.bornYear,
	            this.props.user.age[2]
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Would have been around ',
	            this.props.user.age[0],
	            ' years and ',
	            this.props.user.age[1],
	            ' months old now, if were still alive.'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description:   ',
	            this.props.user.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Photos and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return UserDetail;
	}(_react2.default.Component)) || _class);
	exports.default = UserDetail;
	
	// function mapStateToProps(state) {
	//   return {
	//     user: state.activeUser
	//   };
	// }
	// export default connect(mapStateToProps)(UserDetail);

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _user = __webpack_require__(133);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import store from '../store'
	
	// store.subscribe( () => {
	// console.log("Store changed", store.getState())
	// });
	// //below snippet is a sample of how to add a state into the code
	// //but should be matched by a corresponding reducer function to record and update this new state
	// store.dispatch({type: "ADD_USER_NAME", payload: "Rod"})
	// store.dispatch({type: "ADD_USER_AGE", payload: 23})
	
	var UserList = function (_React$Component) {
	  _inherits(UserList, _React$Component);
	
	  function UserList() {
	    _classCallCheck(this, UserList);
	
	    return _possibleConstructorReturn(this, (UserList.__proto__ || Object.getPrototypeOf(UserList)).apply(this, arguments));
	  }
	
	  _createClass(UserList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.users.map(function (user) {
	        return _react2.default.createElement(
	          'li',
	          { key: user.id, onClick: function onClick() {
	              return _this2.props.selectUser(user);
	            } },
	          user.name,
	          ' ',
	          user.last
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return UserList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    users: state.users
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectUser: _user.selectUser }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(UserList);

/***/ },
/* 140 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (a, b, c) {
	  //This calculation is roughly accurate to months,as you can see...
	  var d = "";
	
	  if (b < 0) {
	    a = a - 1, b = 12 - Math.abs(b);
	  }
	  if (c > 0) {
	    b = b + 1;
	  }
	  if (b === 12) {
	    b = 0, a = a + 1;
	  }
	  if (b === 0 && c === 0) {
	    d = ": Hey, Happy Birthday!!!  Thank you for your tremendous contribution to humanity.";
	  } else {
	    d = ".";
	  }
	  return [a, b, d];
	};
	
	;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _reducerUsers = __webpack_require__(145);
	
	var _reducerUsers2 = _interopRequireDefault(_reducerUsers);
	
	var _reducerTurtles = __webpack_require__(144);
	
	var _reducerTurtles2 = _interopRequireDefault(_reducerTurtles);
	
	var _reducerActiveUser = __webpack_require__(143);
	
	var _reducerActiveUser2 = _interopRequireDefault(_reducerActiveUser);
	
	var _reducerActiveTurtle = __webpack_require__(142);
	
	var _reducerActiveTurtle2 = _interopRequireDefault(_reducerActiveTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var allReducers = (0, _redux.combineReducers)({
	  users: _reducerUsers2.default,
	  turtles: _reducerTurtles2.default,
	  activeUser: _reducerActiveUser2.default,
	  activeTurtle: _reducerActiveTurtle2.default,
	  routing: _reactRouterRedux.routerReducer
	});
	
	exports.default = allReducers;

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "TURTLE_SELECTED":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "USER_SELECTED":
	      return action.payload;
	      break;
	    case "ADD_USER_NAME":
	      return action.payload;
	      break;
	    case "ADD_USER_AGE":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    name: "Leonardo",
	    aka: "Leo",
	    age: "eternally < 20",
	    image: _leonardo2.default,
	    description: "Leonardo is the cool, courageous leader of the Ninja Turtles and a devoted student of Ninjutsu, usually wearing a blue mask and wielding two katanas. Leader in blue."
	  }, {
	    id: 2,
	    name: "Michaelangelo",
	    aka: "Mickey",
	    age: "eternally < 20",
	    image: _michaelangelo2.default,
	    description: "Michelangelo is the most comical of the Ninja Turtles, usually wearing an orange mask and wielding a pair of nunchucks."
	  }, {
	    id: 3,
	    name: "Donatello",
	    aka: "Donnie",
	    age: "eternally < 20",
	    image: _donatello2.default,
	    description: "Donatello is the scientist, inventor, engineer and technological genius of the Ninja Turtles, usually wearing a purple mask and wielding a bo-staff."
	  }, {
	    id: 4,
	    name: "Raphael",
	    aka: "Raph",
	    age: "eternally < 20",
	    image: _raphael2.default,
	    description: "Raphael is the bad boy of the Ninja Turtles, wearing a red mask and wielding a pair of sais."
	  }];
	};
	
	var _leonardo = __webpack_require__(302);
	
	var _leonardo2 = _interopRequireDefault(_leonardo);
	
	var _michaelangelo = __webpack_require__(303);
	
	var _michaelangelo2 = _interopRequireDefault(_michaelangelo);
	
	var _donatello = __webpack_require__(301);
	
	var _donatello2 = _interopRequireDefault(_donatello);
	
	var _raphael = __webpack_require__(304);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	
	  var today = new Date(),
	      dd = today.getDate(),
	      mm = today.getMonth() + 1,
	      yyyy = today.getFullYear();
	
	  return [{
	    id: 1,
	    name: "Leonardo",
	    last: "Da Vinci",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1452,
	    age: (0, _ageCalculator2.default)(yyyy - 1452, mm - 4, dd - 15),
	    image: _daVinci2.default,
	    description: "Leonardo di ser Piero da Vinci, more commonly Leonardo a Vinci or simply Leonardo, was an Italian polymath whose areas of interest included invention, painting, sculpting, architecture, science, music, mathematics, engineering, literature, anatomy, geology, astronomy, botany, writing, history, and cartography. He has been variously called the father of palaeontology, ichnology, and architecture, and is widely considered one of the greatest painters of all time. Sometimes credited with the inventions of the parachute, helicopter and tank, he epitomised the Renaissance humanist ideal."
	  }, {
	    id: 2,
	    name: "Isaac",
	    last: "Newton",
	    bornMonth: "January",
	    bornDay: 4,
	    bornYear: 1643,
	    age: (0, _ageCalculator2.default)(yyyy - 1643, mm - 1, dd - 4),
	    image: _Newton2.default,
	    description: "Sir Isaac Newton was an English physicist and mathematician (described in his own day as a \"natural philosopher\") who is widely recognised as one of the most influential scientists of all time and a key figure in the scientific revolution. His book Philosophiæ Naturalis Principia Mathematica (\"Mathematical Principles of Natural Philosophy\"), first published in 1687, laid the foundations for classical mechanics. Newton made seminal contributions to optics, and he shares credit with Gottfried Wilhelm Leibniz for the development of calculus."
	  }, {
	    id: 3,
	    name: "Leonhard",
	    last: "Euler",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1707,
	    age: (0, _ageCalculator2.default)(yyyy - 1707, mm - 4, dd - 15),
	    image: _Euler2.default,
	    description: "Leonhard Euler was a Swiss mathematician, physicist, astronomer, logician and engineer who made important and influential discoveries in many branches of mathematics like infinitesimal calculus and graph theory while also making pioneering contributions to several branches such as topology and analytic number theory. He also introduced much of the modern mathematical terminology and notation, particularly for mathematical analysis, such as the notion of a mathematical function.  He is also known for his work in mechanics, fluid dynamics, optics, astronomy, and music theory."
	  }, {
	    id: 4,
	    name: "Albert",
	    last: "Einstein",
	    bornMonth: "March",
	    bornDay: 14,
	    bornYear: 1879,
	    age: (0, _ageCalculator2.default)(yyyy - 1879, mm - 3, dd - 14),
	    image: _Einstein2.default,
	    description: "Albert Einstein was a German-born theoretical physicist. He developed the general theory of relativity, one of the two pillars of modern physics (alongside quantum mechanics).  Einstein's work is also known for its influence on the philosophy of science.  Einstein is best known in popular culture for his mass–energy equivalence formula E = mc2 (which has been dubbed \"the world's most famous equation\").  He received the 1921 Nobel Prize in Physics for his \"services to theoretical physics\", in particular his discovery of the law of the photoelectric effect, a pivotal step in the evolution of quantum theory."
	  }, {
	    id: 5,
	    name: "Erwin",
	    last: "Schroedinger",
	    bornMonth: "August",
	    bornDay: 12,
	    bornYear: 1887,
	    age: (0, _ageCalculator2.default)(yyyy - 1887, mm - 8, dd - 12),
	    image: _Schroedinger2.default,
	    description: "Erwin Rudolf Josef Alexander Schrödinger, sometimes written as Erwin Schrodinger or Erwin Schroedinger, was a Nobel Prize-winning Austrian physicist who developed a number of fundamental results in the field of quantum theory, which formed the basis of wave mechanics: he formulated the wave equation (stationary and time-dependent Schrödinger equation) and revealed the identity of his development of the formalism and matrix mechanics. Schrödinger proposed an original interpretation of the physical meaning of the wave function."
	  }, {
	    id: 6,
	    name: "Georges",
	    last: "Lemaitre",
	    bornMonth: "July",
	    bornDay: 17,
	    bornYear: 1894,
	    age: (0, _ageCalculator2.default)(yyyy - 1894, mm - 7, dd - 17),
	    image: _Lemaitre2.default,
	    description: "Georges Henri Joseph Édouard Lemaître was a Belgian priest, astronomer and professor of physics at the Catholic University of Leuven.  He proposed the theory of the expansion of the universe, widely misattributed to Edwin Hubble.  He was the first to derive what is now known as Hubble's law and made the first estimation of what is now called the Hubble constant, which he published in 1927, two years before Hubble's article.  Lemaître also proposed what became known as the Big Bang theory of the origin of the universe, which he called his \"hypothesis of the primeval atom\" or the \"Cosmic Egg\"."
	  }, {
	    id: 7,
	    name: "Mother",
	    last: "Teresa",
	    bornMonth: "August",
	    bornDay: 26,
	    bornYear: 1910,
	    age: (0, _ageCalculator2.default)(yyyy - 1910, mm - 8, dd - 26),
	    image: _MTeresa2.default,
	    description: "Mother Teresa MC, known in the Catholic Church as Saint Teresa of Calcutta was an Albanian-Indian Roman Catholic nun and missionary.  She was born in Skopje (now capital of the Republic of Macedonia), then part of the Kosovo Vilayet in the Ottoman Empire. After having lived in Macedonia for eighteen years, she moved to Ireland and then to India, where she lived for most of her life.  In 1950, Teresa founded the Missionaries of Charity, a Roman Catholic religious congregation, which in 2012 consisted of over 4,500 sisters and was active in 133 countries. They run homes for people dying of HIV/AIDS, leprosy and tuberculosis; soup kitchens; dispensaries and mobile clinics; children's and family counselling programmes; orphanages; and schools. Members must adhere to the vows of chastity, poverty, and obedience, as well as a fourth vow, to give \"wholehearted free service to the poorest of the poor.\""
	  }];
	};
	
	var _daVinci = __webpack_require__(300);
	
	var _daVinci2 = _interopRequireDefault(_daVinci);
	
	var _Einstein = __webpack_require__(294);
	
	var _Einstein2 = _interopRequireDefault(_Einstein);
	
	var _Euler = __webpack_require__(295);
	
	var _Euler2 = _interopRequireDefault(_Euler);
	
	var _Lemaitre = __webpack_require__(296);
	
	var _Lemaitre2 = _interopRequireDefault(_Lemaitre);
	
	var _MTeresa = __webpack_require__(297);
	
	var _MTeresa2 = _interopRequireDefault(_MTeresa);
	
	var _Newton = __webpack_require__(298);
	
	var _Newton2 = _interopRequireDefault(_Newton);
	
	var _Schroedinger = __webpack_require__(299);
	
	var _Schroedinger2 = _interopRequireDefault(_Schroedinger);
	
	var _ageCalculator = __webpack_require__(140);
	
	var _ageCalculator2 = _interopRequireDefault(_ageCalculator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _container = __webpack_require__(147);
	
	var _home = __webpack_require__(148);
	
	var _user = __webpack_require__(151);
	
	var _turtles = __webpack_require__(150);
	
	var _notfound = __webpack_require__(149);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var history = (0, _reactRouterRedux.syncHistoryWithStore)(_reactRouter.browserHistory, _store2.default);
	
	var App = function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        _reactRouter.Router,
	        { history: history },
	        _react2.default.createElement(
	          _reactRouter.Route,
	          { path: '/', component: _container.Container },
	          _react2.default.createElement(_reactRouter.IndexRoute, { component: _home.Home }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'user', component: _user.User }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'turtles(/:name)', component: _turtles.Turtles }),
	          _react2.default.createElement(_reactRouter.Route, { path: '*', component: _notfound.NotFound })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react2.default.Component);
	
	exports.default = App;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Container = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  fontFamily: 'Dosis'
	};
	
	var Container = exports.Container = function Container(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement(Nav, null),
	    props.children
	  );
	};
	var Nav = function Nav() {
	  return _react2.default.createElement(
	    'nav',
	    { className: 'navbar navbar-inverse' },
	    _react2.default.createElement(
	      'div',
	      { className: 'container-fluid' },
	      _react2.default.createElement(
	        'div',
	        { className: 'navbar-header' },
	        _react2.default.createElement(
	          'button',
	          { type: 'button', className: 'navbar-toggle', 'data-toggle': 'collapse', 'data-target': '#myNavbar' },
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' })
	        )
	      )
	    ),
	    _react2.default.createElement(
	      'div',
	      { className: 'collapse navbar-collapse', id: 'myNavbar' },
	      _react2.default.createElement(
	        'ul',
	        { className: 'nav navbar-nav' },
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/' },
	            'Home'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/user' },
	            'Famous People'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/turtles' },
	            'Mutant Turtles'
	          )
	        )
	      )
	    )
	  );
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Home = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Home = exports.Home = function Home() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'Welcome to the World of famE and muTAatIoNs!'
	    ),
	    _react2.default.createElement(
	      'h4',
	      null,
	      '> click on navigation to see more...'
	    )
	  );
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotFound = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NotFound = exports.NotFound = function NotFound() {
	  return _react2.default.createElement(
	    'h2',
	    null,
	    '404: This page is not found!'
	  );
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Turtles = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compTurtle = __webpack_require__(134);
	
	var _compTurtle2 = _interopRequireDefault(_compTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Turtles = exports.Turtles = function Turtles(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Turtles Page'
	    ),
	    _react2.default.createElement(_compTurtle2.default, null)
	  );
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.User = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compUser = __webpack_require__(135);
	
	var _compUser2 = _interopRequireDefault(_compUser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var User = exports.User = function User() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Famous People Page'
	    ),
	    _react2.default.createElement(_compUser2.default, null)
	  );
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(212);


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(155);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(156);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(163);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(157);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(158);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(37);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 158 */
10,
/* 159 */
[305, 161],
/* 160 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 163 */
[306, 159, 160, 162],
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports['default'] = routerMiddleware;
	
	var _actions = __webpack_require__(82);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/**
	 * This middleware captures CALL_HISTORY_METHOD actions to redirect to the
	 * provided history object. This will prevent these actions from reaching your
	 * reducer or any middleware that comes after this one.
	 */
	function routerMiddleware(history) {
	  return function () {
	    return function (next) {
	      return function (action) {
	        if (action.type !== _actions.CALL_HISTORY_METHOD) {
	          return next(action);
	        }
	
	        var _action$payload = action.payload;
	        var method = _action$payload.method;
	        var args = _action$payload.args;
	
	        history[method].apply(history, _toConsumableArray(args));
	      };
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = syncHistoryWithStore;
	
	var _reducer = __webpack_require__(84);
	
	var defaultSelectLocationState = function defaultSelectLocationState(state) {
	  return state.routing;
	};
	
	/**
	 * This function synchronizes your history state with the Redux store.
	 * Location changes flow from history to the store. An enhanced history is
	 * returned with a listen method that responds to store updates for location.
	 *
	 * When this history is provided to the router, this means the location data
	 * will flow like this:
	 * history.push -> store.dispatch -> enhancedHistory.listen -> router
	 * This ensures that when the store state changes due to a replay or other
	 * event, the router will be updated appropriately and can transition to the
	 * correct router state.
	 */
	function syncHistoryWithStore(history, store) {
	  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  var _ref$selectLocationSt = _ref.selectLocationState;
	  var selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt;
	  var _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay;
	  var adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;
	
	  // Ensure that the reducer is mounted on the store and functioning properly.
	  if (typeof selectLocationState(store.getState()) === 'undefined') {
	    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');
	  }
	
	  var initialLocation = void 0;
	  var isTimeTraveling = void 0;
	  var unsubscribeFromStore = void 0;
	  var unsubscribeFromHistory = void 0;
	
	  // What does the store say about current location?
	  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {
	    var locationState = selectLocationState(store.getState());
	    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);
	  };
	
	  // Init currentLocation with potential location in store
	  var currentLocation = getLocationInStore();
	
	  // If the store is replayed, update the URL in the browser to match.
	  if (adjustUrlOnReplay) {
	    var handleStoreChange = function handleStoreChange() {
	      var locationInStore = getLocationInStore(true);
	      if (currentLocation === locationInStore) {
	        return;
	      }
	
	      // Update address bar to reflect store state
	      isTimeTraveling = true;
	      currentLocation = locationInStore;
	      history.transitionTo(_extends({}, locationInStore, {
	        action: 'PUSH'
	      }));
	      isTimeTraveling = false;
	    };
	
	    unsubscribeFromStore = store.subscribe(handleStoreChange);
	    handleStoreChange();
	  }
	
	  // Whenever location changes, dispatch an action to get it in the store
	  var handleLocationChange = function handleLocationChange(location) {
	    // ... unless we just caused that location change
	    if (isTimeTraveling) {
	      return;
	    }
	
	    // Remember where we are
	    currentLocation = location;
	
	    // Are we being called for the first time?
	    if (!initialLocation) {
	      // Remember as a fallback in case state is reset
	      initialLocation = location;
	
	      // Respect persisted location, if any
	      if (getLocationInStore()) {
	        return;
	      }
	    }
	
	    // Tell the store to update by dispatching an action
	    store.dispatch({
	      type: _reducer.LOCATION_CHANGE,
	      payload: location
	    });
	  };
	  unsubscribeFromHistory = history.listen(handleLocationChange);
	
	  // The enhanced history uses store as source of truth
	  return _extends({}, history, {
	    // The listeners are subscribed to the store instead of history
	
	    listen: function listen(listener) {
	      // Copy of last location.
	      var lastPublishedLocation = getLocationInStore(true);
	
	      // Keep track of whether we unsubscribed, as Redux store
	      // only applies changes in subscriptions on next dispatch
	      var unsubscribed = false;
	      var unsubscribeFromStore = store.subscribe(function () {
	        var currentLocation = getLocationInStore(true);
	        if (currentLocation === lastPublishedLocation) {
	          return;
	        }
	        lastPublishedLocation = currentLocation;
	        if (!unsubscribed) {
	          listener(lastPublishedLocation);
	        }
	      });
	
	      // History listeners expect a synchronous call. Make the first call to the
	      // listener after subscribing to the store, in case the listener causes a
	      // location change (e.g. when it redirects)
	      listener(lastPublishedLocation);
	
	      // Let user unsubscribe later
	      return function () {
	        unsubscribed = true;
	        unsubscribeFromStore();
	      };
	    },
	
	
	    // It also provides a way to destroy internal listeners
	    unsubscribe: function unsubscribe() {
	      if (adjustUrlOnReplay) {
	        unsubscribeFromStore();
	      }
	      unsubscribeFromHistory();
	    }
	  });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(85);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(86);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(188);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(26);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(88);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation, nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(196);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 187 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	          window.history.pushState(historyState, null, path);
	        }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	          window.history.replaceState(historyState, null, path);
	        }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if (typeof action === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(24);
	
	var _Actions = __webpack_require__(27);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(193);
	var isArguments = __webpack_require__(192);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 192 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 193 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(195);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ },
/* 195 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ },
/* 196 */
157,
/* 197 */
15,
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var focusNode = __webpack_require__(125);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(205);
	var SyntheticCompositionEvent = __webpack_require__(249);
	var SyntheticInputEvent = __webpack_require__(252);
	
	var keyOf = __webpack_require__(22);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInstrumentation = __webpack_require__(11);
	
	var camelizeStyleName = __webpack_require__(268);
	var dangerousStyleValue = __webpack_require__(258);
	var hyphenateStyleName = __webpack_require__(275);
	var memoizeStringOnly = __webpack_require__(278);
	var warning = __webpack_require__(3);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	var isEventSupported = __webpack_require__(74);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(271);
	var emptyFunction = __webpack_require__(14);
	var invariant = __webpack_require__(2);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(22);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticMouseEvent = __webpack_require__(46);
	
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactComponent = __webpack_require__(61);
	var ReactPureComponent = __webpack_require__(239);
	var ReactClass = __webpack_require__(102);
	var ReactDOMFactories = __webpack_require__(217);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypes = __webpack_require__(113);
	var ReactVersion = __webpack_require__(114);
	
	var onlyChild = __webpack_require__(264);
	var warning = __webpack_require__(3);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(29);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(59);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(12);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMIDOperations = __webpack_require__(219);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactNodeTypes = __webpack_require__(112);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactReconciler = __webpack_require__(29);
	
	var checkReactTypeSpec = __webpack_require__(117);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var shallowEqual = __webpack_require__(78);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDefaultInjection = __webpack_require__(230);
	var ReactMount = __webpack_require__(110);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(16);
	var ReactVersion = __webpack_require__(114);
	
	var findDOMNode = __webpack_require__(259);
	var getHostComponentFromComposite = __webpack_require__(119);
	var renderSubtreeIntoContainer = __webpack_require__(266);
	var warning = __webpack_require__(3);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(9);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(11);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(227);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(221);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(42);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var AutoFocusUtils = __webpack_require__(198);
	var CSSPropertyOperations = __webpack_require__(200);
	var DOMLazyTree = __webpack_require__(28);
	var DOMNamespaces = __webpack_require__(57);
	var DOMProperty = __webpack_require__(25);
	var DOMPropertyOperations = __webpack_require__(100);
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactDOMButton = __webpack_require__(213);
	var ReactDOMComponentFlags = __webpack_require__(103);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMInput = __webpack_require__(220);
	var ReactDOMOption = __webpack_require__(222);
	var ReactDOMSelect = __webpack_require__(104);
	var ReactDOMTextarea = __webpack_require__(225);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChild = __webpack_require__(237);
	var ReactServerRenderingTransaction = __webpack_require__(242);
	
	var emptyFunction = __webpack_require__(14);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var isEventSupported = __webpack_require__(74);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(3);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(77);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 218 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var DOMPropertyOperations = __webpack_require__(100);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMSelect = __webpack_require__(104);
	
	var warning = __webpack_require__(3);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(262);
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DOMChildrenOperations = __webpack_require__(56);
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(235);
	var ReactHostOperationHistoryHook = __webpack_require__(233);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactChildrenMutationWarningHook = __webpack_require__(209);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performanceNow = __webpack_require__(280);
	var warning = __webpack_require__(3);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function (debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactUpdates = __webpack_require__(16);
	var Transaction = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(14);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(199);
	var ChangeEventPlugin = __webpack_require__(201);
	var DefaultEventPluginOrder = __webpack_require__(203);
	var EnterLeaveEventPlugin = __webpack_require__(204);
	var HTMLDOMPropertyConfig = __webpack_require__(206);
	var ReactComponentBrowserEnvironment = __webpack_require__(210);
	var ReactDOMComponent = __webpack_require__(214);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMEmptyComponent = __webpack_require__(216);
	var ReactDOMTreeTraversal = __webpack_require__(226);
	var ReactDOMTextComponent = __webpack_require__(224);
	var ReactDefaultBatchingStrategy = __webpack_require__(229);
	var ReactEventListener = __webpack_require__(232);
	var ReactInjection = __webpack_require__(234);
	var ReactReconcileTransaction = __webpack_require__(240);
	var SVGDOMPropertyConfig = __webpack_require__(244);
	var SelectEventPlugin = __webpack_require__(245);
	var SimpleEventPlugin = __webpack_require__(246);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventListener = __webpack_require__(124);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var getEventTarget = __webpack_require__(72);
	var getUnboundedScrollPosition = __webpack_require__(273);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactClass = __webpack_require__(102);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactHostComponent = __webpack_require__(108);
	var ReactUpdates = __webpack_require__(16);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(257);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(29);
	var ReactChildReconciler = __webpack_require__(208);
	
	var emptyFunction = __webpack_require__(14);
	var flattenChildren = __webpack_require__(260);
	var invariant = __webpack_require__(2);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactInputSelection = __webpack_require__(109);
	var ReactInstrumentation = __webpack_require__(11);
	var Transaction = __webpack_require__(35);
	var ReactUpdateQueue = __webpack_require__(67);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(238);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	var Transaction = __webpack_require__(35);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactServerUpdateQueue = __webpack_require__(243);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(67);
	var Transaction = __webpack_require__(35);
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 244 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInputSelection = __webpack_require__(109);
	var SyntheticEvent = __webpack_require__(19);
	
	var getActiveElement = __webpack_require__(126);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var EventListener = __webpack_require__(124);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticAnimationEvent = __webpack_require__(247);
	var SyntheticClipboardEvent = __webpack_require__(248);
	var SyntheticEvent = __webpack_require__(19);
	var SyntheticFocusEvent = __webpack_require__(251);
	var SyntheticKeyboardEvent = __webpack_require__(253);
	var SyntheticMouseEvent = __webpack_require__(46);
	var SyntheticDragEvent = __webpack_require__(250);
	var SyntheticTouchEvent = __webpack_require__(254);
	var SyntheticTransitionEvent = __webpack_require__(255);
	var SyntheticUIEvent = __webpack_require__(34);
	var SyntheticWheelEvent = __webpack_require__(256);
	
	var emptyFunction = __webpack_require__(14);
	var getEventCharCode = __webpack_require__(70);
	var invariant = __webpack_require__(2);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventCharCode = __webpack_require__(70);
	var getEventKey = __webpack_require__(261);
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(3);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstanceMap = __webpack_require__(33);
	
	var getHostComponentFromComposite = __webpack_require__(119);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(59);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(12);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(70);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 262 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(110);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 267 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(267);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(277);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(270);
	var getMarkupWrap = __webpack_require__(272);
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 273 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 274 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(274);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 276 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(276);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(279);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 281 */
/***/ function(module, exports) {

	"use strict";
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }
	
	var repeat = function repeat(str, times) {
	  return new Array(times + 1).join(str);
	};
	var pad = function pad(num, maxLength) {
	  return repeat("0", maxLength - num.toString().length) + num;
	};
	var formatTime = function formatTime(time) {
	  return "@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
	};
	
	// Use the new performance api to get better precision if available
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	
	/**
	 * parse the level option of createLogger
	 *
	 * @property {string | function | object} level - console[level]
	 * @property {object} action
	 * @property {array} payload
	 * @property {string} type
	 */
	
	function getLogLevel(level, action, payload, type) {
	  switch (typeof level === "undefined" ? "undefined" : _typeof(level)) {
	    case "object":
	      return typeof level[type] === "function" ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
	    case "function":
	      return level(action);
	    default:
	      return level;
	  }
	}
	
	/**
	 * Creates logger with followed options
	 *
	 * @namespace
	 * @property {object} options - options for logger
	 * @property {string | function | object} options.level - console[level]
	 * @property {boolean} options.duration - print duration of each action?
	 * @property {boolean} options.timestamp - print timestamp with each action?
	 * @property {object} options.colors - custom colors
	 * @property {object} options.logger - implementation of the `console` API
	 * @property {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
	 * @property {boolean} options.collapsed - is group collapsed?
	 * @property {boolean} options.predicate - condition which resolves logger behavior
	 * @property {function} options.stateTransformer - transform state before print
	 * @property {function} options.actionTransformer - transform action before print
	 * @property {function} options.errorTransformer - transform error before print
	 */
	
	function createLogger() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _options$level = options.level;
	  var level = _options$level === undefined ? "log" : _options$level;
	  var _options$logger = options.logger;
	  var logger = _options$logger === undefined ? console : _options$logger;
	  var _options$logErrors = options.logErrors;
	  var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
	  var collapsed = options.collapsed;
	  var predicate = options.predicate;
	  var _options$duration = options.duration;
	  var duration = _options$duration === undefined ? false : _options$duration;
	  var _options$timestamp = options.timestamp;
	  var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
	  var transformer = options.transformer;
	  var _options$stateTransfo = options.stateTransformer;
	  var // deprecated
	  stateTransformer = _options$stateTransfo === undefined ? function (state) {
	    return state;
	  } : _options$stateTransfo;
	  var _options$actionTransf = options.actionTransformer;
	  var actionTransformer = _options$actionTransf === undefined ? function (actn) {
	    return actn;
	  } : _options$actionTransf;
	  var _options$errorTransfo = options.errorTransformer;
	  var errorTransformer = _options$errorTransfo === undefined ? function (error) {
	    return error;
	  } : _options$errorTransfo;
	  var _options$colors = options.colors;
	  var colors = _options$colors === undefined ? {
	    title: function title() {
	      return "#000000";
	    },
	    prevState: function prevState() {
	      return "#9E9E9E";
	    },
	    action: function action() {
	      return "#03A9F4";
	    },
	    nextState: function nextState() {
	      return "#4CAF50";
	    },
	    error: function error() {
	      return "#F20404";
	    }
	  } : _options$colors;
	
	  // exit if console undefined
	
	  if (typeof logger === "undefined") {
	    return function () {
	      return function (next) {
	        return function (action) {
	          return next(action);
	        };
	      };
	    };
	  }
	
	  if (transformer) {
	    console.error("Option 'transformer' is deprecated, use stateTransformer instead");
	  }
	
	  var logBuffer = [];
	  function printBuffer() {
	    logBuffer.forEach(function (logEntry, key) {
	      var started = logEntry.started;
	      var startedTime = logEntry.startedTime;
	      var action = logEntry.action;
	      var prevState = logEntry.prevState;
	      var error = logEntry.error;
	      var took = logEntry.took;
	      var nextState = logEntry.nextState;
	
	      var nextEntry = logBuffer[key + 1];
	      if (nextEntry) {
	        nextState = nextEntry.prevState;
	        took = nextEntry.started - started;
	      }
	      // message
	      var formattedAction = actionTransformer(action);
	      var isCollapsed = typeof collapsed === "function" ? collapsed(function () {
	        return nextState;
	      }, action) : collapsed;
	
	      var formattedTime = formatTime(startedTime);
	      var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	      var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
	
	      // render
	      try {
	        if (isCollapsed) {
	          if (colors.title) logger.groupCollapsed("%c " + title, titleCSS);else logger.groupCollapsed(title);
	        } else {
	          if (colors.title) logger.group("%c " + title, titleCSS);else logger.group(title);
	        }
	      } catch (e) {
	        logger.log(title);
	      }
	
	      var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
	      var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
	      var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
	      var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
	
	      if (prevStateLevel) {
	        if (colors.prevState) logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);else logger[prevStateLevel]("prev state", prevState);
	      }
	
	      if (actionLevel) {
	        if (colors.action) logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);else logger[actionLevel]("action", formattedAction);
	      }
	
	      if (error && errorLevel) {
	        if (colors.error) logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);else logger[errorLevel]("error", error);
	      }
	
	      if (nextStateLevel) {
	        if (colors.nextState) logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);else logger[nextStateLevel]("next state", nextState);
	      }
	
	      try {
	        logger.groupEnd();
	      } catch (e) {
	        logger.log("—— log end ——");
	      }
	    });
	    logBuffer.length = 0;
	  }
	
	  return function (_ref) {
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // exit early if predicate function returns false
	        if (typeof predicate === "function" && !predicate(getState, action)) {
	          return next(action);
	        }
	
	        var logEntry = {};
	        logBuffer.push(logEntry);
	
	        logEntry.started = timer.now();
	        logEntry.startedTime = new Date();
	        logEntry.prevState = stateTransformer(getState());
	        logEntry.action = action;
	
	        var returnedValue = undefined;
	        if (logErrors) {
	          try {
	            returnedValue = next(action);
	          } catch (e) {
	            logEntry.error = errorTransformer(e);
	          }
	        } else {
	          returnedValue = next(action);
	        }
	
	        logEntry.took = timer.now() - logEntry.started;
	        logEntry.nextState = stateTransformer(getState());
	
	        printBuffer();
	
	        if (logEntry.error) throw logEntry.error;
	        return returnedValue;
	      };
	    };
	  };
	}
	
	module.exports = createLogger;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = promiseMiddleware;
	
	var _isPromise = __webpack_require__(283);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultTypes = ['PENDING', 'FULFILLED', 'REJECTED'];
	
	/**
	 * @function promiseMiddleware
	 * @description
	 * @returns {function} thunk
	 */
	function promiseMiddleware() {
	  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;
	
	  return function (ref) {
	    var dispatch = ref.dispatch;
	
	
	    return function (next) {
	      return function (action) {
	        if (action.payload) {
	          if (!(0, _isPromise2.default)(action.payload) && !(0, _isPromise2.default)(action.payload.promise)) {
	            return next(action);
	          }
	        } else {
	          return next(action);
	        }
	
	        // Deconstruct the properties of the original action object to constants
	        var type = action.type;
	        var payload = action.payload;
	        var meta = action.meta;
	
	        // Assign values for promise type suffixes
	
	        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3);
	
	        var PENDING = _promiseTypeSuffixes[0];
	        var FULFILLED = _promiseTypeSuffixes[1];
	        var REJECTED = _promiseTypeSuffixes[2];
	
	        /**
	         * @function getAction
	         * @description Utility function for creating a rejected or fulfilled
	         * flux standard action object.
	         * @param {boolean} Is the action rejected?
	         * @returns {object} action
	         */
	
	        var getAction = function getAction(newPayload, isRejected) {
	          return _extends({
	            type: type + '_' + (isRejected ? REJECTED : FULFILLED)
	          }, newPayload ? {
	            payload: newPayload
	          } : {}, !!meta ? { meta: meta } : {}, isRejected ? {
	            error: true
	          } : {});
	        };
	
	        /**
	         * Assign values for promise and data variables. In the case the payload
	         * is an object with a `promise` and `data` property, the values of those
	         * properties will be used. In the case the payload is a promise, the
	         * value of the payload will be used and data will be null.
	         */
	        var promise = void 0;
	        var data = void 0;
	
	        if (!(0, _isPromise2.default)(action.payload) && _typeof(action.payload) === 'object') {
	          promise = payload.promise;
	          data = payload.data;
	        } else {
	          promise = payload;
	          data = null;
	        }
	
	        /**
	         * First, dispatch the pending action. This flux standard action object
	         * describes the pending state of a promise and will include any data
	         * (for optimistic updates) and/or meta from the original action.
	         */
	        next(_extends({
	          type: type + '_' + PENDING
	        }, !!data ? { payload: data } : {}, !!meta ? { meta: meta } : {}));
	
	        /*
	         * @function handleReject
	         * @description Dispatch the rejected action and return
	         * an error object. The error object is the original error
	         * that was thrown. The user of the library is responsible for
	         * best practices in ensure that they are throwing an Error object.
	         * @params reason The reason the promise was rejected
	         * @returns {object}
	         */
	        var handleReject = function handleReject(reason) {
	          var rejectedAction = getAction(reason, true);
	          dispatch(rejectedAction);
	          throw reason;
	        };
	
	        /*
	         * @function handleFulfill
	         * @description Dispatch the fulfilled action and
	         * return the success object. The success object should
	         * contain the value and the dispatched action.
	         * @param value The value the promise was resloved with
	         * @returns {object}
	         */
	        var handleFulfill = function handleFulfill() {
	          var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	          var resolvedAction = getAction(value, false);
	          dispatch(resolvedAction);
	
	          return { value: value, action: resolvedAction };
	        };
	
	        /**
	         * Second, dispatch a rejected or fulfilled action. This flux standard
	         * action object will describe the resolved state of the promise. In
	         * the case of a rejected promise, it will include an `error` property.
	         *
	         * In order to allow proper chaining of actions using `then`, a new
	         * promise is constructed and returned. This promise will resolve
	         * with two properties: (1) the value (if fulfilled) or reason
	         * (if rejected) and (2) the flux standard action.
	         *
	         * Rejected object:
	         * {
	         *   reason: ...
	         *   action: {
	         *     error: true,
	         *     type: 'ACTION_REJECTED',
	         *     payload: ...
	         *   }
	         * }
	         *
	         * Fulfilled object:
	         * {
	         *   value: ...
	         *   action: {
	         *     type: 'ACTION_FULFILLED',
	         *     payload: ...
	         *   }
	         * }
	         */
	        return promise.then(handleFulfill, handleReject);
	      };
	    };
	  };
	}

/***/ },
/* 283 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isPromise;
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return value && typeof value.then === 'function';
	  }
	
	  return false;
	}

/***/ },
/* 284 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 286 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(128);
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 288 */
[305, 290],
/* 289 */
160,
/* 290 */
161,
/* 291 */
162,
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(293)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 293 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 294 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 295 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 296 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 299 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 300 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD//gBvRmlsZSBzb3VyY2U6IGh0dHA6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9GaWxlOk1vbmFfTGlzYSxfYnlfTGVvbmFyZG9fZGFfVmluY2ksX2Zyb21fQzJSTUZfcmV0b3VjaGVkLmpwZ//bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAb8BLAMBEQACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAADBAIFBgEABwj/xAA/EAACAQMDAgQDBwQBBQABAwUBAhEAAyEEEjEFQRMiUWFxgZEGMqGxwdHwFCNC4fEHFTNSYiQlcsJDU4KSov/EABoBAAMBAQEBAAAAAAAAAAAAAAECAwAEBQb/xAAxEQACAgICAQMCBQMEAwEAAAAAAQIRAyESMUEEIlETYQUycZHwgaGxI9Hh8RQzQsH/2gAMAwEAAhEDEQA/AM82lLMVYTJkxwa4eTWzmkuQIaFhPlglsAE+9D6lk1jfRy3omSGYQOKV5fgdY/k7/Qb7csrLM8Zg0Y5G/IsoJHbvT4SWaV9G4Pyoucl2zQin0iB0NpVLwoiD8eKVz8hUG3RP+kksptkCY4iaP1KSBwOf9tVrgDKUgGYnn+CkeRMKg0Dbpfm3FJzgMZxW+pRvp/BC704QD4SSQF4zTKb8MXhXZ5dEQkbMwT84oxyBcEFtaFHtwUEMIgntSuaV7DwujqWWtpNlYM+VlaB7z8qWNyUXYdxbrQNtChA8qE8sDVHKSsVQQfS2ovLIHBGPdSIoct+4ZRa6J27VpFEBSCRmPwqUV8DNNEra2wzmIJBAEdu9MtLYN2DTT2nMkHjBiT8ayi19wXYX+nRN3ktiFiQsH50y10Z2wF3SptC+Gs+sxR4+WC34Bf0tsg22SROACf0rLHaszm7psK3TUYAhQT3iYpNR0+jbe12BOgQOH8NTHBHNbnFq4sFNaZIaVbayqgMDPBNLbd3Q3XQL+lRXhLZAAIBAxxWWloNv5If0a+GnkIM58ooNN+QnG0IwfDUme680/KSVWLxV2COikLKIPWBFFNozSZNdLC+UAZGR2Pzo818i8H8EV0pJEjcJ9p/Km5J7FcGgo0ZwwRQT2Mz9aZZNifTdHP6AlAzKJA7HFD6iaaT2FwknbWib6C2BIUZyYFOor4Et/JG1oEV52gqexEUOm0hlbRK50ywSQLVszk/D1p7d0jJP5BDplpp8pHckEgn9KCi2+6GcqXQWz0tdg2tqN092MUjcvDGTp7QK7pNPaeLl65b3SVVW4E95PNVxu12dMJaNLeCyCgMRnFcbkqtmrwiN62Ayj/EHE8RSymqDGIJgPFkKoPqokkx/xStmPWsbWMHng8+/6VoyYGl4OMbbAQpJH4H+Cjya35BQMK7IwC5Mcn14/M/Sl91DasNbU4IXdBgTAn+TRb1QFFXZKfDBLGeSCR2n8efxo2DiRfzOpV5BJmM/GmpUBKiCrtCmATO4yZ/nrSKkM1YJBuUHyLu80dx/P3oKKM/gmsrESwgmDRQGjygM0OpiOxo8kzU0TCofvIAJjIop2CqOhB46YwT8KRSuRWKpUQtnapMeXgVuVWCUbok/njEL7CKKnYONHNgLRDRETNU5vwJxQdFVcEmY5PekbZiJZRzMHsadSA0DKLIgEbveim12wUvB3YTgAx8anKNjIh4WYKGPjSfoM0edVB3KW5IxTJ3oHHyzxUQ2IjvQjJt7ZnFeAZBMROJ+HxptdhqiADEyJg0LS6NXyE2cblMnNNzF4E2QbQzBh8qHI3EiB5TiT/8At5o2+0biujl2T/j5R7Ub8tgr4JWktuVCifiOKLfLSDVbYQIAzYB7fwVuTibimdVBJhFPfyigssurM8cQkIFClB8QOfhTfU8WDgjqIjwNoBXkR+VaM3KrfQJQSCMEBjO4Qc5+FHI22rNCKRneo2bNzUljdVSexz3NNB62WitGktwd4G0sMmK55PZkiITzbie4IJzj1FLFWGRBrQa5kENBkGRH8/Si/hCo4LahPUE8YM85/L6UiVIZuyKiFVVMA4JzET/qivg1WDi4QCcY2zunI9P52ptIFWEYlCZKmSSJMfh+tCzcTlxWZvLkDjFa3YThsFBkD1J9T+lFJg0B83+R2gmA5444iitGaOBPImYb0iMgelBsyRMp5SSInHMTSvsJIWzuVgfhRoBMqT94n4CsA7O2CoAaRg1vI8SNq2DaUd+TmptBCG1Ofwmmh1QsiJQnuee1UFomtny5B+tBb0Z6OG3I3Yj40d9IFHPLOD9KNmo4UMmGj3oMNE0XaB5p7msqTA02SKjuADRQGjzKPDzIJEDFKMCNnaJY5MnFBa0g1Z5re1lI7U3gB4BjxE9vakGo6EPZd2KKTBo9sYYVR9ZrK/AaXkj4ahyYz3NPQr+A1mz5THODmmtCU2Se0ZJIAj4UskmMjwVYwvalqgvYTaJACkwKNAOCyM4z+dCw0CuWnThcRFa9jKqKXqQm+NyAECDB5ya7MduOhdIvtMACJ4ORnmuHvRRhLpWTwTj5Zx+tP0J2cRRvDP52ntn+c0GvLBfhHWYwAFzOfQT2/Kg2+2ZJEERHzg/GtZqJW7SqMZ7cd6ZULsmLKkSQd3rAmg/sMgLptY/fI9ZEUt0NVkSpzIYiMd6blSNVsjbt4EAGe3pW0B2QFoLGDgfWlGOsgBIBk/z2phSQTBiR+lZ6AlYW0gzIz+lIuxmQ2f3lIx5hE/Gje0FLQO0vlkDtzWiGSGUUQDkH0rLTA1ZPwy0nt6ijbYtI74SXPhTV5Acu6YIkrk1k29hqhfwDJYrWb3TCDNsk4mK3ZmTAAkZFahQipLgGTniKKVgDNZyDn84oSVGiBuISBPfOPjQSGvYNkVoIE4rXoNExbIk5GM1jHSuDmRwPjWejLZwWyRJ9e9aJmdtoJMgR7066oVjHE4/1W6Foi4kSZ5rUr2NsgUzyAB8sUZVQEdUhT3MziO9JYzQS2ZJPmk+tDoBy9bkGeSJoWMZzrXk1zKsCAMV2Y5VFC8bNHpbI8KTBEfOuKC2PN6I3QdzBFjgY/L8aZioG4LMOYDGJ9zQYaDLbJDbvUZFJYaOpaIuYxOc/OtC3tglS6Jf4oIJMD96tpCEY8xgmScxSXeh6Jr5sRMTwIEelZ70ZfJ0W1LSCOOYo8V0a32CKeY7TPy/WpvQ3ZwWciVgjHv7Vk0ZkXTbIPpR5UCgiIMFhjtQcrNR3ZkKvB5Fa6DVgnt+dZHlkA0vLex6pHrdojJ4I7VRPsDXRPw5MkgCnWxKokbZ2YPyHetKXwZI4igTJJgzQWuxnvoJkr3mjyYvEHc7qfu96Dfg1ASucDntQX2MySKCDkAzTCh1Xb90E9po2roWjrgniPnQct9hS0Cu4iGEiluxloEwAMAgAAASc0HIZImcjb3I79/lRTBRAfdxBETzWu0GqCoJ8qjMR7TTIDOBYkD1xB+H+6yYGGZTB3RHYE4p20hUQRQEI80ZP8/GlvQzWwhtEEAcd570rkagYWG5yRmD78e1Jz2GtBkUEACD2/wB08XYGjzW2AZvUdqLVmToy32itOeoStsMNgyc+tXi1SGijU6WPAMz6RPFcsYWqQJOnZB1D3GRVIjkx2FGSfkVP4CiyrRAmDjvS1bDdHbyxIkwKLVGTBoY2yYPH4UFKg8ThBKErJn5elBOw1RFFYCMzNMkY6u4juRHpW5Js3GjyW5YAPz39a32MFW0fQDzcxS6Zujl22WAiQSe3wrcWlZkwI3eGBGAKVoKJhWKwx2iskjHmXbx6RTVboHR24hK4JnGf2oUqvyN29HbxtWbBa+6onJLHFI2iig29GX132u0g3L0yxc1Trjc0ovy7mqxUn3ovH03yUOu+1nVHcqvg6eBPlt7iB8SapHHFr5KfQjHsrn+0fU2ZSdfdE4MKg/SqrBH4A4wo8v2o6xb2FNWtxfS7bVvyg0fox+APHB9FhpPtzqrZ/wDy9GhXubTEfgaV+nr8rEeFM0PSftN03qTqi3xZvtkW7vkJPseDUvpvGtojPFJbovFAnjIPEUtrwRaaChYT396La8AoLsAUnMd4NJxpmuwN5cycKODx3p3VWZIHt8uJn1mkaHRKyIbIMxBx/JorQGe2qWJMR+f8/SiqZuiaWxK4nHp/I/aqNCWd2li5iD7fnS32agwSEJjg9qD2gpbJWrU7hzz2+FBdBZK5bO/PrPPNZ0BC7JDA+aAP8anWxwttVZcjIphQrA7Gj/1zAql6E8mS+0Fq6eoEojsNo4MVSMlRSJpdCFWwJB559aWL4onJWybjb5VHmPeZpZO+zJUeW7/6kDuSx/ntQTDRy5bLvhgRP8/nvQkFE7Vpt5yJ7/vSfYclctkKBnv+dBNrs3YMICsCBmmT0bySFoyABMCcH9aNAsJZTa4MZAzWo1kgwAil6RmiKkY2iADma32YSSICzMVhZilk0no1HHt7gMA9wOKVd0Hwda2GiIlaq1Qq2V/Vuo2en6Vrl4+aCEHqfaptvpdl8eNyZ8+6tqtX1fUA6himnU+S0pwB6n1NPqDddnZjhS0d6ZoEG9tsqoyTUcmVvR0RVCeq0xdnZlmTXTCdJEmrZXXdHA3RAGfc10QyWTcaKnU6cRiQR3rojMlJCzam9ZIDedfQ1RwjL7Cqbice5Z1CRbDWjkx+1LxlDvZTlGS0X/2Z+2up6TcTT9UNzU6EY3jNy36fEe1Ry+kWT3Y9MjJLpn1zRamxrNNa1Olui9auDcrrwRXFya01s55QcXTHCoYkBmJxGZrRpiPSBGyJkj2M5rOIUwbJtaFn7uK1JG7O2lBaB+HamAwpX72Z9fem8bF86DrbXadwmB2rS6MuwXg/3ARxxFQkvgogm2AxGdscGtYyRJRtUiDE/wA+VC29BO3JZg3B9YphCPh7gSBP50OwnNsIAe+MU62Kw7wEMCYHpQlKtASsoeqaa22oDORJXv8AEirQVqw2xzRXI06jzTuJJPJpV0F9jdm0H8pHPoJz61qsToM+mDNtBIXGO0UPskH7nTaUEwoOP170jlsZLR0p4YwJOQcZrNUZOzjiVyPjmnUfkF/Bxh5V2rLLz7CkbXgKXyeUT780bQaCKpLxGO+KzkCjwSCSOMULDQArBHvWaMGKqcHABpFFds36HQhaCWwBimUUZsFqHtaXSXL187baLuZvWmYYRbdI+Wa/W3+r9Se66kgytpBnaPYVmlFWejCCSouen/Z/qGpgppyqtjz4rmyZoKRaK0X9n7J3xYa2WC3GEyOO+K5Xm3dDFXrPsprQzFXtNMknIFWj6qPVAoz3VOg67TqbhtBxwdpmurH6mD8iODMxq7bISHQqfccV3wafTIyVdlTqlaSee810wIyQjqFAuYM95A4qyRNkCVdCrwG/Ojxroa7WzUf9P/tU/Qtb/S6t2/7bfJmf/wCk0xuHt6/Wuf1Xpua+pDtf3E/MuLPuVt0FpGGS/AGQc815MPc2RkqPQWnyjdtqnbEArYbJPl9e9amg2cZAI4A9u1CtBsIgIkEAyafwKHUE8nEcUr7CEtWyyiTSOqpBXdnbqqCUXj0jtU2q6KIhdQKh7ACSY+lHoxEoQYIM8H1mte6BXkjbAG717GtAzPKuVPqcGnXYGhh1AUn0BwO9GSTsVFRrT/cUbZheZjua6Ma9oH+pLSKRZBDbv/rn3qC0tlHsbs702scxjGJNBvdIV0OK4aFUbdoyOabSFWzizBYAFe4ihFXsL0TuAOIUTHc0rfj4CkDNliMtg96Ckw0R2YAyST270j30Mgi2huAMT370dIwWIJiTj1ouXhgoCyCYGTjvW0wnhaBUFpHvQcqNQW2gOCeCY/CgvcwdHbvlQQQMSa6YaEez5/8A9QOrM4t9OsOJJDXI9f8AER+P0oL3SbfSOz0+OlyLr7GdDazprbpbUXXEtcuDJ+Q/evK9Tm5zo74xSR9F0nTWVFDXJLCRsUAcVzyYyG20KsWXzZEg7oM4/wB1JMIjrenWzuPm+IPwocmGjOdT6ZFsxcaRMA1SMgHzbr/SQGY8T2ImvT9PnoSUbMN1PTFHK4PfHFevhyJ7OWcKKLVAISTMdzXbB2QkgBIYNu4iMAD6U4oJwIKnI9ae12K/g+v/APSP7Q3Nb0+50nVvvvaUf22OSbfp8vyPtXj+qwrHk5Lp/wCTZFyXI+kABQCvI+9UI2ts52ewpLMMdqL0BHRb3HdwRmkaHTJKsnM7gc4ocvBqJhAuSc5pm7WgUdLHzADHApKHPNbJUSM+9akY41toBkyD6UeJrAMu26QAe+0d6zVBR22CdxODOJpYeQtErSeZFAiDHPzoXvRmGjyndxtmme02L5KbqAC3Eg4KTyPU11enT4IWVWOdM8O7Hh/5LIzxXM7pjN7G/ADPuUwygADsPetG+hZV2e1Nlk1GwKZMGQMDEUIK42wvTolZtsspdeSBANaOm7N3Q1asjadx3D4d/wCCjFcv0M9HVsjcRsHtWaoyIG02Tz6AYik2uxkeNoq67wN2az0FHtvnAgmflWXuZnpHrKy5BgdvWnS+RWwdwAopGDwPpStIKCWlEhoxVIRTdsWTaVIrutaoaHRPcALufKiTl29Pb408qX2GhByZ8Z6G93qf2pN3WXC17ezH0GYgD0FVz1jw+09GC91H337NjYi8Axjt2r5yXZ0mmBAHmJBAA49xSWGiYfdiZIx8amlSCCvkEQcknNb7GKPqHhAOSOeM0UAwn2gt72JQfvXThdMzPnfWNJwYPNezgmQmjJau1NyDIEwccV6UHo52t7Ky9bCkhCCBma6ottbIyVdAXH+BMT3FU+5PxRY/Zrq79G67otck7LbjxV/9l4YfSahnxfUxuIVvXyfpM3UNly7rtgR6HPP0rxXclaIdMilzfcUAGDHHbMUU9Ga2MhkthpJBUcE0jlTGoNYYMSFbc8xis35Zq8I6zoUEZ5BjtFGu0gJkFkn07z6UPGxq+Bm3DKQcnsY9qF2w1RJrZ2EiJkxTN0DsXe1ucbSDP4iptjIE1vmVB/D1pRjtldz5JmOxj60VtgY21ubLAQYHFWT0TaM91Vit2zIUk25MtH+Rq+GTUNGcbYt9ntbaFoCdoxkiJwP9VJx0wS1JIvNNeF294dtoPJxmg/am0BbZ3V6gFQ7lmI2mFP5UsU2hnpimk1YfX29vnDmRHNKo0qYX3aLlWJZkwSDIzVFVWDYe2h2HcSBkenf+fWlk0ZIiLtlrgtliWHI4n1ipykuxl8BLykuBJz3rBoSuKQ87T3+f1NGMVWjNt9hbAUqGH3cTFN3pCv7g1RmNsBeD8/8AmpsZB7doJaydoAkk0baWjVs+Y/bXr7rdU2T/AHL0rbB4t2x3+JP8xVIR+q99I7MOOuzK/YHTf1HVLrqdxQgmYySZq34g+MEi2LbZ956LCLbdl7Sa8BryXLa3udGUMWkwCDHP/FTprYxMFrbSswRE8/zilWwsjc3Q0SIHM03FJaFsotejs3mBIOPmR/utFa0Yo9fpGuAYxAJPpVE0jGX6p0nfkqYHFdeLLxYkkfOvtPpF05OwH1Ne16WfLs58ioy72yF3zII4ntXop+DmryAuLgkTHqOBVCb0BVSWK5O6jQvk+1/ZfrF7X/ZjQ3DdbcloWy2MbMbj9BXkZILHNxI5Lb0aW3rFa1aC79zKGliRiO5+lckXV2O43VExqxd1Aedzcn0HtRjF1voE5V0WqXfA07XWaYWYHrWat0LdKyXjeBpbG4AvgH2J5oOPKWjRfGI2JPEEHgR3ik5Ui1DPhsyEE9p+dBfJidryiDIPFa7A0Qby3ATxBJNI2MugNxGiSDE9+KyCDtPN1RxOMd81RKtsVvwOOB4KwRBba3Yj4UW2+hV9zOdVulL6KF3wn3gB6n1rrwW4aRnVmc6TrhqdOW0zi1sG0Lcgtn2pJx4e1m7dj2s1nhXvv7wEhmnJM8Y9fStBWiUlsjoNWL1hhfYtcElfNwD29qXImtIrFLtnhcOmdLtvxCBBg8getKlybT7C9LRoNP1SUtuNhIO0knbu9f3pGkrSMk/IW91Br9uLbBYG8Tyxzio009lO1oVOv8NgTg5YEH3iPpTRhYk3RZ6fq1j+mtvfdReLbQgaSR6/nVIwblpaF5pLfZYWdl8K4KsCJke/FOqXjZuw9q0q452nOeKTYSVhRtTaAATP51NqmN2I/aBxpem6hhJlAN3u2P1pIt2OlbPhH2vvFuuZYeGbQ2EfP8cV6XpoLh/U7IOkWH/SlT/X6pVOTtIHqIzU/wAVVqLDg1Z9q0rae1ZUsADEiRFeFJuqOhbH9JqbTf8AjaYjEz71NutDUN233LyJjn+fP60qfwYqepdZ0mmJDvuaeAaKjKXRqEB1axeUkBAMcmnUGgMX1ersmGD2weImjGLMUPVNfaIYSIrohDYjZ8v+1rh7rsBivY9KqI5OjGX0iIjb6V7EejjaYBAS7LGGHA9qdrViWRZIZQBOSKCA0b77C6gD7Nvbf7qahkIHoQCB9Zrg9VH/AFLJT8Gk0Go/qLJWWkEhfSMf7rklDiC7LfSW3sMrMSQZmeZj+fSlVS1YJMsLOse7qUR4VUImPw/StxSV/JNyt0S1WrY+Ane4GYZjvA/WtGHn4By1RotHqLLhU3DxAMj0Fcs6XZ1Rdj4bymYk0rY1HlUEZwpPcYqfNXQeIbwfDbxLiiAJMmPrRn1aMuys1F8hHkznuea0VrQZFfpr8307j1HYCa6oLVEZMnqer7NHhIO+AD7D8aosRN5DK9V1167fR2UAlP8AI+5rrwxShQbtmH6K7m+WmAvmHqRGarkjplNWaJbty7ZEHbbB4PeTUFFLvsi9jfTfNdIONsscwCe00k1W0PF62OW7wNwbVLMZIIwB/P2qTi/0Q9jN26LQlCpuRyfjxSKN9hbFbWqed6ncoJIoSWqGSB/15W8Ts4Mc44/5p4wpInLbCabUXL2qVmVZe5gAcCKZ2o0jKCbssrPUL3Trguo3/jKjaTOPf5UmPHzdAnLjE3RDm46qBgjn4+tSjHlsZutHBcAtEgndJEAdq3DTHUtGV+2esYdNJ3MVW4h9YExP40+OCrQIu5Hx/rhtX7s3GMqxC9zH/P5124rj0d0I8k7Hfsvqn6brNVesgFlgERPek9VD6kUmPD2tmyt9cbVadr2u112yF8zW9NpzeZV9WJIC/CvLlg4uoq/1dF077JdD67bXVeL07W3tQF/8lu9a2NHcgTB+VLmwNKpqgxd9H0DXapregbVIx8Nl3A+o5rzIRuXEdnynUajV9Q6iWD7Ubz72wACa9hRhjgSttlnrrnTulaVG1Z6xdFydty2gRCRHG7kVDGsmWVR4jOktmd1nUn279Bq7wX/+3qVAb5EYNdkMPia/Ym38Aumtr9fqNoVmWMsBimyLHjQFbEvtLo7iW2Fw574qnpppvQJrRinSQwErECdtezFnG1Yq8qwM8cmOKrVoi9HpIYEngzkUKsNmn+yRd9NrdPuAAuJdCnjIIP6Vy+opNMlkT0aa3f8ACVJOzYI8hkj1rlcLI9dFp0++5tXLdxmOJDHJQ9/jilcUnaFb1sftXC/ibGV5Ag9/jRqhHvoC3Uxd1tjcFtW7R2+pIA/Wt9Kougpq0afpF7drLW0yGwccnaf3rgyx4xbZ1Qe0kai0oVCzLM9654uyrCoSl8ggkYgEfjSRjbehm9BL2pVVhgGk8k9qpxf9BbKbVXbbW7hG3c0ZHp7UYd0jTWrK/UXAhNu2pVigzPqa6cKvbIZXSpA30nhdPW/cIbd/jHqKupX7UJXkoepWEe5aZ9m42x95gO59TXXg1BBads+f9LB3+HIgnJOI4qmRoqzVaaEuWts7ST7j4muaW1RL7jdlJ07tdOGLGFMz/DS7ukZtBdISxGSnlBEH1ipyST2FSvoC5CXGDXIg7cjjOBS3pJIovklYVWtmGlYLMOO/5UJN9hRWWNQ98spVVtbtwHEfOrqKirvZNvY/otSqXUuFgAhMjj+CoTX2KRdDmm1Fi51u6mvh9KlprrqpiYUQJ+NBclBcNOxGk+/g1us68mns+OGDbkDLBkRHNQVt8YlVHVszdn7R6rTo6Xrhayybw/dWAOB7ZH0rphjTJzb6GvtJrLY6Y62ypvXrYFsdsgSx9hP1ipw8FIK2fG9Y8G+SPOWgmeM8/lXoR20elSUdG1/6SadddqOoFlt3BtRCrZ5mvP8AxTJw4r9Q4Y9s+k2+jpo+l3dKemePZuLDi1A3TXkSzc5KVlkqK/o/QUS4bqdMtaRUHlLMWI98nmtPM5acrCaHriqPswLSgeRNuRFRxOslmaMl9mdEUvgJZRjEgMJyOK6vUTUkKtGk6xp/+521t6zpjajYd6lQfL2xniuSEuDuMqHsqE+zlx7hjpaae1Mk3Blv1ro+vS3Kxatlrf09vSaUjbbRwOFUCKkpXKwtHyf7cXUV7gEZr2PRKyGTo+bs8M/BnHPFe9FaOJuhe+fOW5MHEY4/5q6Iyetkh5wVBExg1O6YatF39lLyJqtUl0Za0IgxBDCZ+tR9R0mieRWaO1dtusKpJU5xiK5pPRz+Sz0dqTKs6gD7qms5rwhHHQYO1u4xVmVgIkiJoXezVRK2bf8AUsGAxGeJFZt1sC7L3ot8Wb9wOViQ6mZmYBrmypS0Wi6PoVq6j2gxIKjOOD6VwKNdnTd9EWup9719OabSBsBfuI0rbIY+s1nTVIZfcS1EspVgFJPPapxTi6C3aKl3Y6pmJMKMCefSu3Eq0znyb2OXn8Xp4VSIic9oHenapixZnup7i9nZe2f28gxnzNnNd/p43AznTrsx/Runvct+MiEo2QWIAxg/jU8mVJ8WVkixLbn2vdtDB2hboYn/AHSNrujRSqmENxrai0162pHaZAPvApk9WQcRjdCl0vKTgeUzSSVaaBGxS5qdtxkgOynBM4P681Nxva6LRtIFrTcsgMpY3WDbo42/8VodhfRHTlSGFvKCAYOM+tM+9it6Frrxdw8KBkdqdIFkrl5zqQbbbWZNhzzx/qhx1sZDK66/c0sFZswEQnMAdvzqX0Vyu9llL20S6pqGNmzbGBsAGKOFbbFmlpHNRrhcdLT3QoS3aQZwMSePcn6UHGnopi/LZieqDfq9RcsuNrNgHBP+q6sbpJM7OL4m1/6Mas6fqOusiN7BSPlXmfjEeSjL9S2DVo+56J2e2vicASR6jFeIizRzUAMqooD4ExxWjFMDYp122qaC2ARBO4gfz+TRxx9wGyo6KoW+u2JmCAKpljZomxs3gWBAhTA4j6/WuVKlsdoV1t9QLhO0ETxNamEw/XdcFDDdHsDXXhhYsnR8i+1+pa5cYSTnj0r3fRxo5crMdtMSCJOCfSK9dM4mjpt/3EBJkERPFOpaEcbA2VggTkkciOfX5VmBMufsxauaj7Q21tKWa9afgjkCTz8KjmaUN+BZqzcjpmoXcLdgiI5uLPPxrheSLXZHi07YzptHr0A//GIJH+IBz9aXnF+TSgzzaXqTffs3So7bYxVeUfDI8WAOk1wuEeERbPG5SYzRbhXZkN6Aai1d3MrbTBINs/tU218hTo2/SOrW206pcRvKAJiuLLifgvjn8lh/WI1shnG2eD+NRUWtFm0wTamyG3eIi5/yPE0rt6GS1YLU6u2SRvWBEZk1VVJiU0hNLiKd0By3c9qurEoX1V1TaUEmDOBgcYHzqlOhF2IdSa0162Ycf2xhT8a7sEvYJKOzJ6Bja6ZdFsCQAu7GSRJE894qE177Z0vboqdQu3UKoBB8qtHqBnP1qy2rFLNWBtKzEERk8wfX/mkRLpnbAUXygID7dxWec9v2oN2FJUFDILzSSA0Rn9Km0xkOXDauh2DDY2GB5HypG3VGitityxusum0rn7oPtTXTsVbE7ltg8WjBUifpTp/Juket2mAW40hNwXAzMVnJPTGS8g2Qq0gnHl28Yn1oKWqH8Artx920eYgAAgcCPamitG8lbf1DQ6sNoZicEH0A96fj5LY/AjeuMA9zDKMAx3gH8IoJJujvpxjaLb/p5rjY+06uTtNxY+NQ/Ecd4f0Bhl72j9E9P1Yv2EYOVEcTzXzTjR1M5e1IbV2rSmN84PcxQj8sDQP7TX7ensLN1VgRLGO3pVIe56FM/wBH1dv/ALrYsjUKRdJAC+sTVJxfG6MuzWWybZG4nA5Mfz1rmpWOVXUtbsRxuExNNCIGz591/W7mbI74r0MOMm2fNPtA7Pff/wBhXsenVHNkdlIQPMwXyiYk13r4OZ67OsQFBDEwQSTTK+haVWKlT4ZYAmRIM9oqhKx7QubWrs31YSjhie8EGTUcivQXuJrU6hqblrZde4yoQOS4AxHf41yuEVshTfktdL13UwFu+Ge+4rH+qR4k+jNOh231i/uIFq2RIBkk5nissSJO0Gtdfuhkmzb2k/dGKLxJiKx/T9ftuolGtMRxMjnsam8DDzZar1NVUNcVsDAx6GofSsqptdkm6tYbhQzRBUx/OKV4fI6y3oQbqrXWcC2ltVkzH5H1p3hUKs0crlZXWusXBfCui3EAkmcx6/jVJYF+gYzbLO51fRWLakOGZ5MbRPzqa9PJvYHlYhqOtb9Iuy0rNgb2UQPl3qv0PuaOR+Svu6q8j+Vy4IncCIPb9K7cKSikjXb2Z23qUtdObxHkF5VAYJHaPnFTlG51RV/IFme5fu3GAKqJgdxn0/OikkkkKnY90pyQyPDEzcb4zx9INJLQslexgZZ7qDsPcfjSdaFT2FuEIqZhgskflj9qTspQK95dxSIKzz3rLYZKhzT3WvIWukAloOR6VmuPRMWDg3Lu1cboEDjn96KQWgawbgUtOZAEZz70WNFEGG1mEsDPG3d9SKHgYWv7nZpEicAyR708WkLuym1LJavONoaB5QBEwCJ/GqU2WxvWxC/Iu7RDWoztPf2+UUyo61JtBek3Dp+qaS9JAVlX3iAKX1EeWNoMHUkz7n0XX3E0tsNORXzOSCO01Q0uj6lo0W8CrKd6OhhrbdiD+lccXKMrCz5n9tdL1d+oXNPfu/1CIBtuWwVx7jsea9X0ssVWicrO/ZDpN7SdRsazU3TFkyFJmKPqcqnFxSFiqN9qesW7h8NGE+3evO+m1tlLKTq952RieI4q0IpCtmL6su/cZPy9K7sQjMH1f77g8nv+tenhOfIUzDdMngZ/Ou1M52iV0MQAsgEngxj+RVExGgF0eU4UASPQZimi7JNUMaWIiSR4UD4gEUmQePwaPT2LhtswZRvVSZ74FcrkmQdx0OFLgTcY/wATKsI47DFbTFbaC2hcXIdGg/dM5k+n4UbEZ0Pc3AAhByRu7RQNQyLqBxltoMGDBOaD6MlsOepObjMpYKTheMdqRQ0kF92Hsax2uMGUjJO4/wA+P0rPH5FUqdDStcXSOjIAY3GVGRMxPbilaXJMZdUhLUqwVQCFJ24GZ5Ip4tN2NToHettaKuSN/wB4Afma12Gg1p0XTBWMgwB3E4n50E2Fx+BvUaU3UsNbsI82xJZtpBk9pq8G6GSRitJpvNZVjLeh+v60Mk+x0hliiG4sgm4NgEn1NBXoBZ6C2LYDNO4qc9sgRU27BLoIQkgK07ZJ25JpNiqJyGuNuuMyiQDNC0uiqTYVkS7uaRtmD6x8aWOlQJW2BN2xatxuX1wP561TbEoh4iuy5U8eU5/4rbG0Sa69oiFYqGkmTB5+VDsZfIG44I3b4J7ztP6UNm0BZDc+/OOTHv8AhTp0JdCXULRu3GLDzbBgCOZz6U0XRbF8lcQqo1zAAzkTJif1ozd6O7GuKsUuOrI7qQP/AFA7fyKql4Fm92fYvsP1Gz1HpdvcwLKoVh3r5z1eJ48jR1wlyjZrNJ0vqG+/qNJ1ZtPbgeXwg4P7VwucXpxsZdi3WNJ1O9aA/r9A+JZ8qT8QR+tHHOEX0x2rRmH0vUmu+F/W2k3d1Wa7VPHV0SaZf9H6emjtAXLz37mS114BPwA4rnnNzd9G0gfV71tUgHAowTFZhuq6jFw7iTgV6GKIkmYjqTb3YmYn07V6WLRzzKsLDFcEtxNdfggztxIjaYUd+8/z9KZP5Fa+BV2G5iGmcjyx/O1UiTex3TKEcAMQuzgjvupJu0GJpOmAPohukOBBHqYH8/SuWb2RktssVFu4xFvYAIEKu3IHxzx60idMWS1skLZVZdWmBgY+OaexG9nUtAXFYqVJaSBjPzrNGUglq0Bs3TgEeUUtMzYzYt2/EG3yqQJxNYR9D1s20HBZpnI71OUW2OpJENRqFcFS6gnIRSSTWjH5GtvoQ1F25dYKjBRt2wO/pJ7z7VSKoPboGiKvhxdN1uSZ96ztoda0Oaa4RaHhoQhxIXzCTnPuaKQL2E1lq4LiQFcbBknPFWj0BGQ099lKF8kGFb0gftSZI2tFY6exgpvuLeMA24YieB/DU+bWjOJZi4WFotJDArLAmMgT8efpQaMifh3CF8OAxO6WXbjgcZ+tJfyEITfVgdwIjBE/tSqggDcuNumX77eVB98UejUQTeXjMATCCP0o68itfB7wluJI5kRPH5U2hXYZdJcBTyFd0sMiD6EcVm67F5WEXT3QxUIW757/AEpLRkwluxe2ptS4DIzt/k0G1sbsr+p6e8msYEeVgrFoiMH/AHWUlR0YlaM3rvEt3CIDA4jtXTGpKzpUtUhO2shAxhTwSPlmnumZ70WfQOrX+jasOj/2mI3qD+NQ9RgWeO+wwn9N0fcfsh1q11bRg2rgMxKk5Bnivms+J45VJHYnatFxr/snZ1l3xfFYE9hMVGOeUNINWUmo6Pa0W9Q8sI471dZXIWhNrosAktGOKZKwGa6x1QsSAwzzNdWLEI2ZjU3y4uFjOMGu3HGicjNa197wvmiu3En2QmxTcV3QO0ZMGfX8q6STBuWBIUkQZz6UyEe9AGUyMgYHeaaLEaosNOH8YcNCn2yJ5+lJLoZLZrOiqLllitsm4Su2fnmuGbp1YuVU7GraXBdZXAyvBJMDtzWbVElsbtackQGAIkyJiP4PSs8nHYnG9HLqsgbwyI3hF9Wxk5GK0cjbqjOIFLjyAwE8YiOOxqnexXrQTe6yDuB7jE8ekUdg0CvXLzEKd2RiZz+sUGFJI7ZRgpkyeJ4n2oWmM9Denss13bczgACRgTTIUheAH3iSxMR60u7KaDWrgWx93sDjA59qLsWtgtY95r2L+mtbVAK3Lm08enpXRi3GxmjHL57dsHkEn8qzVFbLCz57KqxlndVjiexNc0tOw2St27zAgN5Ib5nvB9uaPNaFC9Ne7cui3dhikneM9hIJ78ihJKrAy1ck8TDk7ZGCJ7fOk6MmxMWdrLJBMxJPv3H7Vm9DKWyCMQ6r5mETniR7UaNZJJ3wBHcmIIj8hB/GgCw7PdDW9r98bwJB7xnimXQuhm1Z1H+LoFJwd4IifalaiBsbt6PWmGS7tyZgH170jaQUxH7Q2Lth7F66ykMjIcRkcD8T9KENl8U+0ZK+QVFx9vl8xH8+NdK+EdcVqxYXV3IHECNvue5Nbi/BTmnti5uq19jGTJ2/KqqLSohOSbsuvsz1zUdH6gl/Tsdswy9iK5fUemWeNPsfHl4P7H2jQfb7SajRB/FCvGVPpXz2T0OSEqaOxTjJWio6l9qLFwsUJZjgEetVh6aXkVyRlNf1a9ecqZCjAg12RwKInOyo1N4A7rjD2EzNXjH4Ecq7Ky/qmvYVfKAeOa6YY+O2SlO9IrtRZZCxcdoj+fKrRlekTfyxQhzcPaRE8VVNCHkEqqvIwTuGJx3puhQJgOvl3BckR6U8RJMYtkh025kHnilktGT2aXoF2bl+Ax8NgQJxwZJrmnEnmkXRv21Sd6meFGR3/HipNNvQkR1dYHtBIYZC4MAmPWl+iB5ewGpNu54YkkYwRj400Y12I529ELpQWi5Jm43rBx/BimTa0NVkhdW2QPEFvd2Ge3w5puba0TeN2Cv3L1uSpUAiZUkcnua132MotBdMzsR5j4gyDMwI9TQtGphrGmu3GubfvDkkj6U1/JrA3bF1CqttHwBYflRTTQyGLIKWUgEMRJ3ALSPopqyv1OmDai549+HB/wAUkERXRjl7UZ9masACBkwSRPBzTSHLCxcVGEmdp3EA4An/AJrmlFsFkdTqHbU2bVu4FRBtECOZmtjxqm5CN70MHTlPDZLoRLg3NnnvAHyoXZRaRaWwLqiCFKpAbfE5/wBUiVugN0rOnTnazPeQc/eYR+FPxJ8wadPD5VwRIOJ9PatTM5hl0VhEAa6wjA8p7/lQqQOQ14Gna8nh3riuiqrBTE8wYAMUsYuKoLny2O2+mWhLi7fLk4HE/hSyck6fQFTWuxpEWxaCh35jaWMmkavbCr8Fb9pbSajp9zzS6EOMcQcxPtNGFp3ZTG6aMBr9yXyLbDYVOD8a6oK1bO1SrQgVUEs6yyiJ4PNM76Q6a7BPZJIdTDCnUibQSzuGwqcSCfWlFLLpfi3tTatK0eIQpA5/k1LK0otvwND82i8vdP1tglXJMe2eTXHHLCRdqSEryX1Co2DOaquIlsWOmdmiJMzk0/1EkLxsPa0pLWwoJJnA+BpHkDxOt01nAa4SOccUv1a6NxKXqNoWm8o4/GunHO+xJR+BFjsVoIK9j2JFdK7JPoEBJtyy4ORzn+RTJkmg2VFtpxxntx+9Duwlx0E3/EcLLKfMQIyfXNJkaohkVO2aDw7l0BrnhgKYgiIj4Vy8kLdaGbflI23WmcnYBn2zTMR7JX7IKq1y673CBAg4g80iybG412KsnmQMnJPIn0xk8U6d9DL7nVuoGDgst5ZCjnHqT6mc1q8BsBggAlR7GTuPOf2pg2HtJ4VtNzDYDumfetdgaH7WpGDaZix/+gtLLQkYP5C2tY1646ahwABjwwD8p70Ute0LTQa4J0zPaAdyICFYM0ZOlcmaCbdUUmvOo/qm8O8qrAgBfYVbFuN0UlGnRRWwniJ95pJEAxNO32O6S0OmxcWDdVk3GDjJyZqDa8C9kNRYYMlxCzKZkAZxzWi/DFYe2lzWG0DbAUDA+6AOOTS6iMWmn03hoiJbUgf5XGVuc4ge1Tbt2FPQ9p9ImwNcZFPqp/WKLyUSqwlnTaaVAVDnJZzJxSvI2HiMratJkW7e7nkn8+a3Ji0HvO62maycgSBtjHxouqBFboMlxvElX3YmQZHFBxcjWokHYHarNuYNwcxnnipvQ8d7FdVcCqZ8pgjDH9RQi22NSMD1xAuv1S2j5F2/ASsx8MfiK68b9qOzHtWxK4VdQEUiCAWPcnj6ZrJfc6HJfAvfG4mD4Y/9R2AFNF0TydhAAGAEQff40LJj3Tbhs6q1cE7lcMPgCP2NSyK4uI0XTPsOo6amp04vqZ3DdIrwYzcdHV2Z3qPSCXYQQv8Ar/dXj6gHErB0oqwChiRwY/Oq/XBxGdLoiGAYT2yeKnLKNxDavp4NoYM4iJzSrLsFGM63pSl15EAMFAyJNehgyCyjoz94F4Rj5p5OK7oPyc8lqgElk5+6IOferLRF7D3QV2nbhRuI9BSRdhkqG+h6xbd25aYfeUhWjII7VssLpkZ7WjYaa0l5LZZrYLATnPpNcjkot0ScWy1taDSi0WuakpOBsYZ/OoSzSk6ihow47YK3oVLrF+6EUkkTmPQ1TtC86Z6504Pc/tF3UQAJnHuaZWlUvIrnfQa/obiMFvIB3AJnHyrRaltMN12ji9IXfuDOwAxt75oPLWrHjb8DlroDPawgVexu+X+Gud+q49sqsTl4Ftb0xrJIREQGADvVix59faqQzcqb2Z46tAtFpD4o8ypBBLFvwrp+oqJONlppAxnxXBFrMjj0/euXNPVItijTszuuV3vBy5BcbjJGfeu6DpUCS2UmltTd3MoJwSD2+nwqk5CFzZsm829XUNwIBEY9qixW6DLZDABrogNJgGPpR4E3OmMWLKMNu+fl785peJubDWNJpmXdeuEBT5ioJH7Us010NGd6O6m1OlY6dmtgxsPf4n8oriedt0jqhhS/MKX9U9jVWkvPCXNxjwtxEAAfjP4VSE+asEsSS0LWb+pdHv27jhZbcHzk5Ux68YoufF18jfTTSGNL1uxf0xs6lQNZLL92A2eQTxyKtTekSWFqVp6Gb+vS1a8Urb2IvmLOAQQOBiTUfqSvilsb6C8sHqOraf8AozfQO5UyyHy7SAGIJn5Yp7ldCrFsR1PVLd7UWdRpw5tKCptkxHrOcUr5KWwqGqMrr9T43UNY4BC3LkZOcDkV2wh7Y32dEHxXESa7c3bWk7nVue6iOaLjXRTlZ5CGIwcjAiaFUCTsbsWXubRwFIz8jU3KhaNB0bot7VuvlcWzPmjmuPNnUSsYH1boyumitWLgLFBE94AxXjZHbbRdIY1eiFxQPMQRkfCkUg0VbdLMqNvPI9Kf6hqGLPTfDG5hGY96VzZqB6zQ/wD4paIjnJ5n86XnsKRhPtdooBdVIuKN3EA9gPzr0PSZN0zSWjEaiybshRLx6fGvYxyo5pLkgbaaLLkIQcc/Imnjktk5QpBerWvDs2GBMsgkfp+NLgbcmgZElFMp/wC5bubhlgC8ye2a7GlJUzm2i4say812EeQ6j7rmOPz5+lczjSA4ot7D6t0X+6B6Q0xmueXFbEa8DvSdVqXv3dNJCqCzZgc/nSTailMfg5PiWWp+0Nuzp40FguMrFzDbpiSR2oKEpSuQiVaDdF6nZ6heN3XIwdREAkiJ5pM8ZwjxxuikEuVyVmtuWrYtkpdubztIWTn9q8nHKXKns7mvbrRVaoBdOL10XboJCqpuCZ+HpXbBK+KaX9CEm6tpgNJpFsh71yJCztnAB4/WnyZHJqKFiq2Jagsu8kFEJ2hR37TXZjVoRkdPeuJp3s2ratMqZ/xGRj8aM4JtNmi60iOrMaq74ZJSfKVYjEe1Vxp8QSqyrIt21V5yVAInvSKcnKmWniXG12OaW8HVdpSBzOOfzquzikqYe5/aXc6W8NAz7Uykkmybi26RHSaq0ni+JZXYIhh/v40kskbob6MqsbVRc8pOy2SSEiSQOJ9u9efnzSbaXR2YcCik32A1+riQDhVhQDB+NRgjoUa7FNIPFvsxgXbmNwInj/dUk6VeECiWnuzprll4G8tnjtz9aMo7sUzl1rf/AHW8XAaU2gE8fCu1X9NUL5YK1qwtm2NQbl3bJILkFSP5xTSi27iIutjdseLpr6KzbQ3zzI/Y1N+2SbM1Yj4z6a85YblA80//ALf5+NVcOao17K3e1yS5ksofHqef1rokqQ8FbJWk3srrgBYk4JM8fQUknWiqp7LDp2je4wVFLFsAAScnioZcqj2xlG+je9B+ybIFu62y5LCVtCI5HNeRm9dy9sGVWOuz6N0TpVnTIrXEVY5rzpZHJlKLh9ALTnYvlI7jvPFSlMKQG7pH3+UBhGDx3oRmzNI6uhLkErjtmjzAG/okBBKgnmSDn+etZswlf0qi2wcouZlvxJ/GlbtjGJ+2GiT+mUghAFKqJ5mM5OcV1enn7rCfLtVaVdYgtuNglw+2MivehL2WyDXupEvB/wD0ZrrnzloIkDvH6UVL/VpfAkvyOxHrNsSlsHIInM9v91fBLtkcnSRWskXV3f8Aq3M5x/uurlojQbpu0XCrsBbb7rEwAR2pMn2Bx0Xtnpt29t8C9acGJ/uAZB4iZ/CuZyS/MhWn0i30XQL99HR3Kt6gjPrzxUnlS6Fcfksrf2T/ALQX+8WAgGQBSPO+xdWP9P8AspcsBd20qoyTciR71z5fVX5L48bfg0OsFrTae2uqvsUiFW027HFceOLcriXk+Kp6M3vd9VevFCLQVtkmTA/euykopIi+w+lvBbBe4d9y5LEESvp+FFwuWujXoq9c/iXJtyybgAJ5AArtwritkpO9heloltA10gbnIMjt2/Wlzybeh4L5K3X3ybwCFSAvcA+/611YoJx2TnJp6BIouIjFVI2rPuRArkm6k/6np464pMm9lNzumGJABHFBZZKjTwwlYK7rLjofGRG2lR3B9fWqKXcfk5JenSakn0S6YGfT7blsNuMQB25/MikzNRdpghCy0cgBFAJMGf564rhW9s6+KiDfR+Jd8MtLOREkAD39h3o86V0LXyF0nT0063WsleR5+FE8QOTxSzyOTSkCvgR17Wk0jeCu3aCT3wI/cE1bHblsVqkZwWp1Q5KQGMexrucqiSoF1xTb1O7aMiH9zyT/AD0o+ndxoWfyM6YkdOuJMBnkwe22M/Wln+exkrRUdRVrYAbIYs3MTmunC1JtoVxaWxe3I2gcqomTjvVJjQ+w9o7Tv5BkKTMdq58rUNnRBN6Pp3/T3olu+hvmFYmFBHaa+f8AXZ25cUdUYqKPqug6aqhdwB7mRJrzwPZbppRtBA8wMg+n1pE/JqCf04e0rAEBRgKYHyFJdjdAbun23JYACt0YnbtbSpVWj/2jBzimTBRG/bhgAuRn+Gg3syRT64BVYKOZ4Gf5zQYaPnn28Vrek8QmN1sIDH3STkfSM13ekaeRILXtZ841enFu4vjhmCkjaB8Mf8V7MJ2qiTca2w2sup/2zTbVgk8Dt5jE/Whji+bEyPRnup3i2rIkGWMY9IH6V6GGNROXI/dQJoPmPAUKMdyKdMFaBvbOxSV2q5kCOKdSVma0WvTdcANpm2wAnMSfX+etc+TG+ybjRpOldW1Nh2RLlzzKyncxzNcOTGpKwXTpH0jT6y1c0tprKS5UBnVSQxj1rznFsraiwXULOsaLiW9sCQCIVvjRio65DuV9FddS4bI8NA2zJJEwfjTqUeVtiOLqqFb07ShRVUAfeWNxnsaonW0LXyATS3r63EtgMCGUACIz2ro+pGFNicW+jidOKNtNtnbcIEc/D8ar9dPaYFBiQVXvWFYIqWwznE8kYp/Da8hSvTFNRbN0pdIA8QFvL6FjE11w1FJEpbdshZbZ03TE5ISZGCASf2FcM03ll+p6EekzwZzZDQAm7PfjtSSSUq8lU9bO2dOj6e7u+4qrtURyQKSU3GWvv/kWKu7O9JdRcS2YCMwUH0x3o5k2gJU7RcLoo1LBwQFWY4354rl+prRmDtaNBqbcMxLASM4E5+taWR8WmKlbPXUfTm/bFzcA26CIgREfKlTUqY9Gfu2QUuLebhiuT94GD+ldcZ9NIWUfkVFlHvIiBk2nazgTjmPjVeTUW3snKvBHqFk3be25/wCRpaSePejjnxdgcLVAxbt6fT3FDeUANvYR3H4U1ynK0GMFFGd119b94m2ZRTtBnme/516GGDhHfZGclJ66J6e07uoESQBjtmhOairKY43o1HR9CzXPDTCkQ7xPPrXlepzatnfjhWkfcPsb05LGiUL90qNoH7+tfPZJ8pWx590bCzYhgwYTET3GanYg6qoBEj0rPRgLs7EqoxnkcUtvwEE6f3gWGCIBNK+woOtvbOJHxqiFFNRzE8doEE0H2Ep+qKNojaIMn/isjHzv7Zalbdt0ugNbK7eBJJE9/YV1+mg3K0OvufNr997mkt5LXATAzK49a9uMEpP4JN6I6oi30qyC242oBiB3B/angrm2Rn0Ze4394kSSpg555Neko+0479w7pdO95tgMIJMk4JipTmolYK0Wer6Ve8gVfLtAEsfwx7VCHqEUlDwVuq01zSXhdYLE8Azj0rphNTVIlOLTtlt0bWJcvi3G8GBBaPz4rm9RjaViRj47Nh0/W32K6WyElJM3LhKLHeeD6V58o0rsPtb92y30Gq1d4XXtDSlQQFUWx5vXOam26WzOML6HjqtSmluas3tMpC+S0bXmOeJj51BpSaTKJKPQpptZqtdZLt4SnuRaHPaT6VRwhjdICcpLYV9XasFltlyqDz3ydqg+1VjjlOn8+BeSuhO+2pfU3WRrplSEEnA+HwmuiCgo7Elfgr9WlsDwSVS2p2kzm5Mft+FWi3dgS0V+u/pA1rfcElAYCkgZOBVMf1GtIEuKfYDRoU0to3BAa3hvX+CpZHc3Xyd0VUEDe/cW06WwVEBRgZOcRRaTdsEk6pHUvJa0zqTJ5AjsBUpRbkZMT014NZcEzlW4/AVeUaFUjX2utLqNZpLN9EFm4q23LEgq0Zafc/nXlz9M4qUo9oppKi4axbuFrtkAEwJLCOc5/wCeK5ItrTBaEL2mVXfdcTaxAJ3c9oqibaA5UUfU9OBd8QM11FYMBHcnED2roxS1QJOxCyyu8sGzPlbgese9dEvahYptinWb6WtrEhVUgz61TBCU3SHlUNsyWv1V3W6h4ZhaaPL6kjivXxYo4oo45zc3SBWkCFhtluB6Azii3ezJUaj7MdOOpuAldzPgCfl/v5V5nrc3HR34I6s+g6DolzUPaXTKbl12BdzgMPL34H6V4WTNumdkaStn1zpWjNq1IAOSxIJjOf58686/BN7LayBMGRnsee9MmKGIG7blvefrTUAE6s8QBjn1oUawZtlXAgfHk4rSWkFBXI2kMIPE1rMIalWUEg8dzWfZkUvUFYad9wJB4HOKxj5n9sQDrVJVWYW8ZkKc+uOK7PS9FDEasqCLVtG2M4bzjPqa9TFb22Jk0hXVLd1Wm/p7K83CSxMAcSSe3FdEGoS5SZySuSpEunfZa6VZvCu3S/mATyiJ/wDc/pRy+uj0nX8+BY4Gi+03SdZpgWs2dBoUUxm4Cwj3rjnnhN7bkWUGutC3UOnIqeLqupB3MDyWi0T7k8fKqwzP8sYgcfLZntfpdGdzL1J8Z81ofpXfiyZE/wAn9yE0muykFq5buHwWFwqIlDBx7V2WmvdoirvRd9K6+9hgt6bb/d8UYx6MDXJm9Ffuh+3+w8cqepmu0n2gvIQot6FgCBG1bZIIwMCPwrz3jrWykscXtmi6T17T6lyr6CxYInaFdWn8s/Wpyxpbf+BHifgsDrtGqlXslhJYKE2yPXmkULdxAk2tsd0ut6be04ewVZGwyskgfL2oSxyX5tM249bQd/6NLbujW9pO4EYke3wqXCXVlOa7aKPqfTf6k+IipcwGUoZnHM/PFdGPI8Wnozqa0ZvW9I1/jZRFwMNGK9PBnx8DmnilfRSaGbiWkYKTs5PIE1syqTZ243cUWF23bCqqkuAMk1ycn2ynEg+jF6yTkFFI8ogfP8qX6jixVFPoCtmzYZkt+H4hj3kYxAp+cpb8AUAGtVnOxAoIIEjuRNUhKtszjfQ30u5f0O1rV02mAz3XnMjvxS5YxyOmjVo0n9ZbvW01F0CbiAhdpJWe5j515jxyjJxXj9Bq1Yta041Kkaa5b2kHaynjOR7c0HNwfuGcUyt6nY/o9O9y8NiqhmTnjJ9vjXRil9SSUQUo7Z8+6hq7us1PiFvJwme3r8TX0ODDHHGkcGXK5MjbUAnaVG0cjj4D6UZMWKOBDcvLbQzJ496VulyY6VukfWfsD01HthwwAI2SIk+3tXzXr8rbo9PGqR9Y6T05VuN4VnwbYUSezN6578TXjylsdvWzRW7QVioBjcdswO/rSL4EZNoDAgnn71MAlukRj1pzBkCkgkSwBIHrTAOPagnn5mg4mTIlVLDGD6n3/wCKNIwrqLflwQDnn2qbQUZvql1ip8QnaAYkiaCboZI+YfaHxNTqhdLSjy62lfbwYE/KK9D09RVDvRmrvTEtkXNRcZGMByBIAHYHtz8a9GOV9ROedPstumad2c2undNZ3USHNuQo7STgT8Khkl5nI2l0X7aJkteJ1jqCWS4MoGDuO8COK5uSuoIOyv1/VuhaS94dm2LjLyxgs2c+pq8MOWasW0ig6h9rdykaPp+nQHAd4Zhj5mu2Hor/ADSJuaXRnOo9e1l22YvWhuPZTGR8K7cXpYJ7RGeR+DO3rlwsQ5R8TIwSc/D1r0IxRztsggGoSASGnv3MVR+3aF/NpjvTtTsdbOpKqsgBiT5R6H8Khmx2ucSuOde1mjR0NkDTqA0yWjmcfSuKt+46lHWhkdVvIhW4Uc7uXBPp/IowxpPRKcWy66a2q16G304p4YP9xbRAaPhUcnGLvJ2TkpV9jQ/0GrYi3de3bIXYzEzAjj8q5rS2kCTT0hz+kSxi5dZ0XaBxAUfOp+99IflB9imvWyuoKxeMDsZ/Wur0/Jw91E8n078mA6YqhlJySpwTA5iu31Dd0dWCuNlpdAtSQxB5J/CB9a4G+RcH/VsFIXzPzxxih9NeQOTR21ZlwbuHHm3OIg8QKDl4RlF1bGbtktZLWcwBJZeO0+3Hak5W6YXohZ0RJXyEjbIB8q/zmmllS8i/cbTSanUEjZdaQJW2pAj09BXO8kItNNf1DfyhzSdMfR3hcuxprYG1U/yY9yf2qMsymuK9zDTZkvt71lNUw0OmYstuN5HHwnvXrfhvpJY19SaOfPkX5UYpiX85YSx44ivYOL7jLAi0zLhRgGMVG7dFEtWG6ZZJvW2Y7RG74CalmlppFcSp2z6R9jupnp2ssjUS1gg7h/6f/UV4PrMP1Fyj2d0HXtPuXS+oabVaVXR0If8AyU4/KvBlFxdD2XE7rRZtozDfwUX8oURa4VOwSWLTHt6VSO0gNjmkRnIEwT5o9vb8KD7MPr91GWDief3/AHqnexSbIMjA5GJxTNATAMiqQDtDEce1LQbFtTs2Qvfjila2MjKdde3akEz5cebj0mkUHJ0NdHzvrOoQXdulFu5eIzdJAAHxnAnt9a9HDjpbElOyjS9oNITe1Fw3n7KFhZ7kflgV1OOSS4xEvdsR6r9ub8Pb00BYAUAkKB8Kth/Dk9yEllSMxreoa/W3Dcv3H8EgwzEIo+vNd8cGPHpLf7k/qSkVjXHB2rqkU7p8iSPqf2rpjFd8STk/krrl2TN687zhRvz+FdCj8Ii5fLAM6mSHuDiOTOCapTE5L5JI8sp8VzJAEnBFGvsLy+5O0OCwMDB9OMUQ8r7DEsyAN5sQDMkex+v4UqVFL8lz0jVtesi3cAZlHlaYJA7fKuTLh4vmujsx5uftfZZDxNoDLuSe/NRtFOMl2StpZDYdrThvKVGflTNyr5QnGLfwa7o/2h1Whuhuo+Lq7ERvS4dwxGR3rz83pYZF7Pax/fHxZoL32i0+pEadEa2RywQT8QfjXPH0Sxv3N/3IuWWW1EFptSvhklXyT90pFdeOUYxq/wDJz5PT5m7UT5ZZuta1gdCYIK+m7PMdq9XLBONMpik07NCLlt9zu3ilpmD7ivHkmutHpximO6GwlpCX+65BKjJ+tQnNyfFeCn00lbH7Nu3pn8S7aRi3mAImM8k/ziotuTpMygmjmq1txvDt22XaxyFQH4VoYY7bBwgtB11d/TOQ91u8wBPuPWi8MZq0iUqi+gWo61qSHUXWCsNu0kfM5pF6WKdg5fYxP2l69fa42mt3rhcAm65JJH/z/P0r2vRejjFc2v0/3Ob1GXfFMzTSltmdjuyciY/hzXovbo5OgGlsm7etKcIBye1NN0mxI7Y5eXxWFu0pgnEfia517VyZXvRb6HTEX0BjaBAn1HJ+uPlXJOWisTQhxaS3CDfENIxGIk/GR8jXE42XUvDLXS9VvaV1fQX209yfMN0j1yPgPxrmngjL8ysrGT8mt0P2+1ektx1KwLgH+VpozPcGuOXo1J+xj1qy66N9rtBqtQz3tQLbu0gXBEDtmpz9POKqhTc6HqmgvWAbWosmMYec1zSi12YcXU2pHhXUP+OGyRHv/OfWmiwNE1vCVZ2QZ3CDgA0b8AoX1GphIBGOwHMZ459aDbugpIznXOv2NEjKLieKARCgTxwINaEJSYej5l1br97WanwijOfNFtT933Y8V348CirJuRi/tB1dkARr/mAwEiT7e/4CvS9PgvdEpTpGZuXLjsXvOVBI/wAiWPxr0IwS6IymKvdFiyWRZaRDOMAniBVuHLsk5UJag3tRqtzl3O45YyB2/WrRjGK1onJt9nT0/wAIlbgEwGAifSPhIzR+rfQOHyC1OkRHubViHAGPejGdpWBx2LGRIDEMCVkYjn96ohaJWVlRtXjzRHbtFFsFDVn7rKw+8ZI9cUGNH4C2SBkA7GmQe+R/qlasePtY3oB4V6QzJuE7gJg/Cg/cqHi+Ls1SKHFp7K7bbc7QTB4x868mftuL20exBKaUo6sNc0ihWhQ0DsM80I5N/AJYtdHbHOwMysp4OR/qqtWrIrTromd2lui8AFYjzSJVvamSjk9rFdw2v+P6lrp9Zau6e3cuXrlosMJ4cxn1+M0iw8Ndgnn5u1ow12/t1Nu4QSFB78H4/CvRlC1RxwnTvsuOi39PfQ2kDCebcQV9DXkephKLtnr4MkJR9ui+LMAq+ef8WjiuLirZW1SQ25GpsqmrQo6iN6mQfkal/wCt3Df6g4tC66Qk27iXEJC8t5Sc96eWa9NC1TG30l24yswBc58hmflU1mS0hZK+xHquh12lsPqX0OqG0fe2+WZ+Hwq+LJjnJRUkSaaTaPm9pN2rv3WU4JPmH1r6PXFRR5v/ANWyZUeHcJOWOGmeQaK7Edg7KqiBlncxgSZ5+XtWlsCdDmktFtYpWJnBPE+tc2WS4loLZf6e6tsNsWAh2qIiYGCfXn//AKNcEk29lER1OrFtbV64wkHcYMx2A+MT8z7Vo4+TaQ3JJWT0dy8LK3rqhTcO53OSO8A88Qfn8aXIo3xXgaLfY9pbrai7cdWGxH2LPmBMT8s471GcVFJFOdsskKlQLlsQFDGYlfie0EgR71Nr4CmgyXbUq1q49okgAqxAJkf7pJQvtDKT8Ddnq2rsNNrW31HBhg3NReGL8D2OJ9qup2yR/WSpUAb0ngdqL9NB9IW/kJqPtb1M2S126kN7Bce5nj86H/ixbEeRLSRQdS6ibVkXtXq7is4lUKw7j/8AiPxq8MNuoom8hm7usuahWuam9/SaKSQqgkt8B/kfc11xxKOoq2I5v9DM9R6pYS8w0WnZAT99jvuN869DF6eTXvf+xzzyJdFe117zs4wTmD3xkmutQUSLk2F0trdeJcHauSRn4frU8k6VBitl9pNHb3C/dAI3b2b/AORgAe5rkyZP/lFVHyJ3m8QXbrZLviB/PWqpcaiB7Eda+65qBP8AkCDHuarBaTEaKwjzzLQRBg810JiNHrDEL68kfz5UWKEtQbgEDI+MxWfQY9jFokdoMZjv70KGutMZSUaFUt25oJbsLeqLrR6u4NPDT2BE4x3rlz405KR2+nytRcfgsH1xu6Uh7e3cCdyZk/D5VzRwpS0zqllbjtHdHd8W4ZdCewPr8O1UnHiroSElLVlt1Gw1/SWnVYBAHOQfSKhgyJZKbKZoXDSFLKuLSk3razMDxAO8cHjivRS+DypySdMz91ZYFlABE7fUelObsQ0WpdNfbcP4ckgkehHFTy404NUdOHJxmmarS624zgi6QSJkE5+FeVkxJaaPVjJNWW2n6heIcEHgeb/mZrkyYojpJ9oL/XqVB28+luD+FR+k1/2NxiQ/7r90Km+DEE+n+6dYPLZKUV4E+udYY6FrXgIpJzE5+NdPpfTx+pdnPmTjGzFm4AMFZIjk8xXupHkybIllCf5FQMY5EUUKyIjwlLbokUJMyGulBt7kQAVxPuSPlXPnrorDqx6/qg+uUKGCKIJI4FcqjUbHF9XqBqNZbRVmzbycwD6/U4+dUhHjBt9sDduidzVMFNhXbcTDEiRtncY+NBQV8guXguun3FRHJLNdnfMQCxwPxmubIrY6ZZtcUqLajyyQG5wIVSfQ5dviahFPt/z+aQ7fgiLihQpkb1WfaWwDPsJ+QrO7sK2AfUIbs7l+6xViYEDE/wAzRUdBvYD+qZrqW1Zi427ggILGDj4nGf0qiglsSUn1Yb+quB9wVLl7BdifJaXjk/nz6DvS0v6f5EKLqWusG8He61+4cT90T7dyfeurHjk1VUI5JGe1+sa6dx3ERtye36V248aiQlJsrss8KpBJ7d66NJbJbLDQWQzAPjknueP9VLJOlopGI9aX+0shlLmYngR+351zt7spQ9r9RNtdLYJBLBnkcETgfAfianjjvmwyfgWvIEtWbarucySAPkKdO22wPoMPs9eNu9e191dIgK+QkNcbnAA47c1N+sjqMFf+B/pPuWhS70vRrfNuyLzW1+/dd/N2zAxE08fUTq29/APoqxe9orQs27NvYH8Kd/EvMmT3GYHwq0czvk/n+wrxeEK6ewUuG5ddggJWAuf5H6VdztaEUalsixm5lYMbfN6djPensWrGUJclW47+1azJFl0ohtZaR8JeBUA+p4/KufP/AOtteDqwNLJvyi5fTFbTOAyqhAHfmuKGRN0dskkrsIbAFxtwBwZEQTFGGR1o01HtnHuBrCBWuFlXcfMSBngCuiCpnLOV+SemaLQN3R3bjNmVcAD8DTvj8kvd8FP4oJdSjMQSsTEZ9as0xFKKRXG2TqGbb58gA8Ce9ZvVGTd2aWzZurprJDeXwxEGScCvKySTk6PYhy4r+g/Z011yl1EZ1USQTE/OpSa6YeTQErdLRdUqvZVPGe/40qpdDttrYRptIIBUnAIOeZpNyDpFR1bU2Xssiq7kHLE4+HvXbgxTUuT6OXNmjTj5KIqN6qSAoycV6S6PKk7YB7rLdYwcHn0/anS1Qnk5ausQUYmSYmKSXyMix6dd2G424/eUebg4J/aufKrKRejrMCdRcIMwFWTyef8A+JqbjpIKZDpz7tQXYAAEsfgB+8Uci9tGXYQXFV5I3MTPf1/ahxdGst9NqDY0+/aoad0xPAgfiSa55R5SoZMaTVkWEQZbcqkzg9z9Sak4bsdP5I3dU7ByG/8ALdOR2AkY+lZQ3+geWhK3ce5cPG4CEQ9gDyaq1xQt2MvcFnTCzbYBmEPcMyB/OfpSJcnbA2Vuua7ctBV3pYUnzHEmYk+p/wCKtCKT32I3oor9zIUcj/KPl+ldkY/JFsSuXXYlRIx2GPhVkqEeyekUZYwOy+3qaWb8DJD1i4FTccQxZhHIHb8hUZW3oeNHV1J89wnyruPr5j/BQ4VpGu9h9EDe8W48sx8qDuWJOPpS5JcaSGirZc9KZnup4drffyAedoj+En3rkzdO3orBfHY3qLvnUFWvXmIJ42j4nv8AlUYrT8IrVfcr1sax9VeG5gNxB2nEe5/WqucFFAqTdiD3D5h5HKmQ4eeexNdUItiSddlVf1Za4yqQQQQSBGDjFdsI0jknK2esLPlMgDPrgftRkLHbC2t/iIHAngDtWVDttMYt3TbVT3Uhh3zQcE9DKdGr0nWbD2DvsqGK7nEEZH+5ry5+jyKWn+h6cM2KUVZPX66ze8BrLKAGYnGab0+Ccb5C5pY60xXS3QHtSRtK4aY78fjXZGNnLLQ8l7w7VvzJBEiWg+n6Vz5Iyb9peHCvcVSWyoQE8cSMVVuznSO9O6edT1RrLBwqyzNAkCPz7fGky5eGPkGKuVG4XSmbRtmdg2qpwB2ivGk41TR2rLPwxo6dlDJCEyfvAfhFTTiZ5Mj8kBpFZ1R7NoweIiKLku0zLJkXkFrdJpQjpd09scBDmQPStCTu0wvJkfbMH1YaW0q2raJKkFoMzjj5Ga9zC5v3SODI/CKZm/xIDM3piB/PyrqWyLFwhN08GQMGI9KdsVA7PmchomY5iaEkFMatsQX2kkbpn3ipyiFM8x3WXyBvbv8AA0lbCEtEJZvkDIgZ/ntSS20hgRc+MoTAKiPjxT1rYB+5c8S5tbCKZM9gKglSsayaXDb5jJ3/AEGAKDVhPC6XZVUiQC2B3yf1oca2GxtANNaKnNw5uEHHOFqbuTCdaLdjffH91vN4PBj39KK9z9vQrKPX6u9eujex2rEEcZ9K64QUeibYhcYW0CnbvIniqR2I9AFWOBk+UVQUKSCQABAG35+vzpN9jBLrbdOEBJZjvgDt2H6/OlSt2G9C9lC9yBhRDcc8UZaVgiX1u0bGkt2zksNzHjk5HxwM1xN8pNnRFVouungIsqB5gwMDMkA8VzZdvZeOj3jph9hchsBew7E+uaHF9G12Umu6mLNx/GuvdY/4twvtiuzF6fmlSpE55VD7sz1y/c1D3Q1zbJDbRA/nNejGCiqRxym5OzyIgYBPUifxphA1tyt1X8uGH48ig1aoKdMtTYMEwJtRjGByDUVNJ/qWcbX6HBbBdgGBAEg/jTqTFaT0WvS9Gmps3iVhwRIJ7H/c1z58rhJb0dOFJxqizuaBfBt+HaUtay0iZ9RNRhnfK2+yk9xqhXTSWAgrIJJIgTJ5rqW9nNJvpEblu55dqDaJjbbxyaDr5DykOXum6t7okww+8sAj+YrnlmxxSZRY5tl70jRDQ6e4zuDdf7zDIIHArzc+b6jrwXjDiWqPvtD70SGMGudoemFN7YUIALHgc0nEIV7irabxWud1gNAGP5xU9t0hin+0HU10vSb1wFWuuQlsAyRPf2gV0+mwfUyJPoXJLhFtHzV97sWJJYc45JM19DpaPNt9gzbm5vBG0DkDvTr4EfyeIILgJOIyvNFtBSOBba7yZG7gCt9gNeSSkMrhI5BwKWWgxBBgthgcAH4ZpGthCqSdORiWPYfAVN/mG8AbQB1qiIg8R2FPL8gPI7acm62JnykfialJaGB33LuWIBY5IjijFUYc0AIuNcaIkgepqWSugoZ8TwbQuHN1siR9339z2qVcnQ3RXvcN6ZYiee8mrxXHoRil8hMjEfcB7+9Vir0KyreWubvp710JUqJvZMPB34gfdx3NK14MRtgFoJwo3NTMBIvue6SOe3p3oJUBstNGmxFuvAREJgDJMY/HNc+SV+1FYKtlgB4SAsGD7BHtiua+To6EuKGtLqP6fSjcQGblo4J9alOHOWh06Wyl6p1E2N9rTck8znI+ldeLDyVyJTyU6RRNJDloJ9Oe9dqdaOdq9nhCuZkYgxiMcfWimZoMFE8wJ/WmEYUGZmPcEe9YUudOVe1bbzNuAQzXNNU2dMXaREpseVIgCYGMVRMR6LPoj7dctolj4i7QYkbhkVz+qXsb+C2H81fJpdIotlMtkMG759YrzZOzsohc6axZH0yhbe1iAREE+vtVcXqktSJzwt9Ak0TbAu2+QvG0CADnv8aaWdPdoKhQt1PXXBqLfnbt/iB29J/Cup4Y10cscshFNfqJM3mPcwOPpU5YYfBT6khrSavUCE8a9Puv+6nLHDukbnIZ/qrttApa60ACNhkfKp8IvwNykDv9ZddPdPi3CFMSV4xjvWj6dOXRvqNLsz3Utbd1RU3WkTG05PFd+LEoflITm5diTOy3VCHv2/GrJeSbGUKxbUrCkdyTJqcnJWMkieot+aQ4aRPHNLGY7QjfQkOxIIngDNWjJWTlEjbbYHIPJkj5/wC6MlYsQd1gVZiBE5z3pUthD2iCbSvng/hNSl5oZALbMLxZee84qjWtg8jSP5n5hQecdo5qTXQT1n+6wgncrcAdqz0EeQkuqW5hBlucfz86g+rYyIuwIG8kDMD2/k0VrozA8jgBQcnufYfrToVlbr7niXYByOw9K6McaVk5MUaQqkHkHkVTyAGx8gWccH40AMmWCAjEgEtPfNGr2C6PWzuAGDLZgRmiwFrahwt2NwXaqj1Ocke1ckte0tH5JanV3L117rsCIgY7UkcaSpFXNt2xG9q5Cg42kAKa6I4/gm5/IjfuG42TkkiPT/mqpJCW2EVSNOCFg8QPgf1pbuVFKqJALuUs2Cfb2pm6FSsNM4BPI+96U6JyCK53zAI2/wDriiIP27xQEbhIC8dualJWUjKj39QdxUEj/wCo4FFRA5WFtXnW+LgJVwQwkc5ouKaphUmnaLNtfdO1FZTuiY9v4Kh9GN2W+tKgum1d9mE3SRECfjS/SiukH6kmTW9qWnwrj7QYwSKH04/Bnkl8jXUgovrKTnmY7UG20CMULrbUFQwGeB6VNtsdIJZILIu5eY3CP2qcrDojq7yWVWb8gD7wgk+mO9aEXJ6QG6KfV3vGuLtXw03cMZYk/DArqhHiqEbsWS0xtyziJ9eKpdvSFejqWIO4yQ2Z4+lM2xUN2UJthd7x/wDAHNc0nvoskHayMBnubSImZH5UnJ/YNFfqECsxLj5mavGViNCxYC8oY8jgU92heOxM3v7lxNgzmZ9KdLyK+6JW7hN4bBwCQJ9aDjo1hNOCSWH3tue9CRvIRCfDljn9M0jVsYZ0Vz+0bhjjipzW6ChizItsWAgmdp/yP7VN9jHllpuXCRJyR3+H8xQ60gsr9Tf3EqkBFzg10QjW2SbE58xPfAGe3FWEI7dzIDwv8/SszAbhgKZ5IJ/nzNFCsg+4spGABAH4/WmWhQlryqrt34HzzSv4Ciy02NOHL+TBCxzA/euWf5qLRK65qju22pz/AJTGK6I49e4Vz8IGig3YLCTJk9+cU/6C/qetoXeSQW96DdFIxJ+ZDBMgKDHvk0i2O1RAzySYPaKcVhPKFX0DQI+VMmJJBVO4SDjg+8xTEh1VLkgERA/D9Oak3TKJWjtsGeV9h60wtE0XbcXxIIEe2PasEethmtgCOMxU5tLsrCLY9pbN1RnykzJImADUuUSvFjenDBW3Xxlj/j/uk5peDODfk71K41y+kZA57waDpAjYoXZMKIE/SloLI6zUPp7ClE3XCcK2APc/zvRxw5vfQsnSKm433WuvvukZ9h+me1dK+F0I/kKqXE0y3ntkq7lV8vMRxWf2AiV5We4oC2wu0AhRtE8SR+tK5VthUG+glpfIpPlFv7oEmkeRvQ6xpBra2AzgSvIBMj+c1KUpaKKIVvAcsLWpckCGYGAPhSXJVaNRV3TfvK5NoXQRAcx2/PFWXGL7oWrE7m5bm4g7SIYAZX+RVE7QrVCdwEXpIMHOfarLok+zoDAo64Bgz3rP4NXkLYeLbKAF5AB/Cg15MSktdYRCjAA/Kl6QRywodlQzsEFv2qUrWxkP3V22i7iF7H1+FRTt6GK3U32cRwuQB7d/1q0YUK2V93iBIXj51eKJs4ASYAwfzogPXSQoOInAFZGA3Fb0kj+CmQrIEgbSJA5mPasAkFYMiAeZSIHcd6F6sxLU3h4RCTtPlEelJGG9jctCLM0tBG329K6KJ2FtjcVBEH4UjZWKGmWLhA5JnA9f+fxqdtluKXQByQVIyCqgmPamihJWjm6cwwJgZPNNTFsmuUg5WTS3QaGLBhwDGSOe1UfRKt0WG07iPX1z3qS2O3VkV8tyB6x68U4rCr2YQD37j6UAlhp7e4gbzjEAmWqc35KY7+R/TI67QGO7zZZj5RUZUWV0EW5cEnaSSZMA1PgHkMalCruR96klLZoRdFZqCWHn8qISzGYx3NNHul2zNPsr/Ea8LmovmAT90nAAwAPh6101xqMSPe2RtKGO50YE8DEQDii3xVApyYPxghcpg4m4WOI/2OKHC+x40gmnvm2vnRNoyHvSCRk4A5mklj5dP9v5oopVv/Ivd1yKGDsPNnbbaMVSOF6ElkRy3d09yU/uTjkkTQamt6F5RPPfsoy7WnJ8u6TQ+nNrYynFdHjqC94kZXkKBGZoPGkjKTbB3HlSznJOI7Gso7pBtdsQBaAoznP1/wB10JEWMbh4ITggY+dIluxm9UCbbByPrPemoUNpUZgYIOCSTgHFJJpBRbWtlgM2LlzdJbsPlXNK5MfSAaq4bpcu5wODTRjx6A2JEbjJ4zA9KuAWIJBJbEmJ9f4Kb7CHkO1QeSo4ogOXD5x6z+lBIDOTBM9xgnimoDAnmJ45j8KYUPauSb1wjJO1ZPMjNTa6QfuKXzKhfYH408UBsHEH4UwUMWgACz8dqnItHQyhYtA2wYJBqTRZHrKk3EkzjiML6YoS0jJfci6AWyrIpE4gftTp7ElFC6naCCDknd7SKo1ZJPiHtkxCwuIPt/qmQklQ8bzGFufP6c0vEPLwyM7iTndJxHzrUCxlCN68EAzgVqCWGjceNbBUsJI/GpZFplcemWvhjxkICf5f5H61BPTLNdFpobHi2SzFQwYgiCYpNAdiPWS39TcfufNCjuTSr4Y66szOvunZDkwzCfeMkx9K68cVdkZt1R603iMiPA2knaD74n0p6roVu+yep1DZIhRIjvtz+NJGCsaTdUK27W20107Z4QEEjfOTHcgHHvWlK5KK/iHjGo2WOm6SHLLqlv39YcrpwNzkerAGFHxNQyera/JSj8+P6fP9B44Ivc7b+P5/+hj0O9pt7Xm0mhQ+bYCLr/hgVzv1kZ1Scv7IssDW9L+5xbGiVCq6u9cuYPmhU/I1nkyt3xSX7sDxw6bF9R02/et+IumFxBJ3pdBPf2FVj6hRdcqf6CvDy8X/AFKp5014jzFTytwQR657967E1kV/4OWUXjZ2+26biQBtkluTj0pUq9rDd7QlEloERmrLom+yUkAEwZyP586NGIqCMkQI79qVs1Dli4LaAH7kYAxmam1bCG8Qu2YI5zSVQbBlkjLYo0zAbtyQOPiTVEgAGLE8DJk0wpC6xAED0j40UgMgklVBgzzPb+RRFJXGKiCMRgUFsDFy0wOT3pxSb3CrKgiBzHqaVK9h6BMZMe8TOYpkKzoYnAUetZryMgttWYwVlsjHJxU5Otl4K3QS4mwjdA9gZ78fnSp2O4k7NwWjwhYc+IJn5DtSyi2Muuz17UbyvmOMkcAZ7CjGFCyleha4W3uDmTkRmqpaIth9OwJEwyg5rPQE70MyHvFJTBMS3aayvsD+AgDK7SMzExE1jBRcKpPPxOTiiYb0WoAvWnzKsDBxU5QtNFISppmhtXkZlyFMsDjExxXJT3Z1a8Fj03xf6cm3cdQWM7RIJGP0o6RGVtlV1m9/dY9y0g/LP50uONlJOkZ3V7l1m1zhQDjt/MV2Y9xtEJalTOEgLAIAAPmNGjWC1LkMNglnGB655/KslYW6LnTBUdbhVjasf2rcEAm5yzT7E8+9efO9rzLb/Twv6nZCv2/yWXTdRse4rLs0gHiXLYP3yOM959/fFc2aFpO/d0i0XQGzodd1zV+IqvbsMcY+8T6esepwBWllxelhXb/n8+4HyyP4Qzd0SdPuLb0dmzqW2y1+5fS2gP8A+45PyAqccrzJuba+yTb/AG/7C4cOlYDWLq7XTyb+ts6fTSFVbNslWPoC0E/SqQeOU/bBt/d/7f7galW3RW3+i9SuFYDguu5EvrtciOQokgfGK6I+swR/46/cm8M5ef3KO7bbTuyF0O7ytHAr0ItZEnRxyjwbVg0tbc3SVPafrP50b+BEvk4hVAGlJxAJ71pX0FBbKC1c3Oe/I7UknekYhetjdCng+XaeBRi9bA1sk1z/ABMj1/1WUTAi7+XmeZHtTUayO4Rn09KNGsiJBEelGhbORM4xzmsA4DAieRETn1/Wh2ABduegnMmnSFZy00EtEAUWgHmli0zWAQuAbSSY25+OP9VjB0siV8TyCO3JyaRy+CkY/JJy9ufDGwERzP1pavsqm10SA3qFLgD/AOV5rdbobb1Z42EUmXu/Hb/uhyb8IPFLyDQBsFscYFNbXgV0yWyA4hjDTIoqQjictNtImYEDinqyQdBNxQOCABI4NAIYqULW13AgEENj/ihYaC22NxdrMBskr6ZyYooDDIQrMFC44xx7/lQMi10l4uyyQCTMAc44/wBVFxLcqo0vRb0aQqFRirkEkfCufJCTY6mkil62y2b5P3o8xDCOeBWwpzKSajsoHltRJ+9iTXalSOZ7ZJomJjaZII59qDMhUAtrpclkknJ9BNGWoaDHctl7pVtvcs2vEVFVQTOdzMwMD5n6CvPm2k5V/EdkfCNL4GnPhpfti55WvNP3QsHJAwABJj3NeVzm7cX9jpdIj1LrpudOs6XpSXrbapF8V2g3LgIwgA+4o7KPXJpsXpEpueZ3x6+P1+7+5uWtCel6fb6TpRrtZtF1v/DvM+IeCV/+R/7DngHvVZ5nnl9OHXn7f8/bx2/gCXFWHtXbjNptZaW5qNbqjs0pvAK91piUAxbtLyeJMySAaWcYpOD1GO5V0v1+ZP8At8GTff8AP+gty1uuL0fpmoa/rtTP9drgZLHloPp+eKSGk/U5lUY/lj/g0m/yRe35NF9lvsTo9QPuFdMg2XL4T+5eYcqjf4qDEkc1zep/EMl2+/jwv1XyaGKK6PoGh+zXSNFbB0nTtIhCfe8MMT8WMk15k/UZZ/mk/wByqhFeBPqfQ9LqFYXtLp2BmQbKn9KOPNKO03+4zSfgw/WP+n/TtSWOmtf0V0/5WRifdeK9TD+KZYfmfJff/chP00JdaMR1r7D9U0JY6YW9TbHdPK30P716vp/xPDkpT0zlyeknH8uzJ6izctMUu22t3BMKykGa9OMoy3E5WmtMCwYHEgxJn0ptGaAksJOQTTUhWSLeWYJjB+tahQkgAE5PrFLRmwLHh5+o/npTJCtizkrAE+mD8aZIVkrYyo5BPHNZhRKYneQOO2aBjsB5iQBkbvXvW6McBDtu98+1atDJ7CKhYAEgHmlbKpWGtWxAJVycH4VNsrFJHbqlWO1SQe/rQTTC9C/3fug8QZEVVUyUr7RHeytILKR3FNSJWEt23jeFYICJYr37CayAxhVm4Nu4+/8AqgwpWHeWuOXZm/y59qAVo87z2kxxxRowcAZAkGJ4/nwoijmmtMVumSrIFgEZMmDHwpAy8F/0yGsEoIBP+RgzAqUtMZJUV/2g3HVqGXaQdrD4VP0/To6Mngp3PmLcCJrqrRC9ngFk+i5M9yP5+FH7AryLbg10XATEwInGIotaoye7LfRsA73QBNuSCR6D/dcGWOq+TrhIuer6r+n0Wo09gKb+qne8/dtCIX//ACgH4fGuH02LnNTl1H/P/B0ZJNKl2FUW9Ct/X3kt3tpTS2lYxvMCZ9hn8u9I7y1iWu2/3Ha42/6COq1Q6z1J73VbreAjZCDadgxsQdpiPYSavDH/AOPjUcK2/wDPy/0/uTcuUt9InqdZc1Q/qryLbuX3XT2UQALZsoR5F9ASVX4BvWljiUPYukm392/L/wA/sM3e/wCha/Zq0dPZ6lqSQLxUWlbgy7nj6RUPVPk4Q8d/sjR02z7B0fZpdFp7CYVLYAE/j9a8LJcpOT8lkqVFouoVbSyRwMVHiMBa7v3E++PpWowq9pc5JkyJ7U0QsrtRpgzcYqikEU1PSdFrrRTWaSxfTuLiBqpDNPG7g2gOKlqSPnv2t+wWl2ve6RNi4M+ETKN7CcivY9H+KzT45tr58nNl9JGSuGj5lqNPc0l82dRbe04/xcQSPb1r6GEo5Fyi7R5souLqRAkQeZj0pidnjLTOSDnFagMjcCqq5zkEUFZmKXACDPM1RCM8JA7qAYkc1qMdXIhTBOJImhXyY6CN0scAQZGDn9qFBODaChiSIJBrBQa1dMCIn4ZNBxRRSb0FRnj7zRMZPFI0iibO3dxQEmT8fegqsLsAy4P3hBqiom7Daey1wGGAIEyxj/k+1Fifqd2NZuQR50EkATEfH+RWANaS3v3EPbTaS3AgjORP0oSMjqbWFwBWCnAYcTHH50rRRNHmU7FbdniTnGP903QErGUVmtgL90DbGBzxS9bCnehlASyeYiRE8EYMUF2CSND0wzpt3iqoJkBvgKhN0yiVorPtIxGtxGWLfUA8/Wp+l6K5PBTXBLA4O+K7LpHN2zzwi3SDgEgCeQBSJt0O0lbENRK22UdyD8vT8asnbJS0h/SalvBK5DMCMiJ4rnyRV2XxsL/UFX3bdyKNzA96lx1RW92WnWNemouWRaJaxZYOZEBmZgT+ED5Vy4MLgnfbOjLkukgNpktqz3AIuahlg+gH5S351nctLwl/P7ATSdv5GNXcUWdPbVlZdONoKmQWBLMfcScfCtii7cn5/wCl/YE5dJFppdUbLFVYbGu2bhHtJMiuaUOVP4TKfJ9M0XUkZEhhtC/814s8bR0aGk6mhVVkDik+mzDOn1UkwZ+dJKIRwXgRjip0FnGG4SDng4oWzC7IYnt+dNyMKajSC4CCrHPamjkoaiq6n9m9Ne0hS/prWptnJtXV/FTyp+FXxernCVxlT/n7iyxxmqkrPnnXvsAgW5c6HfuBxJOmviSB8efnmvb9N+MS6zrXyjgyehXeN/uYXWdN6hpbrLqdHfQgwYQkH4EV7MPUYpr2yRwzw5IvaK52O0bjHaPSrEWCLTBg4kCM0bAeYeUkYPMVrMTQ/e+ECRM0Gwog7gQdwEYiaIDikn7kH2GaF12FJvomu5CwdGUx3U/GhafTGqS7RO3cbB5zPFBodSGHcOh8giMQaVWmUtNAciSFnNN+ojvwFt3riqNp2DMwP0o8UhHJsbt2b5XxbjMwvDy3DkMRHJmZGB8KD+AWdSAJt7A0bGAIEnEwO0/vQtj0qPF5bDgGAWEyuMjPr2oroD2w+qV7F+wtxChdQ0c4PHFbsCfEKqkW32gBlaI9BxQTGfdhLV0LfgkqBEZ7TmaVI0nouNJf2adBECBGJqMlbsonSSYr10lzvBTB4ECe3FDC0nRScW1ZRXLm1pBODOPnXW1o5o9kVvLDBm7k8x8aFDOwGoYZgyOeaeIkkd01za8dpEAmlyRtDY5UOLcZrbyQPIY9xUHGmV5WSa+XCk4AAkT/AD0pFCnRRytWFt3t9oBynBMD1Jmg4KLtAc3IJevMNPtxumfX6/ShGOzN2hzTaz+o0PhsPMpkwc4GP0qE8XCfJFY5LjRoen9aa1ZCagsrxAHb4zXHk9Mm7iXhlstdB1ZblwL4iyYjPPwrmngaVlFNM02hvMUnnFcE4lUWtm/Dc5PaudjUOLeiWJn50OzNEBqAW9RP0oOJkSv6hVtll4FLGO6GYlpOrWLt7w2YEg8GqTwSirMmmWOu0Gl6jpYaA4GGUww+BqUMksbtGr5Pln2o6LrrGt8IawJYuD+3dcGN3YN+hr2/S+qxuNuNteCWWMq9pj7/ANh+r+Ptsvo7rlvueLDme+1o9+K9SP4x6erdr+fY8t+iydob6T9hrGoR01mvujVp97TWkCsFE5BbmPhUPUfjEoO8cPb8t/7FYehX/wByI6z7GaG2pWz1G/p7jEBDqrYKHP8A7L3rY/xfI9ygmvs9/sxn6CPiTEX+zlzpZDa3Tm+mYdSdhE+2R2qq/EVn1jdf5/uGPpFDtWaHpd7S29PbbTjS2ljG5FKz6bo/E15udZJNqTb/AJ/OjqhFJaQLqdlfHZdf0rQuGCnd4fgsxHo6GPT0p8GR8f8ATyP97/szSxxb2kV403Tg5NvU6jQ3RJFnU2/GtmRH3hn866Pq5vMVJfKdP9uhOKXTr9Su6j0i21m44bS+IsEPYeQ/xFdWH1TTS3X3I5PTqSvz9iguo1obWMd8GvSjNSPPlBxJ2bqlTuA8QEZ4n50XH4Mp/IUXApDwPKYUL7d/ljn1rAdeDW6dLF7pOmN4i5ZQ3LkAhYntA7EgCKXyLVGcu21s6guVA2wSpyR220bCtgizpfN6FXfMA4jkRTJKqA+yVxAwV0wFaCSR+lYw4sgltsyJH89cUGFbO2lLXh3X37UjdDqNofu3b1sqLdxgsSAaT2vtBqXyNdav6YOqWzvukidoErB71zYITbt9HZmlCKryZO8CWIEsVPHrzXonnoibUpv4jPxxQsYA8BCSadE5HmUgAqJWsCgy3LtoIZBB4I7UjgmMpNEPF3YbcD79qXjQ6kM6XVFSeOByOKWULCpBG1Ae087ZwWB9Z5ocaGTD6Iai9rLaaJHuag/dtINzMKSfGMbn18hjbejZaD7I9W1Kp/3J7OiXja3mc/IY/GvKyevwxdY7kdUME33o1eg+yuk0ekU27RuPH/kuCfoOBXnz9bOctui8cSigul1BtK9pyQbeJ9alON7XkvEsLGqznia53AaxtdVCkHMntScA2cN1ABckiKyT6MHTV2dQoSfN8YmlcZR2EzH2s6BqxZ/ruksVuJkqOSPb1Nd/pPUwvhl6JTjJbiVPRvtlqNIFt9QBC8C4OJ9D6VbL+HxnvGCObxM0Or6pp+oaEg7bquIiJBrhWGWOXxR0pJmVvWdttEuEvZX7ock7R6V3Jqm0tslODTTXR27rNdpFCG4NTaA8QWb67vmrcxntUlix5N1T+V/+iNtb7A6nqT9TNxkRBc2g3bTfcux6++OeaaOBYKTf6P4CmmtCmjvvbslLV68lg4XxHk2Wmdp9vRop8kFKVtb+3n+fAU6FtRqDa1ROs0wBA2u9ryuueT2Ye9Uhj5Q/05fv1/wByp7LHSvavJcs/wBQlzTtEKx8pBjtyp9xiuealFqVU/5+/wDUbTRTdTtvpHa20XLLxEmSvwrtwSWTfTJzVa8CKJbV2ZC5E/cMSDXS22qZBquis1tlX82QwMbW788V14pNaOfLFPZTkbHZgxgevIrtW9HDJVtBQ7JeYhYuNHeCJ/ejWgXsdt6u8enmwty4bbv5kB8sjIHxxSVUrH00R3f2UWQQZEDlc9xHP6UX2BaJeIRtAE7YMxP1pkKwjMAEWD5T25FBhRKS+/zRJwJ7R/qgFfAzogwwGIHBHocVKb3stBOtMev3CmwF+VnHxNJSYdor9SZv3C8li/c96ukkSbbECVVnUnzYI/amBpaI3nIRgARJNZAYB4MFzOZg0yFDyrTIaT3mRStjUc2qNpBIHYKcg0OTDxXYElRIYEtgTR7NfEiwWSWU4EyJE1tgtMe6Nov+59T02jt3Da8Voa4xnaoyT9BUs+T6ONzauimKP1JKKPrmgtdK6HYXTdPtKDHnc5dz/wDTcn8B7V8vlll9S+U3/sv0PVhCONVFD/T2v63VoqQYIZ37Kv6VKcYwi2PZqy2+34VrAGPWuNLyEzfWtFcUm/axcTkdmFdWHKn7ZGryin0uvO6CCCMEHkVeeKkFOy0tardBB47VzuAxZ6Z7WpWAe0R61CSlFh0U3WLGs6PqP6zTqb+kMSoyyfvXThlDOuEtSElcN+Cz6V161rNOIuBpqOb08oPY8ZKStFP9qeh2NWrarTKq34llHDirem9S4eyXQs8fLaMRba7oGnTXGG4+aw54j09K9S1k1Nf1JRk4dfsW2j6lZ1Qe2zbXB8yN97+e9c+TC4e5dHTDKpaIam74TJbL/wDk/wDE/uMxS8buS8diTXFlLfvGzqPFHl3SCAcTXTGHOPE53Lixm9etvqdyOEuEEQ33XGMGoxg1GmtFOSbDXLS37CC2GDKSAZ8y/wDyfUelTjLhL3fz7jtWtFDdDBzc07lLi5KLwfhXoxaqpK0czdPXZJNYLqReB3rzPH0pHi4P2j/U5aYv/UWiX8rAj0q3CSEU09EXIvWWyAQOeKKuDBKKlsoNSNl0kDBEGOK9DG7R5+VcZA1YC2wG4MTzOI/erWc5K3cB2ycSN08RQ8hvQ09w7BJkE55way0FuyViGaJAPrNGhW7C353GSTBiSe/egFWGtW96qN5x97H40jZSKLHp432WBjkx8cVzZXUjqxRuNjGstqzWzz5OQPc1lM30yq1Ll7rtuMkk4rrOMrgQSSojvzz8qYwQDenqQIj1oXRqs8SvAyZ8xjkjt8KXYyo8QHghgIwATWug1Z6PWTmaFmoG6zwTB96KkK42DdNoJk45zTWDiaL7DWd3WxcYR4dl2ke+K4PxKdYaXlo7PRwqdm40ti7r9abFgAMctcIkW1nJ/wBdzXiynGEbf/Z6NGp/q9P0/SrptICLY7kyzH1b3rj4vI+UgJUy26TdC2Bdu5d1kL7dq58ndIYD1Am4LjOREd6MF8B6MZ1mzF7xbQgz9a9HDO1xYkl5I6LVW7x253DsTkfGjkg4hTslc1+p6bqEuDc9k5xkj96CxxyqvILcezV9H6tZ1tgBirq2eZrz8uF42VTtaMv9pOj3Omag9Q6QQLR8z2d2PiPSu703qFlX0sv7kpwcfdEh03rI1iKC8GIKnkfI1svpvpsaGRTAfaPpia1Te0YAvqPuyfNit6bM8b4z6Hy4+StdmOvidTbtvvtXVHlZTBU16kXUW+0cd+77nFuXjdQ6m6z+ESwk+laSjT4rsLnJ6l4F01TvaYXAc5A3TFO8aTVE1NtHOoXQEtkMxJAOG7xWwx2wZXVUOaDqT20QlyduJ3ZPtUMvp1JukVhlpbEtTdBvm4jbW5x61aEPbxZOcrlaIM5ut4lsgNwVpuKj7WDle0KX2UXCwBiBB944q0FqhJPdgvEm35Gin472blrTK64xDNuz7TXTFHJN29gk2yJEjjPwpvBJBVfcxnk9ogfGijWMEqbe1xABmR8K3kxOw5t6veyhiQYzySMfz2oPoKRMAkkKGYA+/NCxkiys29oFwQBBmMyI/n0pWMtjXS4a1uIAzkDuBx/PauXP+ZI68D9rG9cwNxNqJ9wTuahDrYZbZnNVehmgEZImvQPPEgwLQccZFNugavYVLyrIjjHFI02OnQQHxMAqCTxMUNoN2TAUGCQYHEE0jbYyIrcGdwJwQARAH0rNM1kd7EgSRA2+tGtGXZ1lIQLlnH0FBO2F6NL9j7iae9e3A7rlvaMfOB9K8716ckq8M7PSPb/Q2HStb4OhZFwWYl2AzPpXl5Mbc78HXy8B+ng6zWqrSbSmXPqJ4pcn+nH7mWzV6S/4rXLjiLVvGOCfT5CvOkqpDlX1vqqlSq9j9K6MWJm+5ltZ1LxJDSTOAK7seKicpeCj1GrNphctyLg4rrjDlp9Em/KH9J1u3qrZW8CrxMGoz9M4O0MsnIHp9Tc0N43dIxKHLL2P7GtKKyLjMZXF3EtH+0a6tDbZ8jG01z/+I8bsosikU+stf3vHs3Tbu+qmZ9q68c9cZK0SlD/6joZ6T11f6rwtSCl5eM4Ye1Tz+l9tx2h8ea3xlpgftRYs6uyddpl/vIDJU4YUfSzlB/Tl0HPjUlzXaMw+s32HY5YggT713LHUkjic1QtYuQiwTA5qk1sSD0Q1F3denaSEGM8U0FUf1BN7O2r4FvO4wZ5oODbFUiJ1LEEgwB2pvpoHM8L5CyMHn+fWs4+A8iF+8GDEnmjGLRm9CYu4MdzxVaJKQB23EnNUWiTdkVn05mjYoRN0sckxRs1DCQSW80EYzQchlEONnlEQ2Zz3j0+tKthlokl0rvFtYgZ3H3/CiwxH7bb1mGbB5A+f6UllKp0MdOuKijcHFuTuiCZjv8TFRyK5WWxOo0hnVbWdSzQdg9D2pY2vAZGd6mf7jkgwSfxruRxMG7PeuC5dLMAFUGOw4FHpUgJErdkhf8c8iKRyHojctsOVEexkispAaIbtuDIj1PFEBwE+pOKxgiFyp7Hk0rHiHt3sLMekmlaqw90P2LzgoyhpVpnn4ipTgmikJuLtGk6X1Dab3iFTI/x57TNeZlxVR6EZc1o1PQGW/bRLZjed9xx/iteb6h8XbLQjod651hLVnwNLCWkwufzqWHA5PkzN0YTU9T1F4uUuLtkiTmvXhhjHs55TcuhMB3fc19x7LEVa0vBN8vkE2nts2brMP/pporI14Nwvtk201tBJ2g0PqNm4onatMTtS98ATPalcl5QdrpkNVpHPLgdwViaaORLwCVtAVv6myApuLcH/ANc0XGEt1RlOUdPYnrTc1ABXajLkHv8AWq46iJkfLoFc1muGmaybhZDg/wC6dY8fLlQrzZFHjZVb7ijawPBgRXTSe0crbWmTXUFF4g0jhbG58UBF4ncSc+9PwE5nReO2DW4G56O+KNkCM1qMpEWuYMA4/KtRuRwuSVjk81qM5AiYUCihGzgY5jj3omslu95Y9+IrBCKPKYIgcgULY3FDAbaqiEBHBjPw+FYN0dBBziSDOfb+fWtsFDKgbWBYKCCRA78xSXbKpUg1l43A4gcek0QInYuHw1EDygnyiCZ/4pZrY+N0g2oM3TheByK0VoDdCd9Abj7juJxINVIgAAwOYAb6miHweKnaFLgmflQMybKiqWLe38+lC/AGgEW/MMgcx3o2wqKZJfD27Qi7gZmK1PsCpaR4DyHc3J4oN/AVslZ2rcAUnAMn1pZW0MqQTxdowROBkVuIbDaW/ctXBcRs5BBzIPIqeSCkqZTHNxdmz+zWvujpupG4SXCgx7GvG9VgX1EehjyXGyq6xq2Np03BiCPMOfeur0+NWmRzN0VGndxcZCCwbIINdUoqrIpvonevMphXJER92goJiuTF3dpBR3IPI296fivIrkw/nuN5XZhHJApKSCpMPZlDDO8+x5oNJmtgdUxBH9y4Yx97ijFIFsSdoPM+nE1RIDsEXGZWSM80yiC2cZs5E/GikZsDcM4haZIVgGCgzNMLSIMvMuKKFa+4M7YimQjolux71qNyObpWM1qRnI8MQSfShQLPbsEBRmtQeRAGTgx3rUCzgEn4+tEAa1LEjMHECtSGTY5pUS40Ezic4qeR10VxJSeztgAsNskbSDIEimfVAj3YRTtG1ZkH0gc/8UEvIzfgJbyzEHHvQZl0T0s8cCa06Di8jF9Q1wy23tBE1o6QZdlffJUtMkiePjVSIFGWPPmMxMUWn4Mq8ngzAAt3iJ9KzQL+SNxmuCCRPYAUEqC3yPIoEksCeI9KDsy0EH+UbZ7mKFM1kwGzJMA8zSjrsiGVQYJLZitxbNaRFSWJ9e2KLVGjsYtLEbztB+dTlvorHT2W/TNcbKG2coSe3NcebDydnTiyUqFdZqSb1wyGDce1Ux49IWWSmK+JtKkY9Zq3G+yfOiVt4P8A5IExxupGmF0GV1IWXBAGfJz7e1CmK6CJeRTtBwD/AOsUHFms5cuqWJDOJEghfahxaDaFbjg7pe5//r/uqJMVtAXuDhiwHwAplFi8kD8S3/7PPvAzTcWBySOG8mI3SfVqKixXNC91hldgnvJNMk/kSUl8EbjBuEA78UUgN/Yi0xOV+UZrUBsET7n0opCWc7mZogO+gzRCdER2oUEiSaAD2eJxn4UaMcXt6zWoAS20SR8c1qCOaZiXwYPqKTJ0Xw9knm3dA9Ru+uKWLtaDOPGVEZYAwDM5zTJCh0MBjOTij5GVUMdOIe4BBADAAD1nNCaNB9nrzsXJJH0/atFaNJ7FdVIuFZBM+kTVBAMRkRBGYHHtWB0edgVHl8wNagNoCJkTEGjYqTCIBIJPHqtK3XQ/H5J7QMAnbyfetboFbOO5I5GeKC0MRAb/ANpA7DNZsyQdI2gDHfikZSKClPKGkmPWlvwN9yRJdQEnfExHFJ09lKtaAeJPqTFO0STBO5btEe1MlQJNs8Lr7AAWB7RWcUZTfQfxG8IZdrgiG3mI70lIYjvcAkuxMT8a1I2wdy6zEyTjvTKKEcgLgd2nFOTYI5A/WihGRxyfrRAdBzg/OsayIbPtWNZLccRPpS0MmcZvLBJrUZsHOKIh0e/FExJsCCCD3BEUAkZ4rGPeg9TWMeEYHaaxjkyCTMniaICQmT/7c0AoPpXKlROJ54pZq0UxSpjerYk2mfbMFSQKlj80XzPaFyfOY78dqoibqwouKpUhgQRHYUyM3Qxobu1jGQIJgUJ7DAGdjEl5DegAooDVkr5X+puYO3cfpNOxFoVdgCVny+3ajQLOswJ9QTmgbo4p29gVYYJEVmgxdBZC2oBkj17UvbGukBYd5HFMTOLnAJIz8qAyDLafbxj3NI5Ioos65Cp6GJwaHY2kc3P4bLHOa1K7A2+iCXImfXtTON9CxlS2et3QXPAoOJlOzshj+s1uhuzpICgcwa3ZnoNCPYYsNrDA+NTtpqiqSadi7XV8EggyTEz6U6i7JOSUQe8McgKfc01E7R1hKys1l9zNX0BnMR8gaYmQYmROKwGe3Dd2j3rAOE47QMUa0YmCJ7fOlGR58DtWRmDkDggHiiKeBBif3rGOme/PPrWMc7jigE6BWMc4kisY4eB6fGsYkDjIwawUFskKO31/Sgxo0gjvucAjmBFBJJDSbkyLYMg4isBqmEcm2dsrznvMQee8UUEY0YBdt3MH6+lCQ8EEVXuAlWQCYhuaJmLXG/uuMEEkiaoIDIk459I4rAqjgyeBHpQZv1OzmCNxAwIog0R3zAUcc96FGskTJzj1oBGLQJQ42iPvRmkkUjomZIESxj1pQ7Zy5tVZO2SKKTYbSBEqc4kelFJitogzKcwI5M96ZIWwbAByePY80Ra2FXAOKRlUTVUmWO5okjsKVt+B1FXsJbEWnLKPNx7Ur70PHptijsFV/wD17VVK2c8nxTRxVtlZDHccwcRW2BKJ4wBAkj8qIGyJPaM+tahGwVwAEYxRAyWwMMkAmTQs3E46kDkGimK0ERCwkRFK2ikYtnryAJI+BrJhnHVoBmIHemJHI9cCiY9x9e1Ax4fjGKwQm3yTHelvY/HVkI9hmiIcwaxjoHtz60asyCKQoYnLTAilfZSNJNhNx3AzGQOeKWh7tk70b1OGPJE4k1ohyVaIBtwUQMdqahLsPZbacgcjPzrNDJhwjGSJyZxTpAbC9b0VzS9Q1KbFADTj0JgGnjtEnLYkqggw8iJJI4PpWcQqRBo3GSfmKCiFyRK2uW8MknjBiazQE0TbTsqByu4MYGe+KHehujhTaASASW2lQcg8fDtW4sXkiRuQxQBiZ/yjsaHAb6iOs5MST5pg/MitwYfqILo9K2suPat3LauiFgHnzEdhj84rNULyBG0HOCDjsK3RgTKFBkSM89jFGjWiTKEaGUhoB7cGhQyaPKZHHHeKXiPyJ7UZBBOPahTBaYx4YCAs3lA+lKosrzSRBdMzIXSCJlexEHmjdOhGkwX9JccmYB78Zo8khOJFtIwMd4o8kK0QbTsWCzk0U0LXgh4c7QT8KID1u2S6o3JwB70Ggo89skiIUjBEzmaIHsIVbapJEYgAUlIrydA7ltxuQkAzmmSEb1RMWE2GPEcgR2A+XejTEtC7oV+/IYijQCKKDMsdvrFajHVVZAZjI9uK3EJ0SFgRETJ+FLwGU6VEBJ3GTgQZpuItnAuDINagHtpC7pEAwfWtRrPHE+/FLQeVEmuHuADFbgM8l7JSWJyccUVAznbsmiiTM45PpR4hUiZlpKknOT3oqIHI1PQ+iaXU9PS9rg/iv5gFP+JyPzpJSadI0drZ/9k="

/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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jZdlgrzQv7myFldfJQFOk+E0XjLx/wO6IG3XnQWvfQAAAEx0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlREb25hdGVsbG8yMDEyLnBuZ1IQ5DAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDMtMDdUMjM6NTA6NTkrMDA6MDCf1JlFAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTAzLTA3VDIzOjUwOjU5KzAwOjAw7okh+QAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADQwNDFqrhIAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjQ3FC4VkwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI1NzcyMjU5PufDkwAAABJ0RVh0VGh1bWI6OlNpemUAMTIzS0JC4fuycgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfYjg3YzQ1OWM0MzQ1LTEucG5nEZaXyAAAAABJRU5ErkJggg=="

/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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eUFugqPpskfsJlc6HA5vyaOo/69Ysnn/gkJVadt2cWVI17ArEK58Y/valW9sfxIo3/n4mYesSJtZGTStaohRQqdtlVsDMdK66HwbJr1evtrcqLLZ1pR2XKkgYnJDNPhq7r40uVF9bOfl8Vdi1L3FcEDTj23350dVjR2x8pYmJS4zyH/l2N3dXXy52A8ePss9UE5vA/v9jX5Z9osTYmQYvJoYYkdYjESUat7uXX966wvH3nL09PzyuLfzwg2id5KXWS2ZfXmy3/yLrZcn/3R8bfYtVcZdr7FoyBdlVTj05zIej7lx48byjVoC5Lsq4quAEveuTOfP/8crX53O3FMms9MQVULUvNXYd5kiGdTbzZVLX776r4+c27hr/4WdE9Or402MPOmb+K92r1X/dO/y/Pd95Te7UmrGTYbugUoJt6jfx39pyPJ/wX/1//8HVgkkVesS6AMFMDr14Im7jr/5yJvy4/378rXirlGeHZ9fmW8/+enn/7eTj5x4pN6cnNs9v/uVttGnmpm/3vUWflFScVPbKvJK+dAlOJYA+Z4JcwgktgNH2QGmI7VTDE4OV1ePDQf4aG+8uHMNRWNUr1GrQwBwh8qoP88AZxlLgHzPgkReBZTsEEjkVf2LHAJF7ICweL26x1iCYwmQN9R7sQCLPZRdzKtA8mf6l0M/F181CFjGEiBvyPdF/pwXf87Dr4dAw7LHWALkVm7oX/3wL4HwOsb/C6yPRSDGvMY7AAAARnRFWHRjb21tZW50AEZpbGUgc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZpbGU6VE1OVExlbzIwMTIucG5nJXHGFgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wOS0xNlQyMzoyNzo0MSswMDowMI1cwmAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDktMTZUMjM6Mjc6NDErMDA6MDD8AXrcAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjYuOS03IDIwMTItMDgtMTcgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3JnnL25SAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMzkze4OWfQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAyNTJ9X9BdAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEzNzkzNzQwNjFNTtgfAAAAEnRFWHRUaHVtYjo6U2l6ZQAxMzJLQkJkJ/ynAAAAM3RFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL2xvY2FsY29weV82YWIzYWMxMThhYzAtMS5wbmf+cubjAAAAAElFTkSuQmCC"

/***/ },
/* 303 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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/n8n/Kawy9PwPAAAAE90RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRNaWNoZWxhbmdlbG8yMDEyLnBuZzgbWSMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDQtMTVUMTE6MDI6MzMrMDA6MDDebEYIAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA0LTE1VDExOjAyOjMzKzAwOjAwrzH+tAAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADM3M+UAu/MAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjY2UR9HhwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI5MDk1NzUzILs0cgAAABJ0RVh0VGh1bWI6OlNpemUAMTU5S0JCPGaOBgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfZTVlMmQ2OWIyMWZjLTEucG5ntTzkBwAAAABJRU5ErkJggg=="

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAD8CAYAAAAys+slAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAABIAAAASABGyWs+AACAAElEQVR42uz9d5Rl2XXeCf7OOdc8F95lRPrMyqzK8t4DBVsACE8QAkiRokhJNFKLlESNXGu1uqdH6qXV6uleq2e61TMSu3tE2SYpgRJBI8IQBVsGhSqUzczKrHThzfPXnXP2/HHvi4wqoI0kiswq5Kn1VkaaiIq473537/3tb38brp8/6qPe9LF6059dP9fIm3P9/OFf9+8HCKleb/74+rkOkB+Y662rj83oY6XU6O+ciDjAVy+ug+SP7ujrl+AP7hw8ePD/CBi6AkRYvWrVqw7URSQSESUio393PdW6Bo65fgn+AC5iaFAoTpw4wcc/9nFmpmfUhQsXlPdefx9gREBcvUIgOHnyZPzTf+pPL3z203/8/UcPH6899cy3Vq6nWNfGCa5fgn//Mz4+zuTkJMurywjC6dOn1UsvvYS1Vltr94IjUEoZIBSRAND1ei38wOMfmH73u99/e73WuK/I3Dt2ttvzWWL/C+Dp6nPd9at8HSBv6ZpCRBAvAKrX6+0FhamubwgEVeqkjx492vzgBz546KGH3vmh1ZWN+wbd7NTZl8/ry5cvP7uxtvrLa1urv119DXv98l4v0t/S105rrZRSSkR0lU4ZIFRKjUARAHpqerL2x3/sJw4eOXzstqnJmcd63eG9Fy9cnLt88VKvs7P9reXVy7+y1d56YXnt8iqQV+AoqghyPc26DpC33PUaFd26ihLBm+oME4ZhePjQofE/86d/9s65ucV3DgbJve3tzrGzZ18zqyvL5we9zhfb3Z2vXFm99NJOZ2ezAkOxByCW6yzWdYC8ha6T4o1sVFDVFqGIhKM/u+mmG5sPPfjI/vvve+DRZn38wY2N7duvXFmeP3vmTNppb7/c63d/Pc0GT595/cyZIs+TCgSjiDH6dUTxXo8e1wHylgJFBQwVABFIAJgojusPPfjA9Ic/9NH7xiemH1aYe65cXjlw/tz5aHn58nY6HDw7TPq/tbG1/tSV1UsXRXbTJ7snYox6H443Ngqvn+sAuaZTKLMnjRrRtAFgbr3l1smHHnro8EMPPvyY9+beNMluPXfuwvhrZ8/KzvbG9nDY/50sS7+8ubPx3Mra8saeKLE3jXJ7wMH1qHEdIG/VFCoEwkajXvvhT/7w4bvvuvfeycnZRxTm9gsXLk9fungxXL5yOe10di5kWfrVXr/zpSurl58dDPuDPWAY1RhOKeUou+ZyPWJcB8h/0PnMH/ss29vbnH3tDOfPn//fe+LvPXtvNPnA4x/gia8+QZIklPfj94BC8b3U7G60CIIgOnny5OwnP/HDp248eephW/h7nJWbXn7lTHjp4gU219fSwaD3nSQdfGF7Z+trW52t19M0GVaRId8bMZRSTinltdKCQrz3opTCuestj2vxXNN9kGajSVEUHDxwiCNHjnDo0EH+4fl/+P1ubkWpZ6J6IntAlFIyNjbG3NwcQRC8GRhv7lmESqmoihYBEB0+fLjx/ve9/4Zbb7ntkaWlg+/c2uosXbm0sfD666+r1ZUVt729uTUc9l5I0+QLW+3NL6+ur6wB2ZuAMUqrvFLKG21kZnpWnPfivaPd2eGqDOv6uQ6Q73N+9s/8GC++dJqzr13k0Xe8i6eefJIrVy7TqDfo2A5f+NLvqc2NDba2t9T3ucFHLyUitooeukxf8FEY8cy3nyFJEiUi34+ejapXKCImjuPmY+98bN+7HnvXrXOz+x5tjU3cv7mxM/fkt56Lli9fZmtj3XW6O5eyIvvm9s7m77a72y91up3NN9UXeyOG11r7eq0ueZ6jtZKTN5ziiW98ifGxCbz3eO+v34nXU6zvPZ/9zKf5/Od/m26vh4iwvnaev/SX/3OeevKbnD9/XjnnqG5qpZTSIqJHHek9T34D0Gg01H/6N/7WLd/4+jcu/pvP/6vlKop4pZQopdTeRh4QKFQkSDRKp265+eap9773/bffdsvt9zXqrXsGw/TI1tbO5MWLl2VtZUV1Ozv5cNA73xv0vzZIer+9ubVxrtvv7HyfaFGM6gtARETGxyZkbnaBqalpnnv+GQ4fOsrk5DRPf/ub1+/AH/QIcvsddxDHMVFoePHFl+h0urt1wN/9r/5LvvilLzNMhhw8uKR2drqIiMqyTI3AUAHEiIhWShmllKlAshtN7r3n7vCnf/pn71xcPPhXh4P07/ybz/+r1QoMrlLIjvRQkUgJCkHCgwcPTtx7732L9997/92HDh55OApr912+stY6ffrlYHVlhc2NVQb9XjdJk9PDdPClTmfnic2dzQtpmgz2FNzFnpdTSvk4rkkcxVKr1WX/wjxnzp9HxJMkQwpbcPbc6et33g8qQD776cdIXIcnfv81drb7jI+PUxQFe+YddnPuW++4TyVJorwXrlxZ1XtZpD2y791XBSyJa3Fw8MDBxqc+9enjc7OLt4rITRtr24+8+tKZ5DvPf/sKpYx8VKybURpVST9q73/f44cfeeSRW48cPvaQEn2T9/rIhQtr8eXLl9nc2JDOzpb0B93tJBm+MEyHv7m5vf701vbmioiMQJHtrS+UUh7wRhtx3snD979TvPf81I/9LD/5Z38EgF6/e/1u+0EHSD2Ouf/+k7x2+Qz1RsT2lqhvffMbmCBU4r3y3mlj9O6TfzgcKufcXhZJVxFiBAoNoDTBnbffGd1xx10LU1Mzxw4fPnqzCHcNB8nJ8+deb2xtbuxsrK99fm197SuvnHmpDTSrgn30deKjx46NPfrwoyfvvuvuew4dOvruNCmOra1tNFdX11lbXWNne4Nup10kyfBKkg6eyYr8ie3O1vMbG2vre6JFWoFjb8SQer3hjTaEQSDb7W3K1NDvguP6+Z50Xr2ZaXzb1iB//a//dYbDAa+++gpP/P4THDg4q5SxXLywrZIk39tX0HtSnatDQSJa3lhTKEDFcRQfP37D2DsefdfSzaduebjT7Z+MwvBEt9tf2lhfs2urK6/3ut0zG1vrX93YWDu9trl2cU/EUIBqNJqNj3zkI4fvufu+e+dm5x5oNsZuSpJs9uKl5WBtdY2NjXXptnfo9zqFLYrXM5t9YX1z9Yn1zbUzRVHsTZ9GUSPbU4xbpbRvNprMTM3Io488zm/85j+jWW+yurHyA4+GG8dbbGU5m1m+d/BrL8kib3pdk0D5DwJIFEU8+eS3+I3f+BxPP/2M+u3f+m2cd0oQLf4qILjafR699vYdNKDHxqeigwcOtA4ePDB/7OgNx5f2HzoVmOBUv9dfzLP84MrKcrG2ury6tbX5b/v9znNbO5sv7XQ72965gqv9C1FKBbfeetvkgw8+dOKB+x98YN++xYd6ncGhzY2d+MLly7Kxtk57Z0v1Om0piqyfZumrWZ59rTfofv3ildfPO+vyqrgv9qRUe0EykoO4MAh9szkmcRShTcDK6uXrcaI6t0yM0S4KrgzT78c47lUNeN44XvzWBsiv//qv85WvfIV/8A/+AQDve9/71DPPPMPm5qbKskx773ebbXuK4ggI5+ZmWx/5yEf2HT24ODczPTa9sHRg+tUXX8i//pWvJUdP3HTT2MTBu6yYmSJPZ9s723GnvV1sbW2sdzrbL2/vbH+tP+i93h/0LhTWJm/6/tWBAwcn3/Oe9xy+/bY77jh54sYHgyA+sr6+Nb68vBqsrKyytbkh7e1N1et2vPd2Ky/yrw+Swdc3Ntef3drZ2vLeFRUwfAUMe/DgAfO+932g5r34xaUlFuYWx770xS+c/41/8+sdpZQ3JnBjrXHZaW9dR8TefOl/+Nsc+sv/JT3rVCcvlLzx4chfOX7k0He3O9lv7exc5qpY01+LEeTfqQb5+3//71Ov13fBNRgM+I3f+A01Sp+qIjikGikVkbDVao6dOnXT7C/+4i/cd+rUyYfmp5vHpsbieQ9jp18+H69eKdw9757yral1k/S7Zm1FceHsWra23PlOu9d+utPpnesn3SvO+aHNXSae2ugpFNcawX33P7Dv4YcevuGee+594PDBQ/esXFmbvnhxNbx48RJbW9vS3t6k09khz1JX5NlqXuTf7g97X7l45cKzSZJ0eKO03APuYx/92Ox73/P4w91O/0Hr3Fy325NBZ6gvDy8PAxP9HeBbgBLx6v/qmxoGhmPzU9QCw3MX197excaf/U959/yM+trmttpDrUdA8Es3Hj/cyoq/WvP+nwLLb6si/eDBg/zSL/0S7XZbZVmmlFK7EUOp3YZbDYjuv//e+Y9+5GO3f/CHPvSupcV9p1o1fShSyURcD+kPCn7r87/GC5eeYOxwHiyc0CgDE+SyeLtSt7wz1sNkcsYz8bBYedAKaKWcy127vZ2tXDzfuRTYKff4I5+6I3KNk1MzC0ubW9uNL7/4ol5e3aDTG9Dt9WjvbCub52lWZBeH6fDb7c7OUxtbG+eyLG1X6RKgBMQD/tFH39H41A9/+l244I9fubiycPHC+dWd9vY30PqlLEm6vV7vfG/YP1NFLg9K8jzbvT61KFDOyW6GXZTyEQEwCiYaNeqhYbIRA9AeZm9LgPzcDUf49csr2LK+DBREAvGHl/YtjBXyNy50+reeHgz/mwo4Bdew5On/EkAeuOcOvvvyaf7JP/kn6tKlS/T7/VF9sevQIVK5dGiaf/4Xf/7mP/NTP/OjJ284/o4g0M2ks6W6y68wtW+fbK731G/+7r/kcvYtjj0Yo3QdhadicJUXIazrsE50xDkhRFEoRWjKO20/4o7cOO1Xn0x44YufD9zAKus9RmnSPAelqesA7aBWU/RUvrLW3fhqZ3vn1fXt7qYtu9ajQj4A4fbbb5/8xMc/def01PxHOjvdO1556ZX15eVL//1zLz7zr9vdnfae4nykuhUREecsw+FgZNmj0tx+j8eVUkoQoXAiZ1a3pBEGKKWkFhoKr2jEMRudztsGHH/thqN8td2mWxTKC7p6aNZn4qhxUxR+dr3T+chWkn5xw7v2HoC8tSPIT/zER/jLf+3v8U//6T+lat4Fe6JFTRHWTxzfPz2x2F/85GceevzTH/7p9x5dOnYDNsFnorrrl5BiyPals+r3vv0039n6Gjfe3CRGUArCUKFUmanUAoXWEGiFVhovmsIJ3VQYOs/m6VSf/1JHD9cyFSpDEAVEYUCgoRmHeO8pXI62FkkSxpCl5nT0qcXm5I5dGt9Kcru+3e2f3+wOz+dilj/9Ez97+NSNt7y72+nd/eLzL/nzr5/7jcuXz//z1y6cea0oipTvnezbO8ikBNHIG1g4vQckXqSMTt571x6kvgOitfLtgZeJVouNTof5ep31JHlbAKSpNae7fZU7r/YQNOFn5ufuK/rJj3bSLMwCfW4r9SlvAVed/0sA+dpXv0Or0VDbeWcEjlgp6iI07r/rzgMPPnL03YduMu+T5sbCXTc/eOTwvsORz3sopUgGCcmgx8K+A3znhWd5ofcstdkI7zWDVAgCjzgIKpAkoghUQBQHKPxu57AVKTaeHXDhd9rKD2BmYgytFVlmES/kriArLP0kY3OrTVGkKDxREMQgseAnlNJHYpTsG4+K+ZZJTVjbjgYbk688953J85evPHX67Kv/65WVi88myXCbNw40vSF6VL++2esq5uro7d4o4gArUCBSCDjvxAI+zXMZr9VE6jG8TQCyXhRMRxEbeTHSu4WnWq3JIC0+vtofHMq9H+wg59xumnptz7/8nwLkYx/7JF/+6ldVu9tVVb0RAQ0RWh95/J0nH3r06J9t7O+9N55MY09L7Zu6DYPBOkGUsLF8mTiO6PV6fP3FJ4hbjjAIKKynnzjiUFGLNNoIxoDSijiAvLAEWrAiKK248tSAV/9tmyiIaE2EiIC1jsBocuvY3OmysbmN9wWBhsgo4ijGOU+a55jA0Gi0CIOI3LoQIQpMMH76O9+g8EZWtnrmysqGScQH1c2e7gGDexNARuAYFZ91BbXpscbkZCOerkdmHJRa7w5X1zuDnT0p2t5+is3y3IsxPnaR7Buvs9p964NkPctZz3OllNKIBALBrc3G/n6a3d23hRKlOh0vF/dEZPk+jKq8JQDy5/7Up/nC115ia7uDc270pKwDzU9+9ENH/8yf/thfvDh44t1d6ZssDaRZqzFRn8XlGeIdg8GAztYax48f5jsvPoWtbzDWCLHakReAaNJcSHKHMgpRiiAQAu0wCHGoMFrRPjPg9S+2McoQRQFKqbKRYgzOO1Y2tul2ukTaoQNd3tXOY4sCtGFiYooorpPmjpXOUA11QVQzBAp6ymJaRk0frN+tFufM8oXe39vaHL5SpY+jpuCbx2BHT8ca0DBat959y+F3H54b/4x4mdNajVuPfvL05TNTjfj3Jlu17fX28PT5jfYFYFhFmVSgyJ2T3nBIaJRM1mq00/QtDZC5MKDwXu32ppQyM0FwWyrJfu+FIDCDQrnB/07kUHseQPIWiCDCzvaqsrbQIruapvoD99+972/8lZ//swcOL777wtef1FnqCQJR3mpckpLpLt5brrx+Ho1jY3WVp199guY+IQwC4sYM3aJDbguy3OPEY7whChSFFXygMUphC+if7rP8lTbaGcIowHnQRpdAcZ7t9S5SpDQihXXVVa2iThDXWJifx3nFle0d/LTjtvfPsnBsjCjWGCXkTshUQKEN3a69bf1i/+fPPLX2j7775cvPebdb0Aejp/4egMRAKzR67OGTBx47Pj/512qhOTjIctIip3Aw1YqXDsxMPBiGxh2YHj97aG7i156/uP75nX6yOXpiCkhWWGedZjwO3vIThf9iZZ3E+ZEKO2gGJgxFDg099UBrnyu1ke0yiLtgMHtodvWWiSBhc4ZarQ4oDRICtTAIGn/x5378fTceP/y+IGyaxfFj7ORX8AWsdXtsbK1Ty2O8Upw7/RKH9s/xzPMv0nXL7G+OY7QmCH3VTtUEStFQgtEBVgSvINCaMPB0zw0583trqDwkCA25L6jXFFmRE8fC9nabfmcbvMP5kgkrLdw0M9OztMbG6PZT1ocdbni0xV3vmSdqxQxzIS3AO2E8L1Di6TkhMaLH9489eOtU7dDx+/Y9efmFzd96/kuXnkkHRZerAkVXvaENoHnv8cUHb1qa/kWt1MG0sDgRSl2W5qaD81jrYw+MNWq3T7bqRxtxPPu7z535Zed3R229gDgR183yt36KlecYpVQlH9KHo7gxr4P9q9Ypj9o+a4t/sezcdgUE9a7pKXP/zNQtHfEX/qezr29eaz/P/yGLcPnSCusbm9o5FyilakDj53/mx2/7ic9+8hcbcbRkTIjC8Oz5Z1nd7tPpFxwZO8xsc4bcWdZXr6C848vPfon9NxkazQgfKLy2NGJDGCiUgmZsMEYjCqJQExrYvjjg+c9d5MrrO4gOQAeEgaEoPFluQWm2trYZJH0GaY4TwYmnXqszN79ArVZnuzNkub/N3R+d4R0f3o+JDFnm0VoRBqCUpsCAKOo1zXhdUzMoE+nxsdn6TQdumnnoyKnZqXRgN7dX+uke5q4JNI7OT9x068G5vzBWj2/LbIETz+zEOGkhiAhBGOAEvAgCxHEUa8WpOAiG693hGV8yXHYPdfy2KNSNUkYq+v9EvT5zW1T79Jl+b78gNlPqqRXvzwCFgvTTc7Mn5uPwht/c2H5xLU2vOR+w/8MIsry6OprLCJQijqMwfv+73/GO2fnFk3m/J3m/q6aCGaaDQ1wYPIfNHJ1+FxNErK2vkOUZa1nC0GzTGF+gUJpGPSQyGq0U9cAQYPHi0eIxpkx5Om3Hs5+7wMWXtjChJsoKWg1Fbj3OOZRSRM4zTBOStKBwpUun0YqlxWmCIGKrPeByf4fbP77IiYfmyCw0I01kNLmAc0IzUgwMdFVA7iFWwr4pzVThSZxSnYK5+s1TPzE2V79t+kDrV1748qXnBp0sAYLj+yYPnNw3+WPOuTu7aUZoDFrg0kYblKIeB+TWkxUWpRSCsNMbooXxAzNjP7nW7p27uNX9yh6GbBQAJTaG7C04o368HnMuyUbFRTXopgMPjTLCy/iU0vcq+KJAshBFZioM71tNstee32ln12LD8PsBZHeHxZ6eR02E2s03npi/7eTxh7JeWw86bbxXZGnBPfvv5/Tl17mUrLHS3SHNUrqdDtY6ljfWmVqK0LWQWmSIQ8AHWOfLmkE0CiHQmtR6hrniwukdLryygdKaMAgprCOzFi8a5zzGaLLCUliHda5sMoqgTEBmPb2kx6XNHU58aJH9t83RG2ryHLIYGpGglKcWaLTSBNoTGkitojsUhs4QBZpm6KlHnl4mgdlXv/f+Txw/cvjuuSdf/NLl32uu+PptB2Y/A9xktAkUit4gZXmnQxSHzE+M4zx4PEopnPcU1iICsQm4stFZ7PSSn6wFweupta/tAYnT5TjiWzKUvJZkRFqpovIqBnSuIWjEWRwEDIqCUKvJMdFjXe+7906MHzow1pr5/UvLn6sIIHstA+R7HD729DyawPhOp9O8sHxBNWsRRZZTDIfoK5vMvvQCn3yhz2vdIbG7wM6RDZI8p7A54XSX+cUxTBDTqIPyEYNMcC7AiSYpBoRak4un2xfWB57ll9vYzFOrhYDCOkeS5RTGEJiygM+tJS8sXgTnHd57xsYnCYKQdi9BjWluu/8A9VCjlScrPGmhyGPDZLOsgKIgAJvRiqERawSh7zV9C1ZrxkNh2jhqucPU1Wx4bPxDs+nR+3l+SJ7aWRFFkhVopUkKy76ZSZIiY6vXIw4CBLDOoQS0AoUml4JemqnpydYtoTEPnF7ZXGXPfImISGyM2LdYBPmXD97N//zaBX5zc3u3/gDMSpo6Z9TaZD2WxFo03DSv1PEurNzTat3aEamviuspMHINutkHbwLHbnNHKWKRMucWoR5o1WqEm9NPvfD/SQ+N3yxLUVe5bB1/eof6FxJq2zDnhEvLL3CpNU9x8jhDs8Hk8ZxEN0mtIspjcJrCOnIHubVoZXDW0xl6Oh3LTqegu9pHSTl5KOLJ0oJGvQEotNbkhSPQ5d8pFN4LShnCqEY/SUnSnHgpYpg5gsAw1mgQR5AVGUku5N6jlWOyrqjHmiiAKGiitBBlCUmhKRykXlAo4sixYBxbr6Qq+W4yO+hleC/U4yq6FRlhYMjzHOc8eVHQG6SMN2KacUyr3mCYpAyzDK01tx/ZR2jMxGZ38NM7nf7GxjD9Alfn2l1mrYqDQDL71jJ437FWqT0NVAXBVl64TesuxmGAByJhdkHphy8p/9y+uHZqbZitvNrpGa7RVQ97AaL3dIRrIsRA84bFYObPfKR+xw2Hg3tOHAzuOLTv3I317IzSQ1CFprgpIrMxV35TcWYjYzUdsvFPP8fsZx5k5gHQtRpz0TiTzSXSPGN1sM4g8wge5wTrHP1hQbef0+vktNeGdFe6ePFl+uSFUoleFr55XqC1htBgffn5HqhFEU4gS1Jy6wjDiGFmyXNLUXimxsaom5DEZeRZhhfICkst0kw1Q3LnKJwnUgZMGWGsA7wm80L6Ssr60wOG3YJhlhMaQ1pYtNHUg4gstziBOIoYr9fJrQUvaKXZbHfpDhLGWzWMNiWTFxg11agfXRhvPr4xTJ+qwJEKWOu9aK3fUmlWpBWbzuEqDwEgnI3C+kdnZj6c5fl9RunCikQWH9S1vvFQHB+qaXVjL82fS50L91C81yxARrqZ+k1HgrkHbg1O/vh76o8eWIzuWJxUtzVipsWhXGpIs4g0DRl0DcO+ZhhpLh3M+M65DmcHQ9wN4zy0fxNpziFaMVYfoxFO0B4sgyhc4cm9w1lHd5jT7mYMOjmDXk53tUfaTVAC1lrEGBSQJkPiWp3AGLz3ZHlF64qUEUQHpVgRRZZbAqMqAHmCJCNN87IL36oTmxZeW3KXs9N2eCvosASaNhqjFVo0DXE4Db0rls0ne3R3Mkqxo8KKUBSlEFUpULqkrAOtqUUB/SRjqzcktY5GqAiNBlWmi7UwRLwoozUTjfieeqBvSKzvcFW8591byAroFw7s51PffJZ8DziA8HijMbNozIdf2ti+e2ALseJJBYxSMzNBsCTWzQ7zIqkeyiNGz15rACnZBggE4ofvjGf/n39p4s8dORx8dMrLjHEqSoqAXltJnmiSJCAZaAYDzTBRJENYa1ue7yZ8ORlQOznJR/78bSwdmcU5w2StRaAiNruXGaRDsqKsFyg8w6Sg1y/o72QM2imDTkbnSodkmFOPQ6y1KBRGQZam1OqNMq+3Dq0VKE1ROJRWoAzOlfVIIY5aKwQB6yDNhVAEW/Tp9BMajXGajRrNRo2G9iTZkDQrCCNNqx4hToFzoAx+YGl/s8vqpR65syityrleUcRRiNYKo8EWvtxf4Czr7ZQ8L2hEAUoJk6064oTIlNFDvKCNQsch483agbl6/NjFXvLini67ct4z14jZuMYl8bdNjvNakjAfhepSminZM/9xa6t14/ogOdjPMgpE5SIopQiUihtaT08YM3eq2bx3JgjObFm71+H+mhmeCnbTK0WAEHzm/RP3zKvxz2x8V0/YMctkM2enH9HuBSobwiDRZBkMBmXdsLlT8OJyl+9e7KCOjfP4z93G7MFpQhUyUQ8xYhgmOcO8IM8saZaTW0eWW5LEMthJ6W4M6G0N2dnoMVju4q2nMLZMpQBRoJRgbUEYxhXVa9AmxImgvULrEEFROEdhHbWWwXtHmld1ilZ4JxTWsTPcQRvN9MQYR+YWCRFQjroxYHO2kxyNIg40yemU/qUUJ2C9px6GhJEhCgy1OCzpXaXwzpHnZUpIXSi8kBeWzjBFKUWjHqNQREFQppVZQVpYhnkRxKF5MDbq1zInvRFAAq2uqY7y/9451Kjz1Fab7TzfGz1qDaObY0rdveHsrPWeAsEDSZm7j0dKzUSK2q21+GfeNzX1yj/f2PhS9bn5tZRq7U2xDBDERXh0ayWqpykMdgzZgsJ5zfqapj8UugNPZ+jo9Sxp6ugMc7opvPODH6J1t2d8f1luBaHHAEmWk9qMvPAkaU6Re9Lcsr0zpLuT0V4fsHWlw/Zqh+5OH2lbikJQ2hGGUBQW0aVmMM8ywjDGe4+1kGUFznqCOMB6wRhdajcURLWQwjus8+RW4bTCCxSFBwXeCxvbHYb9hMnAUJ+cItR1hoVFxKBDzbBTsP5Sn84wx3tPI46YnqhTj0MUZTk6GKZ0hzlZYdnpDCisK5uegLMOtKZZj6lHNbqDlLXOJt1BRi/JyKzDlbKMRaP0ArjzjAwuQBVy7QPk365uoED5q8NRsUD8+NzcMYriwe0kUU6VcgFVhYihs2oemj53RoV68tH5mUd/dXPzSVeOOgdcHaKSawUgu1Tv1pbrq314owGn2FyO0JHQ7jjOrBQME0cAuEJIc8vKxoAHP/gJ/sxf/Iuc67zCN1//NWJTvvGJWMRBWniGWUE/tfSSgl43ZWdtQHsrYf31LXZWyxu1yCw+Uzgv1CibiVlusaqcG0mSAWFcp7BldDFBgBewHoLA4LzHaI1SGmtLEkBrQZQnt1Wo1KYs/L0nSxzKgtQC1tfX0VrTaETU6xHaGHpne2xe7KO1ptWIqEeGLC3Y7PTZ6vbJtacwjqH1pFbIC0+WOtJ+Tt4vUCKgNa04IDTrDLKczFa0717Fm2JcUEtclc8rkfKmuhbPUi1mOS1Tv9x7pUpA72r1xoOgeXMcv+/89vaNibVlvVblTab8HK+0RoMBMQthePupifG5F9qdPldnaty1FEEY5X07Hb8pXnIj1ASF9jBoK9ody047p2YUKMUwLbiyM2RDj3Hng48i1nFy6ja6g2Ve2XgCry3egReLdcIwc/SSgo2thN5WwvblLhuXttlaa2Nzi7jyhk4LwXjIMoeI4DwoLTjrSCWFXp8gCNAiGBOA0uWNWRRls1BRNhBzS82UNYg2glMK7ykDvQKxUhby1tEdCoWUTT3rHGlhibsBGy9uk2SWRqzZ6fQ5PRwwvmS4+ZEZbl1YIpysMTYVk+dCmsEwFdqdgrXLA1bOdbn48haby306yVWNld5zB1TqPPFCQ5CZPWyiEhGsvfaYzxvqdc4mCQ1jSJ1TUs4s74JDoH6qXj+02R+848pgGAhXB2s80FLgRQ1WbbE+EJ8WRUEtDg7cOza274V25xJv3BF/TUSQUjAnZSf36bPJa+8+5V7bNxHclYtIbpRKnJBkQiAiSeZUL7H5lV66tjFWn5ho7Rtv1OskaYEJYo427mQ1uMhGdq66IRV5LvSTgp2dlK0rXS6f3mB7eZthLyk746XJG+IEfJmEigWlqpvWC4X2KC+oLMWELXJradZrNJpNuv0E70sZSqA1INQiTaQVgS7rFwkU1oPzHmVKxsmqERtlGeYOE5iy2y3Q3xiyebFNnlnOr3RpLMLjP3qAex6eZ2G2RidXdBOPcoYkK3AWkkyYmY85cGSM9m1zrNy/xNln1nn5G5cZbA/RvHEksQKIklIImfDGaURKqda1df7agQP81Quv07dOyZsiB9C6qdWau7vZ+MTL2zsnrJTU/OguDxUSKU1P8cpmUZzfdrbXUIolz9ShuHYM+HZ1T+prpQ4J9ojDHFB8+aXelcdvmfjczC1jJ0JDyyrY7BSsbqa0+5lf62WnL7bzb5zu2O82x/QPnVos3m+d4L1i0OsQqYAbJu5jfXmZQgpcYUhTz9ZmwvmX1rn48io76x181SnWSiHel2pcX8552OqSJhYCJRgFPhXiSHBFjrMOpcB5wZgQTYovc/lSi67VyL8UNIQaRAkaAaOxXhAtGF1+Da0g1KqUvygFmSW73GVzs0vbJ9z92DSf/PFDHDrcwFnIC6E/9BS5UFiPsx7xEBioi0Ij+DGFUnXGmgdoTkQ887uv0d9Mdvc7q6sXXiqD7fIi7pH7XCuu71KxTwB/7rXXAFG5L2sOIFJl5JiYi+OJD89O//BrO+1PdfM8ru8JAbpSA1kl/Z5SzyQibYF8QgfUoL5Qj2+Njfn1zLlrBhxviCDV+5YBwa98devfIDTuOtr8472BnfvCM+uy2c2XO4X6vdNb2VfWBrLerMf1WdX0xpf0apHnYBRBFHNo6iSnN2/ila1nEevZWO3z0tMXufjSKllaFrxKVeo87/EieCd4UTi5+g0l1SOqBtRM+e/zLEcHKXG9ZLMcGqEUA446784J/UFBlpRQE9G7zySREoijN10EcucpvOBEwCmUVbSvdBhEGZ/9mZO8813zTI2VQBYFhSuH0L2UABGnMMagcdSCci573AtjdaFdA33HHGk75ZkvnMdmbnfWtEKCUhXz8yYt3DVxmsbA/+PP89nFWfXbG2261o4ix2jysiHQHA+CiU/Nzn7gcrf/x8/1+uNBFRKDqodgBCzYnvCVFeQp7SVD6fZkGCLWUfgiCIzW15pI880RJAfMSyvJ6t/8tSu/fM+h+jfJ3D3dYVb0HM8uD7hQvbfxxHht7IZj86ZIA/I0xdkC7zQ6iEDBgfgET+08x4Vzy5x95hKbyzvVU758IukqxfQiu3JwrwRbDdG4q9/X7kV2grKFJ+8PGddVd9MYarW4jETVTesRUgftnkOLENUM2ihEl7ej976qADVKSopFKQhVyYL51BHU4DN/9iTveM8SIZYi8yhdKoYDAckczpYVdhCANo6Q0oUlDDWihHogxLEirhtMeJBBP+PFr11BykGs3STbgzfqTUWpUoSRIcv+aPpmN4+Pc2U4wKOI/9b/gAJlRZTfM4OvoCnQvG9yYt99jebHz/d6n7nY78+J91etLkfvo0IVwjcuivxyT1ivK6+9sIVWaBSD3G4MC1uoq9zENTdROIoiKeC9iH3qwvBJ4Cm+13g42m4P8jDWz8YmfmxjbTNcXNxHrdEkTVPyNKXhIvy5iCd/62WKYYqocnjMeUG8IFqhkHJaqAKArqpXeeOt4jNQkUfHDpwH8Q5rHYUu8NqjjaawdveO895RpJ5B7pHCo4eOMNToQJdd70DjUHg8OGHQy5BaQKg1xhjEex780D7ueXAGmwsOwSihFilwZcSKo5i+c1ifIChakcaI4J3DulJ2VwN8CLoZog8ZHvrkcYYDy7lnVxl54uxeVNm9KaRq/aAxfySN5TunJlmKaqylQ/rWKycyonH31hsNpVTj/bPTN8xH4Z863em+/+JgUBeR3ZvKVzdTIKgCXluH/7kL5wBS77kk9vlbQ/NDzoq0rX2pWoC0d6HpNRVB4Ors9QgsuwtqrtaUaKCWZtZf3mx/6+BE9Pr66saJNE0xQYAtcro7O3z3O8/TPr1OkBmGo0JcleCgiiIiCg/lExe6olmLalxJCnew+n+eUbBioTn0HEI4rBTT4n2cJgVhGIgSUVprbJHvAq3IHVurfcb2NREvGIEgK+lVE2h8oMtaBPAehgOLpI5aPcQEwsJMyM13NBHvsbYSpoaQWY/3jl4meELElxSz05A6T00HZGIR6xCriZQmU45IK5qhZ3Yu4oGP3UA6tFx5eWMXIIo3PHDlKv1bPpfi2GCtx+/hfZVWjE9GtLf+YDvtD8/MobTn9KDP0IkqvFdSZkgjg4oG0DhQq00+OD72GM59+vmN7Xt6eR6Ee+injF0q26bw7S34/27C01WWgoiop4eDb39ofKLdF9n5erf7Cm90ueRaiyBvBondQzvufbqZ0a/fPn3ptYW7J5/stneOJcNEK5Tqdjq8+Nx3eeqbT5IXBacWDnBma5WdYU+8tx6FVwrlBCteNpTWl53XV7xTT6cDd7bIZRNoVRdpR8qHUJRBqxAOBHB7IDxAVtxYt/GsDhU6CDEEZX1iyig17Bckg6LUXRtFgSJQoDy43CMVpWSriT87sChR6FA4vFRjvKnJ8/KSFL5MA4nK4h/ryaSPVxrRkKWeZCg0awqlpUwjHQy9L58oqgRvM4C5+Zi73n+MtJuxfaU74nRzBT2+xwZHCENDEIQ4l78h61CUEvow1rt/7L3g7NV/U28EBKFCG0Vn+/98nPdUo0EzNJzvJ6ymqUqdG9UaoxqpEWjd/ODc7A0Htf74xV7vk68nyVTqvAr3fF97VIf9BH5zHf5//TJyZHvaIUFNKZs6sS8PBt9+stNZ5o0GGdekacNekLx5g6zsiSQayJO06L1yaeVfHTxw5OGdrZ2jeZbz3Lef5blnniXPc6I4pBXU3GG18EKxpl/d6GxfVkgmCsQz9J7X8GrFO9+3uRutS5aqk7rXXkcBWx4u58KzOfxm7uSEGqTva8Xm0abIfBRGRhsvXqxSIrjMYjNbNg69Ji8TKhQOK4IohU8t1nl0vbQRSpOciTDi2P4QL5DbctJRvKIQhTIlI2aCsj+kAkEVilBApKSjjVIoQhxC5oTcKmzhiQJFpDVjdVjY3+TGBw/ynX97lrSbCUq1veJSdYUdVS3Vz3IFgnNOec8bXBudE9rbOWUcVkJFUhw82pSxyQhbCHHdSGcrJQgVnZ2cKNLc/dgBtFF8/bcuvOGNf8/0NONa89Kgy+Uk01nZ4wj2pFTNhjGtjy/MPTAFP/fydvvWzTSNc5CRGdieednMwks9+NwGfCGDDa76i5XPLK31YhTP/f7OdvrNnZ1vFCIDvtde6ZoDyPcDy+43enimqa7sJGK9HzFe6UuXVr57ZPHKPzl+cfkXd7Y2W6++9BIoj64Fsu4HaiVtv7ix3P+vO5vp+TRnyNUFl9WFcH7P792eVO7Nnkm7sypA34osbw/zZ7uJ+lwrtu+fbLqHA8UR54rQIOTDnCLJUXH5bDMKsdajpKyGrC9b1d467KCcaPIexhcims2gjBgKhllZoIdhwERgEFdK6I3RNEONWPBGo9A4L1gPmddk1pcOLR6CUEiLUsnqPdRqmsVDE2ydnOe1Z68ovKx7YeNNP7sq1869YVWEemOfRAQFUnkLiwhXLgy9ujgs02SFaK2o+AtBKRrjpYizNRlTpI4stXzznQ/zX718lqe6HbVTFCov06qgKsQbAs1HpqcX7xtvffxsp/vZ57q9A865UcmnSgYXZWDo4btD+P1N+OIQLu0Bhq8EsdF4EEQ/srR0q8rSv/Tt7Xb/1aJ4lqv+Y9eUy/u/k3n1sf2z0s7W6fSTEeM1BPQ3X3rpXzbr8aL2ySd30m59Jx+Gm2nPD2z+Sp7J/9BeSb+LyN4FNI43GrLtBcb3c9tT3wckEZBakXY7LV4cZPY3I60eDI08IJ6bk620deH59f7kXKPdHI9na7WwrrQyCikLFcoWtojgC4vznjz3BNRxUkaFKKQUKRYQBCFJrinyhMAKcQNCowiq52bmBFelYoFy6FCh8SgHQaBQKPqJx3qNGIibAfNHJli/tE1nfXgGxU6l59trhROIlC/euFtFVe2J8r+9N5eSksirfu9dCR6tlNjc+2/+zkWpNUJERB5K97Fxd8GDX/k6t4+P0baW5Co4ahWF23hocnz/HY3az7/Q7nz8YrdXZ084C65GjO8W8JUt+N0erFb1ebEnVQ8FooO1WuuTM7MfXOsP/vhGv3c88f5/3VKslg7G3+NB9tYCyC0HxvnW6RUxRotzu1FEb/d7a7/zzSf/+9np5m/vFMOlpEiPmlDt+EJ/Ne24iyDpmy6Yr6g/v+cN/p5NQ2/SGozek5EdaFZ9zQhIC5Fu4eS7OH5dwyFBjqxfGqztrA136s1wX62hb6o1whvjenAsCvUUWk0ppYyoiuP2IllaqIAJvMAg99RDTS1Q5KEisxnKqdJvq2HKFCrN0V6TFIpCPHEsTNQVtVCRWc8wo/zxRLAObFOz1fdse0HHivpYyL7j08mwl7+WDgv7pofAyPg5HtUAB460WtOztThJnKwtD7LuTp7ueag4qtXXgFdqV+FhRbAjhigZWJcMrFfAN+qr3Fybl31RjbODoUqu1hxxVYw3f2Tfwol9gfnJJ7fbH18ZDmtx1U4KS+Ktn8OLQ/idLnx1AGt73ufRjb7rz/uxmdlbFoPw42c6nQ+sDAfTU6jtVOuv5SLuTQ9O3pIA+dzTVziyOMXadl92ukPvS/UlgOtmadFdSTdHrFfZivNvXpFsKYkrUQpRSiGlPxRKK6lPBww2iu/J8fb8dm8NOLqoo92Bo6gy8HAZ+AYQFLmYIs9f6e7wBKTNIGC+Vtf745q+NYj0QW3UYVEyJ8i4K3xdrFWFF+2sEBtfDnh5hxdNZAJEKVIrGK1QxqCUwltLGEKrpmjWhGZYpliZg05azrNEAUQapsegFUMkmmQ7YuHApMtTm5/99sre3SqjaFGbnIrG/8TP3vjgwePj95nQLEWBms6sz5PUbbS3k9Us88Mksf1kULSvnOuvvvZKZ7PbLjqdnXzAVR+v3U1Z4iWn5Cactd5fPtdh4IqRrmqve2bjsampI4vG/IVv73TeszIcBo2rGrKigNcH8Ktb8KW0BEb2JmCMzPWik43G1AON1iPeu598pb1z03qeqQmBQqtnL3n7wh7W9Joq0P+dAXJpfZvbji/uGjiVvbs30MK75s3yxh96t+ZQCjERYowmMAF/87/7NH/jT/1jBEg7/6ecv7yJUfPfByjm++Tso9/3rGW93/Ov9Hv+K0A9CJk1AfPGsN97lrY2ixvT1L/bKB8WtkyNIlNSvIWzpYVeZcCgK/MI64UIRT8TIlMyEIKnGYETxTCHYaFQqmxQOqOYnNKcuKlGoKU5HIzd9Jpa/T0R2TsLEd7z0OzSxz577If3HR37pDJmX6QDwNLEI8DCUowvI0PuvM+M933xvtPrFa+vXBq+dvlC8trlC4Pzr5/prS5fHHa4uoQ0A3JXeLu5NnSqDDt6D1tV/8jSvkOPjI//hX/5+sV3b6SpGS+fPlLAxhA+t1OmUuekTLOLPcTK6OuE+8Kode9Y69SSCX7k3HD4yJVkOKO8lzpglNrswG9uetnmGhyU4j9E1jA93gCv8CKqm6RKxKuyXES/SYnpqRrcVaGIMlUTzGiMLlss6bD4g/gZ3vz/19+nfhkBJXjTxyN+v37few48/PGfPPGfTU3q8fFaqetSokgKwSpVckaqXNHgPfQzi7YOZXQ1kagYq0EzLO2ECge9HNYHJVC0CGKh8OCtp9/zvPZK//kv/erZv7t+oXMRKJRS8okfO3zrez984GdqY/E9uZfA2lJQE4e6lMuo0mpVlepYFEIUQBwIoRYRwVkvWbdj17Y289Pnzyff+v3PX/nS66+0lyugDPY89amuRQ1oHW21Zn5kYf5nX9za+ukz7U5UK0OBs/CtTfhny/AtX35+/ibGMQCC8SBoPDo5efRwEHxsZZi85+JwsNRzTself600IM20+V9eEfmfhuI3gf6e1OyaSrH+vfYzJFnBO265EY2h3R+I9R7Um57qZb9jVGNIEEIcg80pZfBWsIXHFv4PBOXqjVHFfx8SYG8k27uYM9/z9NJxLdCHbpp+dHw8mKoFZa/BGFXRvuVrLJrGAZ1hRpq4ktoNNGFQ2pnmbjR7UhYFhRW0UiRWkeXlzw5CPSwL/eZYONWYrDUuvtY5r71Ef/I/Ofmud3xw6WebE/FtRmkTagi1ox6U+1MiU+psPJrCKTKrsNU2beXLfoh4NKIiY8yUqYc3NCfr9y8cnDjabReXtlaH3Tc9QHQlOmwEWjd+7MD+913pdH/+zE57LAapg03gdy7B/7gOz8tVG1a/J2JE03HcevfM9M2PT059ssjzP3mu33/35WQ4mTuHBlU9ibIC9asXFL/cFb9VET3ZtdYg/A8CCMDh+dnKmKCPEw81UOWDTYzRoo0SpVXZOa9uFqVKRugPKQyKMkigEDSidNn62AMeuyc9GwFIJYMiO3hy+tjkXP2WKPBltWwUaQ79zCNojApL1xIR8rRUJzXqikZF6aS57LrQl6sYSi8v56E3FDKhktqUwIuMMrWx6Mh8vT7z2MMzhx/88NKPE4QH00KU0ZXeS5dqYW0McWAIqyVD4sv+i0JGBqYoQXlRSpzCOXBWUVgVqig4Nnd44s6pfU25fKZ90Zfr4kZRNAYaj83NHAyt/cVXtrZvDLwnhM0u/Mp5+Md9WFXg1NVhpgCIbxprTX9gfu6eO8daP6qd+9kXtrbfeXk43DcsCq1F0KW5MwrWU/iVC6j/pS2yXEWxvUU9bxuAnF/bYKPbLcFRVQVK9hQJclUSIRX/7/4wZUVVkifV68jNsLNefmvG7NE8qd2oA6Cd9Wpspq6nF5sPmVDXo2r1W+ZASYBzim6aYBRorxmmBY2aYrZlaMYlpVuvKaLAEBiDUhAHhkArQiUYU6Zpzmsypyi8wnjP4rnC3LJQP7L08OQtRaBaRiDJIXcKpTVONPlIoVXR1IFSaGXQyhMgaDxalU1LqXjgUfajqmZmEAczE7P1u6f3NWVnfbg87BVu1AxsBmbsM3MLn31xZ+cjWZYFEQza8I9fg39dlDezByRUSu2LovE7W62jj89Mv3NfEPzYIM9/9LV256Hz3e54Zq3RVc5dvTIHz/fg/30efjWFUeRI9xAJ1+QinT+4FVjypo/33JzXwmlvvEEou3u0YeQZvUuxJv2imD88cXvYCA+FkcJojfOKwkKBIgwCmnGNJHF475id0DTicry3HkIjVgS6rFVypwhUVPZIfGmxGppSOazQeA/7v50xg5A/XNeupowSRaggF41HkzrBisKjyV3pgC+iS6BJyZRoVUYRJ2UKW3o+6F1nF1dV4ZVgLR6brt++cGBsbnN5cH7QzVFQ+/EDB+/QRfGzZ3fa0xEM+kr9xmn4LQ+ZRsnhej2+Z2py/72N5nuOh9GPiHOfvTDof+DyMLlluT8Yy6xVYXURpcy7xEC7D/9iDf5fa/BtKSU1fUo1fL5HPXFNDhgH/ACe0RxSGEORgVJK5CoXn2+tDDYunel+YWK6dkc9ilp4wSIUUqqAoxASV5CLw1QjyEnhaSqohZrQ6MoCyJFZTXuY48VjtMI5IaDswMdSZ/67Xcav5Gx+ooUKdenWoDWZE5QG7xR5VaCHpqyHBtUgWUBJAgRKlXQ0ZbSxXigsiJNyuL1KQpUqN2/5AMTT2Hdo7KOPfvR44yufO/srbj1vjyv1gZfb7f3eu7yj1G9eUfq3j8Vh62itdnRc64MCN1nxJ64k6eJqkkZeROnq6aL3AKOCZs/C17bhc2vwlIV2BYpkRA4o8KaUrV2zvvaGH+Djq6x3Yq6hitSyh4kLuptpe+HgxO21ZnRAqqe0KwSvNEorQh2ifYCt1kDHsaYRasLAEOqAQJeuinmhGWaWtBCyTGh3YGNT2GgLUy8mHPtKh41311HHa8TG4EQzzIXCUxXg5Vy+UBo+Gl26GIbVKLGvNoj6oiQCRMA6Re7KyIEIqa2iSNWGGxldWCe6NRYfbk435lpbLh0buMfP9bozxphXJ5qtZ0/V6/fOafOhvrWPb+b5Y8vJ8MTl/nCyWxTGlIyUqqhBUVfrjEEOTw/hH1+Bf7QFL3jo7okau+BQIHWUvIeIs9dmCfKDDZBd2nqxRVL67e7SwVlS2OZ4HI1P1+83RoVlTa3J/WikV6OtQrzFBDDZ1NQjjUjpGl9O+4YoIjoDx05b2FiHnbbQ6zuWXk148OtDiglN+/EW9VZAag2DTCESICpgWDjSotRxKAFFuQ47qMzrtCrn7iND5dpYjgOLKAy6nPT0iqyArCjJg9yC3QMY8aKbE9GB8fHayfT17uKYMmZurCVJUdy1nCR3Xc7SpU6et4bWaucFAz4oI21ARV8FZeG+buE7ffhHq/DLm/BkUdYagz3FeA5YDb6JYgEtCbCK51rdzhhch0cZSSqZuK/SrBSITz+79qWp+cZ7URPvLIqAqCaoUJNrjXcZKnGYCOpRGVWsoxod9gRaI+IoCk8+rLOy3ifPHI0M7n8l44ZXEpqZJp0tm+a5rZHl5T6RMChvbiWaWCtiJQSqtDgtnOB8WYxrXf65Fo11vhw9VpX8UyiNwQUQT2E9aT6axymFT1opAqNR4o060jhQPDjD8pcusbW5tZCXeisJyjpCydUm0+sp/JaCxRiOe+gW8EIbnunCq8lV5e6oKbm7JXgUNWKQCOE4hotc2wbd1yMIUAw9QaxKDx7Zs9sitTYITRI3ojtF6XERQVWmcMp5XOHQkWJ6XNOqdiR6EYwqi2/rhDSNuLTusc4Tas29Tw+56btDglxwSoiDkM5iQHcyJM081pcsl4giUoZQlVIVVWV/uZVyYhFICkVaQJJXfyYlZzQSTeLL76lwYAuNdwrrBGdBfPlvdVU0KAE1GTMQoX25W+aUIB4SVdoDrCs4ncCvXILf6MLXHXylDZ9fht8fwFkLO1UaNdibTo3AMVGlY6Ohole49v2HrwMEcM6xcGQCZ72y2RveNL29NljXRhdxI7zDaBMrrZSuGnUaxXjTMD8VUDMlczVir7wHrWLa3ZBu32GBU2dTbn2mD9ZXXUzBYIhXHb05hZuMiFRQWhNRRqMRsIzWpaylWjzkfUUD29LwQnxpdyq+qjWkGk+WshdSFFKmXIXH5lJWxhV5pyhtlryFxnSdNPfDrbX+M0741hB+I4HPD+BXO/DrO/BdKeuJXgpreQmKEWU73AMMq8CZPRTufkrR1miu+61wrgOkOmPTdbqbCfJGqx0F0NkcXgpCHUW18EYT6NjoctFopDUTY4bZCVN1xSvbIVOqWHIb0e4qUq+Y3yy454k2RTfHq0ot6DxJVmB6jlYW0p8NsA1DVDlGxkELNYoIntI8WwmBriKBK73EjAoIVEBhy/2ivmoYlmlWaUxRAktwRWnbGOSq2p9Y0khKRgW+IJEZ7qT2f7u8lfxGAi+k8EoGlwrYrsAxAsQbtF28adZHgdRAJrjqcHKYMgfjOkDeWqe3nWICjbNXPaBG3Lz34nfWhmfEuWFYC04GoWkYY2hEhqmpkImGLjVQoap0UYbCafrDgGFuCEzCzd/tMnUuJ3OObp6zcmiJ+fvvIltexecFM6pJuAP5yQnqYzNYC4MsJS0KrHMUzpapmwTkuS1dYaSSlUgZaayV0qOrorJVtY4BNL7qw3gPRmuslMV6OTQGmoDcOfo7Gb3tJA5C3d7eTL5hC9+pGKi9wMiATJVsVKHLwtvqkrb1ukzNdsVZVJ8weIuB4zpAvqdYF6oJvDe3PhEvsrM+vJAP8ySsBTebOKw3WwEHFpo0G4rI+IpmNWQF9FNDbhWmljIuOce+kRN1Pc55+lnK5g3HuP///reQzg7d77zIIM0xWyl5L6N3qAVKkeYOQ1SOCTuHE13ulc8doTbV2GE5GpxmvkyplAIpaxWDpiYeW1m4StVNFytk1VJ58Qpnyx0pydDSXU/IhlYFceDy3D3R3UlHkpAhkCqlCqXKmgLwURkhfFl4I40KSaMzGhp6q57rAHnTUUpx790naXcG2Ksr0EZK4LDXzjZ67aSdZ/bg7L76+LHDY2qsodCq7HY7r0gLTZYbJMhQgaW26Vh8Moe0vNEHeU5x6iZu/9SPENfrrHzhywyTBHGeyQ4MjdCbq2PQKFX2U7xXFFaQwpbz8L7UdhVeSPLSLG9k9VpGFaq0DJwvayJvZRdU1pdz7b5K0/K0YNjO6LdTQIhqUZYX/onNld5FVJlOaa3sxExdGl6w1ovj6njnXsOC9G10P1yned8cRbzw/AvnybI3OPDvjSZ2qj716oH63MWdS8nBctRbV7tJSjGmIcIEZdGs0KhAUeDReWmwHaAYHx8jiEI2D4zRWYhodMt9iAbF0tc3KQJN97YpAh2VY7p2gPKOWIflkiDryb1QIBSFUBPBKY23pUOkpkylktHgZiXR1KKwUpIAWoQkd4gVkk5BfyvFFQ6lIYyiOIyiRtlhKddoeS9MTNelJUI3tcR7CpC367kOkDed/ftnWV7eQkT2DlsFQGiMNj/5Y++/4+47jv5ElgxuWu8tqygIKsOGAkShxKAwJD6nFmkCI+Tjhv6UonnZ4TWMRxHqyjLb66v8r4OvM33XBLec6+C9J89yIh+w/8kd8ljTvWEcX3hUtSjIWiF3Hl/1MbSHQGmseJx1jFwenBdsoCm8x/uyL6NQiCvnPAtXmfb50jivtzEkS4ryayqNRsfa+nqFI60U2gQaUYat1F57u9Kup1j/cc/ddx6gXgu5eGmLKApxzu/d29g4dfLA3M/99Ac/csupgz8nPr/JuiKYXgyYPRihlcf6HGs1irActc0KorBMbTIUrXMFzSsZVjxojer0uDxp+PXoVXpPrLPvwg4trat6wBMVCtO37MyHuFiB9+RZQZ57UuspCl/O1RSy63GsULhqjURQObaUK+/K6GGdlNHIaZKkIM8cNvFsr/YZdJOrYwNGUY+iMFoZXrqy2XvaXQ0UbthNpZvaH5j74jpAgCiKWNo3xiAp6Pdz5b3XIjKy2Wzce9eJ/X/6T7zvFxb3Tf3EYNhbbLe3KIqciSXF2FSAs32sFZK87H4nhbCTOBqxJs2EQiCyitnzHpfZyv6xYPvll3l5Kecbz5xm9nLKjXG9GhEsnRbGJISNhM5CSBEIeeYoqrGiIheK3JbjvVK6LsrIfbFSUZe1iMFVDJet6o2i8BS5o9fO2FkbkHRSvB+5X4IKDXEUq3C5P9xoD7+YID0g1yjrnJcfpHvjOkCAgwfGOPPaFv1+pqz1ynsZmRc0gPpYK7rv0P7JXwgDme51O9jC4iiYP1rDRBbxWVl/2LKe72XC9rCgWdMYBaFX5C1Fa9kSblkyBKugOSxYujwkOTbOlbsmuOlKRisvnVOs0XgRmgm4Xs7mZClxKXJXusw7j/a+GgmuOnG67Geoav7DOcHoEFGCsxaDBhGy3NFvZ7RX+iTdlKIokGonvDYaEwborSFs5d++mGRfysUPgUwpZeUtsDfxOkD+AM+jD91Mp9ul08lUUbhdtopqIQww2e4M4kuX1m6xRXpgfCwGoDlumD4UIGQgHusU3imU0nRzzyCztGqKelSChHrAMLXUXx6WS4PKxSDUNnOObFvO3jROHLY4dLmPGEUhZbFtraO+leOGlq2GJtVSyVw8VMW2HS2p0aWmzFlfWQ15ClsgvtKbOcHmjmxY0F4f0NseYq3DF5ZA61IZbBRqa4g5syXdfva7l7x9RkTSPQDxDzRaXCny6wD5QTi33nyYV08vq8J6JSJ7rTYbYWDGwlDP1uJgXsQevnx566R1Tu2bb3H8xkn0WEHpfCQ4X86FO6XoJOW+Ea09YVCCJi+EQQjNyznNQblgI3OeXMNYrrjl9YLtgWXQ6VEzBq8VuhInFs7RaFtmtwsCI2QaMhEKEax3eFWBKfelI7yUa+jEQew9eeHIneAKj88cw05KZ71PluSMhg6NMejEMt7OmVxNUcOCFJ5cEf+dagY9EygCpWQ+CFn5jzE7fZ3FurbOLaeWuHBxHefYm1bVgNbBpYmjjSY/kqXZHbVabV9oZGmQpOq5Fy7z0AMnOHLDGJe66zjvCIOyT+Gq1Mb6cm7De+illmakyQqhGDNsPjLBzL/uUPRzUIpISsOHpvUc2e5zQUFLyr3uo00ZhQh5VmAuF9y4lXPz0hjJWEAncOwYR68Gw6YhDxSiLJEFrMdJ6fhtLbSxDH1VtHcywoFlymmU1rQkYqwHdmOITy2Zs4QKxk0wbbyLPLJrpaTAFyIcw8i5a3SG4zpA/oDOqZNL/P7XXlVJmqu9RfmNNyzO/fCHb/uZK6trP/La+dWg3UlUbgtUoLjz9jk+8UOH2WFYPr29oLynsArrza4Rg1alViqzgnhbjdpqeqfqXLmQsfCkpx6YXQeJwnsmgxrjtRrOObzSJK703KqmyrEaus4Trw4JNg3TXpjILUNvkVaMrweoUBNmHrGuNNN25fezlSW0XUZXLLPeg1e4Qkh8jvFQpAW9JKGUuQtNbVSzFu2LlWsWWd6t7hVtRdSFLJUZFLUoJM2L6wB5u54jB/fx2+kLam/dERjd+PD7b373wnzjg83mfHhw/6RsbHQ4f2mTYZrz53/+YY6fnOCbZxPC0sIFjy9TGO8JdbmSThspbV680E8sY/WQelTqorrvmmC6DbVXhtAMqdVj8iQjzwp0YVGhwQrgFLkvza9kZBHtPKnLUCgK58grQ1+3kV1dG105UVglZN6TO0eWF/SLnPUspe0suVKlJF58OS4rZZGuKBuMCkVtrH73qUOzdz31wmtbVWTNBFxPvGRKS0vpt1XX/HoNUp2nv/B3eOXMMl/86suq1x1q7yVUqrT4f+cjJ2948L6Dv5TnxZFSGVuoRiNkYWGSj3/wNj70Q8epxY6ZiZjDCzMcXphj3/QUY3Edrcr11e2hBe1oBNXWXis4FPW4jDA6VPTGNc0VR9y1GF0KD8WWHlsmLNW8aeHIfGmsbSvqtxAoRlr10nSXzHsSaxm6glzK+flMCQNrSawtTeYQcu/YzjN63uHF766+M3u8/qQCSGgMr9uiXluYnhpv1l/Y2O7uMPL/Be81YrUiMCWNfD2CvI3O4YOzbG712NzqKO+9AUIRavVa1Hz3O+54f71ev9G5vkSxUdbmFKlnaWGKx95xglqQgGRMxdXong4hbHJ0boZBLqxt7PCVl69wfmeHvGpBxxq8cyRJwfR4A6MU3SNw/iPT3PyFIXKxh6c0YXBCyUKhCJVCi6KaDik77d7RLSwemAqjkhK2jmGeVfsOPJEOy36I81A4XOBR1pEXBYPRUh/2mhyXw/hh5SaOUngFK8OEeG3r7iNL8x+q1aKLaZlPWcCJFyms8957OXViiZfPLF+PIG+Xc9vNh3nqO6+plbW2Frm6IOaD773tljtvWfzZJB3uGw4GKkuHWFvQaNT54Afu5OhShhqsQK8H3Tb02jDog1gUligwTE+NMyzgzKVNnK0cSQR0JYYS8YSBQStoNzzdOYPueGr9cl+i9b4afvIUlM09L6OtumXU6DvL68mAlSzlii+YPHUjemmOi2ZA2mxwtpfwar/Lzk0TbL3nCB/50T/NDXfcy7mdLa5sbDDaxjOyVrQVOKpAhgE6wOveszNI9eRY48DBfTOvXV7dusIb9niIjLXqjI/V2dzuXQfI2+W8cnaZ8xfWdVG4Ea3brNfi8U/80J0fiyP5QJKkxntB8BRFwd333sJD90+jV55Btrfw/QTJUvC2tNYhQjILaQelCnqp5elXtxj0PFkm5Zo3V5baWe5IC0ezFhIoT7fuWV4yFBZal1OwHqXL+iCxjlwJXpXS9QxfrllQhvE4JjAarzXHH3yAG37qU/zaQ0Psbft44fk1zscFqz92lMb77uQvf+QXuPM9H+Dmxx7DDwacf+klbLUA581myhaIWjW2FydY7Zb759Msby7OTUxrpZ9t94a9UaqlwEdRIGPNGps7/esAeTuc40fnaLdT1ekOtIhEVe3R+sjjd91666nFnxsM+/POlcs6rbVMTYzz3vfdylT2Mm7tEjYr8L40SLCi8daVvG5eQDqEIiMvEp6/mLGxmrG5PCBNhVw0uS/nwYeJpT+0REYThxA0DZ39AdvjhsBqwk6Bzxyiyo576btw1Y1PKc1YEDAThkzrgOTMa2w/8zxqs0t3IkNuGUO9/yDxsUP8+Rs+yTvnbqXodpGtTV78/G/x/KuvQmnbs5tqUQFEAkPttoMMx2qsL29XVqqF8iKLNxxepD9MXxgmWVqBxFrrpD/MxNq3J+X7A1eDKKXYbveQktsPRKhFUdi4987j73HOHi9yi6eUc3jnuOPeEyxObGPPXSBPSgM3FZQ7Q1yVzausSxiFaBSSZswGiv0NOJd6Nl/v0OkMmD48wdSBCcaaIbVYMTCeTrtgfq7Gvtkawbhl854ay8ci5l4KWXimz/h6js5zNOBUaeXjtSDeUzhPVDUUvRfclTWOnLcceCJkcKiJW2hyYnGWW197kafci7z09FM88+x3ePH1C3jndp+MV81JQUKNWxqDA1Nk5zaqqFee1c1OMD898clTx/e/utPp/5p1Pgdy78UnaS6NZizDQXYdIG/l81/89Y/xr3/7uUqMuLvzO7rj1kOLY2P6HcPB0OiqoLa2YHysxanDAWr5OfL+EO/KiTycx6oyBUMMSmvEOrQxaK0IVMBSHcKaZnt7wMalnKmxFsv9LSb2tZiaqdOsa6yBK8sJw74wNqFp1hTRlGbz7hob+wNmXxwydTqltm1JBik5YIymwOO8Q2mF1hplDF6D0wEqc0y80iU43afLGp/zX6RX5KwkA7adK90VKV3r2bOjvog1w4UGzNSYFCEdlje7VmV30FrHmdeXxxdnmx+KQv0F6/xoJt1qrfxEoy5oz7D39uqL/MCkWPfecYzTZy9z+rUNneXWULmZNxrRxE/96CM/0qibx/v9YWhdgS0ykiTjpptmuXt2C7u1hpdSa+WrSbyR1y7V5gexo1UOZTdBa81Lbc+lC11qwSR//Zf+JgtTB3jyyaexWKIoRFEavfUGBd2eJS+EyGhqkSIcN3QPRmwdjOhPhPioWjaSOqz1KF86K2qjMXGAFU9uLcponBGsEgbicEDXFgydw6uS0jXVd4lWFLGmPxnSna3BWI1mq0ljrMHK5S16naQEkqrUwc7hXdEpnHzNOukxcmUXfJoXYiJNc6zGlzf/Cv/gbz9xPYK8Vc787BgXLq+zsdVHa6Wq6BEC0f13Hd0/Mz32njTN6oW12CKnyDLCQHP70Qjdv0zhyzUDeeGqsVWFIOhAIcpXN081wurLMdaFOOTkbMDyXUu8+uQy33z6af7SX/q/Mdaa4pf/2f9INthmbnEME2rQGldovPUMugWNpmFiwjBeMxSLEd2ZgO1barDahOWE2oWU2mbO2MAxZiJQ5cCWQ2PCsGS+vMP5cgdt3QSM6YBQCUMtDJRj2AjIa4ZhpAjqNQINYajRWpNnObWmYXaphbdCNsyxmUUhDDN3IgiC92rtV72XBCgErHXeG6eZnK2/rdS+b2uAvPOOg7x6cZtarVwFHYaBstaOlmRGYRjUH77/1KPO2Rs73R1skeEqleqD9x/gaKtHsZ1B1R33ruwheClBoCuRX+k6WM2C5w4lUA81J2qOVxcbFLfPkssAvPDTP/2zTIxP83f+6/+C3voKC4enCZsheaBJI0MUKno9aG9rmo2Ael0T1AxBXVMciUkPRGzeOoYknngrZ6wnhFuWYAtk6Mh9GcVs5aa4k6d0ozq5j+gZIa1pCgWEAQZFvZKKePFY78myjMFqgjbC4uFJ6o2o8v61+GFGb3tY39lJPuDFPDFI7MihvRARKTJn41qgHmz8bbkOkGv8/JOff5zadJ0/+z/+HuubPSWCstbpaqVyDNQPH5iZmZqM3jsY9mvWFlib463l2LE5Hr2lBptX8OWugXIqzyiqpTOljxRlxDCMetBVsWsd+SDjRM0zMcw5csMkgVtjdft1Zmam+eFPfYqF+QX+2//u7/L8M88wd2iM5mSDIDYYU85k1GNDv1uOwEaRJqoZorpB1wyhUbimpmjWWLcel4X4JCYbOmzm8MOCInMQGfBNnCq9uhoe4sJR5AUUpbo36YEtHM56rHXkaZ9eP6M10QBReAe1VkRjtoUJFI31LulLaye8yz8wTLgiezZ0OevlzPNrbkSGiLz1cfK2rUFeWdnhH3/5ZdUZZDq3XjvnjYhEVGpdoPXud9x03/xc/Y8laVLP8gxxDu8973nnAY7E2+TdfrmWxkHhKmlGRfsoBeX6pzKvl3JnY7mXo+p7NEKF7yf8/kt95g4bLq2/SKCbzE4uceLESe65815eP32Jb3/rRXbW26T9lGE/Jx0UDPsZw35OMrSkQ0uvm9PrFKR9S9KzJH2L5B6KcsWBrvY++0q3VTmPEsQBYagJAlPZEkk5lmsd+bDA5Y6isOR5wWCQsr2eMBgWRI2Q5kSd1lSD8ekarekajemYsYUW4wvjwcx089BUvbm8st69yNWNXdVSopIBWDw2xc0PHuTK2e3rALmWzk37pnh1ta2ywinvRcvV9cojcIzX6+HU4+899YnAqHvTJNPOOmxhOXygxfvvCtD9nXL4SASHXPWU8uXNqFS5PUuZMpp4X5ogqMoiVyhtevZPBlx+vcuXv73D5Jxnees5Xr90FuUibjh2E+946GHG6uNsXNlmY7nD9to2nc0e3e0h7c0Bve0B3XZCv5OQ9DIGvaw0d9tK6W4ktNcGdFYHdDaG9LaHJP0Ma0vXE5t7isyS9DOSfka/nbC90aO7PWDYScmGOb1en24/odtN6G4XpEMhrIccvnWRo3fsY+bQOGMLDcam6tTGQoJQ0ZqKmd4/3pqdHltqbw+f6+wkPfbuhlSIEqi1Yqb3tYjHauys9K4D5Fo5WimGuVW+lLDvplRAQys1brSeXZwfP3bvXYc+gchinmdAlUYVAx48nIMt7XC8L4FgAoOvFtnoau4DqmU81RI3rRTVVOuo6YLSipv21/j6U1v87pdXmBgPaUwNefX177C12Wbf/FFuv/V2bjp+grmJKSIilNWkw5xsWNDrZvQ7GcP2kH57QHdnwKAz3PNK6O0M6O8M6W0O6GwP6G8P6G326W712VnrsL3Wob3ZY2ezR2enR78/JE0y0jRjmGYMU0uaCDYBE2qOP3CAO991A/MHm8StABNrdFAycxaFKxxOQzihJ6dmaq2d9eEr/W6WVFei9OJVSBAYjNGsvrpKUch1gFwrJ3deeS+jYrwGNIzS44tTY3cuTrX+2Eyt9qlD+6ceXzo4fdJ7G3hXznXcdHKGc+e3WBxzLE1H5LlHBwFBFOKrMVelKnBUxghKwIjatcsRyjkQpcDocmtoLdLcfbzJy+d6/P43rqCV4cRNc2x0zvH1p54gSQqOHD7J0tIS+2bmWJiY5tDsPpam55kfn2aiPkaoIopcUWSeJMnIkpwszXHW4m2ZGlpXzatLac4gzuOcK00bnMNVvsOqSsGs9xSFUGTgkhLks8cmuePx48wdaKBN6WavfNkP8QKiNCow5cyL1mZiMj4+t9Ac31wZvDro5eneSJKnVvLMMbk4TndreB0g18I5PDvF9iBRSqlRr6MeB2bq5NLMH5toRH+jWY/eFUfm2IFD0/MzC63A2gKPZ2ayzqfeM8kNs0POXUo5ui8Ar4haMd5DkRR4W1K6ZQ+hXKmkKwZLeVWxQVLRq+rqLkSlmBkLuO1wnbNXMr76zSusr3Q5fHQfzQl47uVnWNvYZHJ8gTCqozTUoxrjjQYLkzMcnFvg6OJ+ji/t58DcPLPjUzTiFojBFZ6isLhKvu68rzrg5Qo3Vc19iHqj+6FzgrUem4GtljCbWHPHuw9x8s4FwkAjIoSBxmhVegEjFNZjTFnTiBMEMa2J+IaZ+UZrc3nw8rCfZ+yKGZEis6IVpGnB1L4WaT+/DpA/ymOdx3mvKefLY6C+ODl221gc/WUtHNNaqWFhmVsaV1NTTWxRIAre/8AkN7Y2mdIZYw2NqeTizjqsdbiiWlAj4BFMUN5xCoUayZB0+Xdo0FrvtqlHm36nxwz33jjG5fWCJ59b59LrG8zMTrKwOMbKxnlev3yWQZKT545hMsSLIwgNoQmoRRHNeoPpiXEWZ+c4NL+PI/sWmZucph416Pcz0ixD6dI0bjSxKyK7tLT3JcALV+6odznlLsNKn9ucqnHnYweZmW8gHiJtMEpRi8pIaJRmZFvsS8+IsvZCzNhYdGxssqaunGu/XORu1+EdweeZozEWS3dzyAf/3L2cfWr5OkD+KM7MRIvuIBnthQmBhtG6dXB67KOB0R8UwTgrar07UPsOzDA3N4bSEQszdd51skOY9rC5omFAuXLXhi0EjGFkvYkqu+fa6HLfnwNVDTO5it5SqMrhUKEqq3MTGERgomF49NZxBil8/dtbvPTcFUSE6ZkWhfS5cPkVltev4JwmGST0ejtkRcIwy8jzvDKGc4gXgjCg1awTBRHb7YT1zR7eOrS6ujS2HEIs0z7nHM6XuxZtDjav6qWKf5ra3+LovfvRYVDOsRCWRnfVnvc4DIiC8nLEkSodUCoqWJCw2QhP1Zpx59LZ7TMiu7vnq60lcOSOBeYOTXDmyesA+SM59TgiyXKl1K7OqlGPwumFqdYPh2FwC0qRWctOkrN/aYrJyQaN1hg37DOcmumVpmqpL5fJVB1xj8LEQUnLSElRqWpJjow2yVY7A/2etddKKXS5tLx0OoxC4npIkTvG6gF3HmuQForTFwece3WT5YttxMPkdB1RGZ3hNoMkYdAfMhwMKVxC7lN2eh1WNta5sr7GdqdDu9fnhTPnOX9llTSzKCCKKsJAlQNQzpcLdpwDV5TAsGm5F2RUVutAceT2eRZvmMIEZaRQunogQLnEB08tgHqkiEODMoowKAe8tFIYQ1irh4es57WNy91V9syOeOfFFZ6j9+7j9NevXAfIH8Vp1CJya0cOJTHQaNaixalm7ce00QvOe/pJTifJiCOFMR7vE5aX2xxfimj4FKmcC8UL1iv86CYrRVfVQhuq6FE+G3VVk1RkFoFRuztGnCtRoxVEY3V84bCFIw7gobumeHXZcebSgF53yMqFNltrA2qtmNZUhI8yEjUkSRPypCg1WApMaAhCg/WOzU6H15fX6ScpSkG9BkFYUs1eKD17XQkOW5Qvl4EUVwuSoGY4cvcCdz58gNZ4DCYA74kDXfZXvCc2mroBJ556VDYy4wjqsUKZai7eC0GgxuNGuNjZyZ7v76SdPSCRbFjI2W8uy9KJGXpbyXWA/GGfVj0myYqRbWgdaMyNN0/UTPAj1tqmEugOc7pJitiS5pyfafDsS122tgY8enMddveTezwKVw0vaVNRM0JlJD2KFoLR1R5kSrZH6WqtWbVyWVEqgFUYYlot8p0BtXrAK+s5//wLW3zmsX0sNCO2ejlbO0NWL3VJBhmNsRpjM3Xi6RBpCJnL6Ccpvd6QTrfPdr/P6tYOThc0xyKiCILQ796Rzpc0tLNQVCmVz8p1a7s3QGw48Y6D3P6+o8wuNggjgxKIlMKU5RShLpFktDDRMNRjRRwqagEERpioGbQWjAEQhdb7gjgKNy73ni8yu9tpByRuRNKYiK8D5I+EwZqfYbPT1wKhKgESL02Pv7NZCx+3ToxWqJ1BwiArO8jtbsYPvfcgd946xT/53GscPDDOiaUGUi358yJ4XRbaQRAQGI34cklnEJrdPB9dddcBY9TVApnR0prqnzggCPBpRtA0/Lf/2ypLMzV+4tEZ9tUiFsdqhAp6w5TtrRIo22t9bOEI64bmXExjLiKeM0RTmrAJ49Mxk9MNXCWVsVI2LJ1cBYdNq6gxuk1H5JpW3PDgEne+7witsaj8HCeECJER4kBo1IRWrdzc67zQiCq3SA1hUGq46gGIKk3ywqCKp9oc8ui1jYud10Qq1S+4SrMlRfbWGLB6W2mxnHOj6VEtYLRWYT00i1pjAg3WetJq8q2wMDMe88hNE9x/7wIXz23yK19o89CtM7QkBy0o5zAexCiiKEBVd57yV0dolapSLRGM0btrzvyI7/FlT8QiuCRH8jZxqPiXX+3x8usFf+tH53CJpdXU3LDYIEARe8/5tR6DIidZzbmw0uX1UBOP1WhM1GlMxHjr6e0kJMOcLLMUeYEguzajI3BIxTbtPSOd1OT+Jre98wCTzRAqKjeKINKO8YZBG2jGQj2CXqbpp0I/dwjQjMv1bvWg/DlDo/AGgnq5oySfkfHDxyd/orM2+8qFlzeeoZTGF96JG3YzxVvE4/ftlWLVItUdpprK46oWRRMHZ8ff78TfiqAK59VmP8GLRxR84F37+akPThDmKXedmuBbz29y9lKfB26dxOblDvTAmF3HdJzgM4/NXdmMqxZxUrFWAhWjU7aSy7mREkTGaJyUxggrXeHv/fo6n3psgVv3ReRVA7Jw7K6B7g4yisxR02UojKwgg4J0c0h3pUe62cd1U0gLVO5IM8gydtkpP6JvR6RB9QIw2lBrRpx4+AD7bpjCeYtRjlZNUavBWFMz1tSoAFIvZFLWXVkhmKCscbyFJPdYW6ZyDkVWUC4YFUWWeWzGuHWSbSz3nnWFr7otuz2S6xHkD/ts9QdIFT0oiZmWhoNeRCtBRh1nAaIo4JG7ZmiagmQwZFwF/MLHF/hv/uU6n3uqy4fvalAMC4LQob1CknL4iKq+8K5sFI5uwHJxZlnYa6UwWvBSPqm9BwKFiCeuBfzq725waDbioSMBaVIQRuWd02xppouANK+zMxwntW06vaK05NHlD1Wrah0EAnPVuqcmsJZBvjs/+8Zro40mrgfMTI3z8Y98lPe+7zFmDk4x8H26vTWyZAunt7DBDplrEwSWpjIMCkOgwFbr2/pDX7nGl2saQl2SFKJKe1VMKfWv1wOCMA+nZho/tP/o9G+fe3GtSzmBmCuFG5+O5eZ75/nG71y6DpA/rDNI890UC9BjtXBSid9HWayq3FFaeQocOzzOI3dMYYd9xBZktmBfS/PzH5jiV746ZHY25pEjMfkgJzClUDEvPB5f1RuyS+vqSszoqna1lzKaaF2pf1W5tjnU8Frb8NIlx1/8xBwGKU2qNdQisJHQrCmmWgGH51vk1vGa6zBMHF7K0ddqu3OZRklJ6SoF02FpMbqSQ1Qz1Jsh+/a3mF6oUasFzMw3mJqvc/jgEvfddZSD+yY5MnsvYVDDpQniHUk+ICl22B5eZid9mdS+zKDYISs0gwxaNUVkLGubBbmUtch4XaG0kOUW5xS5aJQIUaSpNQOC0EyOT9dvB75TMYsZKKuUEq2VXI8gf0jnoVMH+ebLl0DtLtzUC+PNfUZJS1UD2IV3eCnXPD9w6zTHpzR5z+J9+VTMcsfBcc1nHx3n739+nfpH5rl9UpMNHUo7rC2f2FpVM90jpkqz22WniiTiITQVg6VAe4+JDf/699Z5+M5pFqdCuu2cRj1AG0WROuox5HUYyw0LNsK5McTBxbUug8TuzpAL4LTCFoJSDYIwxBYDbr9nmkdPTHHgxikWlmrMzsbENbPLrGVWyIuCV1ae4JWVb3L/DTvcdehdCBrRinptjMjUmaztx7rbyPwK28mzLPeeZtO0KQqNVyFWoDcQlC+355pA02yUyoN+4hhkgvKaWiOQMNZBoxneHjeiyWyYZ0AkIra7ncmzT6z4INRSjipfB8h/1KOUKvN870cRJKiHZj+iWoqS18p9WaAvLozxox88hMkT0syX9joenCvp2ENNx594xwRffLJN88EJDjfLppgWR5G6suehyl0a5eyH2p3bHpkcFL7svCsliCu7z5ezgNc3HX/hsSa9boIWKPpFyX8qBUqIIxhrlEoZ52vlm2QUy5t9uv2sLLpV+b0ePXGSz/zUTzF3YJ6nX/6H3PDgBPOzNQLlEO/wVf8jtyUpUTjB5Q4lmtwVPHf+tzk4fYKFqRvJkx7OJqBiikr6X4uPcHjiBibiW3hx+V+wJeuoQmjUFLVQ090qKIaeUCtU9WeN2NNLod33hE2lmhMhYS28dXZf6/iVc9u7c+zeC8NBYat10nKtFu1vmyI9LSzDtNh1SlRKNY9Ot94rqAcKUN4Lm72ExDo++bGb+emPLWC327iiVOl6r3CVsWaWwXQjYHIi5neeG3BsISRwUhXkgolCMKaMGo49uqfySY0C68A5jTZl36TVCvhX3+xgRPHA8QbDxCICRimUUVg/ulNUtc65BH2gNLUoxBhNbh1ZajFBi/d/7BP80n/5t3nPhz/EydtuZ+FYm3r4Oo1AytRt5Ofr9O4q6Mx6MisUDkQ0w6xLXJvi8MLdGG0I4zGCqI6gMFqjjcK5gogp0s0a/WSFTPdIs9LwOqoZrC1rsVqsCQxEgaIZK2px+aRotALiSEVF7i9dOrtzhqsl2/cDhboOkP9IJ8kK9pgx1Cdb9aljs+Mfsc7fmOcebz2r3QFzcy3+s//kFo43+yS9FHEesVIxP1WXXBR5IUzXFK1Y8+vf2OHIYo1WFOAKwQkEoSGqhbs3s6AQX04Z+srEwbsy7YoC2PIB//DzW7zn5jrjdYOgCcIAgjJVcgKi93gc7g5llbL5KAowCLOLB/mJP/9X+ZO/+Bc4cuIoRgtaGSI1znD4DE4ScqfILGQOUitkeWlhWlQbbtXI97cMWpxYeojAxLtpotamlPXroHLthVo4wWC1QGrrSJBhtMZEmqgWkDlNUjFYUVBKcWqhUIsUJjI0p+Jwfqk22xwL25urw+0scSN7YHWt31dvG4BUNKuuCsH6VLM+vTRe/6Hc2iPWKxzCWrvPBz54nJ/56BzFynrpRFKU8xN5obCjBlvZ4aAohH2TEarV4Lee7bJ/MmCqFZT1SurIUwdaE0QGE+gqgpT6LO9ll+UKAsX/8rvrdPueTz82i6ZsqAHkqcNXw0Ruj4x+V/RoNDrQBAqO3HQHf+wX/jMe+8hHqdc0UuSl/EVBFEyxM1hjs3eWQabpZkIvLReL5lZhbYD4WqnIFY/RV72xDi3eT7Mxy2iyviQdRtKa8usHtRrFQOOKPnpiEwLFeN1gjMErg0eXaW6FOitlDRZUH5somNl/uHXnHffPHpudrxXnXu1ueCeaqxbB6vtFknozZmZhnEE3vQ6Qf99z++F51jrD0Z6PCKjPjjVm943VP5wWfskHmkI8vazgxz91lHfdPcVgq0+RFlhbPlU9umyujSQkUhafeeq4YamJatT419/Y4Ni+GtPNAGtHCtlKWm49eeb3yMDLaNKoGda7Bf/w327yJ35oP0uTAdmgQJyUAHNlOjbaMagArQFTKoHLvoXi0K2P8M4f+4scOXkKXIoSh1IGFTYQFFo8W/1tXlt/jjQPGKSaIgvJ0hibtjBumsn6fqK6Z2h7pYt8leMcnLuLido8IrvtTYo8K3W44hBXyn1NGLF+sU0/vEIYl7lVKVJURGGJ7NRCHIy67OXXCoKSFpZAN+rjtRNHjo3de+j4uFm5NFjpd/Kiet/Um8AhUEbqmflx2juDP5Iq5W0BkIXJJtu9VPs9MyBTzXh+rlH7cOb8vDWKNC8Ynwr5xc8cYrEJJo5I+yk2LSXghVdl57mSaPiqC+49JP2Mo3MRR45N8i+e2KAWKg4tNEpAVTVM6YlVdtWd7A6mMzYe8s2LlotrKZ95ZJrOdoYvhDwb9U4qMOlSNo8rIxC6bORoIywcvZe7PvxzTMzuQ5wtb+SoVYoKBcTloAwrqyu8uvIivaFhq60Z9EK8r75w2MPqDYZFtwS2VN1+FXLD0iNMNuZw2QBUaRDnrC0bpCiUNtgsRStPrz3kubOXWE83mZ8My1mRip0wSuOlLNanm5SgoRRujpi0XgEFpjk1V7vj2Knpg/VWnKxd6ncrJkt/v/d3OMhUYR0PnTjK5a32dRbr3/WUOwFV1YUuw3Y9CppK07JaxBitCgd3Hm9xZEoYbPcwUYAxBvxos5JU+5XK/sauAUPFTPW2BhyYavD+2yb4F19aJSHgoWNNbFGuWHOuHE4q6V9Via+EQSZ84Zltbl6MyLp52WGXUpqCLf+tSKmu1VqqTVLl/LeJLBMHTnH8HT9JrTVdRjYTokxU1j3Oo/D4osC7DNXXrK4EbOXbLEwFjE1pmg1PHFQdfwFfjIaoynQycwVJ1i8jlwmwaYLgsXk5zmvCCK0NOqzhvTDWmmRalvjCSxfY6Q65+2SNucmAtb5jKBAEmtwruqlhvO7LuRFtgHLicaah2BgIfWdqjYWxD9z3gfodR26d+dK3fufCP3v5ybXT1T0ZAAmQ28JZ57xvhEY55+R6BPn3OPumx9nsDpQTGa1vrp3aP3v3dCP6oV6Sx6KVSnLLxx8Z4+4lRTrMQTRZUuAyW9qKir7KRFVSdakm8hCFUZANC2ZqiqOLNT73zS0S67n56DhF7nan9RRXPz8MFOvW8M+/sM4P3TtFXJnMiSovvIhCKcEbtQtKcYrAaEwgNMbnueGdP0Nz6hDKRKighgoilKqezGhsOiDpdeh0+kSNKc6ufZMDB4fsnw9oNRRxNewUGUWkyyEvoWSYCkpbxOPz9zDXXMLaHHFFVZhr8iTB2RybpXjrUCogS1LWLl1g07dZ6Q7Y6JUp6lQ9ZKxmiANN7iF3ikFWulBGpqwRrS+/68iAQ6vUgta06mPxzZMHJ26c2dfIOuvDnWRQFHv1AEqQWhTK/ulJLm7uXAfIv+tZnBpjozPQ5RpnVQNqxxemHhqPgvf001w7rZUJHT/2nilm66VsAmUQUbhcqtpDVUCpEuGKicKrXbWuUO4hH69rjs2G/N5zHTqZ54bFBmKlAlfZM1FKUY81v/fdISvrAz5w53QlGpRdRxSjKYeYKrbLisIE1YirE4JonH33fBITjVWhLCxjnStKg+2kT7fdxquA8bmD9PoDNvtfZHK6XBoam1FTsxzeKkSwKLzWWCk1U6GJODX/IOPRNPlwQBDX0dqU7vai0QpsUZAnQ5y1FFlGb6fNUPVoJzsoHbDetbS7lthoZsajUuyjNYUvFwj9/9n7ryDLszu/D/wc8zfXpq3M8lVd1d6g0Rh4jMEMh9TQDZdkyAQVjF1pSW3E2tjYoKgHBh8YepEeNxT7QGlldkVR1GopR8qMIwfAwBAYAN1ogzblXfq89u+O24fzvzezC42ZwXBmhW71jcjoquqqm3nvPb/zc1+TKIHWEYKzgP+nIroClzagRZBZqs9vnBt89vL11a2qMPcOd+YLnaBIuPIhFHXDvD7htG8OulzbXmdvMv+4xPo9R7zGRiRrCKK9nKUkrAoRpPAOnOTq2S7nBtDUFucFpinReYoVMmpf+ZaaasNyeoNoOeZeLLFWAN4ENnqav/KlDf7+N454tF/xr355C6oGa+OYNEkFJs35zd99yNPbOakSNG1psxjmLiw/Fr/WWpKkAtuqvs3ClEfjd3mi+0WcNQhvou2CMVSzGcYYumtb5L0VpNRYW6ITQz+NyiuNjXW/RVCaQO1jYDjfblKlp5us0Bc9TFlRzYsW6i9wxmCMQ0rRUo9dpBabqD65nqxE+H7tIJMcjBzTouBgYriwlaEzRZopqgqaVuXFBofQEi0jEmBFBQIB08BAeRohVpNz/b/8+T9z/amsk/17r3/j/ldCiJBL6z3707mVYimOEc6tDbm0scLuaEo/S7h1MP44g3zQY1zUuBOf866Ssvf8hY1fyJX45GhaCu+9KIxAenjybIpxsSGvS7eEhTsXa3Lj4+E6Gam0iu5tbeRDPN7WQUcJXr424MaR4dVbc57czohGtoI0Tfn6HcuvfWef/82vnGOlI2lMWGKoln182wjLVJLEnhvjoJMpjja7yM2LXFx7AYSMkj5ANS9BKvob2+TdzrLkKqspk/qrpIkhBMhaqMukjP4+eElVC2ojqGvBbO4ZurM8kT5JMZ1hqppiPGU+mTAdj2nKmmo2wxrDbDyOuljW8+juXXqrPd46uocNIe5ERCwZq9pzeGwoKkeaSJJMceKfC7N7lvndwPhRg5SwspqQKolHkCnQBNHUnHNOro/2yu8Us/r0fFcsSMBCCHk0K9kZTYWWgovrA/YmBZvDLpc2VjmYFh9nkGWTbt3pPYhQSiZZonpCRBVMX9c01vOPvx1YH2i++GzeHsx48EObPYjT1VjGLGRGOfk9tGNgETcGjRMIa/nVlwb8xg9nfOXdgj/5fC8y8HTCV3/3Piup4EwmmRxalG6zRYuvELZd2mmBXhCtfKDT0VgCoyRj3ZVLo57gYXy4T9Lp0lvfRCX5Ygu01NEdj2Ejc3SUomwUk0LjjMQ2UJnApDBUtac2gcp4Xtq+yM69Byid0On1kCoOL8rZHKU0EJBa4xpLOZkShETrHOvq2BwEkMhItxWxLK1d4NFOzfHIcGYrZ7iaUhxa9l874sH3xiQ+p9vNOVKO/ErC4LkctZricXSHiEupYD7On17d7j55sDMet+c0IaKBDWBDCM567yZl7ZUQYX9WhFTL0Ek1947GH2eQDwBjLXjoeS9LNl6+vPUXBf7K8WROY+KK3AbBu7ueXi65uJEQFj3HMkMsSqt2mtVCNBZTeb+YzrdBtDSSbTzPXugy3Ozyj759zNZ6htea//B/uM+XX1zhma0MYyMEJJZTAtfW4zqVpDqOQaWUpKlEhsDYK0abQ9JOwvn+UyiRMzk+pigrVs+eJ8n6LCcJOBABgea9u9/BqSnzasDRpMNoKpnPJZOpoygd88LS1FEZJQsZr5z9NNprnK1RSlOXJcF7mqpkOhpTlXO8s1hrESHw1htv0dQlKlPcmN5GJotxtMACJkSBiI6EuvFMJ4bpoWH/uzOmbzb4OlBWJXVdIZzEHwv2b81RHehvdHBzyH1gbahyLaXZuTO7X5Z2AUtZeErqU7sT4U9EsoVvM9qwlzOvmo8zCCdTo0VpL1ItcyXYdEgSrUQkNjn8vODYef6/X4uYlM89nUeeQ4hgweBP1Vb+ZG0VTtNn2yBxLVMQ4h5gPGoYdjU/c33Ad3Y9N393h6rxfP6FNayN28fQ8kNoM1Caybb5j8s2IeP23pSWai3DK8mk2mV39B4bSjCZTtl64inSvNuS4OMCLzgXxea6KWvDKzycHONtznhaMp9XGGMwxuKloIaoxBgc5wbnGSYDUBLnMqyxWGMoZnOkEpTFLLpnAXVZsb97yHg25okrF7k3eYgzPjbf7fZdC2gQGAJeSILzVLWnCB51XtDvdejvdiiPaqqyYjyZ0O12Gcg+428UzN+q2O522J00OOH0sNS/+uXnLl0vC/tO49ybh7P6nXcfHt6alvWEqCpft1mlBozzwU3Lxqda0cnS8HEGaR/9TiaMXTrW5mu9/MJT2yv/ovP0K+Mw1saD7QO+aTAi4faBo9+RnF3V7Yj1FEgQCD42s6HFz/t2gRjaKAmn/257vzWNZ6uvuHpthb/3Pz5gOqn55ZfX6Emom0AQcVws2yylVSyvkha/VZae+cyAh8laTrXSwYWGd3du8+j+mLPbV9m+cAm8a/sOWHBsg3e4smA8GvPa7TeZlzXzSUlTGRpjCVKQpDmZThDW4Z3jqc3nONe9TF2bmCF9dPUNwSOkRKcpSmm8s9x87wbv3rjBE9cukScZr+28w155TFfJ9oKKfu1SQZIIBAolJNY4jPEYG2g6Ar0tGfZTeq5LnqVMJhNq5+jonNl+zd7OFKymmYMtg+7k2bk8Uc8Pu9nnLm6u/sK1syuf6SVqRQhZzOqmCeF9jtYt8TMEHwL9PKFq7PvwK6r98v9LChAfEMH7pdTo5qBz6frWyp/1iF5jPS54EFGEQUiJEIHKCH74sGF7PeH8hsYsxrScNNG+DQRaOm3sEcRyLBuWgIgTr7+idKxo2J87RKLo9xQ6ESRtYLgQECHyvxdAJCnj5zufmqhEImC82cd0UyrreefBIUUV+PKnf4lO1mtxWu3P5S2uaSgm4yi2bQJv3HuTg+I4CsypgEglSisEsdG3oUbrjBc2XqErui3LMtBUBc450iyPkqU+0NQV1hrefe8m/UGH89tb7I/2+c6jt6mFJc+SiF4mishFXa7onYL3CONbR3VoCk/ReOo+pCbQDx3SNGFv/xAQDAddjIPj2RxBQCtNnmUorTHWJd6HoUBc0UJ8br3f+Znz64OtVKvp0awsHtvCB2udqIw7HRtCnCozghBc3lrllevnub17/NEOkBCCDKdU3LeHvWvXt1f/tBB0q8aBELEkkjKCCYPHW4cTijsHlrVhwtZQRrhIONHYXQbMgiuyCIW2fwgtc3ARPIts0u0obh42fOnZFZ7bzqhVwo0ji/COzWGKXUoGCZJUEXxgPjPt2DdglORoq0/IE2aV5d7DkgsrT/LlT/58/IBVCs5EFuBkTFMUeOswTUOqcnaO97l9+B5StfpYPmCdpWkajG2ojWWYbvDMynP4xlPMZxhTxb6AqOVlTINss8ON924RguXi+S0SnbBfjrg5vR+bdC1awYf4emQQZEISWzdJkihUizFzztNUjqLxEXpyYAki7lxGkwl5ltHJMqrGMjHzKL/UOIQIQgREIESjH+cVPmxrKT+51sufy1J9sD8p9k6d5+XdI4SQUgqhlJYIIQJCCCnZXh+w2sv4Z//B/41/9+/9BvbHLOk/EgHSri0WSu6d7ZXuUxdXe3/KOJ9Xxi2hHVJKhFSEELDG4mpL5RTvPmwY5IrtttxaHN5Y5y/USU6WiJxq1gliKe0jREAoMAL+2btTrvYzKB1d6VkdJryzX3HvoKGTRVqtdRHpO5/ZVuM2fi+jJaPVDj5TTGaO3Z2SiyuX+MKLX4iwDW/xpqaYzGmKEmc93jR472jqCmUEt/beobB1VFT0rRavcZjGU9eWrfQ8l7oXKeYFQggW3vDGNDhnY3AQ+OGbb3NwuM+Vy+cZ9Pt4Bz/YeYfDZoRSkiCjaJxoFSSDD/QSRSYE1nq8iMtPLWgngyJqjmno1JJi3CCVoihKpvMCISSJThnPa8R5RVdrfGGjRZx1rQ+LF1IKQghKCXl+kKcvdrJkPC7qfRcriaT90kASAtp7r1oJbxFCEEXV4Fzg//5ffoWjWfXRziCPBUh+dWP4qbOrvV801qVVY7HOt2JuolU2jxWoNRZvPU5pbuwa8kRyfl0jaJcUtB8qccoUiKIMhPeTpJZU2wBSSI5LwxuPAp97ekhVGKomQOM5t57S7ylef1Dy+r0SrWCYKYz1lBHYi7HxyYphjulojsaO0ZGhLg2f/sTPMugO8M4xn5XMjg+J/lZxoemMpa5K+lmfe4/uc2/ygGADpnLUlaMqHVUVp1nXVq4zpIsxDd7FLDs+PkYlCm8dTVVx7/5D7t6/x9aZNbp5hpSRNvC7O29S0JB1E4SWLQ+fUxKnkVAljMfY9kIXEUIj24WrDYHESJg66lYEYjqdYb0nyzNUkNwbzeg83ScYT2oknSyN/BglSZSOnBUhkEKsrXTzl/udrDqYlg/aIFkatZ4aEy8nX4FIsptVDSH8eF7KRylAkkUGeXp79Utr3fyLReOUbT8wIaK3hZQSKWQUhQsOYw3eOIJMeG+vwdjA5c0UrVqUagtkXAZCeP8GPLQlVxCCLNf0BwmPJo57R4afeaJLOTdLUJF1kAnBmV4CWvLN96bc2i25dCan11V4B7aFzxfDjKqbMj52TEcNRTXnU89/gu2V88zHY4rpHO8cxtSterunrkrKomQ2n6Gs5L3771GUJdXcUs4M87mlKCzSa17cuIadNREWIyVKadI0I0kzTNNw48Ytbt6+w8bagLXVIVpqhJA8mu3xw+O7CBVIujpKqlYuCua1qhItGBktBI0B24pjSyXROuJ2lAQrPZ1KUc4NIcpZUtcVSZKSpgnT44q6J0nO5dTjElEHskSjpYx+9FrhQ0BrRZboXp6o5588u3b52vb6pe21/ta59cH5rZXe2TPD7rbzjrKxvg2WJVnrMRtF8ZEc854e8QJCS9k11qmyNgElhVQS61zrIShRWpO2XhpCSOqqoZrO8f0Ov/n6nKoJ/PlP92mVbU6CofUmxJ+Ma3WiSBKJUhJrIlHqh3fnyKpmflzjWjWSuMGM4MCm8VzIFZvPrnIwN7yxGyVHnz3X5fxqRt0EmDUUq56qdpGA5Wru7H6XK73zjPaOWmhKQpKmVMUM530sk4LD2oaVbMAFfZFv3v9u60UYS60k15y/fJZBOqCuSwgC5yxl6en1+njnuHnrDjfv3uPyxS02V1eig28IWGu5cfAAGwKpjL1TEIKgYqnoRITJKCCVAukDuRBMjadpop6WSkBqSSrBrQV8BStVytGsJs07NKahaWq6ec7ZlQH3HxRUgxx1JuXwfsVaA4M8jXMoH9BKYKxHKkmaqPVUyT876OQBKZ2UogxQWe+a0bz63lv39v+z1+/svQEULVp46dLLicfiRzKDyNMZ5NJa/7OdRH26bpzwPiy1ZUKIuwutVOuhIdoJUqCpoxd40knYHTvGZeDsWkI3jbASYBkwQsjoRpsIkkRiGk9RWozzCO95+1HFmbUO5wea4ANJOwWzITb/qBOJoNVc0dewe1Tz9XcmPBxbrm6kJB3NbpZxfGyp5obgIB2OKMclm/l5EFBVVewb6orZdIpzDts0zCYTJpMxofR8//Ufcu/OI2ZHM4pZRWUdn7z2PBf6m1jvse0SUEqJc46HDx/y1rvvcWZjlauXL0IIKKVI05RxPeeNo1tYDFke7dWkjEahUp3or3oXAZkSj3WexgWaxmOMX2ZTLyBLBCEHMXLY0iGkxjlDWcYs0s1zillNIwKqn9AkUI8qfOOjzbVz7U7KL8utOngxr4yYzmvlvc8SJXtpooeDTvbU1krvU9trg2EgTEfzquD95KzwUQ8QDWRCiN7FYecXtOCT1gdhfRDe++Uky3m/HKu61q5MSIWUClM3lLMakSbsTgIPjw1PnM/p52opNcop7w9rI/XWtIhgqQQiTfjOQ8O1jYSVllXXaj9HktKpniXgaUhR3S2unNvkqfPrNGjeelBgnWXayzmcNFSzBuE9a5uam/sPmM8tW72zpGlCURRxd+Edo6MjZtMpk9GIo8NDjvb2mR/OuXnvPo2pMc6xvrHJZ598CeUC0+mIpqlJ0g7OGd544y1u3L7NlcvnOX92myyL0HrXWtQ9nO1yt3iIkHHJqROFkmJpNedaPoz3gcp6bABT2cicbHs+2zgI8dKxDtJ+vGjCkaVpPEppTFPjvKPX7SI97B2OEV1FOsgo6gZdtgS1FuCpFgLjUrZMydZ8NQSKyjCflzjrhGnMer+T/MzZtcHPpEpV++Niz4dwymXyIxogbU2pgFRJ2TnbT39BED5hnMeDsG4x6vXREsDFIFFKLu8PlWict4QQmBcNvVwzKuHWbsNaX7M50Etoh2uXHu59e5DYCaluxpv3C54YCFKh8O3hkaINkgWK13vk6nW6T/9ZwvmfpXfl83S3nufiE69w7trLyP5V8s4ZhE+xNThrWd/STOeGG/t3GI8nbObrCARVOaeYF0zGY6aTCUf7++zt7PDo/iOCsUzKiuPZFJEovvyFL/DU5kXqqiZJNLUxWEtNGwcAAG4SSURBVGe4/2CHuw8fcuHcFhfObrUlpaeu4mH1wfPu8R0m9YQs0yQdHW0eZKtP3PZpUhDBi1LGcXZp8ZXFKrH0TfQutHZ2Efwpu5K0EpSjJlrkek9d16gkIc8yxpOSmanIBhk+VzTThp5MMdbRWIcSCh0ln5Y3ZppqdKKxAYKM3PaofFNLreVmN00/pYRYmVXNW8b55lSQLL7ERylAFkvSJISg13P9CsH9jHFeSKmEkLKFdyw4HXGsmiQJQsQNcFj2J9F9pyxKpFRUXvHDBzVKwtZQo3Uk/mgt8CJObha6vAGwCt56WPPs+S7BxMAMLWRchoAMAhECXmV0nvmLZOde4WhuWF3dYDKu+OGtPXYOChqf0QmbXF59mifPv8DTVz/B5vAKiRhijOfO8QPeefQuRTFHGSimc0bHRzy4e58Hd+9ztH9IXUSYiZCKB0dTzmyf51d/4cvIxmGdI0k7KKl5+GiXO/fvc2Zzjc31taUId1lVSBnodTrcH+3zxuFNJIGso0lyhZSyLVvbzCojGkEKgZbxdYqIq0cISS5yJALjLGVpsMZhTZQnCkoQDhvGswqtNUVZxAMvNc4GDkdTkn5KdzWndp60BC0kVWOwLqC0JgSPaRydNCXVUTCvshaVKM5urIAPyNaAVCeqs7HSf3p90GU8q25Xxlac6AYvs8lHSXp0YWZvDuf1t4TXf1nKcNY6R5Z3EF5yCtQWHWHrCNCTSkUYqk5wjUNpifeS2Wgab7t+zv/w3QkPDgy/8ukhg75qb8EozBbNMmPplOQZaZ6hQoTQCx99M0IIrTjDSY3lvUfiUQKKKqJjb924yXQ+o6kLqrJEJQkXLl7g3LlznD9/gatrV3n+TMq8HnEw3WH/4AH3771BWjnCvOJwb59yNsdZS9UYUmu56AKh0+cTn/gUaUiYzY/I8g6TyZTvvfoDyqbmmWuXEd4xGY8o5jOyPGunRRnjYs4747s0GHpZikzjaFe0xqEiyFYxPlKfl/qvAryK7lTOgpYS38joP2+iCLgzHlt7agfBGA6Pp3Q6OU0TmEyP6NYt0roMTPdmdAcpejWlLh2ZVfiqpjIWqTTDboKWkqppUFaSaol2AS0DtjHoFoHgg0cKRZKo7vb64F97WQj7tddv/fvW+aVNw6In+dBnkF6qFlvQBSYnKaybJIJUifCStTZ1Np5i62KmUFItexAhIuxj4SfoXLxdRYtzqssaZx1JlrEzsexPLRsDzUo/KptYExlzWRplfwpree9RwZMrGmfixlgubKMJrWqKAFtjyUi3n0MKwdG04OzWOod7e9y7c4eqLOI2W0iKqmb/4JA79+5w58499vaPsI3g/Pplrp57lqtXnqM72CTrrtHpDglSMS9LrhYFv1QYfsYEXhCa7nRO5Rxj75jMC3749jtUpuHiuS163Q4uePI8RyuFkgpjapRU/ODRDW6MH5IoRZprZHTUQYmohaVV7AOcjzuKWGIJlIz9SLSDA+MMjTXUxsX3VMqo7lIamtJS7VccHoyYFxVFVVGWNUEoqrqmKhtqZ+kMUlSuabwnTAyJiqPeumlofOwn80TTyRLuHkyomoZUa4qiQUtF09jo1Ctlu3j0upMlF5NE39k7nt1plQKWTiof+gDZ7KXUNgh3CvIcQMytv93RMksEzxvrtBDgfDz8WictQzDWrFEoLX6Yoq3YAnF5JRXYJqJhdaI4nAduPKjIU8lGR7bNOxGkpxU7xzXv3ZvzzGaGc9Ca4UbeSQuIXCCQm/kxfnCV/voW01lJmmas9HLeefttiiISfpTWpHm+LAeNtYzHEx7t7vLOeze59/AhZVkxGKxy+YnrnL9ynStPPc+Vp17k4pVrdC8/gVjpo/spopnjb9yiePCI7+/s4rKE82fPkCUJ1jqyLEUnKWmaYq2l1+9yb7LP63s346UhQGcK61uWjGwVGIVYIHCWxCgh4lpWtj2KbnckoXUTUjL6IDrjaWqLLRzmoGJ0PKVpDM5apBSoJKWpG8ra4BLJcLMbS7ME9icT3NySKYXzESFQ1AapE4racDiecPncKoNOjlIK42w0QFKyNSRVJEqhlRiCWN0bF19tjJ1zEiQfjQwyj6C007pKKoBcG2b7n76+8sxkZi7MyiYqlwgRgXtCtEILJzfcYi24XA62Ep5SicgBbxyJVtigeG+npm48G4OEPJNYF4NrVnusE1zbypA6en04F1ozzTjmFQiEkIjQ0JQz0jNPo7Ocadlw+fw2R7uPuHf/AYF2IZYkaKVboKVAKrU06SzLkkePdrl37wG379xjVhT0+j02zpxBb52l2NxmfuU65qnn8NefwZ6/gKhKZg8eIM9skHVzCGCdJc9yTNO0blqKUTnnd268zriYIojv2wKfteC5+xC1h72PCGDZ0gYW06xA7NcWzr9SnKT6sNi8tyWUOWqYzYpWgSXEUbpKaGpDURt0N6G/1qE2lsZYiqbmwcMRoQlkUraU6HgDGevRItDNcjppiiQ+X5IkS9E+1S6NG+M4nlRqbzT/jdraw1N7Ef+hD5B547h4ZdCWO34ZIEKQTUrrvvD8qnj58uAzjw7rZDIz7aw+oLVGtbgsCEv4uFRyidJdrFq10i1y1lMVNVpK0JobezX3jwxnV1OGXc1goDmcGX7nrQlSxKBJs2jAs0AL+3Cy+1dKEub71CGhf/Y6x9OS/qDHRi8hPf4BrqkorcQT0bhKtZKgS1JXq9+rNCHEpnpv/4Dbd+6zf3iMUopMR+iMTHPkcA21dRGeeAYxXKesG6qmRGuBEoqqamLgCsG9w11++63vMi5nKCHQWpJmCbI9iM4FbIx4QmMRJqKUXWscFLflsi2xTvC07bwkBscSFBpQc5gdzCnKMu5RAKVUHNs6R2EdOtfk/RTnY9ZpiorJqOJoVFM1ZpkVyrKmrhu8hzSJkqrzsiII2UKHFnYVgdrGkqusmuJgVv7jsjEHp5aH/iMxxfrin7rEOz84wkco7gLlkIVAp3u+1/+znzvzpafW897tvYrjSY2UCztnuVwaWmtBCJTWS0901fqjRxyRijemc9RVHRd3WcKk8rxzv8S6wNaKZq/03DsyJCIwKjylid7oq8OkRfwuloZxXCwI1KNHiN45kuEZ5mXDhYsXUMUuW+aHdJSlcoKaFKUSdJIgpEAKuSRshVZ/dKFwj4DJdMb9B4/YOxqR5106WYZupUG1VuTrZ+hvnkdlQ5xzVOUcgsf7wO74iK+89T3GxRQtFZ4QDXjyJO56PK1lRDuqbdxyOejkiXRrtMD2ywO5oBQvlnqC9uf1EI48o70JTRPV7r3zUV1FROxcaQNpR9NbyXDOY4yLRLDSUNeBeW0ZlzWdU3sRrSRa6/j3bHxtjfUY51FKLbPc0WTOg72x9zL5+qysbrUB0nxkAuTSk6vUlRPTcb1YGKZC0JNK9P7cv/7ynzn/7Mbnz8xK+eT5rhjPHbtHNd7bBUC7dYHySKValkbEaUXEKMtbe/HBOmcp5w22duR5ShMEt/drRlNLEeDqVsbnrwzY6GlWu6p9xkhLXWz0LXFMjBf4pqScHTO4+AmmlWO4MkTqLqO7rzMUY9Y7FaOupRIerEIJfVLPc/LzBeKyLLS3r9IJUiqGgyHrZzZIk4SFKgjBkyQJg+EaurOOQ2OaktuP7vHNd97guJjG9yIEhFaoVJN3dOwpTmP8WydfRGuaImW7DW0t6Jxf/pzB+yjwHURbasZ/EpqA2XMcHYyx1kaUgwvI1v7OWkftA71+Sm81w1qHaQcuxlhsE/1YlBAM84RUa7Ruf9Y22/oWxWDtyS4MYDwtuHFnl/msEs773y2sffUjFSDPvXKGd149ZHJcC+/8Qpu3C/T+/F959tOf+fKlvz5ybk0fleJ8Jnjm6oDjqeXefhkFmtsSK7RvoPNxguUWrL02Jcft+6KsAWNdNM+sIzRcacWjkeO923MyBFoItGyJQibQmOhBIqXA2MhrCD60UqUCVxzjSeluP8HhaM7lq1cYj6YUu++gQ8CImofMGJe7WO9IZI4SEdEaFluY9vBLIZFKo5OE9bV1nrhyif6gDyr2EFIIgvM465ACet2cwcoGqrvBuAnsHB5QFhPAI5RAJ5okWVwe8TUQoilqlGcNNC7C9X0r1yJbCH1j28HHwvjU0xqdhjbDBEIJ5sBweDSKW3jjEYudRVueWilYWc/Ju3rZOxI8trE0TRQaXuto1rud5dAlTRKUjA28sabd2cTrylpP1cSx8tHxDO/9vHTuv2oCN4kU3o9GgDz/M1vceONQWBtkCEvIe+/iEyvbf+GvPvO/VRmfOi6dINVslIZuIri8mWMd3NtrF2miDQIRyw+IS6hUa4SAJEnQKiEs+pEQ8D5OdWzjKOY1xrq4YdaKnf2G9x4VjIuIck11u20Oob0RPbY9OIuyAwLVeIfuxlVMskLeyegN1nj0zvfwzQzVOEZBUncEdZhi/BRnmkhtVelyDyFaxLLSirzT49z2Oba2NpFJ7F8Q7fabgGkMVV1TFBVNYxgO+lw8f4VzW5fBC6bzMcY30ZexFapGRgZk9GlcKMMEjHHxrmnVG20T4SkiRAKWiFQMvAutd0oMLus8buKZ7ZZMZyXOeyrjFto+sYkn4JVi80wXlYmlw1fTmPaSCmgE63lCoiMuLEt0vNRCvD4i36VdBre9nJSCsjYcjwt84E4Z+HsOjloQowHchzpA/sRffpJi0rD/cC6t9dHjUtBXWgz+xb/+wp/Zujr8K/PC5VpKXK5ZE4FsVpNqwVPneyRac3u3oigNAof3jtZ5YOlMGw+DWJYKUkkWlm4R0hVvuLKxUdJURE+MxsPD44Yb+zWjmW3h3vHfRQ2usNTYijgmgbcV1eSQwYVnOZoZLl26yGRScnz/bbAWUxkOHfH5Tcno6BGjyQ7zYoREkaY5WqcRVp4kDAerbJ/ZZjDsxYFAWy6GdgrlrWU+L7l15x7vvXuDg8MDrDOsr61z7eqzXLr4DHnWY16MKao5iMi6xBOZfTbqdCknoDQIG73UnQs01kURvhBo2o35YkdtbZwIunaPZA8sxw8nlHUd+40W1GhDXLRaQCSK9a1O9PNusVZNY2gaS9NA6qDXXgxSqRgoIu66vA8YZ1vURKwaFv3bwWjKvKwRUny1hF8LMONEXujDnUGuv7DO268eiOm4kYQoGgf0PveLl579wp+6/H+d1VwwNpCogFaeqZesTiq09ygtuHa2w7m1nPsHNYeTCAiMwSGX8PE0TdvJjY99ymLy1YLjTqNXrQs0VUNZNgTn4qH0kt2x4eajmkdHDUXtCS0UQ4poKqpUNKPxQdBMDhCqQ37mGh7B+UtXuPfOa5TTA7pCUk8r9qvIn7DGUc1mTMb7HB3ep5iPkTIhSzt0un3W1jZYX1ul28+Wt34kSUZnHhE8ZVHy8NEuR4cH7O/tMBpPmM7nNNawurLGtSvPsr1xmaKcMZ0fxbJLqOUkSgC+dvjKYBsbEQa0N7+J0A9v/VL1wjXxz5xbsBw97sgy2p9SVw2FcTTWx1hq7YprIOtohuvZUhzcGNtmEIepQRnQIaBb6oFSCp3o5ecW2kwS5Zp8i8sL7B1O8M41Xsr/uvDhd9vssQiQD+8eJO8ljA5KRoeV9HYp2NBXiVz5C//r5//lzlr+y0VlVaYFWjskgVkj0bVlzdoIDwG211Iun+lwNLccTgzBt+YyUsSNezsalK1rp2ulOYWU6HYjH0LUpQoL24QQaBpHWRua2kaBag+TuePBseH2YcXOuGHeBLSEPI2Tl7qKB2d+vMvgzFXmPmd9c50QFAe3XicERw7MJxXTxkVcTWPxddTMHY+OODh8yGSyT/Ce1dUtVoYrDAad5fh68ToWlgSmrnm0u8fOgwfUdUWWRwu22WzOaHRMVRac2z7Pi899mn6+RjGfUZRTrDUoIfDWY52LJYzzuLYRdk3MEraJCF5TW2ztKIuIwXImUFUGU1o49oyOxhhjKI3HtBpkC/qfAforKb2VNE7PvMc0DXVjqZtAU0bdgFRCr5PRyTskSVQhM9ZGVQ8h37fElKItr0Yz8OFhI/j/NCHcabkizYd+UahTFRtz62U4lT0+++WLzz7zma2/FqTYVkKQpwEtPbaJB/TYBbYDJK2MZwDWBpqXrgzwXnB7r6JuLIg45l2QSUKIPJLFgtG1CGHvPS64JapViXYOJuKHZrynbixVY5ckKw9M6sDDo4Z7Rw37kwbrPFkSR85VMaMpJqxefIHKCq5cf4pHd95hevAAHwSrWjB0nnpSMi+beOO2NNcQLEU5ZmfnDrs7d1lZOcPFi+dQSYTdJUkS9wsuwmzwntF4ysMH9zFNjWjLM63jbqUoSg4ODwgBLpx7ggtbT9HvrDObT5hOjyIq13lsu/Dz1mPqSBGuqxrfOGxtqauGuoqQkro0lGVD0xiSWuInlqPjMcZ4Sh+WUNpkAQAVsLqZo5PIZzfGLPueqvCY1mslEdDN1FJ7YMEE9YSl4r4P7SY9zTgczZjNS4LgrTKE/8rDISc6W+5DDTXRiSS4ILxnkT163Z4e/sq/8tS/NNjq/pIIaKkCQgaMCdR1oCoDM+ORDjasW2j64GwgUZLLZ3I6nYRHBzVFafHOsZBSEICxZrkbscYuJ16LsmxxO4fWeyNLE5RWeBGFqxvnKBtLYxy+7Wmshb2J4c2HM8aFp6g9soWhJHkXvXqBXr9Pkubcf/v7LVfCk0rBUAnWtKSLIJeSTAkaH1pufGAyPebgcI8nrlxnY/NMi8wXdDoZxpjYLwmoy5o7d+8ynU1i6SgkOo1LwUXzPxqP2NvbxVnH5YtP8syTr2Aax/HRHmUxwzUG25jI+ajNj/zeNhZTG3wrTmcaQ1nVDMmZjwomkznGB6pTkAjVnlKZSFY3W0688/h2X1PXjmIecPbk72eyHacvlOTb3ZBoiW6JVggRS+adozHWOucFv1EF/imx/1g06OFDHSDbF/tMjpvIJBRxcvWZX7rw/IufP/d/UkptREewWGcGH/BWUFceU3t2C0/fBrqta+2CyyETyaUzOU+c7XI0s+wc1VHQILhIkHLx8CZJgtYt3JtAmqTtNMpHIJiMCic+RPPNbhrBc0pKPGCcozKOeWOpGkfVbnPrGvZnlocjx96kZv/Bbc5dfpqQ9rl45SqHuzvs338H4yKM2zqPCJ6uEqwowXqi6Kr4PWxbpozGR0wmY1549kXybo+iqul2cqQUWGvjos45Hu7ssb+709brsddSWi8NPaWUUQjOGo6PDnHW8cSV57lw7imc9Tx69JC6KmNGNRZrbDRIdR5vLcF7nD3586Y2KC/ZSAfs7B5RVgbbXt3qFMHHAp2BpjfUbXnl2hGyY1ZYquKEkxOzTiBN2ia9xQ8lSdyLxMGLIk0086Lh+HiGCGFmhfjPG3izLa/qjwRYcW0zF9NRrQgkCLpCit7P/vkn/sKZ8/0/masg0tQLG+KEyZmArQNVFaHVo7ll3jjOeI8moHWc7CwsnNeHKdfO9TAOdo4b6toRWv1buWjg2y2xd4EsS/HEhVZM7/G5rI8b3rqxgCDXimGWMOhkSKUIASrnadravbKupah6qgb2jwumkzFPPvsC3cGQNO/zzuvfpqpmrdaVb5dxblmW9JRgLdXkWmJadt3h0RHD/irXrz1DZRzOB1aHPcqqjvAPApPpnAf37mOtaS0QOAkQKd9nDBRCYDabMR4dk+U9rl97ifPnrjKdTJmOj/DORnLUQiDc+6WT11JgonZsDzZwdeDR/nFc+rUnU57iYTgBvYEmyU5GtcEHytoym4Zo3X2KNZcrSbeTRcE51cLyW8dgKQRJizPbORozLSqk4N0q8J852G+zR30K7s6HuQcR1dzGxWCgs7Hd3f7sn7zyVzud5Ik8CwScmFQBa8A2AVNBVbmI2aodoyYwVIKe9UjZGnLaNtsEGPY018916Waah6OG8dziTeTThBAieLGFxUfEarvrWI4VIwZJt6Sq2jiqxkaIdYB+lnB22KffyaOCCtFHo7SOyjpKa2ms42Bvj7Nnt3nq2WfROue9Ozu8c+M9miCiV0hLI45moq3YXYjWDGfyhNUsJVWB+eSIy9eeZ31jk9G0YH11sAwyKQXOOt58+01Gx0fLPYFu8V+x1DqhTwpoNXsDxXzOdDJha+sCL7/8BZTK2Nl9gLVNdLxtVb9F1LHCu8hTT2TK+eEGj/aOmcyjYF116qDLtlNWiaA7iNz3BfixahyTqad5zOFAAx0NeZ6S5xmJ1m2JFeH7Eb0dCXK7h5NgrQteiP+uhF9vs0exGO9+6Cm3dWFlCEGHEIUarjy1eu2pT239y2kq15XyorFQmxZO3cQgsXXUh/ImUDaeIxvYDp6k3XBHtmH05zA2ZpZzaxlXt7oIBAcTQ1HZ1noqjjizNO4daIXRIC4Dnff0uj16vR7eR4KWDVH9vLZxwjUpa1QIbHQ7nF0ZsNrJSJTE+kDtPFeuPcnnvvTzbGxusbqywttv3+DW7dvcvXePygjmVtKIFBNkFEYwniYqD+JDbM62eh1eOrdGD8ODUvPccy9RVNHhbNDLqeomIoYF3Lh1ix+89Sqz+ZSqrqIMqUpQWqN10mYS8b4gUSpmmPlsBgieeeYlNjfOcXB4yHR6vETwhtBOuVwgeMnZwRpF0fDgYBQvpTZ7LMB0C0pfry/odCPezPmIo6obTzVvP4bHeNeZFGRpXBgmiY7wGimXEBwCTOYFh6OZUPDIIP6jBm6cGu/aj0SA8H4trO7LP3fh5Y2Lg1/JUtGLKnzRLs2YKLPj2tmhMz4urqxnZgKNhW250MhdwDai1KhxoERgpaO4sJmTJpKDmaUo45RLtDuFhSjEAtNlXVyCaZ2ytbnOxtqAYb9LkqY01uJCBCtaH6gay7SomFUNksBKNwaJEZo/9ct/hu0zF9nd2efV773K3Tt3uHX7PR7t7VI1jsYFjBNYmWBQ1CSUVlA2AuNbQKT3pFqSJJpX7+zzzPOfoD9cYVZUbG2sUtd1ywQEYyzvvPs2R+ND5sWU8fiYo6MDitmY4H2UGcpieUibMReCF1onWGspy4rt7Ys8//wrzIuaR3uPCO0wI4R4AXVkBxkU9/eO4wb+VFe8ENgNQJbBcE212sih7d885Txgan5EYkECHRktqRdZQ7Xw/OUUyweORjOqyoQg5D8u4L9pl4PzBbzk9DN/KAPkC3/6CvffGwsECTGDdF/6/Pmf6292fiHLZGKtj3AGC8ZEF2TnwNvIXTDWU5YW7zzHNtAVsCYCiY43lfdELw/RWhNoQSdTbK9nbPRSbIBZ4Wga15Y17SKq/YqLqEBRGw5GUybTAiUk/TxjfdBjpZehZQwuFwK1D5TOUVQN46KmqBuscxzsHfDw3h32dx+yu/eQh4/ucv/RfWprabynsrHRn5Y189pGpGqQGCepnab0irkTTBrPqHTceHTEYGWN5557gem8YtCP4tFlXaNa0tONGzfY29uJcoTe45uKYjJif/chBzsPmU3GOGtIdEKSpG2fIpFShiRJRZbmEAQbG2d44flPMpuWPNq5j/cG70BYifKandGcphWXXgTHInsIINUwWJPoVC5Pv3WeqgiUs3YAyQcEiJLkeULajqqVikc89oexud89muK9v+eU/LuV8++2wfEj2eNDGyAXrq+wc2cqQwjpIkBe+dL5X97eyj+rdBDBBbyXGBPNbYIHY2KzHjOIpyqj1pTzMGo857SgryO8NDaC7Y3XqrsLKeh2NP1MsdZL6GaSaeWYlXECFUF7Dmvdsh+gxSGVxjIpSo6mM6ZlxG11tGbYSVnt5uRJrJVNCJgWryVCoJiNOR4dcnC4x9HokMl0EjFgvF/QyYe4ka9MHCMX1lE6T2U9lYVpA6O5w0dSPC+/8jMInVAUNWc2ViiKavmcR0cj7tx8B+ns+7Q6pffYumJ0fMj+zn32dh4wm03KNO/czfJc6yTNtFIiSVK6nS6rwyFntze4cP4Ko/GUew/uEGqPb2BSRw2xsFg2PNZ75BK6K5IkF1EqSYBxgXLmKWcsWZmPlxMRxh3IUkWaZku1v7AYMPjA0XjGdF6VUqv/bOr8r4XA9NRy0D2elz6UATI9rqlLq4KPJVba0Suf+vnzvzxcy16wLjL3rANnAqaJwEBnIrTB+4j/Mda3G13PuHKReJWp9mY/0a+yrT2bXzrTRl+PYSehnyuMcxSNixvdxmNaMJ5xC5ptfNct8feNc8wbw7SsKapILU2kZJAl9FNNJ1HY4Gl8iLdpCwtfHNRw6iCdDpTTpUnrkbHMMqWxlMZROc/heMyVy1e4fPUao1nB2c212NM1cTMePNx4522q6fh9FM3TB9F5z7yu6v3D/V87ONz9u2VVfU/rpM7zTjfL8m6n05FnNtfoDTpsrK/gjOLWzTscHx5TuZP30n9AcKQCsr4g60uMjxdGbTzzSYh9x48JjqUYr2iVLFtar1QyllpSMpuX7BxOgkf+eoX49xvnDjjBXn10lBXr0i6ycQp0usN09aXPbf/J4WryVGNDNKvx0QKsbjxxlRFVSESAuvLYFgtkjaOpLDuTCuUDZ3ON1Av+NEvug/UhBloICBkRur1OQr+j6aQghccBpRNU7mRkuXjXF4WtO/V71zbss9owqRoa45CtWHbZ3rCc+tTEB/z38S/5Y/58gR+rmwatFZ/9zGdplVkZDrrMi3qpaXX79m0ePri7DLrTpls2XrX7Fv4LD/9JWZX39nYf3rh758Y3Dw52v93v9c1wuHppY2Mtz/KUXr/LbDJj99E+9x/dj8rxp4JjIYkpiQc764PqRQnT2geaBqopmGpZhX1gabW8KAIkIpAkik6eoxO9nJ7tjWfMquZhEPL/Mbf2zba0+pHJ1Yc+QNqMuTTMOXt5cOaplzd/tT/QF62NN7g30dXJtvN4FcCbKH9ZVbZFkvqWFxFLrruHc1a0ZLubLE+mb0sl32aSJXW2dZjKU02mNVIE+qnCSUk38SQ6LLOHa+f5pwWXlkGyyC4ty3CxF1lkitPBJT7gNv+gg/J4wPDYdrqYz/nES59guLrJtCg5e2adqq7xLSxhNJ5y87238da0yvGtnhIUFr7h4D8M8F8Du8AUKJ2z5Wh0dHDnzo23lFQHmxvrlzfObKxmaUI5n/Hee7e4d+8mzpr39RuLMg4BaTcGhyc4G9ivK363noG3dPl9JKoWz5kCiRSkWUKStgSxEJhXFfvjeeG8/3uF978WYNIGyOm9R/ioBUgK5Oeurpx74vn1v5hmcqMxcZ/hTSQqteZSeBvwNsKunfVY41uL50BdW5qqYTar+OGjKRdXOpzpJW0v0fI1FtI9rcy/cZEA5UOc8Uup6HVSauPpa8cwg9VO/Brm0E0g0TH1t/0wi6c9/SG/T9bvsf8XPuDG5LHAEadKMfEBZYgmavqmacLLn/wU03nN2kqPTp4zL6so1ePgxs33mI0OIWYM28B7Dv4jB/8B8F1g1JYnxSn8kjfG2Fu33r1z5syGe+aZ5z/T6XZ0sJYbN27zzo0fYmyz+HlCuzEXXuBFykj2OHaBW7bhv20q/tNmzj/C83Xg3fb7yPa/+eNnV5waa6Y6BohsQYkBOBjNmNfmqzX8XRcDe/ZYY/6BDjofBeE4keYqV0r0bctsM60fuV6OXlsgXSt96axfnrimjuC5pjb4dj/xP759yEq2zWbnBKzoFv4XxP/a1s+jsZ7KeLwkCs4R5X+CDWgREMKT6RgkPkR/EeMDpYHSnnzVlmVtHh7rK04HiORHg0rywf/udKCcLteE97zx+g+YHO2T99bZ2T/micvnUEoRgmZ7e4uLl69y9+5Nb53ds/BPHfw3wFuPBcXpxla2hw1A3bt35/WimI9XVle3dJKQpnouhHgnwLqALdXauHuog+C3heDXqzm7zrDnLY/askcA94AfAP8YuAD0gT8v4E8H6H7gReLBWYfTMROXVcOkaN4zgf/EwsNTkJIfW1p9VAIkIiC8DzI471vFAOdiKSRdJP8H38qJCJYQCCUC5bzGVi2wrjY461ACbh3P+X9/f4d/+aUtzvWS5UTLhkh2WtBMjQtt2RU5Dy4IjkvHRhZaYWxOKLEhLsy0jCVAR8dm1QYwHhoH8zoGSm2hacWu3WNZZpFh5I8ps8KpTzw8Vn6dDqjdR4947dXv8vlf+Bc4HM24csnT73UYTwz9QY+nnnk+fO/173/t8HDvH4QYGLttSTI/xZdwQsQuLYQgTp2pdG9vd2c8Pr577vyFrcFwQK/Xm3fy7n8+L6ZHwBbwrINVD+8Fzz/yFbunDu2iMvWnkt+UCAfpAHcDHAj4i8BmSzA8KTGlaM1NI/zneFpMjQ9/z8D3OLE+aAAv3++B9IH9zYc5ONrlj7cuhKZpR7nRT6PNGp6o22Q93oZWbicKKZvGYpoIy27qpi27IJGB++M5f/+1Xd47qpa1lWr3yC7EsWPTOMrSRtJO46grs8RHeUIr6BwxSBHmHrFIxgdMq27u235JmBaSrGAlgYGOv85VbF4fzyTuVA/jTo1LT/csp/udxxv9uqr4na9/DVvPkVJweDRhOOgjpEInCdeuPhFe/sTPvN4Gx7g9WIuRaC2EsFIq1+32/Mpw1QshTrUqmBs3b+4fHR2+1jQ1Uio6nU7e7/YN8G6AXzfw7xj4mw7+PR832WNiXzA59evpqd8v/mwE3Af+nwH+VoDvtC3h8vJYvNIQAkVZ+qo2X2ngN8NJ9msAKyNjMISPcAaJL0JL5T3SNgHbeKxpudAtP0EGlqUW7ejUGod1IbLbmogwbV0f48THw62Dgn9Q7/Gnrq/ziXM9FjurhQuUbOWBrHFMS4vxgU4iEbSI07DYy4flHJ4F285B1cA4SOildFc7kCi6vYQ0161oSMDZaJtmTfxZTWWwjacuG2wZy0XXcsP9j7lBxAeUXkoIbt+8ya0b73L1mU+wfzjm7Jk1OnlGaS1ra6vy+hNPvvLd763/d8ejo4UneXPqhg9JkgRa5+AQQhBC+BCCA0wIoS5m0x1rbE0nz/JuF51m/lSJVpxqkO3pWcUH9ATiFDyrOfVzfA0YB/jrwM+KaOAlFkomLnjKyrxZuvAfOtg5BUY0RNF3MiCTMPMfvQBZltXOhmBtvDOrxsflXov3jqPTNoOYqORRlpb53FKVhqZqsO3SQrXudWEhPC1gd17x91/b5eZolT/x5CorqaIIjrqJcBXj4u6jMp7dmaW0nvWexDVR61cKEemxLuBCFGkuqoDxAnmmzxOfOsvGhQGD1Q5JJklTudQLhkgQapoYzI3x1I0jGE9dGKppzeyg4HinYHJQMp/U1KVdomh5rFlfsPQCUWm+ms3c17/+teLaU893R/NGzeYlaytDqrKi1+tw+dKlZ555+oUr3/xnX72zeDopZVg8ALK8w9HRwfLbCSFcGyT2eHR81xgzTpJka3N9LSglF+XNvA2U+lQyDI8lgccD5HSytKey1e8Cj4AvB3gZ+EwgXHbW0Rh/f1q7f7+C19vvueB6eC0I7UCSuf/oZpAAhMZ46xxGtdYEzrR9R8sV9y3jrjEOUzvqMlJA66qhqprlhrll0EYlk5RWIA0Cjq/fPuLRpOaXn1pjNZHMaxeOptVoVtlR2dhQOd8kUs0qG559MAv9SRl7DOMDtXPYVmHQeqgdnL22wou/dIVLT6/R6SpsgETJpZIHoXVpEooQ0hbCEi3cnPOtCIJDOI+tLOP9ksO9kv1HMw7uTxjvF7gqZkXHyeuKm2mBgqkjfPOtt9+6NT7e/9NZf/PS/tGE61fPo7QiZFnYWFsbXLl89aXvfPcb37DWqlP7ylim1dE6+vTn0eZJC9i3337r0Zd+9hdHSp/f6nQ7SZqmvVMHe5GVHg+IH6l4rkG4tcQFv29Kvniuu8B/4eC/qwKvKBv+VROcbQL/cOLDV0/tO2oiQdHnWobCeOa/X3XyEcggIKTwFoFsORI2ZoMQQPoQ19rEhr2qbLz9TSytnDUtiy5+9MuNuYgQh9DaV6ECt0Yz/uHbhq31HolKbh88LP/jyazZCQFpfJAO+anGuBdsOIFmf9AjyRTXXznLhWsrdHOJVAIlJFnrXeF8DOYTDVwJIsJn+ikk2jOZG+pa0ZEZPjHkWrB2vsfl59eZHtfs3p3w8N0jDh/MKOcRXJllAmpIpaKTp828Md9/tLPz9v07t5549uWtC0fHU3n5gqXX6zJujOgPesmFcxe/cPnyE//o5s13pxGe5RdEv/CX/tJf4h/+w3+4fF1rq6uMxmMfFY5CeOutN3eKYn4zSZKn+4O+TNNUnw4EIURI08zXdf3jpqwA3P7Rz/zxFsy0h7808E8nnleDDzZECZ/F/6tP7W3DzPg/WPn+YYuKyxdWuftg9L4/K6ZNWZV+nAoZnWLbDZ1osSKhtLFzbBzzeUMxrWiKBtcYvInjoijhEydNJ+62py0LIMskIdUcCYWt3LfuHdTfxnkHqG4nuzLM1BcbU3acD7/na+iv5px9YoiWCyMeQRDQ+EAiFYmK6oW6Fa7zBLQG4SLxPlGgB4qpimUjMmoAay3pDWBtNWV1o8P5qys8ujvlwbtHjHdmNMagcwFVQEm5mqf66mxavvob/+Q3vvbEU8+9ZETn7NHxhK3NNSaTGVkn49y57WufePGTL9y8+e7NxV5PCCHW19eFtTacGOhAnucwHoe2xHLj8WReFPPdsih9J8/16srqZmzzhAohyBCCcM6J36dPfry3Co/NK8LJgh8NaB+b+dP/b9E3eRVnNu/b5v9ejw/VFKvfT3n11/7PC7n9ZarfuTspppPmTt20u4526+1soLGxPzC1pSwMVdFQFU3sPRqz9LoTCNRCObDlMCwFGNryK80USZagE3VsSvtdnJ8BdaI1W+uDX1RKPul/n+AAWD3TJe9Gxb/GhRaj5bEtjEUQFVWkFGSpZpgnDFJNJxEgAvMqMC+jnYKQIDOJyiVJIpEiQrwHg4T1M13OP7nO9U9f4IUvXebCE+tkgwQvA855lWr1XKpl/uoPfvDu7qP773TyhP3DMVIKut0OUmtWh4OVc9vnXhoMhr12MasidjGIK1euvv8wqcW7hRdCWOd9tb+/d2i9c2vra3J9bX2b93uXK2uN+HEQkt+vtD410FtmkFPlVHlqX2OklE4KEXQcS+P/gN/oQxEgWaq5uD5A1XD1C/8uSsvTCVmGJoj62AhbxwWhCCyXgo31VEBRO6bjknJe4xsDLgonyCgRhSOSlKxvYes+YL1fguOSRNLpZKhU+2D99yd7xZuLD2ZrY+XqoNv5+eBD8nuv/+PAvreaR7clwNHaGbTWArUN2CBJEkU30/RSTSeNquVSx2DQmUQrSSLjf9NEkaXRXUkiSGSCVoo8TVgZZpzZ6rN6YYVLz21z8ZktOms5dd0EQjiXarVmrZ1845u/8zXhmtlkXjKZzllbGSCUptfvi60zWz/77DPPXwVSIUQaQlCz2YzBYPj+TF4Wwcf0u2ykHz64f6Ou63LjzLp45pmn1pVUnTZAslOB8ocJEj4A5rbIJLWIX0aAVUr51eEwbK6thZ/0G/zUQ00ubA6pG0uWKGrnxKxshHN+AePpAN3t1e6VDZn8ZQPbIVNxhFrH0a2rHfNZTTGtmU9LyqLG1TFAFnTZVhz9ZFfQNrOtyzBCQreTkHUzpNbT2VH99453ix8CQQohLp3d+HNayS/N5wVlZYT7ccHRrsEvPrPB9uU+QgqSTuQseBQ2SHyIm/h+quhojVYsFQIDUYZzIVztCK1WfPwhlVQoIZcccuej7q+SOsrgKEmap3gXmOxMUUIkNoTvNNbfLor59BMvvfRc2l3dxnuxubHKvKjw3gc8vdFo9O6bP3z9rZNDGPxXv/qV8Hf/7n/AdDoBoCyr0xevAhLvXPWJF1/+0ur6xtlE6oG19tY77759P0R3Wfd7wTz+sEMbCSGJUJagWvPWqq4pqiqW3x+FAPnVLzzf8okFs7JhWjWiNk74EFQbHLmIsIP+hfX+J9fT9H/F2GSzWS0aGdN90zhMYymnFbNJRTmvcY0h2LgQVFIse40TaZgF86z91CSkqaTXyZCJxlRh//jB/L821h8ADAfdzUvnzvwVY+z5uq4pqkbYxz4DISHtCJSCXj/jyVe2GGx2SDIFiaRyEFRrliMFmZIkQpCoyPQLrai29S4KbiOWpWCsNQWylTgL7RLZuMWiUkTp/xDwUoKIlg9HD6Z4Y5FK3qyMe31eFMVT1651L1y8/Ml5bdX2mTWEEBHEaK1qjJ2/9fbr/6yqqsUW2gkhvNaasizbJn0Da63w3i/2FmoyGTdbm1urgeRTG2fOrF06d+GlK5cuj7736nffcwtR4vdPp/5o4BWLd0mIf64I/KkNkJ//xBPc2x/x8GAiamOlc16GFsbQZo4+MAQ6F9cGnzwz6P5CKmWSN4GdByOmRXT2LavYlFfzGtsYhIuQcinF8oDR6lqFcGLBtiitIpswIU0TRKI53imaamK+4uPsXV45v/Xp9ZXBr1aNya0xopxX2HByhSJhsJowHCZkPcVn/sRVzl9fAyXQucIpBTIaTko8eRIPeLAubuODiyagInaXiyAOBBIpCF60ZWErFlFZfBMIrajCYuggZJQhciGKTxdHlShHhZRCFqX1vx1CqAVh9sILL75s0BvdLGVjfYXxZCqUQMxn825RVd+9c+fWo0X5JITwWZaHv/E3/gZf+cpvs7aywXQ2RixuGRDOOfHejfduBi9dY8Kz65sb25cvXHrhiavXJu/eeOfmvJgbfhTo/M+dRvxjCAM+SgFyaXOF33nzLrOyFmVtpPMnWYM4yOkDvQsbg0ufuLL1JzaHnS/1O8k1rbXMswRlA++8s8/uoynVvMYZgzURaxVcpNKqVhRNyCj5Ewit69HCSyLe/EmionlOqjENjPbLR975/zbAVCvVefrahT+nlXrFGCO9Nbi6RIZA2lqN9bY6nH1iyMpqj2c/tc21l85ggkAlEhJJ0lUMsgQRAlJLOjqStrSSJEqSKB3NLgPLqVogLJ2ZnA/Y2kZDGRcItScYG1HIAoL1JCoKrmmpkULGidncMro/AiHulNb/FtA8ePRo+skXXzy7cebcC8ZYuX1mlbqxWGsJxufT2fz+G2++9loIoWkDxJ4/fy4kScqbb77BbD7h0tnLVE0lvPPLnqKqq+bO7RtvzSfFvbpxF89sb12/ePHip597+rluMZ+9ev/h/eKPI5P8UTx+KgNkpZszrxpRNVacyho50AP6w2629YVnLvzScxc2/nfbq72/1MnSJ5VWWifRHUprhbee0ahgPGqo5zZyP1r1jIXhfdwOLgxlWiZiO9INxOBQkUWERzHarawt7K8F+O0Afntz7fzFs2f+JQHbPniCMxAMeQJZKgh5wvUvXmL76jrbl1Y4/8waTqso+JBIso4izTTdTJOmEq2iKmA/VfQSHfcVWpMovSQzeRE38jGDxN7EFQ7RAG3Q0cJcHAIRYpkqiX6JmgTrHE1pOb4zIoSwWzn/6yHELbM1zey55178rAlquDroMRj0mM4KJChjjN3Zffitw6PDGSc+fmFlZSVsbW3x4MEDtje2MdZQN/UCaBOAYKyxDx7deW9ydPTGdFp1fRAXz2xufXFj42zv/oN73xyNj8vHMsnHAfLjAySjiJlDnsocPSEYfPKJsy9+5trZv7a90vvXlBTPGOuShfhn9PGT7bhRkioZ3aAqh2kiMHBx+FtYVMRTtYzBBXpWCEh0VAn3Itbxs2NDNTWviciJOATClQvbL2yuDf+c964jBAhnEAI6nRStFL0rQ5784gVW1zO6qwmiq3Gt4LNKBWiFyhRpKskTwSDTZFqwkiUMs5ykNcXMdbbEiWnZlkwCUtla50iJSGJmcG3QS9WWXkSrZRoIFmofJ32uthzcGeEac79x/LoPYS6E8IeHh5NPfuITTw/XzjwNIWydWRfzeYl3lrps8qPx6Ps3br57XwhhQwi2aRp3+/atcP36de7cucPG6gbW2Qjtj5qgpzMDx+PD3du33vnqdDx/fT4v0qZq+ju7D/7pweH+6PG/+1OB8/tpDJBHx7MFsHBBiupcP7d+8eWrW7+6mqf/ojXuCWOsXDgqL8zrg41zHSGglyWsD3poKegmc/YmJVUTheSUBqdB5CDbyVCrzt/K/4CQsTFuGqjmnmDYk0L8fRPC3QWcqZOnl5WSQ6XjBCkkCtnNSbRmUtWc++xZVs9myNpjhEQkKkJ4lcCKSCsdKEEnEaymCV2tsN6QhOi9nqoM52PX7UP8SZWQaCuRwZOnAh8kTkdRHO1BWNFOwgJCBKYzi68CMghcDQEZzTZ9iGUeovKxZDIhBF9WlXvnnTd/6+zFJ744nui1uq7p97vUZRlWV1c2t89sv5IkybeMMQmgvPey2+36o6OjAPDunXfYWFmn1+mHEIKv6nKB21q0BUnVVPV3X/36f//eu69/bX11I3l08PDRj4OZ/M/9+Knbg/yrP/8S1nkRThQo026qh89dWP/Xz64P/y8qTa8LKWVALt1Qo+K3paqa2Ge0uCctBZ1OzoWtda5tr3Kml5EKgTNQlzCfwmwWqOsWet6CfayDooTpKDAbBXwdGOrkIMvym4sPUSslU60uKymUkhLdmmN2OzlpkjC82OXs00M6SRwlJ5lG6zhFki0BO0kEyIDSkGqLEk1svNvzlCSSNIk7kSxNkEouxSSEh6ISeCdb1ySJFLHCUiFg6nbLHgJNaSkbzzzAvDEYa3HGoWM51pzSlaiB+p/+9j/59tHB7qvzsuZ4NGVl2Eeliej3u+rqlSd+bmPjzEZ7cSUhBFnXtVjI6wAMBuvMiil5ngWt9ellXtUu8EqgmRST/dsPb92rm7o5NfL9OEB+r8fGsLsYtS6UXJJ+np7f2x/94rt3djoqSUKn11kyx7xtYeAmLi1Eu/nzQJYqenlKJ89YHfa5vLXK5fUeq6lEA9ZCWUIxg3IWg6YqoJhCOQ00FSgfG59csNlN9Ln2QxRZqjudPD0npQqJVkEJ0EqQZQnWOFauD+ivJGCiN0XSegOmSqC1INFRHUXpaBYjorM0iW51nVKFktBJFUm7REzTBKl09CyJJibtJkScbNnaxWcEbUKuJZ1BAgq8jGJ1TW1p5k17kYhYmZ1asu3tHxw/un/7WzK44vBoilKKPM/RecbqysrVVz756ZcXl5cAFUIQBwcHyx/h9v33KKuCEAKD/iAoqbySyp/+Hm2w1AJxGuoeftqyyE9dgHz73QeoiCVZLpv6eXq2MX7j5t0dXnvrlpgWNYlWqNbSLLR6uNZ5ZvOK2azAGosSgl6qybVCS0maJGys9Ll0Zsj5YcaKlugQx6euAVPGL9fEP1NETmciIAQ31MJfECKitvrd/Fw3zy5DEFIivLNRpDmAS6B3NkMR8Ca6HuWpIFOCXEdJU9+yHisrKKxnagNKJ2SJIE2iXXPAtRz2gAuWxnmklNEnUSZUVlIYQdUyEKWM2UTI6Fglk4g40EkMSOmjJ0hdNpjSYhoXEBSnttBLyMbXv/61r5tqdvd4Omc0njIc9JFKhdWVYf/Ja099fjgc9oGkHaKohw8f/shnORqPODo+4v/wmb9KInUAvBTSSSGtEMIIIYyQwiilnFLKK6UWGefjAPlxj2+8fX9BV10EiM5TfRZBJqTg4e4+3339Xe7tHiG0JM9TklSRphGsB1FC01jbGkV6ZPBkKjrPKiEZdLqc3Vjlypkhl1Y7bPcyhpkmaTVqE3EyNtMnyB8tCStCRixSniZbSoo1SfxBfSsgXVUNMhNsb2YkxqOkQMnIT1fCk4hAqlsgZVvTKcAEycg46hDwwqO0J9FEwU0Rs4zzxJ5EplRBM3eSiQVD7EWU1CAUPkSwY7Rai6lWK4H00fMvBocNwTjvPXfCCS9jAUM3r77+g9u3brz91eC92zsY0e91SNJMdHs9ubV55oXLF6+ebQcoifd+qSPxwgsv/Mhn+nd/9++3mE7I0yykOvGpTrxAeO+9d85551xwzi1oJh8HyO+zC10sQhWgMyUvSSES1d6QVV1z+/4OP7z1iIPxDIEgUQqlYx+QpgnJQnLSWJQIdBJFquWyFEm0pt+LgXLt3AbPXNjkybOrbPYyciWWIKFFwvc+SGtcZxG4vW5nPQRknHFFeLsgymPKNDDIJNrFPihRAiUCCQElBDoRZLlqHZMiX10hIUQslhASj4cWYhIVVOLGfW4F4yYwd2CFBBXfk+AlZRO57cZBYyIezbe7HQEIHY1jbGWAIEKgaby7FUIwj2WRCihff/37Xw22Gh+N50sXXJ2lrAyHTzz11LMvn+pDVAhB5nnOG2+8weOHvLI1pvWlDyH8njWUc+7jAPmD7UKXNEtZNnbqQnCyFSMOLWfi8HjM27cf8dadHQ7GBc7FQMkT3YL1NJ08Xcq/5Iki0RIRaElJ0ZIsyzIG/R7b66v0el1q9yMirSGEYK114/aKk6lWAx+89C1GagEv9j6g0ziOlS4g2wVfogRhLmnG8f8pFXuHplVyF0KQqoROkpGqFC0UBI+SGudhWjVMCsf+pOFwVlNVDmGhEyQqSFwVmE094xomBgorqKzAWUFwAu9jMDrTNu8+BO/8bgjc54R8dLoXaX7wg1fffXT/zteaxnA0ntLvd5FaM1wZDp64cu0XzpzZXmlBhzqEIIUQ8t/8G//m7/nJlk1FbWpq0+CD56f98dOM5hUt3kgNe/lGv5sriAY2csG8CwFrLUejCe/efciDvWOM95goJ4KWilTrpZGKFJApRZrEciwGW2Qb0vLWtRA4YrOvxbJrFAFq4/1eC4YK1jrjvQ/OOuG9b/WX4rg462lEiGjiRISlcvzRjZrDBxNc646rZcSD1c7TOIcLnkyn9LMhipTgU9a6z9NUXXb2x+wfTNnbn3J0WDAfV1QzQzGzzGaO0glqBPM6MC8C5dwxq6EuA1UTJ3MIiSksMoCrrfA+3Dc+7PF+OusySA6PR8f37tz4al0Vk73DEVmW0ut26XQ7bG5uvnD16rXzQCKESIQQ0lorbt2+JfgIPfRPb2zELexKJ+uaun5R56nOOwnHo3lsAkRchAkfoRd17bn7cJ+DowmDQY+N1R6qm8davz3wCkWeK5R11MYShIyaWSGm9gCUdYMgGtMTTn4SD7tNWJLbvLG2DiEEY2zwQYiWRodWkqyjER6EjTwSlYKZew5vTBm+oAhCkLRLShsnvVSNxSQptYCd6YRxUTKd1zj/VeraRCSA9cgQEE5ggo9U4jbhRl/EWFJ55/EmYBR4oQnGgg14L2hmBus99bzxzvm3jA8jTjjeiyXdcuT79W9+7XvPvfjKm6NJ7/PTecHKyoDpZBI2N9a3n7r+9Ge/+91/9rZzLgMq55z9jd/4DV555ZWPA+T/Xw8Ppm5sPZvNo1mL0hR1Q9Iqd/tTVZlznvGk4HhSsrs/Zn21z7mtVXqdhDyPHImyNnjvSLWKASYlWkfyUlFWlGWNWsjztF0oUpAP8/G0sqOoCEEI3mlvnZA6WqkRFoLX0Q8xuFaRUUe8cHXHU48rks4aeJZb8iBiQ103gWPrmLg5VVW1rrUS64uoFGkD0kMiBF5GI57G+VN+5e2y1Hk8ARKJ8JET7x24xuFqRzOt8HiawoycC2967xcaV6eFE5a88Vu37+w8vHfrn/bXtj/5aOcwf/r6JZI0pdPp6CevPfXF1dX1f3x4uD9flFmj0cjPZrPwUQkQ+dMdG/hJWc8c4QfOOjMZFdja0e10qJGULvbzslUjUQqkEggCRdlwe+eI7759n7fv7HM4KaiMJdGRSKR1JBspdYKQraroywHQIJA6NvpKSzavrA7Wt3u9xbxeEFxRRE2pLNGcHFHBfGyiV3grx4MRTB84lJQkaR6hH0oQJPQSgfDQVIHjSc20tDROYK3AWZA+MlIXyPCFwSXOI32UHfItycu3Mke+cUjnUd5HH/UQCEJQHMxbmrHDNf5hE/jhKUzVaen/0zTW+qtf++3fKWbjO/vHE0KA4cpA5J1crK+uXX/lk5+6sphmtc26cM7xi7/4Sx8HyB9zl94KoAc7a+xrQsp6AV+fTUoSBGmaUAdB7Vr/jxZoSIvEDQHmdcPNR0d86827fPPNO7z74IDKeob9HmurQ/IsQxA9B4uqjvKiLZAxXXCtOwn9zbyb5aq3CFzrw9wY421rp4yQLfZIIISkiloQMRPNFeWoZnWtj8gkQQqU9XS1JJUySvbLqONUWxP1vAgEEfuSECL8RUpQKqCFI5WgZIS869Ye2ZpoXS0h6mVZj/fRF8SWhvlRgVcCZ7wzlXuj9n73VLbwQFBSBvE+IXea9268e+/R/Vtfr+vG7R0eh7W1FWSS0B/0z1y7+uTn0jTtthMtLYQQm5ub4uMM8scZHSfYHQu4UWFuNS5824MlRL+/qmzAOFKlsFJSIqNcZ8sJX+pNh8Wo0bEzmvPanV1+5827vHbzEUfTAq0jndU7R1U3NCF67yXtiFhKwerZPjKRztZ2YYbklJS2m2ehKmuMsUtbshA89dxSlNFIx3vwE8m6lKz0NTILpIlkQRo2LloqKBno5To67gJCSULL0U1STZJF9G+3o+l3NSv9lFQLMhn7maTlz+PbCV0L2w8+YK2nGlVMJyW1sZjKFbVzvxNCWKByl8y+Jy9dIM8yTr3/VVnVxZuvf/8359PRzqPdI6GVotPt0O120u0z21+6evX6mcXIF1Cj0Ui89tqr/M2/+Tc/7kH+uGKkVekzgJnX5iBV2X/a63Su2aK6snCirRuHsJ4k06SdlNI4jLHoVkPqNLN/oQ8VfGBW1rz1YJ+bO0esr/RY73dwxlDVbTniPHk7Kuit5KyeG6CEQEXCvwOorRvlWdIUVdMtq5o8T0FI6sbg54Ji5pA9ReoFem4RpaGWgo7MUFohEnXikWEDnVTSyVodYCfoJxnWN2Ra0c/7TMojamMwVuCtpqc3eTjeY17McR58iJ4n0ewnnOxAvMdVjtH+FGMMKleYxr1WNu71U1nCCSFClDdK6HQ6VE0TQgjLMus73/lnNz7zhV949Xi4dqFqDBsba8wmU7a3t68+/eQzT7/zzlv3hBBJCEFZa91kMgl5noePM8gf8eNXP/MMT53bWNhS+AX8YdjrNGc3B6rby2hO+W5YHyhKQ1kaOlqSpIpCCspTYxnP+4E+UVkQaut4cDjhjbt73Nwb4ZynI6IerhTRqqh/povKFN75uqnsfHHblrXZMy4cZolmPi+pjUOqBGsNxaRk9KiIS8DSUdwfU5R1hLl7gUwksu2BtJJ0OimDTkI/lax0UjaHXTZXepxb77Mx1GRJRT8XDDuabgZK18zsEQ6LlSKqy7cwfdvCSXS0lsU1nqP7x8yOZlExRYiitv5/qp3baw+/jRAQQi9LgEDZ2AgFPnn/m/F0Orrz3g+/Vlfl+NHOAb1ehyTLQr/fX7t88crP93q9fgihtTb0MoRA09iPS6w/rhJLS/m+iUrdNEejUTFRCPJEYsSJWGwDFNZxPG9orEfLqDNlxfs70Me9/RYDZR8CrtXmTYjq8AgYnslJhxrnHd76nemkXgiR2ca4UWPdCCGCFITxeA4iAgltYzl6UFDXHv/IMHk4p7KWujDU90rMToWb20jGUYI0V+SJpJNAPxOsdhXrgy5PbD3DSrdDomryxLPWG3B+5RzdFBwTgqhIFSRdFbU0WzdXb33ElxnPZHfK6MEoNu5CEBD3S2Pe4uTti+5wIYLK3r55CyEEidKhFaR2i7f5K1/9J9+YjQ7ffLh7hPeBXr8nsjwTly9d+fTWmbMLSZ/WMErIb37zG+LjAPljeDyxvYKJ06SlCdO8cftF1dwezWukEPSUwItTnzBx9Dk3nsJEXwjNiVbmaY7y4yKwp23KQoAgBL21lM5aClKE4IOZzZrvzwszXgRIUdXjujG7UgiRagXe0VhPEBrrHUcPZ0yOGqoDg2siC7CcFxx+9YB7/+Ahd/7LB9z/H3Y4/v4Ie9CQKEmqBYMMVvKETiLpZppBp0eeaQKecXnIpNqLIEYRYnDIQKJDFHfwcRysIjYGM28o9uf4xqGkQCpJgAeT/WLhv2EAJ5Uk66fLhq2YT7l8+TJZmrF4a4UQ9cOdR3sP7938RlmU9mg0YXtrgyTPWV0Zbn/y5U89f7oPcc6Kb37zG/xb/9aHuw/5qWMUvv3wkJu7o4Uz0AKPlTTWybVBZ2VWm88WzqeOaBovxSk9yVMrxtPmEo9bkXk+WAg2ygZC0k9YOZOjtCbJEqESOd7fmf+n46PqVnvzOh+CWB/2tofd/DPOB+29p6obgpCURYlznjTRdBqFKR2NsxS1ieNgC/W4od5vmN+cM7k9Y+VKn5X1lEQKulmHEGqMHdPYgsqUWGewzmKcwdgTgTzTtGaltcc0ngzopwLbOMZ7BbP9Od46Ap6smxoX+J92b4++RivmLARGaemH6x2Oj4rle/Hcs88xGo2IsqDLt1ArQXntyWd+Rups8+L5M0xmc1xj0qa27ubt9749n8+KNqBcnue+aWru3r33cQb5I9+lCxBChBb5YQEzqZq3EOLIBWgCFC6ioPoyagCdPvyP+/s9biZzOmgWmUS12+1BV6NaqHgQgaqybx8dlO+eLjdCCE1Rmzd84DBR0UVViQhb0TqlKmqO780JBjytZnCrPoKML8q0EP3po4L3fvMR03lDjWVmJthQU9uG2tnYhLdCwcFHxRUZIqclYAnOIaxD+oAxjqbxlLOGyeEMUzWEEPsSpNgbH5RfJywNcKyQ0g82OjyuCGmtpSiLcEq/ygDNq699//ajB3e/vn84cvOiYm1thazTERtr689sbmxdOLUTkfP5XH7jG99kZbjycYD8UT/iuHbh1BETwry2D9Ou/vX+atYgo95R7Vv5ehFRc+qxgHhcQx/eLw/+/qCMeCqVRMUTHzxBitAY/8Ni1kxOlSUGMEeTYkfo9EGSxuY20TraSMvo0T49LqIpj4As0S1oMirBaaVaYphAKcXkVsGNrx6yc2PC0cGMsqpxQiBUilex52p8dMU1JqBDn1TmKNkKybmArQzFzHBwWHG0P6eYFFhn6CZd8rxDY/yrBw8m753q7QIhhGrWhKNH0/e9F9/69reWqFxxaljSWFfcufXON+fTyd7u3jHra6ukecbG5vr5p64/9Ym2zFo060IgRKKTj8e8fzzN+snSUAiC8b781JfPvfvsyxv2je8fpq99Y5fxQYkDqnASAMljZdbjDrHisQyzMJ9ofCCVAqmjAILQEqFVY0pzw1l/OjgEYA5H04N51by3Ouh8SmutpIob9cYYpNZUjaNpYjOeak0vD6RttvFCUBuDJ0Qehwvc/q0d7n9d0FvJGGxm9FY6SCXw0kPqUQOJ6EpCpglaEEiQUiCCwzceV3ts5SjmFdOjAlMavA8kOsMqO5+M5l83lT1Nbw3eB8pp84Hvf9M0i4/hfYvDr3zlt1597sVPfefuozN/7vLFLdHt9egPh51rV6//3Nra+v90HGs1DUjnnT8aHYWPA+SPqdI63UYIgdjc7lw9d7mfb17qh2vPronvfXWHd14/pJydfMjuA0qoD3J9PR0ogVi2ZVIg24mQTDVJNzGitOWpQ7V4OgPMH+4dfSVLzv6K0NmadJZEJyRJSq/rwFq895H9KAS9LMU6t4SzKCmx1mKCJU8SskSjhcSMPXuHc3DTOJqVAq0lLgRIQK9o8vU56XqG7VlqC1XpKOaG+axhclwwPZiRNtFHaFqM8Kn64eSgfPMDEAs/CbLBAs1kNh+/89YPvrJx7vIvHo2m/e2tDabjMZcvXX7h0oXLl4+Pj/YWLV2r9C74KRRk+FA26Y+d4dMavP3BSrb+2S+f/9V8kF4PQjBcScWlayusb/Voak9dO5z1yyuPDyivOPVphceaew10c8lgo0dQEtFJ6K12y/mk+c3Dh9MbnLI7XvwTJWRYXxl8PsDZqCai8d61Ep+CQb4Qa4sSoMs9jJCkbdm1EAcWRMnUJFGkWeSl6zRu6EW0v8I2HjN1FLsls/szigcV9qDBTCzTcclkUnJ0MCarBJfyIT2ZkniJaqgzL5sQuFdZd8SJX4b/CT8TBSR1XTTPPfvCp/Lu4NzVy2c5Hk2C8CIdj6cPX3/z1e8LIRb9mvuwBsdPe4AsVE0WgnG955/d/MSLn9/6V3wqB0IIYW0UmO6tZJy7usL2lTWSXGNtwDYR6iF+TJBwagS8aNozoNdPGW6s0AhHNszpDvJielT9k6OH09ucWB8vNmC6bkyzttI/lyXJZ4y1CCmFVhG6ErwnOMfe4ZSjacnxtGRcNBSloWgcRdW04GCxFM9WUiBlhKy4ECdV1nlsi9wVLWZLqqh00tUpfuZQc0vfCHpOMkRzaThkpZvTyRJ6aUovSVcHnfSVbpaavUnxrRDCTxog4qRVE8l4NGouXboyGK5tffbM5rpSSopiXihnXfjhO29+az6fTflRGP3HAfJHmD0WiopdoPfU+a1rP/9zl/+N/sXkeSeFpFVftzYqm7gAKtcMN7usnOmSpQphoglmaHmyQXxwfSEXXwI6Q43PAzLTdIdd0k4iiuPy+wcPpz88tVxbeoO3TLpJnqXPSynPeO+lDyClQiuBrWusiSBGax2NtdTGUlQN07JmWjYUtY0+Jo3F+WhIE9rgQAiUkigtEeLEzDlJoio8xKwlpAQfyKVmkGTLV6eEINEqIpel0FVj7z8czb8aQig4Zcj5h8kiq8NBOHvh6ucGg+HapYvbjMYTgvWdnd2dN+7eu3379K7l4wD54ymtcmCwuTbY+vIr1/6Nc8/0/ozaENo4lnwLZyMw0QUwFqrGg5AkWpJpgZaWLA90Opo8kUgZD6BoR8mcau6VFvTXEtI8IclSdDclzZQe3Z80o/3imyHuDt5n5QWIaVHOJvPiVXAuSeVTApGGFhNrqwrvIxNycbiXBz0slpMC6wLzqmZWNoxnMXCqxlLVMaAq45aK9FFoG4y11HUTRattVH/3eIyPF7aWJ8xLY524tXO0d/tg/P+aG3uHxxxr/4AH+LRhrt7ZeVQ/9+xzW3lv9aUrF7dlYwymaTrzWXH8vVd/9zu83/f8Qxkg+qc0QBZi1V2g+7OvXP+VlWHyK/SDQsrlxti7QPTfjE21p0XBBo+UCtsqN2lik0wI5DYSiLwFY330AAlRZifJFDpXCBUbY0nENCV58qlUyycq6x+cqsxOi63NZ0V109jmP17dkhdl5n55NrEoE6JZT5R1YGFX5rzDB49oPT1i3+KXQwUXAmVtmJcN3rfKKFpGkxwVJYyimmRAikAnS1sJ1bAs1bz37WRDLY2CtlZ75qA0hrLJ2svnNFnqD9JIv69Zr5tm9sYPvvc75y49+Wf3DkZbw+GA425HXLxw4ZUnrj557uatdyft51h/WBt19VMaHMvS6sWnLj79/NUz/0ed+Mu96wlWgTciig+4gLExQIwL1E0E7VkXvcvL0kQ7AOtQQkSeeGtxIFRUNMxzRZJD1pWkHY3SGp0o0AqdKPq9NATvxeHD6bca49/lRBrHPbaHFM4Fl3eT4/Wz3edIw4aZN7jKxpKpRRMuLNakUEiihm6M3ZYUJYjMyZaLEkJc2rngaaxlVlSMiznTecnxvGBeN8wrS1HbZa/iQ0DLOE6OJqARo9XNk/6gk26UtX1vVpsjfrwv+R90sphMJ6P6madfeG64tnH96uWzYTyeChFC7+Dw4M33brzznhDifXyTjwPkj6Yxz4De1sbwzM9/+qm/qrz7ss6Dzp9IMB5cHZ1svY9o3ujnEb0IGxOwLmLdvfFID946ZEveXvBFpIh2ZQuAn2gF17IkRWgV/Tu0otvNmE9qv39v8m1j/Zuc4CPtYwESADE6rkZSy2J1o/uimoV+PTcIEZasxYVmpGyFG0RLWhFtvSeVOrE38B4pF2WYb0uzEKV7XIP3jhAkzniqxjArGyZFzaSsmFeWsrHL9yd+fyk6ibq42ssvVNb/YFrWk8eC5CedaOmyqsL62po+c/biz126eC5pefr68OBg8v3XvvutU+/XT6W06IcpQJbZQwh6QPdf+LmX/syFzeFfK6ezfpIJsgsai8DbQGgDxPso8Y8UmNrTNC7+PoBsD4aPTKqoXkKIJYs48QURMiqcKCXRaYpuuRpZljLod8XhzkSUR/Wd2vpvhxAWo167fIrHXsN4VB3kXsqOk58UHrUorXyI0p+htYgO/tTYV6koLKFULCGdf9+zWucRIsTACtHeQAlNopLos9iKxIX2EoiDgJp51VA2ltqGGDDOi1TJcyud7KLz/u1x2Rw8FiDhJ7jMFJAE78ylK0/+zMbm5vbZ7Q1xfDwWuND54Ts//NZ4Mjo81ax/6LKI+mnNHtubK2e/9MpT/3tr7DNVWQWtpEg2ND4DV0cHW+fjoYuTUklVO6qmhbsTULSCCLXBWY8IUd5nabO2cJWVEq01SiukjpnEA3mWkmjJ4b2RdHMzq5z/J96HGdAIgd1cHXpA2JPDHF9DQPWF3ky1/hxC5MF7scgQrjU+9N7Hbb2Uy/Lct1wOQdsDSRmdbNsSTSwMP1uB64WPegiRJqyEjBbWbSut26CTQuI91MYxK2vGs0oaY6946/Npbb7h4sj3J22mF2WWHk/G9vz5y2tnzpx75fq1S3pWlHhru5PJ9N7b77z15od5miV/yjLIYnqVvPDk+Rc6WfJcWdXUjRV14bDTsDT4cG2v4Xzbczjf+mdIMiUY5tF3Q6eKtJOSZglaq+VNHhDtZCkeMqlkFL4msvPipx8YH0+ZHBZIIVKB0KfWJmJe1mJ7bRikFKfhXR4IO9Pi7eOi+tbOeBZ25zV705J57RBSRbaEaAuflkQfx9E+fsHiL+C9xXnbTr9ioITgY0+FwDsXSy0fltrAUQ8sNvSJTlqYe0DIeDl476maRtRNc1VLMTj1mn6Sx6JZr51z1Wvf/9ZX7967d/d4NGFjfZVuv589ee2pz60MVzc44Yko/nButv/LDZA0Td93Gy0259cubn1eCtaqqqaxFmsc9Z7F28XZCTTW0xi/5H7rJN6u1katWysirirLNXmml2VMNHZshRHa3mChHOJalRCFwBrLwaMZ9axBKpUnWi2YuDIERFHVHI1n7e3+/gb28pnhmatnBpcHmZLzecX+vObuuODm8Zz705rD2jJt4vi2MVH4WrRBe7ppD4AxZjn5akzTqqVIlFIxo7T+ihHCEtop1gmcZQHC9K2GmFAxSIx108Z584c4uD/iUX7jvXduP7h399v3Huz6brdDp9fl8qVLzz77zPPXOOGJLM9bv9//OED+wKkj1h/LmvbK+Y0zK/3u8wGhmsYSfMB4T/Gowe85XDiR9LQuBsoCrZ20tgDGxcmlUBHSkeUZeZa3B6qFdrTjUinjqjBRSWuxHJ+7mFYcP5zGUk3KVErRObVXFAC1sSIQRGh1hIFkpZf3r26u/GWt5HNrLXV2LddkCpx1zCrD/rTi/qTg9vGcu+OCnXnNYVFzPCuoGrMQcGwHCPFnXE62fIhI4xYjsxCnCN6/LyGLtkHy/gSJFgPP45wLCPHInaACftLH6QBpjDWz11/7zj958GDnOCAYDAesrq9vPfvUs58TQiy80TUghRAivucf70H+MD2IfvrK2St5llw31oEQVI1Fa8VkWpPe0ehnNO7Uassaj3NRgUS0s1FjPKEVgtZZEpGIuaBumlg82Th+FSFWRUom5Dqn9lU0x7SOw5059czQTROUksNulm5Oi0qeDpKqMeGUqW0KpJfWB6+YxnymNo0gwNpKj14vp2oaqtpiXKAxjsY4au8x1lPZhlHVbr5VTSdRdHR0v1UhRDFuEWIT3wax966daLnWRKfNKDJmFE5lDiEW/8a3/z44F/xuCH9oKMjpLNIAzZtvvvb6rZs3fvf4E8/9yY2NVY4ODtX160/+wvlzF//hg4f3pm0WaYQQfjab8WHoR/5nD+P2JhG0ZD4h0OvD/jOp1qvWedIswzgfiUDWcvhgjrntcE3sRYKNXIjGRNckZz3WR3KSc3HMG0TAawg6kGUJSseskiZRDFtJQQiWxpWtVq/jcHfOaK9CSYlONAKxmibJpTYQln1IeH/vlG6v9LZyGf7C4fF0o6wi2Sn4gJaabpaxNuhydm3ApTOrXNle5ermgEtrPc4NclYzTSIExlpGRc2jScmd44Lbo5Lbx3MejEsOCsOoaGJpZl0cW5+SV4V2jyJlNPi0DudsFJULcTrmrMP6YGob9iH880yXlllECNHM59PRzffe/sqt2/fKbrcj+sMBW1vbl65fe+rZD+pD/vbf/tsfZ5Df72GMWSLPA+gs0WmeJ9eFEto6F6QUQghB2ViUFJTTCvuOZ7PpIzYVdmHf7AKNdODbkiIEtBJoKxHEfiSogE4VmU9aIGHABGJ972MWMj4wOa6ZH1uS0BKdJCBEooU8s5C24f0s3sXmP1nrJC+VZfXpsqiElIo0SxdqIjGqVLupb914hYymn6LVCa4bQ2MMxjpq42IguGiBUDnPcWXihk6K5bg6EYFMOTKn6KRpO+GK3u++LalCq0JvnYUgaO+Q+gP2OT/pwwO2BT/Wr776nW9/+jOfe+Opp65+ZmV1GIarK92nrj/12a987bd+m2i9pgGjlPpQ7ER+WkqspdXBmfXh6upK95L3HqUUWZqhk4TZdE43TzHecTApKN+2rB/36G4qyizghMcFEQkQHryxcRFItBqQSqBTiUAhQ4I1liY4kKLdYAvKsmF8bKlnDu2jInuEiEiEEIlU6pJWKjXWnmbthkWADLpZTxG+VJf1inM+CrbVDUrFZjl4otJ8VBdpA6QFIyqNkhGh28niIfetev0JyNFRNo7KeawP1DacEp7wyMqSSkMqo9Vblmi6WUqaaIJ3WGuRUsYM4pxxISxkjNw/R5nF6V7k7t2bD27dePd3dl587pPXnricdHpd8eT1Jz91+dLVC3fv3R4tsu/6+vrHPcgfsEE/fQuLlUF3I8/SC84FoaQkzVJ6vS6HxxOoTbyyPBxNC8azgvWDDp2VlHSYUPfAydB6iguoA045NFHcQSlJUALXLtR86/DnjKeaOYqpwzbtAEC0S6IWnhLLQbGmlcyMfX+jvgjuYZZsmsa+OC9t2x6fDIZ8q4tqF5yQEFAtzETJuH9Z2KdFTkiKlPGCSJNAHuIEKjhPbUyc7FlP7TyVdXHU7WOWKdvjKiqLnjeRdxKXL3Qy5XVgv7H+oYd9/jm9ySNw0i8puUD11a/95m996Ytf/NMXL5x9JlGSLOtefOnFTz5/997tNxfvVetpGD4OkJ9s6USa6J5Wqh/9PARKSrI8J88zZrOCTpZGkKH31NYy3a1I9iV5liA7KekgJRtqkkRgbcwsWkt0EHHp5tuxjxWEMjAfW+YzS1W6pcttq6K4/Py8j9AUJeXZbp6tl3XzgB9l8GKM3Rxbd37eSu+I1p5NutMvMpxCEsfnd8KhvI8LQOLiT2tDkmp0kkTAoorwdpkokkRjXbszaf3IQ4h2EE1bltU2wkyMD5RNs5zyzYwTWaJfC178A+Pcff45vcmllME5vwQwCiHqe/fu3Lx1892vn9veemo8nXHvwc5QyezJ098jhMDf+Tt/5+MM8gdp0p1zyz5EK5kqIVXccquo+aQ1qysrzGYls3lF3snxzlNHpCJeOOZVjTuGTOt4wBKJ0guHWJYNrW0cdd1QVJa6cpSNPRHwXc6aW7V0ILhAr5uitY77bSEU7wfsLR+zyghCUM3jqSWcNCynu3sVBU4QhPbXsXcAcNZgjCGEkhBi9luMe5WKvYWUEp0mCB/5IZkQDLudOGiIPo801lFbQ9nuXIwLKCmf9VqFuizLx0qln/gRp4cKH7ExhkDVNI381je/8d8Ep75YNuaZB3fvVaPDg3vttGsZjH/rb/0t/u1/+9/+OEB+kkzSNNb6EHxoN8wB0EqSZCkbG2s8eLhLMy3I0lizLxyipFQIHC44rDFUTYTDO+vaWt5HpqELizblR05GNOZpEbRxYE+WpWjdLuMItYuLNfEB40484TDALQ8vt4ZW7+PHhw9IO4vgEa41PxSLYApIe/LvTCuGR1v+LclerTaYlJGqm6QtxTf4lmylGWQZK508yg/F6df5orF/okR835+61P8wgfKlL/0S3/7210LTuAC4QKgB+Vtf+c3v7+0d/Tv9bv/PeWtu7h3u/vf8/9o70x7JrrOO/55z7r219TLdM56xTSY4mTgkIgsQCREJxAfgO/Al+BrAOzZFSEjhFRBFkVheIBGEkxjiEDCTxIodx+PJbD3Tey237tkeXpxb3bdrepLYDnYPrjMq1e2qbvWd6vM/z/7/dyYML1269FS0nHzgAOkIPkreJxoVScYItKdgr9ejbAK9wZDtK5fZebiHOk9lLQlBTSvOaS2xrW/QcUG01c9Y6HWc5/ye5G5b8GT6TUth7UmGyxblSf/tObWA1IT04Mrm6C+2+uUfPDoYvzh28cw00vLvjTw+K38CmKVrPfOZde455ZgLzVrxtvHtaO5pgVDI1tRYybXHwtgU9FfKwo6aEJT31P6hmf0kF1oWNRFUNd587bv/WGK/7okLbfQFE2xqCelWAPk5AHLmj9Mry6KqSuNcpqxZ5PZ7ZUHoVfT7Q555Rtjb3aNuPFXZCoG0YXFowYDIid8dktL2CD72WI62E7mBsDJCYSW3bEQhxkiE2kc/X/LbF0FusNbUN65uPt8zPGeSU7dfyzTqYykfWdr0Z3iCl96Xc35mkTZLS8UYEtiULZGY9ntTi18fzwBTjRFTFsJ75Jf+5je/zklvzGl/1uKjtJ447xwii9Z6nU6nK4C8u6wIRkRMUZS5haRtQrTW0utVDAeREBMbm5eo5/McQfv5aSes5JPTmOyuhFbALzfrCSGrLudmKj1LJicilMZgF/JuKeWgPiW8D5A4DiHV57gjCQhGpLm9c3CtMKqiqm2SaiEhKOcBZflalsC7DKLF93SHK/SclFpKp+DnPGCqxhCifw/1j8dN2unthA5+u6+f1FuMMXrR44+LmMUSY8RWhSGIUuUWD1zjcT4fTEWrb16WJVXdwzlPjD3cvMY3TWspFuKcgorFFpn9vDQF4hxhUYHuAMMChYAhZeVz1TZzZVsRmpCAez6c4cg6UcICnA/RPjiuvyTCtw38DsqnDHwU2FJYiGXIeayPXaBwzvuytNmX0ZnOAdyy9ZEOmCwkTcnxi53ReJI3eea2Na+VBXk3Mcj6aLBZWGvzzHbO3lS9HmsiGGPxPjKrHd7HlluqJBhDSlmbtqgUaw3zpgEXsEVBM3ck5/CNw/lwImZvW2CY7kkoedZ7MY+BQIpJSdIEH96IKTU8XnlOgG/lom+j7ER4Gbgs8DGBjwt8Bvhl4EUDa9r57FPHm9KfAhA9x/U6zxrxBKtzShtBiKo3Axzzf0PL8zOtUr/fZz6frwDyjtO+wrqmZGDRQi6IJKqypCrK/FzVjCc1zmeWwpQia8Mhc+ez4pIPVL0+VZWyhLIqtiiJKll3MGbdvgXVzzn3gLTds4JgbSHG2olL6UHHl04Caq0l5Oh/UU2m44tPFe4rvAJ8DdgWuA7cEPiswMcVnjOwJjA4x7Jo1+roz1NIWnLT5NR3TQkmkmXX/j3AXwPvlvrnPR+KTwM4LmSa1/vAeNbQ61cZHKbdHe2mHfQrFKUsLEfjGY1rFWFjwhrD+miEMZaqyoTJ88Yxnc6YTaYcHY1xIQ9bmTbzpe2OMi15W04tZ2slxpL5dhVjzVHIqkwLjyaJER31e8zmjYYYk56exoFO+zunvVpHCrcVvg18FbjSumCfUPik5OuPCFwRKFq36YzX1XGl5J0c2RaSiPxdUP1X4I0E9zklwnuq2Q8/TADRad0c7R9N41YbmIeYQA1iTonUqqJA+yAMmNaeuvE5FkkRHyLzpmY2mxJCDq5d4/DOISlRyKKOkFvhpc0MLEZTAcS2LOxCO5cBxtjDuZsddGIOTUkJMWhZWHJmOcWYTuQCpJMks51H0QHOYYK3yO7YUGAbeF7gowqfBF4ALgObwEjA2HYs+Twr0f16kRw4iY5VbSFSB3i15featQB5p/SjK4B8kCv4kHb3Dnjw6IDnr11hc2OEsfnoTG2FW8kFsl5VopiWxdBSFJbG5WtNef67cZ6qKvGuoqoqnHNoTITg2mM4T9ctgvVFa1juiDVts6NVU5hd5/zkxL1qJ3d/48UbfOf1N/m169f05t2HWd/v1NPpKr91Gxy7gFlYmGOFXeBNPW0N75NBsylwSTNIrircMPBs+95VzdzFBWANrQJDa20697Kjqm+34Jhyyon1TojjVgB5/9O6Z7KfakmV+rlUxnD39l32N9b4yPNX6VcVEiOeHHdkafK8ka3JmumL0VNp5ZhJBVVVZb6oELLia3sdQiCGzFaoKeFbLt2UEt7l91tKebXWxKS81bZ0txksUVBeuvkaAK/d3yXEMwextrWKRRyxrPhmlh5dC9N9fsRpzdC04OnFbHE2gefI4BkIrCtcVng25dd6wFzgbYGXguq/cGo9FtRFK3A8BRbkhPTAhTATVR2WhmEpTKbH3Lk1x/SGbKyvsb42yPoaLTB6VYFIhJBnHqqyyAW3lEgmYdIp+4cxOVZJMRJTwnlPDBFrDCMRfMxUnjHVWDSzFSYVY62bhvCmtvJr7eNM5mg8dz/P/5GlzBdPsDBd0Jx33e1SeW3x/mLstwVR1f7MnJytqmm7bVnQFuWSkK78q4ttQbqMIHo8afZUmSsySkkprMFoZHawx8HePqbssbGxzuXtDcrKYqyhsJamrRQrmgGUYmsVFGP1pHkPIjFFijLT/NT1nKKwDHp9JtMpPkR6gx7B5bkJg2ILu9/Uzdt0SNaMiA77Pcb1k7Mx8b0BZvlhOtf2HAskS9eyVKdZMEKetHssZoRnKxxcXICklOj8IVNIOlH0wIV4Oaas3grkJryk7B8fMp0cMzk+puz12dxYp9/vZUtiBGsyyVpKBWXMY6mlam5lb8VsysKc6AUa6eNDwAWHsYbRaMi8nlO3o6nGGpwPb82b5n67sYIIyVqjWxujnwqQd2FFzyt/PCmTex5wlh90s27dBEMbIOnKt3p6XKwE6LhudmeNv12VxQ1jhKIoJMZ4Qtu5PhxSSKKQgK+P2W+mlL0+ZdkDMaSW66qwBqzFFkrwntC2omSQFEhMhKgnTCDGWPr9guBDS+bW7kSDq13z8qxx+93TV0QYz5r343N57PqcNK+cA6InZYG1k92mXmHgqQFIBGI999Np7XZHvQprbctY3k4ElgVilaowjIb9lp1Q8D5SNxOcC7i4IJIDEZtrIr2SsiwwbTDvnKNu5sQYsdYw7PcwYmjaBknT3pGqEoJ/u/Z+QeXvyOTr6nzQYa/3QX9m512fdWGXrrvxxir2eAoAYozRlPuyE+BdiK4J6T/LXvV71tjRoF+29YoskhNjytaBPO7pfebNqoosC2BcINnMldU0DfU8MBlnLY2grWCmQFlaRsPhCSG0d4HgAzFGppMpk+lUNfqAkX87rv2bdOgzRVAjwsF48oEj450uy6oq+DSmebUTAPujmbs193G3V8hoMUkX2wnC0trsFrUMiTG1LOjSEjpbi4hSSua1LaoC5xzSCDYpKbpM16kl0+DzpGHIqd+UIiF46llNnDuxpd2bBP1GSjqmo+mnekqxc9GX/oKA9WFdHzh5tbU2EzqfZmeK8Wyu169ufUaEGyLIsNcjhMh87jEijGc1x02NVhFHpImBuglMG4d34YT13flwIn/WKyylNRSmZRNpwx4hYSQnAwQleId3Hk2RJPLSsUt/k1SP22RPY0TS9qiv08avds/Kgrzvh10A/Lzx+/ceHf3zC89tf3HvYLJR+4b+hkW2ArIZWS+F9e0R/WFB9Im6jkwnkbFLBIR+aWAasfvC4Z7DeUWsIcWEziOuzmzvVZ4zbwd7IcTWmviIwt48pH/wMR124o9kRLQoZLVzVgB5f9ZCrJ6zYvXN2zv7/3FpffD9R0fHX/z4L13ic7/9LLZopwMTFMbgXUIN9ErD9tYaY2Ooi0Clim0CcVZxLYzwYpkFZTx1lPPI/LDh6NGM6aMadxyoTCuIqYr3gRhSE0W+MonpZXJhrdOzpLpztMr9rFysDzAsAcy88WE8qf36L/U/ce2jm1uXNgpZWy9yzGIEFSglTw1awBQVc4S5DxRRKXzCBiElyfMiIlSlZdgrGIxKNi4PuHR1yGizxIfA0VGNmweautGo+q1p4s9d4h65NaNuAaJJYVDYVrlptVYAeX+B0X02M+fvXX1ubXbpyugL01kcbG6WlJUlSr7tFBLqcxxz7BwPDxsGA5s7/bxSpirza2pkf7fODCAtbYkgVKVhfa1isFZw584+OzszjOrNufKHddQfdsDhBVJhRJOyAscKIBci8ZLlzA7mu9vPDK4FMZ+eToJsbvdQ28qwNTGr3Yrhe9/b00bh8lZfDAkbEslHEkqTYOfuhGpU0B8WkDJPbllYmtrz9us77D0c781meivCX84SL7VB+ayNP6II2mtn2ldrBZCLYEkAiCHFZubvb18b/fqsjs9M68BwVGFDIjS5V2oyj/E7337w6JkXNm2/Z0uZR2giMQfbBDW6c3+a1rb6ZjgoKcQgCtPjRt/6/n15dOdgb97on0xq/VOvvAqM6WiiC2hhRKWl/l2tFUAu0jKziZv2e0W9tl59bnbYjA4fzrAJ+u3kw73704e3fjL+8Y1Pbz/fEymMS0SfiAFUDSEl/6PX9mZb10ZVWVhpJg33frTH7e/dk8OHx4eN56/2j9LXYmKH3Pk664AjWcmt682q9LwCyAV0txSQg93Z3bW1Mq6Nqs/Mx01vf2cqvkmq1uqr/7XzytrVtfL69fWP9ZOSXCIlpaRHoQNc7cev/WDnwZXn1zcP7x/bH3/3Nnu3d/FNvDf3fOnRXvyKD7rbWo4TtwqIhUDP5DHduNovK4BcwFgEWvKTg9361mi90tGl/q8aoTcZN/Lg3mTv1ltHL115dvR5DXFr/GjG4aMJew/GHO7O2LlzwO0fP9y9c2f8hpvU1/dvPSzD1KHKnZmXP3u4H78agh4Cky44jEEHA0O/b/SzlXKrWW2WD+MqLvj9LWj1BTDORX7wPw+//KnPX5s9+8zg91F97sFPDl4OPh0e3Nq7svuGa5tWEtGHLBUdEo3TyXTCq0cPwhc2+lIFlW8e1+nLB8f+lZQ4bsFRt78rGCNqBB0NLYOB4Vs/WdmOlQW5aJG6PGZJFEgxqtu5O75ZleYOpLWHO/Xfbm31XywIX/QuSEqqISaJIZFiZqoSa16fOf5+UPBpMfKNvbH+8eE4/bcqkyVwRAG1xqgCvV5OC48nK4CsLMhF868UrM0khDFq6IIE8K//cP+fRsPipgvabG/3f9O7uA86EKUkaf6XKc6nKZnvxBB/NG34o+N5er2e6w6ngi+LJsQogopBU0xsXFljb3ey2iEf8nWhm4p+63c/wivfuEuM2h01PdEDBEoR6a+tFZct6QVr9bo1PBujNjHHFfOU2JkHect5PeKUySN0nhcsJdryX5NW2arVehoAMhiWxJBw7qTbtzti2uWX6iqoLuaylxnFu8BYvL6wSAAqsppBXa2nCCA/4567TB9F52GW3LHYsRQL0unE+TPgq7VaTz1Auve9TF7QlWbuyoCkpa9XwFit/9cAeRJYnhjzr0CxWu9m/S9ZhZZICVfkQwAAAEp0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRSYXBoYWVsMjAxMi5wbmekbX/HAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTAzLTA3VDIzOjUwOjQ2KzAwOjAwpTbpMgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wMy0wN1QyMzo1MDo0NiswMDowMNRrUY4AAABGdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuNi45LTcgMjAxNC0wMy0wNiBRMTYgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmeB07PDAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OmhlaWdodAAzNTRJUkzSAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADI4MVH4/6oAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTQyNTc3MjI0NrdD70MAAAASdEVYdFRodW1iOjpTaXplADE1NEtCQs4MVtsAAAAzdEVYdFRodW1iOjpVUkkAZmlsZTovLy90bXAvbG9jYWxjb3B5X2RmZjUwZDE0OTNkZi0xLnBuZ/ZXEo0AAAAASUVORK5CYII="

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var overArg = __webpack_require__(__webpack_module_template_argument_0__);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var getPrototype = __webpack_require__(__webpack_module_template_argument_0__),
	    isHostObject = __webpack_require__(__webpack_module_template_argument_1__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_2__);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDZkZTVkMDVkOTNhMzcxMTNmMmYiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWciLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2FjdGlvbnMvdHVydGxlLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9hY3Rpb25zL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1saXN0LmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9hZ2UtY2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXR1cnRsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdXNlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXVzZXJzLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvaG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvbm90Zm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3R1cnRsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL21pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL3N5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtbG9nZ2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LXByb21pc2UtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaXNQcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FaW5zdGVpbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FdWxlci5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9NVGVyZXNhLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL05ld3Rvbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9kb25hdGVsbG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbWljaGFlbGFuZ2Vsby5wbmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIl0sIm5hbWVzIjpbInJlbmRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtaWRkbGV3YXJlIiwic2VsZWN0VHVydGxlIiwidHVydGxlIiwidHlwZSIsInBheWxvYWQiLCJzZWxlY3RVc2VyIiwidXNlciIsIkNvbXBUdXJ0bGUiLCJDb21wVXNlciIsIlR1cnRsZURldGFpbCIsInN0YXRlIiwiYWN0aXZlVHVydGxlIiwicHJvcHMiLCJpbWFnZSIsIm5hbWUiLCJha2EiLCJhZ2UiLCJkZXNjcmlwdGlvbiIsIkNvbXBvbmVudCIsIlR1cnRsZUxpc3QiLCJ0dXJ0bGVzIiwibWFwIiwiaWQiLCJjcmVhdGVMaXN0SXRlbXMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXRjaERpc3BhdGNoVG9Qcm9wcyIsImRpc3BhdGNoIiwiVXNlckRldGFpbCIsImFjdGl2ZVVzZXIiLCJsYXN0IiwiYm9ybk1vbnRoIiwiYm9ybkRheSIsImJvcm5ZZWFyIiwiVXNlckxpc3QiLCJ1c2VycyIsImEiLCJiIiwiYyIsImQiLCJNYXRoIiwiYWJzIiwiYWxsUmVkdWNlcnMiLCJyb3V0aW5nIiwiYWN0aW9uIiwidG9kYXkiLCJEYXRlIiwiZGQiLCJnZXREYXRlIiwibW0iLCJnZXRNb250aCIsInl5eXkiLCJnZXRGdWxsWWVhciIsImhpc3RvcnkiLCJBcHAiLCJteVN0eWxlIiwiZm9udEZhbWlseSIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiTmF2IiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiSG9tZSIsIk5vdEZvdW5kIiwiVHVydGxlcyIsIlVzZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsb0JBQVNBLE1BQVQsQ0FDRTtBQUFBO0FBQUEsS0FBVSxzQkFBVjtBQUNFO0FBREYsRUFERixFQUlFQyxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBSkYsRTs7Ozs7O0FDTkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMvSnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBLCtGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBCOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBb0Q7O0FBRXBELHVCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCOztBQUV4QjtBQUNBOztBQUVBLHFDOzs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7QUMzTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRkFBb0YsYUFBYTtBQUNqRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHdCOzs7Ozs7O0FDcEJsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixZQUFXLGNBQWM7QUFDekIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0I7Ozs7Ozs7QUMzV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUMsZ0NBQWdDOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLCtCQUE4QjtBQUM5QjtBQUNBLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0Esc0VBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUEsOEI7Ozs7Ozs7QUM3TUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLG1DQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUM7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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RUEsc0M7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsMkM7Ozs7OztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsRUFBRSw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDOzs7Ozs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxlQUFjO0FBQ2Q7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCOzs7Ozs7O0FDOUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0gsRTs7Ozs7O0FDdkZBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDcEdBOztBQUVBOztBQUVBLG9EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3SUFBdUk7QUFDdkksbUJBQWtCO0FBQ2xCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Qsa0NBQWlDLGNBQWMscUJBQXFCO0FBQ3BFLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxtREFBa0QsY0FBYyx5QkFBeUI7QUFDekY7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0MsY0FBYyxxQkFBcUI7O0FBRXZFOztBQUVBO0FBQ0EsMENBQXlDLDJCQUEyQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsd0NBQXdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxtSkFBa0o7O0FBRWxKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7Ozs7QUNuVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUMxRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDOzs7Ozs7O0FDbEJBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILCtKQUE4SjtBQUM5SjtBQUNBOztBQUVBO0FBQ0EscUM7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEIsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQStGLDhEQUE4RDtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQTZGLHVEQUF1RDtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQStGLDhCQUE4QjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7Ozs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLFlBQVcsUUFBUTtBQUNuQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQSxtQzs7Ozs7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEM7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsU0FBUztBQUNwQixZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0M7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsMERBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Qzs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Qzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlSQUF3UjtBQUN4Ujs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFVBQVU7QUFDdkIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQXlJO0FBQ3pJOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUM7Ozs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFFBQVEsb0JBQW9CLEVBQUU7QUFDMUQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxxRDs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DOzs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsNkM7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxHQUFHO0FBQ2QsWUFBVyxRQUFRO0FBQ25CLFlBQVcsVUFBVTtBQUNyQixZQUFXLEdBQUc7QUFDZDtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLG9CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJMQUEyTCx5Q0FBeUMsK0dBQStHLHlDQUF5QztBQUM1WDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsR0FBRztBQUNkLFlBQVcsVUFBVTtBQUNyQixZQUFXLEdBQUc7QUFDZCxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDOzs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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Q0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQSxnQzs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsWUFBVyxlQUFlO0FBQzFCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkI7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIseUJB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDOzs7Ozs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLEVBQUU7QUFDZixjQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsMEJBQTBCO0FBQzFELHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsa0JBQWtCO0FBQy9CLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQixjQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Qzs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsaUJBQWlCO0FBQ3ZDLHdCQUF1Qix3QkFBd0I7QUFDL0MsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMERBQTBEO0FBQ3ZFLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHlDOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQSw2R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsd0M7Ozs7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUMxSkE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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OztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Qzs7Ozs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCOztBQUU1Qiw2QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0Q7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQSxrQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFVBQVU7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVELHlDOzs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsdUM7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLGlCQUFpQjtBQUN2Qyx3QkFBdUIsd0JBQXdCO0FBQy9DLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsZ0JBQWdCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DOzs7Ozs7O0FDMW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUM7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7Ozs7Ozs7O0FDSEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbEJBLG1DQUFrQyxvK2Y7Ozs7OztBQ0FsQyxtQ0FBa0Msd3VtQjs7Ozs7O0FDQWxDLG1DQUFrQyw0bW9COzs7Ozs7QUNBbEMsbUNBQWtDLGdoZDs7Ozs7O0FDQWxDLG1DQUFrQyxvMW1DOzs7Ozs7QUNBbEMsbUNBQWtDLGdxb0I7Ozs7OztBQ0FsQyxtQ0FBa0MsdzE3Qzs7Ozs7O0FDQWxDLGtDQUFpQyxvcXhGOzs7Ozs7QUNBakMsa0NBQWlDLG8yNUY7Ozs7OztBQ0FqQyxrQ0FBaUMsNDM2STs7Ozs7O0FDQWpDLGtDQUFpQyxvdGdGOzs7Ozs7QUNBakM7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGQ2ZGU1ZDA1ZDkzYTM3MTEzZjJmXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgQXBwIGZyb20gJy4vYXBwLmpzJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uL2Rldi9qcy9zdG9yZSdcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICA8QXBwIC8+XG4gIDwvUHJvdmlkZXI+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvaW5kZXguanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcmVhY3RQcm9kSW52YXJpYW50XG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSByb3V0ZXJXYXJuaW5nO1xuZXhwb3J0cy5fcmVzZXRXYXJuZWQgPSBfcmVzZXRXYXJuZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd2FybmVkID0ge307XG5cbmZ1bmN0aW9uIHJvdXRlcldhcm5pbmcoZmFsc2VUb1dhcm4sIG1lc3NhZ2UpIHtcbiAgLy8gT25seSBpc3N1ZSBkZXByZWNhdGlvbiB3YXJuaW5ncyBvbmNlLlxuICBpZiAobWVzc2FnZS5pbmRleE9mKCdkZXByZWNhdGVkJykgIT09IC0xKSB7XG4gICAgaWYgKHdhcm5lZFttZXNzYWdlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIH1cblxuICBtZXNzYWdlID0gJ1tyZWFjdC1yb3V0ZXJdICcgKyBtZXNzYWdlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgX3dhcm5pbmcyLmRlZmF1bHQuYXBwbHkodW5kZWZpbmVkLCBbZmFsc2VUb1dhcm4sIG1lc3NhZ2VdLmNvbmNhdChhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIF9yZXNldFdhcm5lZCgpIHtcbiAgd2FybmVkID0ge307XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0cnVtZW50YXRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50VHJlZUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKGhhc093blByb3BlcnR5KVxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XG4gIC5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XG4vLyBBcnJheS5mcm9tXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuLy8gTWFwXG50eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcCkgJiZcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxuLy8gU2V0XG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcbi8vIFNldC5wcm90b3R5cGUua2V5c1xuU2V0LnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0LnByb3RvdHlwZS5rZXlzKTtcblxudmFyIGl0ZW1NYXA7XG52YXIgcm9vdElEU2V0O1xuXG52YXIgaXRlbUJ5S2V5O1xudmFyIHJvb3RCeUtleTtcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcbn0gZWxzZSB7XG4gIGl0ZW1CeUtleSA9IHt9O1xuICByb290QnlLZXkgPSB7fTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG4vLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3Vlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbmZ1bmN0aW9uIGdldEtleUZyb21JRChpZCkge1xuICByZXR1cm4gJy4nICsgaWQ7XG59XG5mdW5jdGlvbiBnZXRJREZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gIHZhciBpdGVtID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHRleHQ6IG51bGwsXG4gICAgY2hpbGRJRHM6IFtdLFxuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgdXBkYXRlQ291bnQ6IDBcbiAgfTtcblxuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRJRHMoKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290SURzKCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmUoaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyBuYW1lICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXQobmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IElEIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgY3JlYXRlKGlkLCBlbGVtZW50LCBwYXJlbnRJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdG9wRWxlbWVudC50eXBlO1xuICAgICAgdmFyIG5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIDogdHlwZTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUgfHwgJ1Vua25vd24nLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0UmVnaXN0ZXJlZElEcyxcblxuICBnZXRSb290SURzOiBnZXRSb290SURzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcbiAgICB2YXIgc2hhZG93Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKSA/IHByb3BzLmNoaWxkcmVuLnNsaWNlKDApIDogcHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NoYWRvd0NoaWxkcmVuJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2hhZG93Q2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID0gc2hhZG93Q2hpbGRyZW47XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uKTogRXhwZWN0ZWQgcHJvcHMgYXJndW1lbnQgdG8gYmUgYSBwbGFpbiBvYmplY3QuICcgKyAnUHJvcGVydGllcyBkZWZpbmVkIGluIGl0cyBwcm90b3R5cGUgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cblJlYWN0RWxlbWVudC5SRUFDVF9FTEVNRU5UX1RZUEUgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICAvLyBBbnkgdXBkYXRlcyBlbnF1ZXVlZCB3aGlsZSByZWNvbmNpbGluZyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciB0aGlzIGVudGlyZVxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXG4gIC8vIHRvIEIgKHNpbmNlIEIgd291bGQgaGF2ZSBhbHJlYWR5IHVwZGF0ZWQsIHdlIHNob3VsZCBza2lwIGl0LCBhbmQgdGhlIG9ubHlcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgdmFyIG1hcmtlck5hbWU7XG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgICAgdmFyIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzID09PSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50Ll9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcbiAgICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKTtcblxuICAgIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBfcHJvZEludmFyaWFudCgnMTI2JykgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IF9wcm9kSW52YXJpYW50KCcxMjgnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BBbmltYXRpb25FbmQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogbnVsbCxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BJbnZhbGlkOiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENoaWxkcmVuKG9iamVjdCkge1xuICByZXR1cm4gaXNWYWxpZENoaWxkKG9iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5ldmVyeShpc1ZhbGlkQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShkZWZhdWx0UHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh0eXBlLmRlZmF1bHRQcm9wcywgZWxlbWVudC5wcm9wcyk7XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGUuY2hpbGRyZW4sIHJvdXRlKTtcblxuICAgIGlmIChjaGlsZFJvdXRlcy5sZW5ndGgpIHJvdXRlLmNoaWxkUm91dGVzID0gY2hpbGRSb3V0ZXM7XG5cbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gcm91dGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJvdXRlcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi4gSlNYXG4gKiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGluIHRoZSBoaWVyYXJjaHkgYXJlXG4gKiBuZXN0ZWQuXG4gKlxuICogICBpbXBvcnQgeyBSb3V0ZSwgY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gfSBmcm9tICdyZWFjdC1yb3V0ZXInXG4gKlxuICogICBjb25zdCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihcbiAqICAgICA8Um91dGUgY29tcG9uZW50PXtBcHB9PlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwibmV3c1wiIGNvbXBvbmVudD17TmV3c0ZlZWR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICApXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSB1c2VkIHdoZW4geW91IHByb3ZpZGUgPFJvdXRlPiBjaGlsZHJlblxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMocm91dGVzKSB7XG4gIGlmIChpc1JlYWN0Q2hpbGRyZW4ocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XG4gIH0gZWxzZSBpZiAocm91dGVzICYmICFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBbcm91dGVzXTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIGtleU9mKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMuaGlzdG9yeSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIGFycmF5T2YgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2Y7XG52YXIgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGU7XG52YXIgZWxlbWVudCA9IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG5mdW5jdGlvbiBmYWxzeShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gc2hvdWxkIG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xufVxuXG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IHNoYXBlKHtcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBvbmVPZlR5cGUoW2Z1bmMsIHN0cmluZ10pO1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gb25lT2ZUeXBlKFtvYmplY3QsIGVsZW1lbnRdKTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IG9uZU9mVHlwZShbcm91dGUsIGFycmF5T2Yocm91dGUpXSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbnRlcm5hbFByb3BUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmV4dHJhY3RQYXRoID0gZXh0cmFjdFBhdGg7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gZXh0cmFjdFBhdGgoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXlxcL10qLyk7XG5cbiAgaWYgKG1hdGNoID09IG51bGwpIHJldHVybiBzdHJpbmc7XG5cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gZXh0cmFjdFBhdGgocGF0aCk7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJycpIHBhdGhuYW1lID0gJy8nO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2hcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUFVTSCA9ICdQVVNIJztcblxuZXhwb3J0cy5QVVNIID0gUFVTSDtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnJlcGxhY2UuXG4gKi9cbnZhciBSRVBMQUNFID0gJ1JFUExBQ0UnO1xuXG5leHBvcnRzLlJFUExBQ0UgPSBSRVBMQUNFO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gJ1BPUCc7XG5cbmV4cG9ydHMuUE9QID0gUE9QO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBQVVNIOiBQVVNILFxuICBSRVBMQUNFOiBSRVBMQUNFLFxuICBQT1A6IFBPUFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01MYXp5VHJlZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29ubmVjdCA9IGV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUHJvdmlkZXInKTtcblxudmFyIF9Qcm92aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm92aWRlcik7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUHJvdmlkZXIgPSBfUHJvdmlkZXIyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29ubmVjdCA9IF9jb25uZWN0MltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyOCcpIDogdm9pZCAwO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtcyA9IHJlcXVpcmUoJy4vZ2V0Um91dGVQYXJhbXMnKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSb3V0ZVBhcmFtcyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYXJyYXkgPSBfUmVhY3QkUHJvcFR5cGVzLmFycmF5O1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXG4gKiBhbmQgc2V0cyB0aGUgaGlzdG9yeSBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlckNvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlckNvbnRleHQnLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlciA9IF9wcm9wcy5yb3V0ZXI7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb247XG5cbiAgICBpZiAoIXJvdXRlcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgPFJvdXRlckNvbnRleHQ+YCBleHBlY3RzIGEgYHJvdXRlcmAgcmF0aGVyIHRoYW4gYSBgaGlzdG9yeWAnKSA6IHZvaWQgMDtcblxuICAgICAgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgICAgc2V0Um91dGVMZWF2ZUhvb2s6IGhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSByb3V0ZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBsb2NhdGlvbiA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkobG9jYXRpb24sICdgY29udGV4dC5sb2NhdGlvbmAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhIHJvdXRlIGNvbXBvbmVudFxcJ3MgYHByb3BzLmxvY2F0aW9uYCBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItYWNjZXNzaW5nbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiBoaXN0b3J5LCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjb21wb25lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMyLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzMi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9wcm9wczIucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3Byb3BzMi5jb21wb25lbnRzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xuICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgY3JlYXRlIG5ldyBjaGlsZHJlbjsgdXNlIHRoZSBncmFuZGNoaWxkcmVuLlxuXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9ICgwLCBfZ2V0Um91dGVQYXJhbXMyLmRlZmF1bHQpKHJvdXRlLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgIHJvdXRlUGFyYW1zOiByb3V0ZVBhcmFtcyxcbiAgICAgICAgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgoMCwgX1JvdXRlVXRpbHMuaXNSZWFjdENoaWxkcmVuKShlbGVtZW50KSkge1xuICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnQsIHByb3ApKSBwcm9wc1twcm9wXSA9IGVsZW1lbnRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29tcG9uZW50cykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcG9uZW50cywga2V5KSkge1xuICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIGtleSBhcyBhIHByb3AgdG8gY3JlYXRlRWxlbWVudCB0byBhbGxvd1xuICAgICAgICAgICAgICAvLyBjdXN0b20gY3JlYXRlRWxlbWVudCBmdW5jdGlvbnMgdG8ga25vdyB3aGljaCBuYW1lZCBjb21wb25lbnRcbiAgICAgICAgICAgICAgLy8gdGhleSdyZSByZW5kZXJpbmcsIGZvciBlLmcuIG1hdGNoaW5nIHVwIHRvIGZldGNoZWQgZGF0YS5cbiAgICAgICAgICAgICAgZWxlbWVudHNba2V5XSA9IF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c1trZXldLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgfSwgcHJvcHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzLCBwcm9wcyk7XG4gICAgICB9LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgcm9vdCByb3V0ZSBtdXN0IHJlbmRlciBhIHNpbmdsZSBlbGVtZW50JykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXJDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VNZW1icmFuZSA9IGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBmYWxzZTtcblxuLy8gTm8tb3AgYnkgZGVmYXVsdC5cbnZhciBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkueCkge1xuICAgICAgZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGNhblVzZU1lbWJyYW5lID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG4gIGlmIChjYW5Vc2VNZW1icmFuZSkge1xuICAgIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCwgbWVzc2FnZSkge1xuICAgICAgLy8gV3JhcCB0aGUgZGVwcmVjYXRlZCBvYmplY3QgaW4gYSBtZW1icmFuZSB0byB3YXJuIG9uIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgIHZhciBtZW1icmFuZSA9IHt9O1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgdXNlIGZhdCBhcnJvdyBoZXJlIGJlY2F1c2Ugb2YgdXNlIG9mIGFyZ3VtZW50cyBiZWxvdy5cbiAgICAgICAgICBtZW1icmFuZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF0uYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSB0byBwcmV2ZW50IFJlYWN0IGRldiB0b29scyBmcm9tXG4gICAgICAgIC8vIHNlZWluZyB0aGVtIGFuZCBjYXVzaW5nIHNwdXJpb3VzIHdhcm5pbmdzIHdoZW4gYWNjZXNzaW5nIHRoZW0uIEluXG4gICAgICAgIC8vIHByaW5jaXBsZSB0aGlzIGNvdWxkIGJlIGRvbmUgd2l0aCBhIHByb3h5LCBidXQgc3VwcG9ydCBmb3IgdGhlXG4gICAgICAgIC8vIG93bktleXMgdHJhcCBvbiBwcm94aWVzIGlzIG5vdCB1bml2ZXJzYWwsIGV2ZW4gYW1vbmcgYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBvdGhlcndpc2Ugc3VwcG9ydCBwcm94aWVzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVtYnJhbmUsIHByb3AsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtYnJhbmU7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbnZhciBTRUFSQ0hfQkFTRV9LRVkgPSAnJHNlYXJjaEJhc2UnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbmZ1bmN0aW9uIGlzTmVzdGVkT2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSAmJiB0eXBlb2Ygb2JqZWN0W3BdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmplY3RbcF0pICYmIG9iamVjdFtwXSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlUXVlcnlTdHJpbmcgIT09ICdmdW5jdGlvbicpIHBhcnNlUXVlcnlTdHJpbmcgPSBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZztcblxuICAgIGZ1bmN0aW9uIGFkZFF1ZXJ5KGxvY2F0aW9uKSB7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuXG4gICAgICAgIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhzZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6ICcnIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgYWxsIHRoZSBib29rLWtlZXBpbmcgaGVyZSwgdGhpcyBzaG91bGQganVzdCBzdHJpcCB0aGVcbiAgICAgIC8vIHN0cmluZ2lmaWVkIHF1ZXJ5IGZyb20gdGhlIHNlYXJjaC5cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHNlYXJjaEJhc2VTcGVjID0gbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXTtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5ID8gc3RyaW5naWZ5UXVlcnkocXVlcnkpIDogJyc7XG4gICAgICBpZiAoIXNlYXJjaEJhc2VTcGVjICYmICFxdWVyeVN0cmluZykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShzdHJpbmdpZnlRdWVyeSAhPT0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5IHx8ICFpc05lc3RlZE9iamVjdChxdWVyeSksICd1c2VRdWVyaWVzIGRvZXMgbm90IHN0cmluZ2lmeSBuZXN0ZWQgcXVlcnkgb2JqZWN0cyBieSBkZWZhdWx0OyAnICsgJ3VzZSBhIGN1c3RvbSBzdHJpbmdpZnlRdWVyeSBmdW5jdGlvbicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlYXJjaEJhc2VTcGVjICYmIGxvY2F0aW9uLnNlYXJjaCA9PT0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBzZWFyY2hCYXNlU3BlYy5zZWFyY2hCYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlYXJjaCA9IHNlYXJjaEJhc2U7XG4gICAgICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgc2VhcmNoICs9IChzZWFyY2ggPyAnJicgOiAnPycpICsgcXVlcnlTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIChfZXh0ZW5kczIgPSB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9LCBfZXh0ZW5kczJbU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6IHNlYXJjaEJhc2UgfSwgX2V4dGVuZHMyKSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVQYXRoIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZUhyZWYgaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bGxMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2FwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkpIHtcbiAgICAgICAgZnVsbExvY2F0aW9uLnF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkUXVlcnkoZnVsbExvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZVF1ZXJpZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNhYmxlZElucHV0VXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIGhvc3RQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lc1trZXldICYmIHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaG9zdFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzYWJsZWRJbnB1dFV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lID0gcmVxdWlyZSgnLi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZScpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBoYXNFdmVudFBhZ2VYWTtcbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gX2Fzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiAncGFnZVgnIGluIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIG5ld05vZGVzID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZC5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiBrZXlNaXJyb3Iob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuZXhwb3J0cy5tYXBBc3luYyA9IG1hcEFzeW5jO1xuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVyID0gZXhwb3J0cy5yb3V0ZXMgPSBleHBvcnRzLnJvdXRlID0gZXhwb3J0cy5jb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnQgPSBleHBvcnRzLmxvY2F0aW9uID0gZXhwb3J0cy5oaXN0b3J5ID0gZXhwb3J0cy5mYWxzeSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgSW50ZXJuYWxQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfSW50ZXJuYWxQcm9wVHlwZXMpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG52YXIgcm91dGVyU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gc2hhcGUoe1xuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ286IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkLFxuICBzZXRSb3V0ZUxlYXZlSG9vazogZnVuYy5pc1JlcXVpcmVkLFxuICBpc0FjdGl2ZTogZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIGxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBzaGFwZSh7XG4gIHBhdGhuYW1lOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc2VhcmNoOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc3RhdGU6IG9iamVjdCxcbiAgYWN0aW9uOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAga2V5OiBzdHJpbmdcbn0pO1xuXG4vLyBEZXByZWNhdGVkIHN0dWZmIGJlbG93OlxuXG52YXIgZmFsc3kgPSBleHBvcnRzLmZhbHN5ID0gSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3k7XG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IEludGVybmFsUHJvcFR5cGVzLmhpc3Rvcnk7XG52YXIgbG9jYXRpb24gPSBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb25TaGFwZTtcbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IEludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudDtcbnZhciBjb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnRzID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cztcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBJbnRlcm5hbFByb3BUeXBlcy5yb3V0ZTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlcztcbnZhciByb3V0ZXIgPSBleHBvcnRzLnJvdXRlciA9IHJvdXRlclNoYXBlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXByZWNhdGVQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBwcm9wVHlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgJ1RoaXMgcHJvcCB0eXBlIGlzIG5vdCBpbnRlbmRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2FzIHByZXZpb3VzbHkgZXhwb3J0ZWQgYnkgbWlzdGFrZS4gVGhlc2UgaW50ZXJuYWwgcHJvcCB0eXBlcyBhcmUgZGVwcmVjYXRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShwcm9wVHlwZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhlIGAnICsgbmFtZSArICdgIHByb3AgdHlwZSBpcyBub3cgZXhwb3J0ZWQgYXMgYCcgKyBuYW1lICsgJ1NoYXBlYCB0byBhdm9pZCBuYW1lIGNvbmZsaWN0cy4gVGhpcyBleHBvcnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5mYWxzeSA9IGZhbHN5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShmYWxzeSk7XG4gICAgZXhwb3J0cy5oaXN0b3J5ID0gaGlzdG9yeSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoaGlzdG9yeSk7XG4gICAgZXhwb3J0cy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGNvbXBvbmVudCk7XG4gICAgZXhwb3J0cy5jb21wb25lbnRzID0gY29tcG9uZW50cyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50cyk7XG4gICAgZXhwb3J0cy5yb3V0ZSA9IHJvdXRlID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShyb3V0ZSk7XG4gICAgZXhwb3J0cy5yb3V0ZXMgPSByb3V0ZXMgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlcyk7XG5cbiAgICBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb24gPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUobG9jYXRpb24sICdsb2NhdGlvbicpO1xuICAgIGV4cG9ydHMucm91dGVyID0gcm91dGVyID0gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHJvdXRlciwgJ3JvdXRlcicpO1xuICB9KSgpO1xufVxuXG52YXIgZGVmYXVsdEV4cG9ydCA9IHtcbiAgZmFsc3k6IGZhbHN5LFxuICBoaXN0b3J5OiBoaXN0b3J5LFxuICBsb2NhdGlvbjogbG9jYXRpb24sXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICByb3V0ZTogcm91dGUsXG4gIC8vIEZvciBzb21lIHJlYXNvbiwgcm91dGVzIHdhcyBuZXZlciBoZXJlLlxuICByb3V0ZXI6IHJvdXRlclxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVmYXVsdEV4cG9ydCA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkoZGVmYXVsdEV4cG9ydCwgJ1RoZSBkZWZhdWx0IGV4cG9ydCBmcm9tIGByZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgbmFtZWQgZXhwb3J0cyBpbnN0ZWFkLicpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0RXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczIgPSByZXF1aXJlKCcuL2NvbXB1dGVDaGFuZ2VkUm91dGVzJyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyKTtcblxudmFyIF9UcmFuc2l0aW9uVXRpbHMgPSByZXF1aXJlKCcuL1RyYW5zaXRpb25VdGlscycpO1xuXG52YXIgX2lzQWN0aXZlMiA9IHJlcXVpcmUoJy4vaXNBY3RpdmUnKTtcblxudmFyIF9pc0FjdGl2ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FjdGl2ZTIpO1xuXG52YXIgX2dldENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudHMnKTtcblxudmFyIF9nZXRDb21wb25lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbXBvbmVudHMpO1xuXG52YXIgX21hdGNoUm91dGVzID0gcmVxdWlyZSgnLi9tYXRjaFJvdXRlcycpO1xuXG52YXIgX21hdGNoUm91dGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoUm91dGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaGFzQW55UHJvcGVydGllcyhvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihoaXN0b3J5LCByb3V0ZXMpIHtcbiAgdmFyIHN0YXRlID0ge307XG5cbiAgLy8gU2lnbmF0dXJlIHNob3VsZCBiZSAobG9jYXRpb24sIGluZGV4T25seSksIGJ1dCBuZWVkcyB0byBzdXBwb3J0IChwYXRoLFxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxuICBmdW5jdGlvbiBpc0FjdGl2ZShsb2NhdGlvbikge1xuICAgIHZhciBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXByZWNhdGVkSW5kZXhPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBpbmRleE9ubHkgPSB2b2lkIDA7XG4gICAgaWYgKGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICYmIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICE9PSB0cnVlIHx8IGRlcHJlY2F0ZWRJbmRleE9ubHkgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5KSBpcyBkZXByZWNhdGVkOyB1c2UgYGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICBsb2NhdGlvbiA9IHsgcGF0aG5hbWU6IGxvY2F0aW9uLCBxdWVyeTogaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgfTtcbiAgICAgIGluZGV4T25seSA9IGRlcHJlY2F0ZWRJbmRleE9ubHkgfHwgZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICBpbmRleE9ubHkgPSBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pc0FjdGl2ZTMuZGVmYXVsdCkobG9jYXRpb24sIGluZGV4T25seSwgc3RhdGUubG9jYXRpb24sIHN0YXRlLnJvdXRlcywgc3RhdGUucGFyYW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyhsb2NhdGlvbikge1xuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgZmluaXNoTWF0Y2goX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlcyA9ICgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBuZXh0U3RhdGUpO1xuXG4gICAgdmFyIGxlYXZlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmxlYXZlUm91dGVzO1xuICAgIHZhciBjaGFuZ2VSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuY2hhbmdlUm91dGVzO1xuICAgIHZhciBlbnRlclJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5lbnRlclJvdXRlcztcblxuXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuTGVhdmVIb29rcykobGVhdmVSb3V0ZXMsIHN0YXRlKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIGVudGVyUm91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xuXG4gICAgLy8gY2hhbmdlIGFuZCBlbnRlciBob29rcyBhcmUgcnVuIGluIHNlcmllc1xuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAgKDAsIF9nZXRDb21wb25lbnRzMi5kZWZhdWx0KShuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCwgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvcik7ZWxzZSBjYWxsYmFjayhudWxsLCBjcmVhdGVMb2NhdGlvbkZyb21SZWRpcmVjdEluZm8ocmVkaXJlY3RJbmZvKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICAgIGhvb2tzLnB1c2guYXBwbHkoaG9va3MsIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIC8vIFRPRE86IFdhcm4gaWYgdGhleSByZWdpc3RlciBmb3IgYSByb3V0ZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGFjdGl2ZS4gVGhleSdyZSBwcm9iYWJseSBkb2luZyBzb21ldGhpbmcgd3JvbmcsIGxpa2UgcmUtY3JlYXRpbmdcbiAgICAvLyByb3V0ZSBvYmplY3RzIG9uIGV2ZXJ5IGxvY2F0aW9uIGNoYW5nZS5cbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUpO1xuICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhvb2tzKSB7XG4gICAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XG5cbiAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBbaG9va107XG5cbiAgICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob29rcy5pbmRleE9mKGhvb2spID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8ocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnTG9jYXRpb24gXCIlc1wiIGRpZCBub3QgbWF0Y2ggYW55IHJvdXRlcycsIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU6IGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xufVxuXG4vL2V4cG9ydCBkZWZhdWx0IHVzZVJvdXRlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gJyArIG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkZXByZWNhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHN0cmluZ1RleHQpO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHByZXZJbnN0YW5jZS5fZGVidWdJRCwgJ3JlcGxhY2Ugd2l0aCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihuZXh0SW5zdGFuY2UuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdpbnNlcnQgY2hpbGQnLCB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIGNoaWxkcmVuJywgdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIHRleHQnLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlbW92ZSBjaGlsZCcsIHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01OYW1lc3BhY2VzLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgQ29tcG9uZW50VHJlZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBpbnN0YW5jZXNcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb21wb25lbnRUcmVlO1xudmFyIFRyZWVUcmF2ZXJzYWw7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBpbmplY3RUcmVlVHJhdmVyc2FsOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmlzQW5jZXN0b3IgJiYgSW5qZWN0ZWQuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RUcmVlVHJhdmVyc2FsKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgaXNBbmNlc3RvciBvciBnZXRMb3dlc3RDb21tb25BbmNlc3Rvci4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgS2V5RXNjYXBlVXRpbHNcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBfcHJvZEludmFyaWFudCgnODcnKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBfcHJvZEludmFyaWFudCgnODgnKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSBjaGVja2VkTGluaycpIDogX3Byb2RJbnZhcmlhbnQoJzg5JykgOiB2b2lkIDA7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogX3Byb2RJbnZhcmlhbnQoJzg1JykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKGEsIGIpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSwgYik7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNTZWNyZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyAnICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGxlck5hbWUgTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxuICAgIGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvblxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SXRlcmF0b3JGblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdmFsaWRhdGVET01OZXN0aW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIGlmIChjaGlsZFRhZyAhPT0gJyN0ZXh0Jykge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IGxvZ2dlciBmcm9tICdyZWR1eC1sb2dnZXInXG5pbXBvcnQgdGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnXG5pbXBvcnQgcHJvbWlzZSBmcm9tICdyZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUnXG5cbmltcG9ydCByZWR1Y2VyIGZyb20gJy4vcmVkdWNlcnMvJ1xuXG5jb25zdCBtaWRkbGV3YXJlID0gYXBwbHlNaWRkbGV3YXJlKHByb21pc2UoKSwgdGh1bmssIGxvZ2dlcigpKVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyKVxuLy9leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyLCBtaWRkbGV3YXJlKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3N0b3JlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zdG9yZVNoYXBlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogVGhpcyBhY3Rpb24gdHlwZSB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGhpc3RvcnkgYWN0aW9ucyBiZWxvdy5cbiAqIElmIHlvdSdyZSB3cml0aW5nIGEgbWlkZGxld2FyZSB0byB3YXRjaCBmb3IgbmF2aWdhdGlvbiBldmVudHMsIGJlIHN1cmUgdG9cbiAqIGxvb2sgZm9yIGFjdGlvbnMgb2YgdGhpcyB0eXBlLlxuICovXG52YXIgQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9ICdAQHJvdXRlci9DQUxMX0hJU1RPUllfTUVUSE9EJztcblxuZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IENBTExfSElTVE9SWV9NRVRIT0QsXG4gICAgICBwYXlsb2FkOiB7IG1ldGhvZDogbWV0aG9kLCBhcmdzOiBhcmdzIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFRoZXNlIGFjdGlvbnMgY29ycmVzcG9uZCB0byB0aGUgaGlzdG9yeSBBUEkuXG4gKiBUaGUgYXNzb2NpYXRlZCByb3V0ZXJNaWRkbGV3YXJlIHdpbGwgY2FwdHVyZSB0aGVzZSBldmVudHMgYmVmb3JlIHRoZXkgZ2V0IHRvXG4gKiB5b3VyIHJlZHVjZXIgYW5kIHJlaXNzdWUgdGhlbSBhcyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gb24geW91ciBoaXN0b3J5LlxuICovXG52YXIgcHVzaCA9IGV4cG9ydHMucHVzaCA9IHVwZGF0ZUxvY2F0aW9uKCdwdXNoJyk7XG52YXIgcmVwbGFjZSA9IGV4cG9ydHMucmVwbGFjZSA9IHVwZGF0ZUxvY2F0aW9uKCdyZXBsYWNlJyk7XG52YXIgZ28gPSBleHBvcnRzLmdvID0gdXBkYXRlTG9jYXRpb24oJ2dvJyk7XG52YXIgZ29CYWNrID0gZXhwb3J0cy5nb0JhY2sgPSB1cGRhdGVMb2NhdGlvbignZ29CYWNrJyk7XG52YXIgZ29Gb3J3YXJkID0gZXhwb3J0cy5nb0ZvcndhcmQgPSB1cGRhdGVMb2NhdGlvbignZ29Gb3J3YXJkJyk7XG5cbnZhciByb3V0ZXJBY3Rpb25zID0gZXhwb3J0cy5yb3V0ZXJBY3Rpb25zID0geyBwdXNoOiBwdXNoLCByZXBsYWNlOiByZXBsYWNlLCBnbzogZ28sIGdvQmFjazogZ29CYWNrLCBnb0ZvcndhcmQ6IGdvRm9yd2FyZCB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvYWN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLnJvdXRlckFjdGlvbnMgPSBleHBvcnRzLmdvRm9yd2FyZCA9IGV4cG9ydHMuZ29CYWNrID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZSA9IGV4cG9ydHMucHVzaCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMucm91dGVyUmVkdWNlciA9IGV4cG9ydHMuTE9DQVRJT05fQ0hBTkdFID0gZXhwb3J0cy5zeW5jSGlzdG9yeVdpdGhTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTE9DQVRJT05fQ0hBTkdFJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZHVjZXIuTE9DQVRJT05fQ0hBTkdFO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyUmVkdWNlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWR1Y2VyLnJvdXRlclJlZHVjZXI7XG4gIH1cbn0pO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDQUxMX0hJU1RPUllfTUVUSE9EJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuQ0FMTF9ISVNUT1JZX01FVEhPRDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3B1c2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5wdXNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVwbGFjZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJlcGxhY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLmdvO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29CYWNrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29CYWNrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29Gb3J3YXJkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29Gb3J3YXJkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyQWN0aW9ucycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJvdXRlckFjdGlvbnM7XG4gIH1cbn0pO1xuXG52YXIgX3N5bmMgPSByZXF1aXJlKCcuL3N5bmMnKTtcblxudmFyIF9zeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bmMpO1xuXG52YXIgX21pZGRsZXdhcmUgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUnKTtcblxudmFyIF9taWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21pZGRsZXdhcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHMuc3luY0hpc3RvcnlXaXRoU3RvcmUgPSBfc3luYzJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMucm91dGVyTWlkZGxld2FyZSA9IF9taWRkbGV3YXJlMlsnZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLnJvdXRlclJlZHVjZXIgPSByb3V0ZXJSZWR1Y2VyO1xuLyoqXG4gKiBUaGlzIGFjdGlvbiB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZCB3aGVuIHlvdXIgaGlzdG9yeVxuICogcmVjZWl2ZXMgYSBsb2NhdGlvbiBjaGFuZ2UuXG4gKi9cbnZhciBMT0NBVElPTl9DSEFOR0UgPSBleHBvcnRzLkxPQ0FUSU9OX0NIQU5HRSA9ICdAQHJvdXRlci9MT0NBVElPTl9DSEFOR0UnO1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBsb2NhdGlvbkJlZm9yZVRyYW5zaXRpb25zOiBudWxsXG59O1xuXG4vKipcbiAqIFRoaXMgcmVkdWNlciB3aWxsIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB0aGUgbW9zdCByZWNlbnQgbG9jYXRpb24gaGlzdG9yeVxuICogaGFzIHRyYW5zaXRpb25lZCB0by4gVGhpcyBtYXkgbm90IGJlIGluIHN5bmMgd2l0aCB0aGUgcm91dGVyLCBwYXJ0aWN1bGFybHlcbiAqIGlmIHlvdSBoYXZlIGFzeW5jaHJvbm91c2x5LWxvYWRlZCByb3V0ZXMsIHNvIHJlYWRpbmcgZnJvbSBhbmQgcmVseWluZyBvblxuICogdGhpcyBzdGF0ZSBpcyBkaXNjb3VyYWdlZC5cbiAqL1xuZnVuY3Rpb24gcm91dGVyUmVkdWNlcigpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gaW5pdGlhbFN0YXRlIDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG4gIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuXG4gIGlmICh0eXBlID09PSBMT0NBVElPTl9DSEFOR0UpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7IGxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnM6IHBheWxvYWQgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9yZWR1Y2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGJvb2wgPSBfUmVhY3QkUHJvcFR5cGVzLmJvb2w7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvbmVPZlR5cGUgPSBfUmVhY3QkUHJvcFR5cGVzLm9uZU9mVHlwZTtcblxuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8vIFRPRE86IERlLWR1cGxpY2F0ZSBhZ2FpbnN0IGhhc0FueVByb3BlcnRpZXMgaW4gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIGZhbHNlO1xuICB9cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgX3JlZikge1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuICB2YXIgaGFzaCA9IF9yZWYuaGFzaDtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICBpZiAocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSkge1xuICAgIHJldHVybiB7IHBhdGhuYW1lOiB0bywgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfTtcbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiBpcyB1c2VkIHRvIGNyZWF0ZSBhbiA8YT4gZWxlbWVudCB0aGF0IGxpbmtzIHRvIGEgcm91dGUuXG4gKiBXaGVuIHRoYXQgcm91dGUgaXMgYWN0aXZlLCB0aGUgbGluayBnZXRzIHRoZSB2YWx1ZSBvZiBpdHNcbiAqIGFjdGl2ZUNsYXNzTmFtZSBwcm9wLlxuICpcbiAqIEZvciBleGFtcGxlLCBhc3N1bWluZyB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHJvdXRlOlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGNvbXBvbmVudD17UG9zdH0gLz5cbiAqXG4gKiBZb3UgY291bGQgdXNlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50IHRvIGxpbmsgdG8gdGhhdCByb3V0ZTpcbiAqXG4gKiAgIDxMaW5rIHRvPXtgL3Bvc3RzLyR7cG9zdC5pZH1gfSAvPlxuICpcbiAqIExpbmtzIG1heSBwYXNzIGFsb25nIGxvY2F0aW9uIHN0YXRlIGFuZC9vciBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICogaW4gdGhlIHN0YXRlL3F1ZXJ5IHByb3BzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogICA8TGluayAuLi4gcXVlcnk9e3sgc2hvdzogdHJ1ZSB9fSBzdGF0ZT17eyB0aGU6ICdzdGF0ZScgfX0gLz5cbiAqL1xudmFyIExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IG9uZU9mVHlwZShbc3RyaW5nLCBvYmplY3RdKS5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgYWN0aXZlU3R5bGU6IG9iamVjdCxcbiAgICBhY3RpdmVDbGFzc05hbWU6IHN0cmluZyxcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25seUFjdGl2ZU9uSW5kZXg6IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAhdGhpcy5jb250ZXh0LnJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8TGluaz5zIHJlbmRlcmVkIG91dHNpZGUgb2YgYSByb3V0ZXIgY29udGV4dCBjYW5ub3QgbmF2aWdhdGUuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gICAgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRvID0gX3Byb3BzLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wcy5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wcy5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IF9wcm9wcy5zdGF0ZTtcblxuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcblxuICAgIHRoaXMuY29udGV4dC5yb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMyLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wczIucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBfcHJvcHMyLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzMi5zdGF0ZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzMi5hY3RpdmVDbGFzc05hbWU7XG4gICAgdmFyIGFjdGl2ZVN0eWxlID0gX3Byb3BzMi5hY3RpdmVTdHlsZTtcbiAgICB2YXIgb25seUFjdGl2ZU9uSW5kZXggPSBfcHJvcHMyLm9ubHlBY3RpdmVPbkluZGV4O1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsndG8nLCAncXVlcnknLCAnaGFzaCcsICdzdGF0ZScsICdhY3RpdmVDbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnb25seUFjdGl2ZU9uSW5kZXgnXSk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpLCAndGhlIGBxdWVyeWAsIGBoYXNoYCwgYW5kIGBzdGF0ZWAgcHJvcHMgb24gYDxMaW5rPmAgYXJlIGRlcHJlY2F0ZWQsIHVzZSBgPExpbmsgdG89e3sgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoLCBzdGF0ZSB9fS8+LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIsIHNpbXBsaWZpZXMgdW5pdCB0ZXN0aW5nLlxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG5cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XG4gICAgICAgIGlmIChyb3V0ZXIuaXNBY3RpdmUobG9jYXRpb24sIG9ubHlBY3RpdmVPbkluZGV4KSkge1xuICAgICAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWN0aXZlU3R5bGUpIHByb3BzLnN0eWxlID0gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljayB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChyb3V0ZS5mcm9tKSByb3V0ZS5wYXRoID0gcm91dGUuZnJvbTtcblxuICAgICAgcm91dGUub25FbnRlciA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV4dFN0YXRlLnBhcmFtcztcblxuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHJvdXRlLnRvLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShyb3V0ZS50bywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm91dGUudG8pIHtcbiAgICAgICAgICBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb3V0ZUluZGV4ID0gbmV4dFN0YXRlLnJvdXRlcy5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgICB2YXIgcGFyZW50UGF0dGVybiA9IFJlZGlyZWN0LmdldFJvdXRlUGF0dGVybihuZXh0U3RhdGUucm91dGVzLCByb3V0ZUluZGV4IC0gMSk7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXJlbnRQYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHJvdXRlLnRvO1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocGF0dGVybiwgcGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxhY2Uoe1xuICAgICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgICBxdWVyeTogcm91dGUucXVlcnkgfHwgbG9jYXRpb24ucXVlcnksXG4gICAgICAgICAgc3RhdGU6IHJvdXRlLnN0YXRlIHx8IGxvY2F0aW9uLnN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH0sXG4gICAgZ2V0Um91dGVQYXR0ZXJuOiBmdW5jdGlvbiBnZXRSb3V0ZVBhdHRlcm4ocm91dGVzLCByb3V0ZUluZGV4KSB7XG4gICAgICB2YXIgcGFyZW50UGF0dGVybiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gcm91dGVJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICAgICAgcGFyZW50UGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGFyZW50UGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5pbmRleE9mKCcvJykgPT09IDApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJy8nICsgcGFyZW50UGF0dGVybjtcbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZyb206IHN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGhcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmNyZWF0ZVJvdXRlck9iamVjdCA9IGNyZWF0ZVJvdXRlck9iamVjdDtcbmV4cG9ydHMuY3JlYXRlUm91dGluZ0hpc3RvcnkgPSBjcmVhdGVSb3V0aW5nSGlzdG9yeTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xufVxuXG4vLyBkZXByZWNhdGVkXG5mdW5jdGlvbiBjcmVhdGVSb3V0aW5nSGlzdG9yeShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICBoaXN0b3J5ID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGhpc3RvcnkgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGhpc3RvcnksICdgcHJvcHMuaGlzdG9yeWAgYW5kIGBjb250ZXh0Lmhpc3RvcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlcmAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jb250ZXh0Y2hhbmdlcycpO1xuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVJvdXRlc2AgYW5kXG4gIC8vIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCwgaGF2ZSB0byBjcmVhdGUgYG1lbW9yeUhpc3RvcnlgIGZpcnN0IGJlY2F1c2VcbiAgLy8gYHVzZVF1ZXJpZXNgIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGUgc2lnbmF0dXJlXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3JlYXRlSGlzdG9yeSkge1xuICB2YXIgaGlzdG9yeSA9IHZvaWQgMDtcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUHJvcFR5cGVzID0gZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy51c2VSb3V0ZXMgPSBleHBvcnRzLlJvdXRlQ29udGV4dCA9IGV4cG9ydHMuTGlmZWN5Y2xlID0gZXhwb3J0cy5IaXN0b3J5ID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfSGlzdG9yeTIgPSByZXF1aXJlKCcuL0hpc3RvcnknKTtcblxudmFyIF9IaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpc3RvcnkyKTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbnZhciBfUm91dGVDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlQ29udGV4dDIpO1xuXG52YXIgX3VzZVJvdXRlczIgPSByZXF1aXJlKCcuL3VzZVJvdXRlcycpO1xuXG52YXIgX3VzZVJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXMyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiBtaXhpbnMgKi9cblxuZXhwb3J0cy5IaXN0b3J5ID0gX0hpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLkxpZmVjeWNsZSA9IF9MaWZlY3ljbGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlQ29udGV4dCA9IF9Sb3V0ZUNvbnRleHQzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IF9Sb3V0aW5nQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gX1Byb3BUeXBlczMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21ha2VTdGF0ZVdpdGhMb2NhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gcmVhZFN0YXRlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTtcblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVET01IaXN0b3J5KG9wdGlvbnMpIHtcbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogX0RPTVV0aWxzLmdldFVzZXJDb25maXJtYXRpb25cbiAgfSwgb3B0aW9ucywge1xuICAgIGdvOiBfRE9NVXRpbHMuZ29cbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdET00gaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZURPTUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChwYXRoKSB7XG4gIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2goKSB7XG4gIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKGlzQWJzb2x1dGVQYXRoKHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKCcvJyArIHBhdGgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBwYXRoICsgKHBhdGguaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyAoa2V5ICsgJz0nICsgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdbPyZdPycgKyBrZXkgKyAnPVthLXpBLVowLTldKycpLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCdcXFxcPy4qP1xcXFxiJyArIGtleSArICc9KC4rPylcXFxcYicpKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuXG52YXIgRGVmYXVsdFF1ZXJ5S2V5ID0gJ19rJztcblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcblxuICBpZiAocXVlcnlLZXkgPT09IHVuZGVmaW5lZCB8fCAhIXF1ZXJ5S2V5KSBxdWVyeUtleSA9IHR5cGVvZiBxdWVyeUtleSA9PT0gJ3N0cmluZycgPyBxdWVyeUtleSA6IERlZmF1bHRRdWVyeUtleTtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICAgIHZhciBrZXkgPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAga2V5ID0gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcbiAgICAgIHBhdGggPSBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBxdWVyeUtleSk7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gaGFzaENoYW5nZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSByZXR1cm47IC8vIEFsd2F5cyBtYWtlIHN1cmUgaGFzaGVzIGFyZSBwcmVjZWVkZWQgd2l0aCBhIC8uXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfVxuXG4gICAgZW5zdXJlU2xhc2goKTtcbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgcGF0aCA9IGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSk7XG4gICAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRHJvcCBrZXkgYW5kIHN0YXRlLlxuICAgICAgbG9jYXRpb24ua2V5ID0gbG9jYXRpb24uc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SGFzaCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKGN1cnJlbnRIYXNoICE9PSBwYXRoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1lvdSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoIHVzaW5nIGhhc2ggaGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2gobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBsb2NhdGlvbi5zdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgfVxuXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9IF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICByZXR1cm4gJyMnICsgaGlzdG9yeS5jcmVhdGVIcmVmKHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcblxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHB1c2hTdGF0ZTogcHVzaFN0YXRlLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlU3RhdGUgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjIgPSByZXF1aXJlKCcuL2NyZWF0ZUxvY2F0aW9uJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTG9jYXRpb24yKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShsb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoVHJhbnNpdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkwuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5QVVNILCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJhbmRvbUtleShrZXlMZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKHNlYXJjaCkgcmVzdWx0ICs9IHNlYXJjaDtcblxuICAgIGlmIChoYXNoKSByZXN1bHQgKz0gaGFzaDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgICBhY3Rpb24gPSBrZXk7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbM10gfHwgY3JlYXRlS2V5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbjNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpO1xuICAgICAgdXBkYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGdldEN1cnJlbnRMb2NhdGlvbigpLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpIHtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbi5zdGF0ZSwgc3RhdGUpO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKHRyYW5zaXRpb25Ib29rcy5pbmRleE9mKGhvb2spID09PSAtMSkgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgc2V0U3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10oc2V0U3RhdGUsICdzZXRTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgbG9jYXRpb24ua2V5IHRvIHNhdmUgc3RhdGUgaW5zdGVhZCcpLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3JlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3VucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gdXNlQmFzZW5hbWUoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG4gICAgdmFyIGNoZWNrZWRCYXNlSHJlZiA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tCYXNlSHJlZigpIHtcbiAgICAgIGlmIChjaGVja2VkQmFzZUhyZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHVzZSB0aGUgdmFsdWUgb2YgPGJhc2UgaHJlZj4gaW4gSFRNTFxuICAgICAgLy8gZG9jdW1lbnRzIGFzIGJhc2VuYW1lIGlmIGl0J3Mgbm90IGV4cGxpY2l0bHkgZ2l2ZW4uXG4gICAgICBpZiAoYmFzZW5hbWUgPT0gbnVsbCAmJiBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgICAgIHZhciBiYXNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgdmFyIGJhc2VIcmVmID0gYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICAgIGlmIChiYXNlSHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgYmFzZW5hbWUgPSBiYXNlSHJlZjtcblxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0F1dG9tYXRpY2FsbHkgc2V0dGluZyBiYXNlbmFtZSB1c2luZyA8YmFzZSBocmVmPiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsICcgKyAnYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBUaGUgc2VtYW50aWNzIG9mIDxiYXNlIGhyZWY+IGFyZSAnICsgJ3N1YnRseSBkaWZmZXJlbnQgZnJvbSBiYXNlbmFtZS4gUGxlYXNlIHBhc3MgdGhlIGJhc2VuYW1lIGV4cGxpY2l0bHkgaW4gJyArICd0aGUgb3B0aW9ucyB0byBjcmVhdGVIaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tlZEJhc2VIcmVmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBwbmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXNlbmFtZSA9IGJhc2VuYW1lLnNsaWNlKC0xKSA9PT0gJy8nID8gYmFzZW5hbWUgOiBiYXNlbmFtZSArICcvJztcbiAgICAgIHZhciBub3JtYWxpemVkUGF0aG5hbWUgPSBwbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IHBuYW1lLnNsaWNlKDEpIDogcG5hbWU7XG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRCYXNlbmFtZShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlQmFzZW5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuX2Fzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA/IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggOiAwO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAobGVuKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuX2NvbnRleHRzLmxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzYnKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc3Jywgc3BlY1BvbGljeSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBfcHJvZEludmFyaWFudCgnODAnKSA6IHZvaWQgMDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudEZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHNlbGVjdGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGdldFNlbGVjdFZhbHVlQ29udGV4dDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBSZWFjdERPTU9wdGlvbiBsb29rcyBhdCB0aGlzIGluaXRpYWwgdmFsdWUgc28gdGhlIGluaXRpYWwgZ2VuZXJhdGVkXG4gICAgLy8gbWFya3VwIGhhcyBjb3JyZWN0IGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RmVhdHVyZUZsYWdzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEhvc3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBob3N0IHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgX2Fzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKipcbiAgICogVXNlZCBieSBkZXZ0b29scy4gVGhlIGtleXMgYXJlIG5vdCBpbXBvcnRhbnQuXG4gICAqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS4gSG9va2VkIGJ5IGhvb2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNycpIDogdm9pZCAwO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIGZhbHNlKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgdmFyIHdyYXBwZXJJRCA9IGNvbXBvbmVudEluc3RhbmNlLl9pbnN0YW5jZS5yb290SUQ7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFt3cmFwcGVySURdID0gY29tcG9uZW50SW5zdGFuY2U7XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBSZWFjdEluc3RhbmNlTWFwLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzM4JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssICdSZWFjdERPTS5yZW5kZXInKTtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcztcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKGhvc3ROb2RlLl9kZWJ1Z0lELCAnbW91bnQnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vZGVUeXBlc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XG4gIEhPU1Q6IDAsXG4gIENPTVBPU0lURTogMSxcbiAgRU1QVFk6IDIsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuLyoqXG4gKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyIHdlIGRvbid0IHVzZSByZWFsXG4gKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gJyc7XG59XG4vLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG5Qcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICBpZiAoIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBub3Qgd29yayBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBZb3UgbWF5IGJlICcgKyAnc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgbGlicmFyeS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgZm9yIGRldGFpbHMuJywgcHJvcEZ1bGxOYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjMuMSc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNoZWNrUmVhY3RUeXBlU3BlY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4sIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBuZXh0RGVidWdJRCsrIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dElucHV0RWxlbWVudFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0VGV4dENvbnRlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtpbml0aWFsU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gaW5pdGlhbFN0YXRlO1xuICAgIGluaXRpYWxTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG5cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQndnSEJna0lCd2dLQ2drTERSWVBEUXdNRFJzVUZSQVdJQjBpSWlBZEh4OGtLRFFzSkNZeEp4OGZMVDB0TVRVM09qbzZJeXMvUkQ4NFF6UTVPamNCQ2dvS0RRd05HZzhQR2pjbEh5VTNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTi8vQUFCRUlBRm9BV2dNQklnQUNFUUVERVFIL3hBQWNBQUFDQWdNQkFRQUFBQUFBQUFBQUFBQUdCd0FGQVFJRUF3ai94QUJERUFBQkFnVUFCd01JQndRTEFBQUFBQUFCQWdNQUJBVUdFUWNTSVRGQlVXRVRJbkVVRmpJemdaR2h3UWdWSTBKaXNmQlNZNkxSSmpSRFJGTnpkSUtTc3ZIL3hBQWJBUUFDQXdFQkFRQUFBQUFBQUFBQUFBQUNCQUVEQlFZQUIvL0VBQ2tSQUFJQ0FnRUNCUU1GQUFBQUFBQUFBQUFCQWdNRUVTRVNNUVVHRTFHaEZVRnhGQ0lqTW1ILzJnQU1Bd0VBQWhFREVRQS9BSEpFaVFLWHpkL20raGlRcHN1WjZ1enAxSlNUVC8zVnlTUGowQUpGcmVpc3RianVTazIxSmVWVm1jUXdnK2dqZXR3OGtwM21CRk53WHRkU1FxMktNM1I1QlIyVHRVOVlzYzB0alB6SFdPNjFOSHdibkJYcndkVFZxODVoUkx2ZWFsOGJrb1R1MmM4Yk9IT0QwaUZiYm12NmxrWUlYS05IVlZuc0t1RzlheE5MNHR5cXV3UjdobjhoR0RvZHRnOTV4MnByWCsyWnZiK1VNVXhvWXk3cjd2Y3NTUXZGYU0zSk1hMUN1MnV5QzAraUZQOEFhSXoxVHN6SGtaN1NKYlIxcDZWbExsa0Vla3VXSFpUQUhQVnhnK0FCaGpLanpVTThJVitwMzFQbmxFK21tVU5xM3BSYm5TcEVnK3B1YlI2MlRtQnFQTm5qczQrSWdpZ1B1Nng2ZmNKOHFaVXFuMWR2dk1WQ1c3cmlWRGRyWXhyRDQ4akhMWmwzVDRxUnRpOFVKWXJiWSt4ZlQ2dWRTUHZKUDdYNTlOMGJHRjRoVmxMUzRmc1ZUcmNRNmlSSWthSlVWVjAxNld0cWd6ZFZtOEZEQ082ak9DNHM3RXBIaWZuQS9vMHR1WmJRNWRGeER0YTlVeDJoS3gvVjJqdFMya0gwZG1Namh1NFJYM00zNTJhU2FYYnlnVlU2a0krc0owWTdxM0RqVVNmZVBZb3d5eHVoUEl0MCtsRnNJOEhvTVlnRzBwWDJMS3B6SGt6TGI5UW15UXkyNW5WU0J2VXJHM2lOa0cyWStkdnBFTFdiMWswRW5VVFRrRkk0YlhITW45Y29HRFVub2w4RFUwWTN5bTlhVSt0OWxERS9LS1NsOXR2T3FRYzZxazU0SEIyZElNVENCK2pvNDRtNUtvMk05bXFUQlVPb1dNZm1ZZnhqUHpZcU10SU9JQzZXcnVmdE8za3JrRkpUVUp0enNtRktTRmRtQU1xWGc3OERZT3BFRCtoMi9aKzRYNXFrMXQ4UHpUYU8yWWUxQWtyVG5Da25BQTJaQjlwNVJVL1NQU3Z0NkNyQjFOVjhBOWNvZ1gwSEJadjZYS053bDNTdncxZjU0aWYwOWJ3bTJ1ZE5udHZxUG84d01YMWF6Tnkwb0lRcnNhakxIdFpLYVNjS2FjRzBiZVJ4OCtFRThhSzNSeVN2blJZcklQVFJlMG53RHVqcTVYYmhvcWtWQWRuV0tlc3kwKzJjQWh4T3pXd05tM0hEWURrUVZiWVc5V0htdHBNcGxYYU9wSTEwZVJUZzNEdGRtb3J4T3orS0dSdDVIM1I5QXc4bU9UVEcxZmNTbkhwbG9BZEZ5ZkxxemQ5ZFdNcW1xbXBoQ3YzYmVRTWU4ZTZHR0RDNzBIa3Fza3JYNnhjODhwZmprUXdzeGo1RjM4MGkrSzROOHdyZE4xa3p0eHNTZFVvekhiemtva3RPTXA5Snhzbkl4eklPZG5Vd3pFUElXdFNFbkpRY0s2SGZIcG1QUXlYVzludWtXbWhXekoyMjZmT1Q5WGFMTTVPNnFVc0t4ck50cHp2NmtuZHd3SVpSakdZd1RDdVJrT3lUa3lVdEFucEt0QVhoUVBKRzNVdFRiS3c3THVMSGQxdHhCeHdJK1VVV2lyUjg5YVJtWjZxT3RPVDc2ZXpTbG81UzJqT2QvRWs0OTBNY3hvWVRzenJJMHVwZG1Fb3JlekVlWmlQT3BhUVZyT0VnWko1UmpJTVlkejQyV29DdEwwbXFZc2libUc4ZHZKT056TFN1S1NsUUJJOWhNRzFKbkdaK2xTYzRWSE13d2gwNC9Fa0g1d082UUFGV1RYTmJkNUU1K1VWdHBPdWkxYU1BUDdneHgvZHBqcmZMTmpsaXlUKzBtTFhyOXhwb25WNUk1YzFHVU5WVWpWbkNsSEpDL1JQOEpnK2NXVXRxVUJuQXpqbkM5bXo1c2FXVVREbmNrTGpsdzBWYmdKaEdNZThZL3dDVU1IT1JGZmlhOUhJMit6NUNyNWlWVnV1dU5TTXV4TjQ3ZGJmYmF3L3ROYnZLUGlGS09mWWVNWE90SEZOeWJjeXdHc3FiS01GcHhzNFUyb2JpbjlZTzQ1QklpdVhYQlNscFp1QW9sa0hZaWUzUzYraWlmVnE2SzJIZ1R3WDYzZHpEdjdCYTBYaE1ZalZLMHFTbFNWQlNWYlFRY2d4Q1lSc3RhNFpLUmt4b1RFSjZ4VlZDdVNrck1pVGFLcHFmVU83S1M0MW5CMVZ3UW44U2lCQ3VwMnZVRnNMc2RzMCtsaHNyVmxYQktSdlVlQUhXT0tocGVSVDB0ekFTRnRPT05nSk9RRXBVUWtEd0dCRzBuTFBxY0UxVVNnekJIZGJSdFF5RHZBNW5tcmp3d0k3QUFnYk9lWVV5TFlRZzZseS9jSklFOUswNzVIWWRVSTJyZVFsaElIRXJVQWZobUNXMzZReEowR215cmllK3hLTk5xMmNRZ0Q1UUUzai9BRWl2YTNyWWE3elRMdjFoUEFIMFVJOUVIeDJqL2NJWmV0MGp0dkwyTTZzRk9YZVhJcGZMY2djdjIyeGM5dk95YlMrem5XVkIrVGR6alVlVHUyOEFkM3RqanNDNS9PS2txUk5nTlZhU1YyRSt3ZGlrT0RabkhJNFB0eU9FRjhBbDZXdFBOMVZOMTJpRW9yTFNjVEV0OTJkYjRnL2l3QjQ0SEVDSC9FY0paVldsM1hZR3VmU3cwekdyamFIVUtiY1NsYUZEQ2txR1FSeUlnY3RHOEtmYzBzb002MHZQTTdKbVNlMk9OS0cvWnhIWDM0T3lDTE1jSGQ2bVBOd210TkRhMCt3TXZXWEtzcks2RlVLaFJWRTUxSkozN0VuL0FDbFpTUFppT2MwUzhVQW9idk5wU2VCZHBhQ3Iya0t4QmRtTVpndnF0eVhPbitVbWU5TkFvM2FWUm1jZlhsMTFTY1Q5NW1XMVpWQ3VoMU85ajJ4ZlV1bFNGSVlMRk5sR3Bac25XVUcwNDFqekozazlUSFlZd1RDZVI0aGZhdWx5NDlsd3ZnSlFTSkZWY3RjbExlbzh4VTU1WDJiUTdxQWRyaXVDUjFNUzRhL1RiZGtGVHRWbUV0TmpZaE85VGg1SkhFd0xXL1E2bGVsWVp1TzZaY3kxTGx6clUybHIzay80amcvV2VnRzEzd2p3aXpOc1ZrMXFDK2Y4UU50aWlpeTBZVVNiWlluTGtyU2NWYXRLRHFra1k3Rm5laEhUaDhCd2c1aWVNU1BwRVlxS1NRZzN0a2lSSWtFeUFUdXl3NmJYNWdWQ1hjZHBsWlJ0YnFFcDNWNXhnYTJNYTJ6QTU0NHhRaXJYdmF3N092VWNWeVNUdW5xYjZ6SDRtK2ZzQTZ3eVR2alBLRk1uRG95WTlOc2RoeG00OWdCa2RKOXFUUjFIcWd1VGU0dHpiS2tGUGljRWZHTFFYbmJCR1JYNmRqL1VKaStxTkxwOCswZkxwQ1ZtZGl2WE1wWHc2aUF0eTJhQUhnQlE2WmpsNUczL0FDakRuNVl4WlBpVFJlcjVIdFA2U2JTazlpcXcyOHJPeE11aFRoUHRBeDhZcnZPdTVyaSt6dEMzSG1XbGJQckNxL1pJVDFDZVBzejRRYlVPaVVtVGxFcmxLWEpNTEc1VFV1aEorQWkxenNQakYyUDVld3FkU2E2dnlCSytUQWUzOUhqTEUraXNYVE91VnlyREJTcDhaWlpPZnVJUEwvd0NEaUpFamZqRlJXa2lsdHZ1U0pFaVFSQi8vOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWdcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RUdXJ0bGUgPSAodHVydGxlKSA9PiB7XG5cbiAgLy8gY29uc29sZS5sb2coXCJZb3UgY2xpY2tlZCBvbiB1c2VyOiBcIiwgXG4gIC8vIFx0dXNlci5maXJzdCArIFwiLCBcIiArIFxuICAvLyBcdHVzZXIuZGVzY3JpcHRpb25cbiAgLy8gKTtcbiAgcmV0dXJuIHtcbiAgXHR0eXBlOiBcIlRVUlRMRV9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHR1cnRsZVxuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9hY3Rpb25zL3R1cnRsZS5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RVc2VyID0gKHVzZXIpID0+IHtcblxuICAvLyBjb25zb2xlLmxvZyhcIllvdSBjbGlja2VkIG9uIHVzZXI6IFwiLCBcbiAgLy8gXHR1c2VyLmZpcnN0ICsgXCIsIFwiICsgXG4gIC8vIFx0dXNlci5kZXNjcmlwdGlvblxuICAvLyApO1xuICByZXR1cm4ge1xuICBcdHR5cGU6IFwiVVNFUl9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHVzZXJcbiAgfTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvYWN0aW9ucy91c2VyLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFR1cnRsZUxpc3QgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtbGlzdCdcbmltcG9ydCBUdXJ0bGVEZXRhaWwgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFR1cnRsZSA9ICgpID0+IChcbiAgPGRpdj5cbiAgICA8aDM+TmluamEgVHVydGxlcyBMaXN0OjwvaDM+XG4gICAgPFR1cnRsZUxpc3QgLz5cbiAgICA8aHIgLz5cbiAgICA8aDM+QmlvOjwvaDM+XG4gICAgPFR1cnRsZURldGFpbCAvPlxuICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVHVydGxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnLi4vY29udGFpbmVycy91c2VyLWxpc3QnXG5pbXBvcnQgVXNlckRldGFpbCBmcm9tICcuLi9jb250YWluZXJzL3VzZXItZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFVzZXIgPSAoKSA9PiAoXG4gICA8ZGl2PlxuICAgICA8aDM+SW5mbHVlbnRpYWwgUGVyc29ucyBMaXN0OjwvaDM+XG4gICAgIDxVc2VyTGlzdCAvPlxuICAgICA8aHIvPlxuICAgICA8aDM+QmlvOjwvaDM+XG4gICAgIDxVc2VyRGV0YWlsIC8+XG4gICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVXNlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdXNlci5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBTbWlsZXlGYWNlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1wiXG5cbi8vYWx0ZXJuYXRpdmUgY29kZVxuQGNvbm5lY3QoKHN0YXRlKSA9PiB7ICAgIFxuICByZXR1cm4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB0dXJ0bGU6IHN0YXRlLmFjdGl2ZVR1cnRsZVxuICB9O1xufSlcblxuY2xhc3MgVHVydGxlRGV0YWlsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy50dXJ0bGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxoND5cbiAgICAgICAgICAgUGxhY2UgdGhlIGN1cnNvciBvdmVyIHlvdXIgZmF2b3JpdGUgTmluamEgYW5kIGNsaWNrLi4uXG4gICAgICAgIDwvaDQ+KTtcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIHNyYz17dGhpcy5wcm9wcy50dXJ0bGUuaW1hZ2V9IHdpZHRoPVwiMjUwXCIgYWx0PXtTbWlsZXlGYWNlfSAvPlxuICAgICAgICA8ZW0+XG4gICAgICAgICAgPGg0Pnt0aGlzLnByb3BzLnR1cnRsZS5uYW1lfSBha2EgXCJ7dGhpcy5wcm9wcy50dXJ0bGUuYWthfVwiPC9oND5cbiAgICAgICAgICA8aDQ+QWdlOiAmbmJzcDsmbmJzcDt7dGhpcy5wcm9wcy50dXJ0bGUuYWdlfTwvaDQ+XG4gICAgICAgICAgPGg0PkRlc2NyaXB0aW9uOiAmbmJzcDsmbmJzcDt7dGhpcy5wcm9wcy50dXJ0bGUuZGVzY3JpcHRpb259PC9oND5cbiAgICAgICAgICA8aDU+KEltYWdlcyBhbmQgZGVzY3JpcHRpb25zIGNvdXJ0ZXN5IG9mIFdpa2lwZWRpYSk8L2g1PlxuICAgICAgICA8L2VtPlxuICAgICAgPC9kaXY+XG4gIFx0KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVHVydGxlRGV0YWlsO1xuLy8gZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdHVydGxlOiBzdGF0ZS5hY3RpdmVUdXJ0bGVcbi8vICAgfTtcbi8vIH1cbi8vIGV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShUdXJ0bGVEZXRhaWwpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWRldGFpbC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHsgc2VsZWN0VHVydGxlIH0gZnJvbSAnLi4vYWN0aW9ucy90dXJ0bGUnXG5cbmNsYXNzIFR1cnRsZUxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjcmVhdGVMaXN0SXRlbXMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucHJvcHMudHVydGxlcy5tYXAodHVydGxlID0+IHtcbiAgXHQgICAgcmV0dXJuICggICBcbiAgICAgICAgICAgIDxsaSBrZXk9e3R1cnRsZS5pZH0gb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zZWxlY3RUdXJ0bGUodHVydGxlKX0gPiBcbiAgICAgICAgICAgIHt0dXJ0bGUubmFtZX0gXG4gICAgICAgICAgICA8L2xpPiAgICAgXG4gIFx0ICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICBcdHJldHVybiAoXG4gICAgICA8aDQ+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7dGhpcy5jcmVhdGVMaXN0SXRlbXMoKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvaDQ+XG4gIFx0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdHVydGxlczogc3RhdGUudHVydGxlc1xuICB9O1xufVxuZnVuY3Rpb24gbWF0Y2hEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIChcbiAgICBiaW5kQWN0aW9uQ3JlYXRvcnMoe3NlbGVjdFR1cnRsZTogc2VsZWN0VHVydGxlfSwgZGlzcGF0Y2gpXG4gICk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWF0Y2hEaXNwYXRjaFRvUHJvcHMpKFR1cnRsZUxpc3QpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy90dXJ0bGUtbGlzdC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBTbWlsZXlGYWNlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1wiXG5cbi8vYWx0ZXJuYXRpdmUgY29kZVxuQGNvbm5lY3QoKHN0YXRlKSA9PiB7ICAgIFxuICByZXR1cm4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB1c2VyOiBzdGF0ZS5hY3RpdmVVc2VyXG4gIH07XG59KVxuXG5jbGFzcyBVc2VyRGV0YWlsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy51c2VyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8aDQ+XG4gICAgICAgICAgUGxhY2UgdGhlIGN1cnNvciBvdmVyIHlvdXIgZmF2b3JpdGUgZmFtb3VzIHBlcnNvbiBhbmQgc2VsZWN0Li4uXG4gICAgICAgIDwvaDQ+KTtcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIHNyYz17dGhpcy5wcm9wcy51c2VyLmltYWdlfSB3aWR0aD1cIjMwMFwiIGFsdD17U21pbGV5RmFjZX0gLz5cbiAgICAgICAgPGVtPlxuICAgICAgICAgICA8aDQ+e3RoaXMucHJvcHMudXNlci5uYW1lfSB7dGhpcy5wcm9wcy51c2VyLmxhc3R9PC9oND5cbiAgICAgICAgICAgPGg0PkJvcm46ICZuYnNwOyZuYnNwO3t0aGlzLnByb3BzLnVzZXIuYm9ybk1vbnRofSB7dGhpcy5wcm9wcy51c2VyLmJvcm5EYXl9LCB7dGhpcy5wcm9wcy51c2VyLmJvcm5ZZWFyfXt0aGlzLnByb3BzLnVzZXIuYWdlWzJdfTwvaDQ+XG4gICAgICAgICAgIDxoND5Xb3VsZCBoYXZlIGJlZW4gYXJvdW5kIHt0aGlzLnByb3BzLnVzZXIuYWdlWzBdfSB5ZWFycyBhbmQge3RoaXMucHJvcHMudXNlci5hZ2VbMV19IG1vbnRocyBvbGQgbm93LCBpZiB3ZXJlIHN0aWxsIGFsaXZlLjwvaDQ+XG4gICAgICAgICAgIDxoND5EZXNjcmlwdGlvbjogJm5ic3A7Jm5ic3A7e3RoaXMucHJvcHMudXNlci5kZXNjcmlwdGlvbn08L2g0PlxuICAgICAgICAgICA8aDU+KFBob3RvcyBhbmQgZGVzY3JpcHRpb25zIGNvdXJ0ZXN5IG9mIFdpa2lwZWRpYSk8L2g1PlxuICAgICAgICA8L2VtPlxuICAgICAgPC9kaXY+XG4gIFx0KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVXNlckRldGFpbDtcblxuLy8gZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdXNlcjogc3RhdGUuYWN0aXZlVXNlclxuLy8gICB9O1xuLy8gfVxuLy8gZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKFVzZXJEZXRhaWwpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy91c2VyLWRldGFpbC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHsgc2VsZWN0VXNlciB9IGZyb20gJy4uL2FjdGlvbnMvdXNlcidcbi8vIGltcG9ydCBzdG9yZSBmcm9tICcuLi9zdG9yZSdcblxuLy8gc3RvcmUuc3Vic2NyaWJlKCAoKSA9PiB7XG4vLyBjb25zb2xlLmxvZyhcIlN0b3JlIGNoYW5nZWRcIiwgc3RvcmUuZ2V0U3RhdGUoKSlcbi8vIH0pO1xuLy8gLy9iZWxvdyBzbmlwcGV0IGlzIGEgc2FtcGxlIG9mIGhvdyB0byBhZGQgYSBzdGF0ZSBpbnRvIHRoZSBjb2RlXG4vLyAvL2J1dCBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIGNvcnJlc3BvbmRpbmcgcmVkdWNlciBmdW5jdGlvbiB0byByZWNvcmQgYW5kIHVwZGF0ZSB0aGlzIG5ldyBzdGF0ZVxuLy8gc3RvcmUuZGlzcGF0Y2goe3R5cGU6IFwiQUREX1VTRVJfTkFNRVwiLCBwYXlsb2FkOiBcIlJvZFwifSlcbi8vIHN0b3JlLmRpc3BhdGNoKHt0eXBlOiBcIkFERF9VU0VSX0FHRVwiLCBwYXlsb2FkOiAyM30pXG5cbmNsYXNzIFVzZXJMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY3JlYXRlTGlzdEl0ZW1zKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnByb3BzLnVzZXJzLm1hcCh1c2VyID0+IHtcbiAgXHQgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSBrZXk9e3VzZXIuaWR9IG9uQ2xpY2s9eygpID0+IHRoaXMucHJvcHMuc2VsZWN0VXNlcih1c2VyKX0gPiBcbiAgICAgICAgICAgICAge3VzZXIubmFtZX0ge3VzZXIubGFzdH1cbiAgICAgICAgICAgIDwvbGk+XG4gIFx0ICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICBcdHJldHVybiAoXG4gICAgICA8aDQ+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7dGhpcy5jcmVhdGVMaXN0SXRlbXMoKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvaDQ+XG4gIFx0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdXNlcnM6IHN0YXRlLnVzZXJzXG4gIH07XG59XG5mdW5jdGlvbiBtYXRjaERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4gKFxuICAgIGJpbmRBY3Rpb25DcmVhdG9ycyh7c2VsZWN0VXNlcjogc2VsZWN0VXNlcn0sIGRpc3BhdGNoKVxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKShVc2VyTGlzdCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3VzZXItbGlzdC5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsYixjKSB7XG4vL1RoaXMgY2FsY3VsYXRpb24gaXMgcm91Z2hseSBhY2N1cmF0ZSB0byBtb250aHMsYXMgeW91IGNhbiBzZWUuLi5cbnZhciBkID0gXCJcIjtcblxuICBpZihiPDApIHtcbiAgXHRhPWEtMSxcbiAgXHRiPTEyLU1hdGguYWJzKGIpXG4gIH1cbiAgaWYoYz4wKSB7XG4gIFx0Yj1iKzFcbiAgfVxuICBpZihiPT09MTIpIHtcbiAgICBiPTAsXG4gICAgYT1hKzFcbiAgfVxuICBpZiAoYj09PTAgJiYgYz09PTApIHtcbiAgICBkPVwiOiBIZXksIEhhcHB5IEJpcnRoZGF5ISEhICBUaGFuayB5b3UgZm9yIHlvdXIgdHJlbWVuZG91cyBjb250cmlidXRpb24gdG8gaHVtYW5pdHkuXCJcbiAgfSBlbHNlIHtcbiAgXHRkPVwiLlwiXG4gIH1cbiAgcmV0dXJuIChcbiAgICBbYSxiLGRdXG4gICk7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL2FnZS1jYWxjdWxhdG9yLmpzXG4gKiovIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgc3luY0hpc3RvcnlXaXRoU3RvcmUsIHJvdXRlclJlZHVjZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItcmVkdXgnO1xuaW1wb3J0IFJlZHVjZXJVc2VycyBmcm9tICcuL3JlZHVjZXItdXNlcnMnO1xuaW1wb3J0IFJlZHVjZXJUdXJ0bGVzIGZyb20gJy4vcmVkdWNlci10dXJ0bGVzJztcbmltcG9ydCBBY3RpdmVVc2VyUmVkdWNlciBmcm9tICcuL3JlZHVjZXItYWN0aXZlLXVzZXInO1xuaW1wb3J0IEFjdGl2ZVR1cnRsZVJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VyLWFjdGl2ZS10dXJ0bGUnO1xuXG5jb25zdCBhbGxSZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHVzZXJzOiBSZWR1Y2VyVXNlcnMsXG4gIHR1cnRsZXM6IFJlZHVjZXJUdXJ0bGVzLFxuICBhY3RpdmVVc2VyOiBBY3RpdmVVc2VyUmVkdWNlcixcbiAgYWN0aXZlVHVydGxlOiBBY3RpdmVUdXJ0bGVSZWR1Y2VyLFxuICByb3V0aW5nOiByb3V0ZXJSZWR1Y2VyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYWxsUmVkdWNlcnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvaW5kZXguanNcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhdGU9bnVsbCwgYWN0aW9uKSB7XG5cbiAgc3dpdGNoKGFjdGlvbi50eXBlKSB7XG4gICAgXG4gIFx0Y2FzZSBcIlRVUlRMRV9TRUxFQ1RFRFwiOlxuICBcdCAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICBcdCAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufSAgXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdHVydGxlLmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlPW51bGwsIGFjdGlvbikge1xuXG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIFxuICBcdGNhc2UgXCJVU0VSX1NFTEVDVEVEXCI6XG4gIFx0ICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG4gIFx0ICBicmVhaztcbiAgXHRjYXNlIFwiQUREX1VTRVJfTkFNRVwiOlxuICBcdCAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICBcdCAgYnJlYWs7XG4gIFx0Y2FzZSBcIkFERF9VU0VSX0FHRVwiOlxuICBcdCAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICBcdCAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufSAgXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdXNlci5qc1xuICoqLyIsImltcG9ydCBMZW9uYXJkbyBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9sZW9uYXJkby5wbmdcIlxuaW1wb3J0IE1pY2hhZWxhbmdlbG8gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvbWljaGFlbGFuZ2Vsby5wbmdcIlxuaW1wb3J0IERvbmF0ZWxsbyBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9kb25hdGVsbG8ucG5nXCJcbmltcG9ydCBSYXBoYWVsIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL3JhcGhhZWwucG5nXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiBcIkxlb25hcmRvXCIsXG4gICAgICBha2E6IFwiTGVvXCIsXG4gICAgICBhZ2U6IFwiZXRlcm5hbGx5IDwgMjBcIixcbiAgICAgIGltYWdlOiBMZW9uYXJkbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25hcmRvIGlzIHRoZSBjb29sLCBjb3VyYWdlb3VzIGxlYWRlciBvZiB0aGUgTmluamEgVHVydGxlcyBhbmQgYSBkZXZvdGVkIHN0dWRlbnQgb2YgTmluanV0c3UsIHVzdWFsbHkgd2VhcmluZyBhIGJsdWUgbWFzayBhbmQgd2llbGRpbmcgdHdvIGthdGFuYXMuIExlYWRlciBpbiBibHVlLlwiIFxuICAgIH0sXG4gICAge1xuICBcdCAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIk1pY2hhZWxhbmdlbG9cIixcbiAgICAgIGFrYTogXCJNaWNrZXlcIixcbiAgICAgIGFnZTogXCJldGVybmFsbHkgPCAyMFwiLFxuICAgICAgaW1hZ2U6IE1pY2hhZWxhbmdlbG8sXG4gICAgICBkZXNjcmlwdGlvbjogXCJNaWNoZWxhbmdlbG8gaXMgdGhlIG1vc3QgY29taWNhbCBvZiB0aGUgTmluamEgVHVydGxlcywgdXN1YWxseSB3ZWFyaW5nIGFuIG9yYW5nZSBtYXNrIGFuZCB3aWVsZGluZyBhIHBhaXIgb2YgbnVuY2h1Y2tzLlwiXG4gICAgfSxcbiAgICB7XG4gIFx0ICBpZDogMyxcbiAgICAgIG5hbWU6IFwiRG9uYXRlbGxvXCIsXG4gICAgICBha2E6IFwiRG9ubmllXCIsXG4gICAgICBhZ2U6IFwiZXRlcm5hbGx5IDwgMjBcIixcbiAgICAgIGltYWdlOiBEb25hdGVsbG8sXG4gICAgICBkZXNjcmlwdGlvbjogXCJEb25hdGVsbG8gaXMgdGhlIHNjaWVudGlzdCwgaW52ZW50b3IsIGVuZ2luZWVyIGFuZCB0ZWNobm9sb2dpY2FsIGdlbml1cyBvZiB0aGUgTmluamEgVHVydGxlcywgdXN1YWxseSB3ZWFyaW5nIGEgcHVycGxlIG1hc2sgYW5kIHdpZWxkaW5nIGEgYm8tc3RhZmYuXCJcbiAgICAgfSxcbiAgICAge1xuICAgICAgaWQ6IDQsXG4gICAgICBuYW1lOiBcIlJhcGhhZWxcIixcbiAgICAgIGFrYTogXCJSYXBoXCIsXG4gICAgICBhZ2U6IFwiZXRlcm5hbGx5IDwgMjBcIixcbiAgICAgIGltYWdlOiBSYXBoYWVsLFxuICAgICAgZGVzY3JpcHRpb246IFwiUmFwaGFlbCBpcyB0aGUgYmFkIGJveSBvZiB0aGUgTmluamEgVHVydGxlcywgd2VhcmluZyBhIHJlZCBtYXNrIGFuZCB3aWVsZGluZyBhIHBhaXIgb2Ygc2Fpcy5cIlxuICAgICB9XG4gIF1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzXG4gKiovIiwiaW1wb3J0IGRhVmluY2kgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGdcIlxuaW1wb3J0IEVpbnN0ZWluIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZ1wiXG5pbXBvcnQgRXVsZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvRXVsZXIuanBnXCJcbmltcG9ydCBMZW1haXRyZSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGdcIlxuaW1wb3J0IE1UZXJlc2EgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvTVRlcmVzYS5qcGdcIlxuaW1wb3J0IE5ld3RvbiBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9OZXd0b24uanBnXCJcbmltcG9ydCBTY2hyb2VkaW5nZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvU2Nocm9lZGluZ2VyLmpwZ1wiXG5pbXBvcnQgYWdlQ2FsYyBmcm9tIFwiLi9hZ2UtY2FsY3VsYXRvclwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKSxcbiAgICAgICAgZGQgPSB0b2RheS5nZXREYXRlKCksXG4gICAgICAgIG1tID0gdG9kYXkuZ2V0TW9udGgoKSsxLFxuICAgICAgICB5eXl5ID0gdG9kYXkuZ2V0RnVsbFllYXIoKTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogXCJMZW9uYXJkb1wiLFxuICAgICAgbGFzdDogXCJEYSBWaW5jaVwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkFwcmlsXCIsXG4gICAgICBib3JuRGF5OiAxNSwgXG4gICAgICBib3JuWWVhcjogMTQ1MixcbiAgICAgIGFnZTogYWdlQ2FsYyh5eXl5LTE0NTIsIG1tLTQsIGRkLTE1KSxcbiAgICAgIGltYWdlOiBkYVZpbmNpLFxuICAgICAgZGVzY3JpcHRpb246IFwiTGVvbmFyZG8gZGkgc2VyIFBpZXJvIGRhIFZpbmNpLCBtb3JlIGNvbW1vbmx5IExlb25hcmRvIGEgVmluY2kgb3Igc2ltcGx5IExlb25hcmRvLCB3YXMgYW4gSXRhbGlhbiBwb2x5bWF0aCB3aG9zZSBhcmVhcyBvZiBpbnRlcmVzdCBpbmNsdWRlZCBpbnZlbnRpb24sIHBhaW50aW5nLCBzY3VscHRpbmcsIGFyY2hpdGVjdHVyZSwgc2NpZW5jZSwgbXVzaWMsIG1hdGhlbWF0aWNzLCBlbmdpbmVlcmluZywgbGl0ZXJhdHVyZSwgYW5hdG9teSwgZ2VvbG9neSwgYXN0cm9ub215LCBib3RhbnksIHdyaXRpbmcsIGhpc3RvcnksIGFuZCBjYXJ0b2dyYXBoeS4gSGUgaGFzIGJlZW4gdmFyaW91c2x5IGNhbGxlZCB0aGUgZmF0aGVyIG9mIHBhbGFlb250b2xvZ3ksIGljaG5vbG9neSwgYW5kIGFyY2hpdGVjdHVyZSwgYW5kIGlzIHdpZGVseSBjb25zaWRlcmVkIG9uZSBvZiB0aGUgZ3JlYXRlc3QgcGFpbnRlcnMgb2YgYWxsIHRpbWUuIFNvbWV0aW1lcyBjcmVkaXRlZCB3aXRoIHRoZSBpbnZlbnRpb25zIG9mIHRoZSBwYXJhY2h1dGUsIGhlbGljb3B0ZXIgYW5kIHRhbmssIGhlIGVwaXRvbWlzZWQgdGhlIFJlbmFpc3NhbmNlIGh1bWFuaXN0IGlkZWFsLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6IFwiSXNhYWNcIixcbiAgICAgIGxhc3Q6IFwiTmV3dG9uXCIsXG4gICAgICBib3JuTW9udGg6IFwiSmFudWFyeVwiLFxuICAgICAgYm9ybkRheTogNCwgXG4gICAgICBib3JuWWVhcjogMTY0MyxcbiAgICAgIGFnZTogYWdlQ2FsYyh5eXl5LTE2NDMsIG1tLTEsIGRkLTQpLFxuICAgICAgaW1hZ2U6IE5ld3RvbixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlNpciBJc2FhYyBOZXd0b24gd2FzIGFuIEVuZ2xpc2ggcGh5c2ljaXN0IGFuZCBtYXRoZW1hdGljaWFuIChkZXNjcmliZWQgaW4gaGlzIG93biBkYXkgYXMgYSBcXFwibmF0dXJhbCBwaGlsb3NvcGhlclxcXCIpIHdobyBpcyB3aWRlbHkgcmVjb2duaXNlZCBhcyBvbmUgb2YgdGhlIG1vc3QgaW5mbHVlbnRpYWwgc2NpZW50aXN0cyBvZiBhbGwgdGltZSBhbmQgYSBrZXkgZmlndXJlIGluIHRoZSBzY2llbnRpZmljIHJldm9sdXRpb24uIEhpcyBib29rIFBoaWxvc29waGnDpiBOYXR1cmFsaXMgUHJpbmNpcGlhIE1hdGhlbWF0aWNhIChcXFwiTWF0aGVtYXRpY2FsIFByaW5jaXBsZXMgb2YgTmF0dXJhbCBQaGlsb3NvcGh5XFxcIiksIGZpcnN0IHB1Ymxpc2hlZCBpbiAxNjg3LCBsYWlkIHRoZSBmb3VuZGF0aW9ucyBmb3IgY2xhc3NpY2FsIG1lY2hhbmljcy4gTmV3dG9uIG1hZGUgc2VtaW5hbCBjb250cmlidXRpb25zIHRvIG9wdGljcywgYW5kIGhlIHNoYXJlcyBjcmVkaXQgd2l0aCBHb3R0ZnJpZWQgV2lsaGVsbSBMZWlibml6IGZvciB0aGUgZGV2ZWxvcG1lbnQgb2YgY2FsY3VsdXMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAzLFxuICAgICAgbmFtZTogXCJMZW9uaGFyZFwiLFxuICAgICAgbGFzdDogXCJFdWxlclwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkFwcmlsXCIsXG4gICAgICBib3JuRGF5OiAxNSwgXG4gICAgICBib3JuWWVhcjogMTcwNyxcbiAgICAgIGFnZTogYWdlQ2FsYyh5eXl5LTE3MDcsIG1tLTQsIGRkLTE1KSxcbiAgICAgIGltYWdlOiBFdWxlcixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25oYXJkIEV1bGVyIHdhcyBhIFN3aXNzIG1hdGhlbWF0aWNpYW4sIHBoeXNpY2lzdCwgYXN0cm9ub21lciwgbG9naWNpYW4gYW5kIGVuZ2luZWVyIHdobyBtYWRlIGltcG9ydGFudCBhbmQgaW5mbHVlbnRpYWwgZGlzY292ZXJpZXMgaW4gbWFueSBicmFuY2hlcyBvZiBtYXRoZW1hdGljcyBsaWtlIGluZmluaXRlc2ltYWwgY2FsY3VsdXMgYW5kIGdyYXBoIHRoZW9yeSB3aGlsZSBhbHNvIG1ha2luZyBwaW9uZWVyaW5nIGNvbnRyaWJ1dGlvbnMgdG8gc2V2ZXJhbCBicmFuY2hlcyBzdWNoIGFzIHRvcG9sb2d5IGFuZCBhbmFseXRpYyBudW1iZXIgdGhlb3J5LiBIZSBhbHNvIGludHJvZHVjZWQgbXVjaCBvZiB0aGUgbW9kZXJuIG1hdGhlbWF0aWNhbCB0ZXJtaW5vbG9neSBhbmQgbm90YXRpb24sIHBhcnRpY3VsYXJseSBmb3IgbWF0aGVtYXRpY2FsIGFuYWx5c2lzLCBzdWNoIGFzIHRoZSBub3Rpb24gb2YgYSBtYXRoZW1hdGljYWwgZnVuY3Rpb24uICBIZSBpcyBhbHNvIGtub3duIGZvciBoaXMgd29yayBpbiBtZWNoYW5pY3MsIGZsdWlkIGR5bmFtaWNzLCBvcHRpY3MsIGFzdHJvbm9teSwgYW5kIG11c2ljIHRoZW9yeS5cIlxuICAgIH0sICBcbiAgICB7XG4gICAgICBpZDogNCxcbiAgICAgIG5hbWU6IFwiQWxiZXJ0XCIsXG4gICAgICBsYXN0OiBcIkVpbnN0ZWluXCIsXG4gICAgICBib3JuTW9udGg6IFwiTWFyY2hcIixcbiAgICAgIGJvcm5EYXk6IDE0LCBcbiAgICAgIGJvcm5ZZWFyOiAxODc5LFxuICAgICAgYWdlOiBhZ2VDYWxjKHl5eXktMTg3OSwgbW0tMywgZGQtMTQpLFxuICAgICAgaW1hZ2U6IEVpbnN0ZWluLFxuICAgICAgZGVzY3JpcHRpb246IFwiQWxiZXJ0IEVpbnN0ZWluIHdhcyBhIEdlcm1hbi1ib3JuIHRoZW9yZXRpY2FsIHBoeXNpY2lzdC4gSGUgZGV2ZWxvcGVkIHRoZSBnZW5lcmFsIHRoZW9yeSBvZiByZWxhdGl2aXR5LCBvbmUgb2YgdGhlIHR3byBwaWxsYXJzIG9mIG1vZGVybiBwaHlzaWNzIChhbG9uZ3NpZGUgcXVhbnR1bSBtZWNoYW5pY3MpLiAgRWluc3RlaW4ncyB3b3JrIGlzIGFsc28ga25vd24gZm9yIGl0cyBpbmZsdWVuY2Ugb24gdGhlIHBoaWxvc29waHkgb2Ygc2NpZW5jZS4gIEVpbnN0ZWluIGlzIGJlc3Qga25vd24gaW4gcG9wdWxhciBjdWx0dXJlIGZvciBoaXMgbWFzc+KAk2VuZXJneSBlcXVpdmFsZW5jZSBmb3JtdWxhIEUgPSBtYzIgKHdoaWNoIGhhcyBiZWVuIGR1YmJlZCBcXFwidGhlIHdvcmxkJ3MgbW9zdCBmYW1vdXMgZXF1YXRpb25cXFwiKS4gIEhlIHJlY2VpdmVkIHRoZSAxOTIxIE5vYmVsIFByaXplIGluIFBoeXNpY3MgZm9yIGhpcyBcXFwic2VydmljZXMgdG8gdGhlb3JldGljYWwgcGh5c2ljc1xcXCIsIGluIHBhcnRpY3VsYXIgaGlzIGRpc2NvdmVyeSBvZiB0aGUgbGF3IG9mIHRoZSBwaG90b2VsZWN0cmljIGVmZmVjdCwgYSBwaXZvdGFsIHN0ZXAgaW4gdGhlIGV2b2x1dGlvbiBvZiBxdWFudHVtIHRoZW9yeS5cIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDUsXG4gICAgICBuYW1lOiBcIkVyd2luXCIsXG4gICAgICBsYXN0OiBcIlNjaHJvZWRpbmdlclwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkF1Z3VzdFwiLFxuICAgICAgYm9ybkRheTogMTIsIFxuICAgICAgYm9yblllYXI6IDE4ODcsXG4gICAgICBhZ2U6IGFnZUNhbGMoeXl5eS0xODg3LCBtbS04LCBkZC0xMiksXG4gICAgICBpbWFnZTogU2Nocm9lZGluZ2VyLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXJ3aW4gUnVkb2xmIEpvc2VmIEFsZXhhbmRlciBTY2hyw7ZkaW5nZXIsIHNvbWV0aW1lcyB3cml0dGVuIGFzIEVyd2luIFNjaHJvZGluZ2VyIG9yIEVyd2luIFNjaHJvZWRpbmdlciwgd2FzIGEgTm9iZWwgUHJpemUtd2lubmluZyBBdXN0cmlhbiBwaHlzaWNpc3Qgd2hvIGRldmVsb3BlZCBhIG51bWJlciBvZiBmdW5kYW1lbnRhbCByZXN1bHRzIGluIHRoZSBmaWVsZCBvZiBxdWFudHVtIHRoZW9yeSwgd2hpY2ggZm9ybWVkIHRoZSBiYXNpcyBvZiB3YXZlIG1lY2hhbmljczogaGUgZm9ybXVsYXRlZCB0aGUgd2F2ZSBlcXVhdGlvbiAoc3RhdGlvbmFyeSBhbmQgdGltZS1kZXBlbmRlbnQgU2NocsO2ZGluZ2VyIGVxdWF0aW9uKSBhbmQgcmV2ZWFsZWQgdGhlIGlkZW50aXR5IG9mIGhpcyBkZXZlbG9wbWVudCBvZiB0aGUgZm9ybWFsaXNtIGFuZCBtYXRyaXggbWVjaGFuaWNzLiBTY2hyw7ZkaW5nZXIgcHJvcG9zZWQgYW4gb3JpZ2luYWwgaW50ZXJwcmV0YXRpb24gb2YgdGhlIHBoeXNpY2FsIG1lYW5pbmcgb2YgdGhlIHdhdmUgZnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA2LFxuICAgICAgbmFtZTogXCJHZW9yZ2VzXCIsXG4gICAgICBsYXN0OiBcIkxlbWFpdHJlXCIsXG4gICAgICBib3JuTW9udGg6IFwiSnVseVwiLFxuICAgICAgYm9ybkRheTogMTcsIFxuICAgICAgYm9yblllYXI6IDE4OTQsXG4gICAgICBhZ2U6IGFnZUNhbGMoeXl5eS0xODk0LCBtbS03LCBkZC0xNyksXG4gICAgICBpbWFnZTogTGVtYWl0cmUsXG4gICAgICBkZXNjcmlwdGlvbjogXCJHZW9yZ2VzIEhlbnJpIEpvc2VwaCDDiWRvdWFyZCBMZW1hw650cmUgd2FzIGEgQmVsZ2lhbiBwcmllc3QsIGFzdHJvbm9tZXIgYW5kIHByb2Zlc3NvciBvZiBwaHlzaWNzIGF0IHRoZSBDYXRob2xpYyBVbml2ZXJzaXR5IG9mIExldXZlbi4gIEhlIHByb3Bvc2VkIHRoZSB0aGVvcnkgb2YgdGhlIGV4cGFuc2lvbiBvZiB0aGUgdW5pdmVyc2UsIHdpZGVseSBtaXNhdHRyaWJ1dGVkIHRvIEVkd2luIEh1YmJsZS4gIEhlIHdhcyB0aGUgZmlyc3QgdG8gZGVyaXZlIHdoYXQgaXMgbm93IGtub3duIGFzIEh1YmJsZSdzIGxhdyBhbmQgbWFkZSB0aGUgZmlyc3QgZXN0aW1hdGlvbiBvZiB3aGF0IGlzIG5vdyBjYWxsZWQgdGhlIEh1YmJsZSBjb25zdGFudCwgd2hpY2ggaGUgcHVibGlzaGVkIGluIDE5MjcsIHR3byB5ZWFycyBiZWZvcmUgSHViYmxlJ3MgYXJ0aWNsZS4gIExlbWHDrnRyZSBhbHNvIHByb3Bvc2VkIHdoYXQgYmVjYW1lIGtub3duIGFzIHRoZSBCaWcgQmFuZyB0aGVvcnkgb2YgdGhlIG9yaWdpbiBvZiB0aGUgdW5pdmVyc2UsIHdoaWNoIGhlIGNhbGxlZCBoaXMgXFxcImh5cG90aGVzaXMgb2YgdGhlIHByaW1ldmFsIGF0b21cXFwiIG9yIHRoZSBcXFwiQ29zbWljIEVnZ1xcXCIuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA3LFxuICAgICAgbmFtZTogXCJNb3RoZXJcIixcbiAgICAgIGxhc3Q6IFwiVGVyZXNhXCIsXG4gICAgICBib3JuTW9udGg6IFwiQXVndXN0XCIsXG4gICAgICBib3JuRGF5OiAyNiwgXG4gICAgICBib3JuWWVhcjogMTkxMCxcbiAgICAgIGFnZTogYWdlQ2FsYyh5eXl5LTE5MTAsIG1tLTgsIGRkLTI2KSxcbiAgICAgIGltYWdlOiBNVGVyZXNhLFxuICAgICAgZGVzY3JpcHRpb246IFwiTW90aGVyIFRlcmVzYSBNQywga25vd24gaW4gdGhlIENhdGhvbGljIENodXJjaCBhcyBTYWludCBUZXJlc2Egb2YgQ2FsY3V0dGEgd2FzIGFuIEFsYmFuaWFuLUluZGlhbiBSb21hbiBDYXRob2xpYyBudW4gYW5kIG1pc3Npb25hcnkuICBTaGUgd2FzIGJvcm4gaW4gU2tvcGplIChub3cgY2FwaXRhbCBvZiB0aGUgUmVwdWJsaWMgb2YgTWFjZWRvbmlhKSwgdGhlbiBwYXJ0IG9mIHRoZSBLb3Nvdm8gVmlsYXlldCBpbiB0aGUgT3R0b21hbiBFbXBpcmUuIEFmdGVyIGhhdmluZyBsaXZlZCBpbiBNYWNlZG9uaWEgZm9yIGVpZ2h0ZWVuIHllYXJzLCBzaGUgbW92ZWQgdG8gSXJlbGFuZCBhbmQgdGhlbiB0byBJbmRpYSwgd2hlcmUgc2hlIGxpdmVkIGZvciBtb3N0IG9mIGhlciBsaWZlLiAgSW4gMTk1MCwgVGVyZXNhIGZvdW5kZWQgdGhlIE1pc3Npb25hcmllcyBvZiBDaGFyaXR5LCBhIFJvbWFuIENhdGhvbGljIHJlbGlnaW91cyBjb25ncmVnYXRpb24sIHdoaWNoIGluIDIwMTIgY29uc2lzdGVkIG9mIG92ZXIgNCw1MDAgc2lzdGVycyBhbmQgd2FzIGFjdGl2ZSBpbiAxMzMgY291bnRyaWVzLiBUaGV5IHJ1biBob21lcyBmb3IgcGVvcGxlIGR5aW5nIG9mIEhJVi9BSURTLCBsZXByb3N5IGFuZCB0dWJlcmN1bG9zaXM7IHNvdXAga2l0Y2hlbnM7IGRpc3BlbnNhcmllcyBhbmQgbW9iaWxlIGNsaW5pY3M7IGNoaWxkcmVuJ3MgYW5kIGZhbWlseSBjb3Vuc2VsbGluZyBwcm9ncmFtbWVzOyBvcnBoYW5hZ2VzOyBhbmQgc2Nob29scy4gTWVtYmVycyBtdXN0IGFkaGVyZSB0byB0aGUgdm93cyBvZiBjaGFzdGl0eSwgcG92ZXJ0eSwgYW5kIG9iZWRpZW5jZSwgYXMgd2VsbCBhcyBhIGZvdXJ0aCB2b3csIHRvIGdpdmUgXFxcIndob2xlaGVhcnRlZCBmcmVlIHNlcnZpY2UgdG8gdGhlIHBvb3Jlc3Qgb2YgdGhlIHBvb3IuXFxcIlwiXG4gICAgfSxcbiAgXVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXVzZXJzLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUm91dGVyLCBSb3V0ZSwgSW5kZXhSb3V0ZSwgYnJvd3Nlckhpc3RvcnkgfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5pbXBvcnQgeyBzeW5jSGlzdG9yeVdpdGhTdG9yZSwgcm91dGVyUmVkdWNlciB9IGZyb20gJ3JlYWN0LXJvdXRlci1yZWR1eCdcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4vY29udGFpbmVyJ1xuaW1wb3J0IHsgSG9tZSB9IGZyb20gJy4vaG9tZSdcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3VzZXInXG5pbXBvcnQgeyBUdXJ0bGVzIH0gZnJvbSAnLi90dXJ0bGVzJ1xuaW1wb3J0IHsgTm90Rm91bmQgfSBmcm9tICcuL25vdGZvdW5kJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uL2Rldi9qcy9zdG9yZSdcblxuY29uc3QgaGlzdG9yeSA9IHN5bmNIaXN0b3J5V2l0aFN0b3JlKGJyb3dzZXJIaXN0b3J5LCBzdG9yZSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFJvdXRlciBoaXN0b3J5PXtoaXN0b3J5fT5cbiAgICAgICAgPFJvdXRlIHBhdGg9Jy8nIGNvbXBvbmVudD17Q29udGFpbmVyfT5cblxuICAgICAgICAgIDxJbmRleFJvdXRlIGNvbXBvbmVudD17SG9tZX0gLz5cbiAgICAgICAgICA8Um91dGUgcGF0aD0ndXNlcicgY29tcG9uZW50PXtVc2VyfSAvPiAgXG4gICAgICAgICAgPFJvdXRlIHBhdGg9J3R1cnRsZXMoLzpuYW1lKScgY29tcG9uZW50PXtUdXJ0bGVzfSAvPlxuICAgICAgICAgIDxSb3V0ZSBwYXRoPScqJyBjb21wb25lbnQ9e05vdEZvdW5kfSAvPlxuXG4gICAgICAgIDwvUm91dGU+XG4gICAgICA8L1JvdXRlcj5cbiAgICApXG4gIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9hcHAuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBJbmRleExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5cbnZhciBteVN0eWxlID0ge1xuICAgIGZvbnRGYW1pbHk6ICdEb3NpcydcbiAgfVxuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gKHByb3BzKSA9PiAoXG4gIDxkaXYgc3R5bGU9e215U3R5bGV9PlxuICAgIDxOYXYgLz4gXG4gICAge3Byb3BzLmNoaWxkcmVufVxuICA8L2Rpdj5cbilcbmNvbnN0IE5hdiA9ICgpID0+IChcbiAgPG5hdiBjbGFzcz1cIm5hdmJhciBuYXZiYXItaW52ZXJzZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaGVhZGVyXCI+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibmF2YmFyLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBkYXRhLXRhcmdldD1cIiNteU5hdmJhclwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi1iYXJcIj48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLWJhclwiPjwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tYmFyXCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2VcIiBpZD1cIm15TmF2YmFyXCI+XG4gICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2YmFyLW5hdlwiPlxuICAgICAgICA8bGk+PEluZGV4TGluayBhY3RpdmVDbGFzc05hbWU9J2FjdGl2ZScgdG89Jy8nPkhvbWU8L0luZGV4TGluaz48L2xpPlxuICAgICAgICA8bGk+PEluZGV4TGluayBhY3RpdmVDbGFzc05hbWU9J2FjdGl2ZScgdG89Jy91c2VyJz5GYW1vdXMgUGVvcGxlPC9JbmRleExpbms+PC9saT5cbiAgICAgICAgPGxpPjxJbmRleExpbmsgYWN0aXZlQ2xhc3NOYW1lPSdhY3RpdmUnIHRvPScvdHVydGxlcyc+TXV0YW50IFR1cnRsZXM8L0luZGV4TGluaz48L2xpPlxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgPC9uYXY+XG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvY29udGFpbmVyLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuICBcbnZhciBteVN0eWxlID0ge1xuICBcdG1hcmdpbkxlZnQ6IDMwLFxuICBcdG1hcmdpblJpZ2h0OiAyNSxcbiAgXHRmb250RmFtaWx5OiAnRG9zaXMnXG59XG5cbmV4cG9ydCBjb25zdCBIb21lID0gKCkgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8YnIgLz5cbiAgICA8aDI+V2VsY29tZSB0byB0aGUgV29ybGQgb2YgZmFtRSBhbmQgbXVUQWF0SW9OcyE8L2gyPlxuICAgIDxoND4+IGNsaWNrIG9uIG5hdmlnYXRpb24gdG8gc2VlIG1vcmUuLi48L2g0PlxuICA8L2Rpdj5cbilcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL2hvbWUuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBOb3RGb3VuZCA9ICgpID0+IChcbiAgPGgyPjQwNDogVGhpcyBwYWdlIGlzIG5vdCBmb3VuZCE8L2gyPlxuKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL25vdGZvdW5kLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IENvbXBUdXJ0bGUgZnJvbSAnLi4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUnXG5cbnZhciBteVN0eWxlID0ge1xuICBcdG1hcmdpbkxlZnQ6IDMwLFxuICBcdG1hcmdpblJpZ2h0OiAyNSxcbiAgXHRmb250RmFtaWx5OiAnRG9zaXMnXG59XG5cbmV4cG9ydCBjb25zdCBUdXJ0bGVzID0gKHByb3BzKSA9PiAoXG4gIDxkaXYgc3R5bGU9e215U3R5bGV9PlxuICAgIDxiciAvPlxuICAgIDxoMj5UaGlzIGlzIHRoZSBUdXJ0bGVzIFBhZ2U8L2gyPlxuICAgIDxDb21wVHVydGxlIC8+XG4gIDwvZGl2PlxuKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL3R1cnRsZXMuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgQ29tcFVzZXIgZnJvbSAnLi4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyJ1xuXG52YXIgbXlTdHlsZSA9IHtcbiAgXHRtYXJnaW5MZWZ0OiAzMCxcbiAgXHRtYXJnaW5SaWdodDogMjUsXG4gIFx0Zm9udEZhbWlseTogJ0Rvc2lzJ1xufVxuXG5leHBvcnQgY29uc3QgVXNlciA9ICgpID0+IChcbiAgPGRpdiBzdHlsZT17bXlTdHlsZX0+XG4gICAgPGJyIC8+XG4gICAgPGgyPlRoaXMgaXMgdGhlIEZhbW91cyBQZW9wbGUgUGFnZTwvaDI+XG4gICAgPENvbXBVc2VyIC8+XG4gIDwvZGl2PlxuKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL3VzZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1kb20vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuXG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnPFByb3ZpZGVyPiBkb2VzIG5vdCBzdXBwb3J0IGNoYW5naW5nIGBzdG9yZWAgb24gdGhlIGZseS4gJyArICdJdCBpcyBtb3N0IGxpa2VseSB0aGF0IHlvdSBzZWUgdGhpcyBlcnJvciBiZWNhdXNlIHlvdSB1cGRhdGVkIHRvICcgKyAnUmVkdXggMi54IGFuZCBSZWFjdCBSZWR1eCAyLnggd2hpY2ggbm8gbG9uZ2VyIGhvdCByZWxvYWQgcmVkdWNlcnMgJyArICdhdXRvbWF0aWNhbGx5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtcmVkdXgvcmVsZWFzZXMvJyArICd0YWcvdjIuMC4wIGZvciB0aGUgbWlncmF0aW9uIGluc3RydWN0aW9ucy4nKTtcbn1cblxudmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7IHN0b3JlOiB0aGlzLnN0b3JlIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvdmlkZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICBfdGhpcy5zdG9yZSA9IHByb3BzLnN0b3JlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBfcmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFByb3ZpZGVyO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm92aWRlcjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICB2YXIgbmV4dFN0b3JlID0gbmV4dFByb3BzLnN0b3JlO1xuXG4gICAgaWYgKHN0b3JlICE9PSBuZXh0U3RvcmUpIHtcbiAgICAgIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCk7XG4gICAgfVxuICB9O1xufVxuXG5Qcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZFxufTtcblByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL1Byb3ZpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbm5lY3Q7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0b3JlU2hhcGUgPSByZXF1aXJlKCcuLi91dGlscy9zdG9yZVNoYXBlJyk7XG5cbnZhciBfc3RvcmVTaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdG9yZVNoYXBlKTtcblxudmFyIF9zaGFsbG93RXF1YWwgPSByZXF1aXJlKCcuLi91dGlscy9zaGFsbG93RXF1YWwnKTtcblxudmFyIF9zaGFsbG93RXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhbGxvd0VxdWFsKTtcblxudmFyIF93cmFwQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuLi91dGlscy93cmFwQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF93cmFwQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbiAgcmV0dXJuIHt9O1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiB7IGRpc3BhdGNoOiBkaXNwYXRjaCB9O1xufTtcbnZhciBkZWZhdWx0TWVyZ2VQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgcGFyZW50UHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkge1xuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59XG5cbnZhciBlcnJvck9iamVjdCA9IHsgdmFsdWU6IG51bGwgfTtcbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBjdHgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY3R4KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yT2JqZWN0LnZhbHVlID0gZTtcbiAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gIH1cbn1cblxuLy8gSGVscHMgdHJhY2sgaG90IHJlbG9hZGluZy5cbnZhciBuZXh0VmVyc2lvbiA9IDA7XG5cbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICB2YXIgc2hvdWxkU3Vic2NyaWJlID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICB2YXIgbWFwU3RhdGUgPSBtYXBTdGF0ZVRvUHJvcHMgfHwgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcztcblxuICB2YXIgbWFwRGlzcGF0Y2ggPSB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFwRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSBpZiAoIW1hcERpc3BhdGNoVG9Qcm9wcykge1xuICAgIG1hcERpc3BhdGNoID0gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcztcbiAgfSBlbHNlIHtcbiAgICBtYXBEaXNwYXRjaCA9ICgwLCBfd3JhcEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl0pKG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIH1cblxuICB2YXIgZmluYWxNZXJnZVByb3BzID0gbWVyZ2VQcm9wcyB8fCBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgdmFyIF9vcHRpb25zJHB1cmUgPSBvcHRpb25zLnB1cmU7XG4gIHZhciBwdXJlID0gX29wdGlvbnMkcHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJHB1cmU7XG4gIHZhciBfb3B0aW9ucyR3aXRoUmVmID0gb3B0aW9ucy53aXRoUmVmO1xuICB2YXIgd2l0aFJlZiA9IF9vcHRpb25zJHdpdGhSZWYgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkd2l0aFJlZjtcblxuICB2YXIgY2hlY2tNZXJnZWRFcXVhbHMgPSBwdXJlICYmIGZpbmFsTWVyZ2VQcm9wcyAhPT0gZGVmYXVsdE1lcmdlUHJvcHM7XG5cbiAgLy8gSGVscHMgdHJhY2sgaG90IHJlbG9hZGluZy5cbiAgdmFyIHZlcnNpb24gPSBuZXh0VmVyc2lvbisrO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHZhciBjb25uZWN0RGlzcGxheU5hbWUgPSAnQ29ubmVjdCgnICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG5cbiAgICBmdW5jdGlvbiBjaGVja1N0YXRlU2hhcGUocHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKHByb3BzKSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkobWV0aG9kTmFtZSArICcoKSBpbiAnICsgY29ubmVjdERpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gJyArICgnSW5zdGVhZCByZWNlaXZlZCAnICsgcHJvcHMgKyAnLicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVyZ2VkUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpIHtcbiAgICAgIHZhciBtZXJnZWRQcm9wcyA9IGZpbmFsTWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja1N0YXRlU2hhcGUobWVyZ2VkUHJvcHMsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIENvbm5lY3QgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKENvbm5lY3QsIF9Db21wb25lbnQpO1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiAhcHVyZSB8fCB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgfHwgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdG9yZSA9IHByb3BzLnN0b3JlIHx8IGNvbnRleHQuc3RvcmU7XG5cbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gZWl0aGVyIHRoZSBjb250ZXh0IG9yICcgKyAoJ3Byb3BzIG9mIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4gJykgKyAnRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJyArICgnb3IgZXhwbGljaXRseSBwYXNzIFwic3RvcmVcIiBhcyBhIHByb3AgdG8gXCInICsgY29ubmVjdERpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICB2YXIgc3RvcmVTdGF0ZSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH07XG4gICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlU3RhdGVQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVTdGF0ZVByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgc3RhdGVQcm9wcyA9IHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKHN0YXRlUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUgPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkU3RhdGUgPSBtYXBTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBwcm9wcyk7XG4gICAgICAgIHZhciBpc0ZhY3RvcnkgPSB0eXBlb2YgbWFwcGVkU3RhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IGlzRmFjdG9yeSA/IG1hcHBlZFN0YXRlIDogbWFwU3RhdGU7XG4gICAgICAgIHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA9IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMubGVuZ3RoICE9PSAxO1xuXG4gICAgICAgIGlmIChpc0ZhY3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUobWFwcGVkU3RhdGUsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkU3RhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlRGlzcGF0Y2hQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcblxuICAgICAgICB2YXIgZGlzcGF0Y2hQcm9wcyA9IHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKGRpc3BhdGNoUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2ggPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaChzdG9yZS5kaXNwYXRjaCwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZERpc3BhdGNoID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWREaXNwYXRjaCA6IG1hcERpc3BhdGNoO1xuICAgICAgICB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZURpc3BhdGNoUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZERpc3BhdGNoLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZERpc3BhdGNoO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSB0aGlzLmNvbXB1dGVTdGF0ZVByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRTdGF0ZVByb3BzLCB0aGlzLnN0YXRlUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dERpc3BhdGNoUHJvcHMgPSB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5kaXNwYXRjaFByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHREaXNwYXRjaFByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaFByb3BzID0gbmV4dERpc3BhdGNoUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBjb21wdXRlTWVyZ2VkUHJvcHModGhpcy5zdGF0ZVByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZWRQcm9wcyAmJiBjaGVja01lcmdlZEVxdWFscyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0TWVyZ2VkUHJvcHMsIHRoaXMubWVyZ2VkUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZSAmJiAhdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIXB1cmUgfHwgISgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRQcm9wcywgdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBwcmV2U3RvcmVTdGF0ZSA9IHRoaXMuc3RhdGUuc3RvcmVTdGF0ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcHJldlN0b3JlU3RhdGUgPT09IHN0b3JlU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHVyZSAmJiAhdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzKSB7XG4gICAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRyeUNhdGNoKHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIWhhdmVTdGF0ZVByb3BzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IGVycm9yT2JqZWN0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH0pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgICAoMCwgX2ludmFyaWFudDJbXCJkZWZhdWx0XCJdKSh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAneyB3aXRoUmVmOiB0cnVlIH0gYXMgdGhlIGZvdXJ0aCBhcmd1bWVudCBvZiB0aGUgY29ubmVjdCgpIGNhbGwuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBoYXZlT3duUHJvcHNDaGFuZ2VkID0gdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkO1xuICAgICAgICB2YXIgaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkO1xuICAgICAgICB2YXIgaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZDtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgdmFyIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMucmVuZGVyZWRFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcblxuICAgICAgICBpZiAoc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAocHVyZSAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gaGFzU3RvcmVTdGF0ZUNoYW5nZWQgfHwgaGF2ZU93blByb3BzQ2hhbmdlZCAmJiB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHM7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcyA9IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRVcGRhdGVTdGF0ZVByb3BzKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcykge1xuICAgICAgICAgIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0NoYW5nZWQgfHwgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkICYmIHJlbmRlcmVkRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShXcmFwcGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgdGhpcy5tZXJnZWRQcm9wcywge1xuICAgICAgICAgICAgcmVmOiAnd3JhcHBlZEluc3RhbmNlJ1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5tZXJnZWRQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZEVsZW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29ubmVjdDtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGNvbm5lY3REaXNwbGF5TmFtZTtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYXJlIGhvdCByZWxvYWRpbmchXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9ob2lzdE5vblJlYWN0U3RhdGljczJbXCJkZWZhdWx0XCJdKShDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9jb25uZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2hhbGxvd0VxdWFsO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd3JhcEFjdGlvbkNyZWF0b3JzO1xuXG52YXIgX3JlZHV4ID0gcmVxdWlyZSgncmVkdXgnKTtcblxuZnVuY3Rpb24gd3JhcEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gKDAsIF9yZWR1eC5iaW5kQWN0aW9uQ3JlYXRvcnMpKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX292ZXJBcmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcm91dGVyTWlkZGxld2FyZTtcblxudmFyIF9hY3Rpb25zID0gcmVxdWlyZSgnLi9hY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG4vKipcbiAqIFRoaXMgbWlkZGxld2FyZSBjYXB0dXJlcyBDQUxMX0hJU1RPUllfTUVUSE9EIGFjdGlvbnMgdG8gcmVkaXJlY3QgdG8gdGhlXG4gKiBwcm92aWRlZCBoaXN0b3J5IG9iamVjdC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlc2UgYWN0aW9ucyBmcm9tIHJlYWNoaW5nIHlvdXJcbiAqIHJlZHVjZXIgb3IgYW55IG1pZGRsZXdhcmUgdGhhdCBjb21lcyBhZnRlciB0aGlzIG9uZS5cbiAqL1xuZnVuY3Rpb24gcm91dGVyTWlkZGxld2FyZShoaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgIT09IF9hY3Rpb25zLkNBTExfSElTVE9SWV9NRVRIT0QpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9hY3Rpb24kcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB2YXIgbWV0aG9kID0gX2FjdGlvbiRwYXlsb2FkLm1ldGhvZDtcbiAgICAgICAgdmFyIGFyZ3MgPSBfYWN0aW9uJHBheWxvYWQuYXJncztcblxuICAgICAgICBoaXN0b3J5W21ldGhvZF0uYXBwbHkoaGlzdG9yeSwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL21pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gc3luY0hpc3RvcnlXaXRoU3RvcmU7XG5cbnZhciBfcmVkdWNlciA9IHJlcXVpcmUoJy4vcmVkdWNlcicpO1xuXG52YXIgZGVmYXVsdFNlbGVjdExvY2F0aW9uU3RhdGUgPSBmdW5jdGlvbiBkZWZhdWx0U2VsZWN0TG9jYXRpb25TdGF0ZShzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucm91dGluZztcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzeW5jaHJvbml6ZXMgeW91ciBoaXN0b3J5IHN0YXRlIHdpdGggdGhlIFJlZHV4IHN0b3JlLlxuICogTG9jYXRpb24gY2hhbmdlcyBmbG93IGZyb20gaGlzdG9yeSB0byB0aGUgc3RvcmUuIEFuIGVuaGFuY2VkIGhpc3RvcnkgaXNcbiAqIHJldHVybmVkIHdpdGggYSBsaXN0ZW4gbWV0aG9kIHRoYXQgcmVzcG9uZHMgdG8gc3RvcmUgdXBkYXRlcyBmb3IgbG9jYXRpb24uXG4gKlxuICogV2hlbiB0aGlzIGhpc3RvcnkgaXMgcHJvdmlkZWQgdG8gdGhlIHJvdXRlciwgdGhpcyBtZWFucyB0aGUgbG9jYXRpb24gZGF0YVxuICogd2lsbCBmbG93IGxpa2UgdGhpczpcbiAqIGhpc3RvcnkucHVzaCAtPiBzdG9yZS5kaXNwYXRjaCAtPiBlbmhhbmNlZEhpc3RvcnkubGlzdGVuIC0+IHJvdXRlclxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiB0aGUgc3RvcmUgc3RhdGUgY2hhbmdlcyBkdWUgdG8gYSByZXBsYXkgb3Igb3RoZXJcbiAqIGV2ZW50LCB0aGUgcm91dGVyIHdpbGwgYmUgdXBkYXRlZCBhcHByb3ByaWF0ZWx5IGFuZCBjYW4gdHJhbnNpdGlvbiB0byB0aGVcbiAqIGNvcnJlY3Qgcm91dGVyIHN0YXRlLlxuICovXG5mdW5jdGlvbiBzeW5jSGlzdG9yeVdpdGhTdG9yZShoaXN0b3J5LCBzdG9yZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBfcmVmJHNlbGVjdExvY2F0aW9uU3QgPSBfcmVmLnNlbGVjdExvY2F0aW9uU3RhdGU7XG4gIHZhciBzZWxlY3RMb2NhdGlvblN0YXRlID0gX3JlZiRzZWxlY3RMb2NhdGlvblN0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0U2VsZWN0TG9jYXRpb25TdGF0ZSA6IF9yZWYkc2VsZWN0TG9jYXRpb25TdDtcbiAgdmFyIF9yZWYkYWRqdXN0VXJsT25SZXBsYSA9IF9yZWYuYWRqdXN0VXJsT25SZXBsYXk7XG4gIHZhciBhZGp1c3RVcmxPblJlcGxheSA9IF9yZWYkYWRqdXN0VXJsT25SZXBsYSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkYWRqdXN0VXJsT25SZXBsYTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgcmVkdWNlciBpcyBtb3VudGVkIG9uIHRoZSBzdG9yZSBhbmQgZnVuY3Rpb25pbmcgcHJvcGVybHkuXG4gIGlmICh0eXBlb2Ygc2VsZWN0TG9jYXRpb25TdGF0ZShzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByb3V0aW5nIHN0YXRlIHRvIGJlIGF2YWlsYWJsZSBlaXRoZXIgYXMgYHN0YXRlLnJvdXRpbmdgICcgKyAnb3IgYXMgdGhlIGN1c3RvbSBleHByZXNzaW9uIHlvdSBjYW4gc3BlY2lmeSBhcyBgc2VsZWN0TG9jYXRpb25TdGF0ZWAgJyArICdpbiB0aGUgYHN5bmNIaXN0b3J5V2l0aFN0b3JlKClgIG9wdGlvbnMuICcgKyAnRW5zdXJlIHlvdSBoYXZlIGFkZGVkIHRoZSBgcm91dGVyUmVkdWNlcmAgdG8geW91ciBzdG9yZVxcJ3MgJyArICdyZWR1Y2VycyB2aWEgYGNvbWJpbmVSZWR1Y2Vyc2Agb3Igd2hhdGV2ZXIgbWV0aG9kIHlvdSB1c2UgdG8gaXNvbGF0ZSAnICsgJ3lvdXIgcmVkdWNlcnMuJyk7XG4gIH1cblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gdm9pZCAwO1xuICB2YXIgaXNUaW1lVHJhdmVsaW5nID0gdm9pZCAwO1xuICB2YXIgdW5zdWJzY3JpYmVGcm9tU3RvcmUgPSB2b2lkIDA7XG4gIHZhciB1bnN1YnNjcmliZUZyb21IaXN0b3J5ID0gdm9pZCAwO1xuXG4gIC8vIFdoYXQgZG9lcyB0aGUgc3RvcmUgc2F5IGFib3V0IGN1cnJlbnQgbG9jYXRpb24/XG4gIHZhciBnZXRMb2NhdGlvbkluU3RvcmUgPSBmdW5jdGlvbiBnZXRMb2NhdGlvbkluU3RvcmUodXNlSW5pdGlhbElmRW1wdHkpIHtcbiAgICB2YXIgbG9jYXRpb25TdGF0ZSA9IHNlbGVjdExvY2F0aW9uU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgcmV0dXJuIGxvY2F0aW9uU3RhdGUubG9jYXRpb25CZWZvcmVUcmFuc2l0aW9ucyB8fCAodXNlSW5pdGlhbElmRW1wdHkgPyBpbml0aWFsTG9jYXRpb24gOiB1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8vIEluaXQgY3VycmVudExvY2F0aW9uIHdpdGggcG90ZW50aWFsIGxvY2F0aW9uIGluIHN0b3JlXG4gIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRMb2NhdGlvbkluU3RvcmUoKTtcblxuICAvLyBJZiB0aGUgc3RvcmUgaXMgcmVwbGF5ZWQsIHVwZGF0ZSB0aGUgVVJMIGluIHRoZSBicm93c2VyIHRvIG1hdGNoLlxuICBpZiAoYWRqdXN0VXJsT25SZXBsYXkpIHtcbiAgICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTdG9yZUNoYW5nZSgpIHtcbiAgICAgIHZhciBsb2NhdGlvbkluU3RvcmUgPSBnZXRMb2NhdGlvbkluU3RvcmUodHJ1ZSk7XG4gICAgICBpZiAoY3VycmVudExvY2F0aW9uID09PSBsb2NhdGlvbkluU3RvcmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgYWRkcmVzcyBiYXIgdG8gcmVmbGVjdCBzdG9yZSBzdGF0ZVxuICAgICAgaXNUaW1lVHJhdmVsaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uSW5TdG9yZTtcbiAgICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBsb2NhdGlvbkluU3RvcmUsIHtcbiAgICAgICAgYWN0aW9uOiAnUFVTSCdcbiAgICAgIH0pKTtcbiAgICAgIGlzVGltZVRyYXZlbGluZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB1bnN1YnNjcmliZUZyb21TdG9yZSA9IHN0b3JlLnN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG4gICAgaGFuZGxlU3RvcmVDaGFuZ2UoKTtcbiAgfVxuXG4gIC8vIFdoZW5ldmVyIGxvY2F0aW9uIGNoYW5nZXMsIGRpc3BhdGNoIGFuIGFjdGlvbiB0byBnZXQgaXQgaW4gdGhlIHN0b3JlXG4gIHZhciBoYW5kbGVMb2NhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvY2F0aW9uQ2hhbmdlKGxvY2F0aW9uKSB7XG4gICAgLy8gLi4uIHVubGVzcyB3ZSBqdXN0IGNhdXNlZCB0aGF0IGxvY2F0aW9uIGNoYW5nZVxuICAgIGlmIChpc1RpbWVUcmF2ZWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1lbWJlciB3aGVyZSB3ZSBhcmVcbiAgICBjdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICAgIC8vIEFyZSB3ZSBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lP1xuICAgIGlmICghaW5pdGlhbExvY2F0aW9uKSB7XG4gICAgICAvLyBSZW1lbWJlciBhcyBhIGZhbGxiYWNrIGluIGNhc2Ugc3RhdGUgaXMgcmVzZXRcbiAgICAgIGluaXRpYWxMb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gICAgICAvLyBSZXNwZWN0IHBlcnNpc3RlZCBsb2NhdGlvbiwgaWYgYW55XG4gICAgICBpZiAoZ2V0TG9jYXRpb25JblN0b3JlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRlbGwgdGhlIHN0b3JlIHRvIHVwZGF0ZSBieSBkaXNwYXRjaGluZyBhbiBhY3Rpb25cbiAgICBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBfcmVkdWNlci5MT0NBVElPTl9DSEFOR0UsXG4gICAgICBwYXlsb2FkOiBsb2NhdGlvblxuICAgIH0pO1xuICB9O1xuICB1bnN1YnNjcmliZUZyb21IaXN0b3J5ID0gaGlzdG9yeS5saXN0ZW4oaGFuZGxlTG9jYXRpb25DaGFuZ2UpO1xuXG4gIC8vIFRoZSBlbmhhbmNlZCBoaXN0b3J5IHVzZXMgc3RvcmUgYXMgc291cmNlIG9mIHRydXRoXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIC8vIFRoZSBsaXN0ZW5lcnMgYXJlIHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlIGluc3RlYWQgb2YgaGlzdG9yeVxuXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIC8vIENvcHkgb2YgbGFzdCBsb2NhdGlvbi5cbiAgICAgIHZhciBsYXN0UHVibGlzaGVkTG9jYXRpb24gPSBnZXRMb2NhdGlvbkluU3RvcmUodHJ1ZSk7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciB3ZSB1bnN1YnNjcmliZWQsIGFzIFJlZHV4IHN0b3JlXG4gICAgICAvLyBvbmx5IGFwcGxpZXMgY2hhbmdlcyBpbiBzdWJzY3JpcHRpb25zIG9uIG5leHQgZGlzcGF0Y2hcbiAgICAgIHZhciB1bnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHZhciB1bnN1YnNjcmliZUZyb21TdG9yZSA9IHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRMb2NhdGlvbkluU3RvcmUodHJ1ZSk7XG4gICAgICAgIGlmIChjdXJyZW50TG9jYXRpb24gPT09IGxhc3RQdWJsaXNoZWRMb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UHVibGlzaGVkTG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG4gICAgICAgIGlmICghdW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgbGlzdGVuZXIobGFzdFB1Ymxpc2hlZExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEhpc3RvcnkgbGlzdGVuZXJzIGV4cGVjdCBhIHN5bmNocm9ub3VzIGNhbGwuIE1ha2UgdGhlIGZpcnN0IGNhbGwgdG8gdGhlXG4gICAgICAvLyBsaXN0ZW5lciBhZnRlciBzdWJzY3JpYmluZyB0byB0aGUgc3RvcmUsIGluIGNhc2UgdGhlIGxpc3RlbmVyIGNhdXNlcyBhXG4gICAgICAvLyBsb2NhdGlvbiBjaGFuZ2UgKGUuZy4gd2hlbiBpdCByZWRpcmVjdHMpXG4gICAgICBsaXN0ZW5lcihsYXN0UHVibGlzaGVkTG9jYXRpb24pO1xuXG4gICAgICAvLyBMZXQgdXNlciB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdW5zdWJzY3JpYmVGcm9tU3RvcmUoKTtcbiAgICAgIH07XG4gICAgfSxcblxuXG4gICAgLy8gSXQgYWxzbyBwcm92aWRlcyBhIHdheSB0byBkZXN0cm95IGludGVybmFsIGxpc3RlbmVyc1xuICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmIChhZGp1c3RVcmxPblJlcGxheSkge1xuICAgICAgICB1bnN1YnNjcmliZUZyb21TdG9yZSgpO1xuICAgICAgfVxuICAgICAgdW5zdWJzY3JpYmVGcm9tSGlzdG9yeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9zeW5jLmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBtaXhpbiB0aGF0IGFkZHMgdGhlIFwiaGlzdG9yeVwiIGluc3RhbmNlIHZhcmlhYmxlIHRvIGNvbXBvbmVudHMuXG4gKi9cbnZhciBIaXN0b3J5ID0ge1xuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IF9JbnRlcm5hbFByb3BUeXBlcy5oaXN0b3J5XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICd0aGUgYEhpc3RvcnlgIG1peGluIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBhY2Nlc3MgYGNvbnRleHQucm91dGVyYCB3aXRoIHlvdXIgb3duIGBjb250ZXh0VHlwZXNgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaGlzdG9yeW1peGluJykgOiB2b2lkIDA7XG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5jb250ZXh0Lmhpc3Rvcnk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xpbmsgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmspO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIDxJbmRleExpbms+IGlzIHVzZWQgdG8gbGluayB0byBhbiA8SW5kZXhSb3V0ZT4uXG4gKi9cbnZhciBJbmRleExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4TGluaycsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTGluazIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgb25seUFjdGl2ZU9uSW5kZXg6IHRydWUgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JlZGlyZWN0ID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0KTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEFuIDxJbmRleFJlZGlyZWN0PiBpcyB1c2VkIHRvIHJlZGlyZWN0IGZyb20gYW4gaW5kZXhSb3V0ZS5cbiAqL1xuXG52YXIgSW5kZXhSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gX1JlZGlyZWN0Mi5kZWZhdWx0LmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4UmVkaXJlY3Q+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJlZGlyZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJlZGlyZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEFuIDxJbmRleFJvdXRlPiBpcyB1c2VkIHRvIHNwZWNpZnkgaXRzIHBhcmVudCdzIDxSb3V0ZSBpbmRleFJvdXRlPiBpblxuICogYSBKU1ggcm91dGUgY29uZmlnLlxuICovXG5cbnZhciBJbmRleFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJvdXRlJyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4Um91dGU+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJvdXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJvdXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG9iamVjdCA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIFRoZSBMaWZlY3ljbGUgbWl4aW4gYWRkcyB0aGUgcm91dGVyV2lsbExlYXZlIGxpZmVjeWNsZSBtZXRob2QgdG8gYVxuICogY29tcG9uZW50IHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIGEgdHJhbnNpdGlvbiBvciBwcm9tcHQgdGhlIHVzZXJcbiAqIGZvciBjb25maXJtYXRpb24uXG4gKlxuICogT24gc3RhbmRhcmQgdHJhbnNpdGlvbnMsIHJvdXRlcldpbGxMZWF2ZSByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlXG4gKiBsb2NhdGlvbiB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvLiBUbyBjYW5jZWwgdGhlIHRyYW5zaXRpb24sIHJldHVybiBmYWxzZS5cbiAqIFRvIHByb21wdCB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKS5cbiAqXG4gKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoYXNzdW1pbmcgeW91J3JlIHVzaW5nIHRoZSB1c2VCZWZvcmVVbmxvYWRcbiAqIGhpc3RvcnkgZW5oYW5jZXIpLCByb3V0ZXJXaWxsTGVhdmUgZG9lcyBub3QgcmVjZWl2ZSBhIGxvY2F0aW9uIG9iamVjdFxuICogYmVjYXVzZSBpdCBpc24ndCBwb3NzaWJsZSBmb3IgdXMgdG8ga25vdyB0aGUgbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZ1xuICogdG8uIEluIHRoaXMgY2FzZSByb3V0ZXJXaWxsTGVhdmUgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50XG4gKiB0aGUgdXNlciBmcm9tIGNsb3NpbmcgdGhlIHdpbmRvdy90YWIuXG4gKi9cblxudmFyIExpZmVjeWNsZSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICAvLyBOZXN0ZWQgY2hpbGRyZW4gcmVjZWl2ZSB0aGUgcm91dGUgYXMgY29udGV4dCwgZWl0aGVyXG4gICAgLy8gc2V0IGJ5IHRoZSByb3V0ZSBjb21wb25lbnQgdXNpbmcgdGhlIFJvdXRlQ29udGV4dCBtaXhpblxuICAgIC8vIG9yIGJ5IHNvbWUgb3RoZXIgYW5jZXN0b3IuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIC8vIFJvdXRlIGNvbXBvbmVudHMgcmVjZWl2ZSB0aGUgcm91dGUgb2JqZWN0IGFzIGEgcHJvcC5cbiAgICByb3V0ZTogb2JqZWN0XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBMaWZlY3ljbGVgIG1peGluIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGNvbnRleHQucm91dGVyLnNldFJvdXRlTGVhdmVIb29rKHJvdXRlLCBob29rKWAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1saWZlY3ljbGVtaXhpbicpIDogdm9pZCAwO1xuICAgICF0aGlzLnJvdXRlcldpbGxMZWF2ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgTGlmZWN5Y2xlIG1peGluIHJlcXVpcmVzIHlvdSB0byBkZWZpbmUgYSByb3V0ZXJXaWxsTGVhdmUgbWV0aG9kJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJvdXRlID0gdGhpcy5wcm9wcy5yb3V0ZSB8fCB0aGlzLmNvbnRleHQucm91dGU7XG5cbiAgICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiBtdXN0IGJlIHVzZWQgb24gZWl0aGVyIGEpIGEgPFJvdXRlIGNvbXBvbmVudD4gb3IgJyArICdiKSBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGUgY29tcG9uZW50PiB0aGF0IHVzZXMgdGhlIFJvdXRlQ29udGV4dCBtaXhpbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlID0gdGhpcy5jb250ZXh0Lmhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCB0aGlzLnJvdXRlcldpbGxMZWF2ZSk7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUpIHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpZmVjeWNsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEEgPFJvdXRlPiBpcyB1c2VkIHRvIGRlY2xhcmUgd2hpY2ggY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgdG8gdGhlXG4gKiBwYWdlIHdoZW4gdGhlIFVSTCBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybi5cbiAqXG4gKiBSb3V0ZXMgYXJlIGFycmFuZ2VkIGluIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlLiBXaGVuIGEgbmV3IFVSTCBpc1xuICogcmVxdWVzdGVkLCB0aGUgdHJlZSBpcyBzZWFyY2hlZCBkZXB0aC1maXJzdCB0byBmaW5kIGEgcm91dGUgd2hvc2VcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcbiAqIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZCBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZVxuICogcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaW4gdGhlIHRyZWUuXG4gKi9cblxudmFyIFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnRcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb2JqZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogVGhlIFJvdXRlQ29udGV4dCBtaXhpbiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IGZvciByb3V0ZVxuICogY29tcG9uZW50cyB0byBzZXQgdGhlIHJvdXRlIGluIGNvbnRleHQuIFRoaXMgaXMgbmVlZGVkIGZvclxuICogcm91dGVzIHRoYXQgcmVuZGVyIGVsZW1lbnRzIHRoYXQgd2FudCB0byB1c2UgdGhlIExpZmVjeWNsZVxuICogbWl4aW4gdG8gcHJldmVudCB0cmFuc2l0aW9ucy5cbiAqL1xuXG52YXIgUm91dGVDb250ZXh0ID0ge1xuXG4gIHByb3BUeXBlczoge1xuICAgIHJvdXRlOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlOiB0aGlzLnByb3BzLnJvdXRlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdUaGUgYFJvdXRlQ29udGV4dGAgbWl4aW4gaXMgZGVwcmVjYXRlZC4gWW91IGNhbiBwcm92aWRlIGB0aGlzLnByb3BzLnJvdXRlYCBvbiBjb250ZXh0IHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1yb3V0ZWNvbnRleHRtaXhpbicpIDogdm9pZCAwO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgcmV0dXJuICFoaXN0b3J5IHx8ICFoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIC8vIHYzIGhpc3RvcmllcyBleHBvc2UgZ2V0Q3VycmVudExvY2F0aW9uLCBidXQgYXJlbid0IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gIHJldHVybiBoaXN0b3J5ICYmIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uO1xufVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxuICogYSByb3V0ZXIgdGhhdCByZW5kZXJzIGEgPFJvdXRlckNvbnRleHQ+IHdpdGggYWxsIHRoZSBwcm9wc1xuICogaXQgbmVlZHMgZWFjaCB0aW1lIHRoZSBVUkwgY2hhbmdlcy5cbiAqL1xuXG52YXIgUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLFxuICAgIHJvdXRlczogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcywgLy8gYWxpYXMgZm9yIGNoaWxkcmVuXG4gICAgcmVuZGVyOiBmdW5jLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMsXG4gICAgb25FcnJvcjogZnVuYyxcbiAgICBvblVwZGF0ZTogZnVuYyxcblxuICAgIC8vIERlcHJlY2F0ZWQ6XG4gICAgcGFyc2VRdWVyeVN0cmluZzogZnVuYyxcbiAgICBzdHJpbmdpZnlRdWVyeTogZnVuYyxcblxuICAgIC8vIFBSSVZBVEU6IEZvciBjbGllbnQtc2lkZSByZWh5ZHJhdGlvbiBvZiBzZXJ2ZXIgbWF0Y2guXG4gICAgbWF0Y2hDb250ZXh0OiBvYmplY3RcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgcm91dGVzOiBudWxsLFxuICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgY29tcG9uZW50czogbnVsbFxuICAgIH07XG4gIH0sXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnByb3BzLm9uRXJyb3IpIHtcbiAgICAgIHRoaXMucHJvcHMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhyb3cgZXJyb3JzIGJ5IGRlZmF1bHQgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyB0aGVtIVxuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb2NjdXJyZWQgaW4gZ2V0Q2hpbGRSb3V0ZXMgb3IgZ2V0Q29tcG9uZW50cy5cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wcy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wcy5zdHJpbmdpZnlRdWVyeTtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocGFyc2VRdWVyeVN0cmluZyB8fCBzdHJpbmdpZnlRdWVyeSksICdgcGFyc2VRdWVyeVN0cmluZ2AgYW5kIGBzdHJpbmdpZnlRdWVyeWAgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSBjcmVhdGUgYSBjdXN0b20gaGlzdG9yeS4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWN1c3RvbXF1ZXJ5c3RyaW5nJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgX2NyZWF0ZVJvdXRlck9iamVjdHMgPSB0aGlzLmNyZWF0ZVJvdXRlck9iamVjdHMoKTtcblxuICAgIHZhciBoaXN0b3J5ID0gX2NyZWF0ZVJvdXRlck9iamVjdHMuaGlzdG9yeTtcbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy50cmFuc2l0aW9uTWFuYWdlcjtcbiAgICB2YXIgcm91dGVyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMucm91dGVyO1xuXG5cbiAgICB0aGlzLl91bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIF90aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIH0sXG4gIGNyZWF0ZVJvdXRlck9iamVjdHM6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdHMoKSB7XG4gICAgdmFyIG1hdGNoQ29udGV4dCA9IHRoaXMucHJvcHMubWF0Y2hDb250ZXh0O1xuXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG1hdGNoQ29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW47XG5cblxuICAgICEhaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGhhdmUgcHJvdmlkZWQgYSBoaXN0b3J5IG9iamVjdCBjcmVhdGVkIHdpdGggaGlzdG9yeSB2My54LiAnICsgJ1RoaXMgdmVyc2lvbiBvZiBSZWFjdCBSb3V0ZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB2MyBoaXN0b3J5ICcgKyAnb2JqZWN0cy4gUGxlYXNlIHVzZSBoaXN0b3J5IHYyLnggaW5zdGVhZC4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSkge1xuICAgICAgaGlzdG9yeSA9IHRoaXMud3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcyB8fCBjaGlsZHJlbikpO1xuICAgIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICAgIHZhciByb3V0aW5nSGlzdG9yeSA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IHJvdXRpbmdIaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIHdyYXBEZXByZWNhdGVkSGlzdG9yeTogZnVuY3Rpb24gd3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMzLnBhcnNlUXVlcnlTdHJpbmc7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gX3Byb3BzMy5zdHJpbmdpZnlRdWVyeTtcblxuXG4gICAgdmFyIGNyZWF0ZUhpc3RvcnkgPSB2b2lkIDA7XG4gICAgaWYgKGhpc3RvcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSXQgYXBwZWFycyB5b3UgaGF2ZSBwcm92aWRlZCBhIGRlcHJlY2F0ZWQgaGlzdG9yeSBvYmplY3QgdG8gYDxSb3V0ZXIvPmAsIHBsZWFzZSB1c2UgYSBoaXN0b3J5IHByb3ZpZGVkIGJ5ICcgKyAnUmVhY3QgUm91dGVyIHdpdGggYGltcG9ydCB7IGJyb3dzZXJIaXN0b3J5IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgIG9yIGBpbXBvcnQgeyBoYXNoSGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYC4gJyArICdJZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIGhpc3RvcnkgcGxlYXNlIGNyZWF0ZSBpdCB3aXRoIGB1c2VSb3V0ZXJIaXN0b3J5YCwgc2VlIGh0dHA6Ly90aW55LmNjL3JvdXRlci11c2luZ2hpc3RvcnkgZm9yIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2BSb3V0ZXJgIG5vIGxvbmdlciBkZWZhdWx0cyB0aGUgaGlzdG9yeSBwcm9wIHRvIGhhc2ggaGlzdG9yeS4gUGxlYXNlIHVzZSB0aGUgYGhhc2hIaXN0b3J5YCBzaW5nbGV0b24gaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWRlZmF1bHRoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKHsgcGFyc2VRdWVyeVN0cmluZzogcGFyc2VRdWVyeVN0cmluZywgc3RyaW5naWZ5UXVlcnk6IHN0cmluZ2lmeVF1ZXJ5IH0pO1xuICB9LFxuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG5leHRQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKChuZXh0UHJvcHMucm91dGVzIHx8IG5leHRQcm9wcy5jaGlsZHJlbikgPT09ICh0aGlzLnByb3BzLnJvdXRlcyB8fCB0aGlzLnByb3BzLmNoaWxkcmVuKSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgcm91dGVzPjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW4pIHRoaXMuX3VubGlzdGVuKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBsb2NhdGlvbiA9IF9zdGF0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3N0YXRlLnJvdXRlcztcbiAgICB2YXIgcGFyYW1zID0gX3N0YXRlLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9zdGF0ZS5jb21wb25lbnRzO1xuICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY3JlYXRlRWxlbWVudCA9IF9wcm9wczQuY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgcmVuZGVyID0gX3Byb3BzNC5yZW5kZXI7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzNCwgWydjcmVhdGVFbGVtZW50JywgJ3JlbmRlciddKTtcblxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gQXN5bmMgbWF0Y2hcblxuICAgIC8vIE9ubHkgZm9yd2FyZCBub24tUm91dGVyLXNwZWNpZmljIHByb3BzIHRvIHJvdXRpbmcgY29udGV4dCwgYXMgdGhvc2UgYXJlXG4gICAgLy8gdGhlIG9ubHkgb25lcyB0aGF0IG1pZ2h0IGJlIGN1c3RvbSByb3V0aW5nIGNvbnRleHQgcHJvcHMuXG4gICAgT2JqZWN0LmtleXMoUm91dGVyLnByb3BUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZWxldGUgcHJvcHNbcHJvcFR5cGVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXIsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRcbiAgICB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBSb3V0aW5nQ29udGV4dCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGluZ0NvbnRleHQnLFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2BSb3V0aW5nQ29udGV4dGAgaGFzIGJlZW4gcmVuYW1lZCB0byBgUm91dGVyQ29udGV4dGAuIFBsZWFzZSB1c2UgYGltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1yb3V0ZXJjb250ZXh0JykgOiB2b2lkIDA7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgdGhpcy5wcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0aW5nQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGluZ0NvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucnVuRW50ZXJIb29rcyA9IHJ1bkVudGVySG9va3M7XG5leHBvcnRzLnJ1bkNoYW5nZUhvb2tzID0gcnVuQ2hhbmdlSG9va3M7XG5leHBvcnRzLnJ1bkxlYXZlSG9va3MgPSBydW5MZWF2ZUhvb2tzO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbkhvb2soaG9vaywgcm91dGUsIGFzeW5jQXJpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBob29rLmFwcGx5KHJvdXRlLCBhcmdzKTtcblxuICAgIGlmIChob29rLmxlbmd0aCA8IGFzeW5jQXJpdHkpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIC8vIEFzc3VtZSBob29rIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHkgYW5kXG4gICAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGwgdGhlIGNhbGxiYWNrLlxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEVudGVySG9va3Mocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICBpZiAocm91dGUub25FbnRlcikgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkVudGVyLCByb3V0ZSwgMykpO1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5nZUhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uQ2hhbmdlKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uQ2hhbmdlLCByb3V0ZSwgNCkpO1xuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9va3MobGVuZ3RoLCBpdGVyLCBjYWxsYmFjaykge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlZGlyZWN0SW5mbyA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbiwgZGVwcmVjYXRlZFBhdGhuYW1lLCBkZXByZWNhdGVkUXVlcnkpIHtcbiAgICBpZiAoZGVwcmVjYXRlZFBhdGhuYW1lKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2ByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGhuYW1lLCBxdWVyeSkgaXMgZGVwcmVjYXRlZDsgdXNlIGByZXBsYWNlKGxvY2F0aW9uKWAgd2l0aCBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdm9pZCAwO1xuICAgICAgcmVkaXJlY3RJbmZvID0ge1xuICAgICAgICBwYXRobmFtZTogZGVwcmVjYXRlZFBhdGhuYW1lLFxuICAgICAgICBxdWVyeTogZGVwcmVjYXRlZFF1ZXJ5LFxuICAgICAgICBzdGF0ZTogbG9jYXRpb25cbiAgICAgIH07XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWRpcmVjdEluZm8gPSBsb2NhdGlvbjtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKGxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgaXRlcihpbmRleCwgcmVwbGFjZSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIHJlZGlyZWN0SW5mbyk7IC8vIE5vIG5lZWQgdG8gY29udGludWUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkVudGVyIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25FbnRlcihuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuRW50ZXJIb29rcyhyb3V0ZXMsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGhvb2tzID0gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpO1xuICByZXR1cm4gcnVuVHJhbnNpdGlvbkhvb2tzKGhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlLCBuZXh0KSB7XG4gICAgaG9va3NbaW5kZXhdKG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkNoYW5nZSBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uQ2hhbmdlKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkNoYW5nZUhvb2tzKHJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGhvb2tzID0gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShzdGF0ZSwgbmV4dFN0YXRlLCByZXBsYWNlLCBuZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uTGVhdmUgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gcnVuTGVhdmVIb29rcyhyb3V0ZXMsIHByZXZTdGF0ZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHJvdXRlc1tpXS5vbkxlYXZlKSByb3V0ZXNbaV0ub25MZWF2ZS5jYWxsKHJvdXRlc1tpXSwgcHJldlN0YXRlKTtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaChmdW5jdGlvbiAobWlkZGxld2FyZSwgaW5kZXgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dCB8fCBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50LCAnVGhlIG1pZGRsZXdhcmUgc3BlY2lmaWVkIGF0IGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgYXBwZWFyIHRvIGJlICcgKyAnYSB2YWxpZCBSZWFjdCBSb3V0ZXIgbWlkZGxld2FyZS4nKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aXRoQ29udGV4dCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgdmFyIHdpdGhDb21wb25lbnQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHZhciBtYWtlQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIG1ha2VDcmVhdGVFbGVtZW50KCkge1xuICAgIHZhciBiYXNlQ3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IF9yZWFjdC5jcmVhdGVFbGVtZW50IDogYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcykge1xuICAgICAgcmV0dXJuIHdpdGhDb21wb25lbnQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyUm91dGVDb21wb25lbnQocHJldmlvdXMsIHByb3BzKTtcbiAgICAgIH0sIGJhc2VDcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gd2l0aENvbnRleHQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZXJDb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVuZGVyUm91dGVyQ29udGV4dChwcmV2aW91cywgcmVuZGVyUHJvcHMpO1xuICAgIH0sIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgcmVuZGVyUHJvcHMsIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IG1ha2VDcmVhdGVFbGVtZW50KHJlbmRlclByb3BzLmNyZWF0ZUVsZW1lbnQpXG4gICAgfSkpKTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSb3V0ZXJIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShfY3JlYXRlQnJvd3Nlckhpc3RvcnkyLmRlZmF1bHQpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKTtcblxuICByZXR1cm4gcGFyYW1OYW1lcy5zb21lKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICByZXR1cm4gcHJldlN0YXRlLnBhcmFtc1twYXJhbU5hbWVdICE9PSBuZXh0U3RhdGUucGFyYW1zW3BhcmFtTmFtZV07XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHsgbGVhdmVSb3V0ZXMsIGNoYW5nZVJvdXRlcywgZW50ZXJSb3V0ZXMgfSBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgY2hhbmdlIGZyb20gcHJldlN0YXRlIHRvIG5leHRTdGF0ZS4gV2UgbGVhdmUgcm91dGVzIGlmIGVpdGhlclxuICogMSkgdGhleSBhcmUgbm90IGluIHRoZSBuZXh0IHN0YXRlIG9yIDIpIHRoZXkgYXJlIGluIHRoZSBuZXh0IHN0YXRlXG4gKiBidXQgdGhlaXIgcGFyYW1zIGhhdmUgY2hhbmdlZCAoaS5lLiAvdXNlcnMvMTIzID0+IC91c2Vycy80NTYpLlxuICpcbiAqIGxlYXZlUm91dGVzIGFyZSBvcmRlcmVkIHN0YXJ0aW5nIGF0IHRoZSBsZWFmIHJvdXRlIG9mIHRoZSB0cmVlXG4gKiB3ZSdyZSBsZWF2aW5nIHVwIHRvIHRoZSBjb21tb24gcGFyZW50IHJvdXRlLiBlbnRlclJvdXRlcyBhcmUgb3JkZXJlZFxuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB0cmVlIHdlJ3JlIGVudGVyaW5nIGRvd24gdG8gdGhlIGxlYWYgcm91dGUuXG4gKlxuICogY2hhbmdlUm91dGVzIGFyZSBhbnkgcm91dGVzIHRoYXQgZGlkbid0IGxlYXZlIG9yIGVudGVyIGR1cmluZ1xuICogdGhlIHRyYW5zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUm91dGVzKHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIHZhciBwcmV2Um91dGVzID0gcHJldlN0YXRlICYmIHByZXZTdGF0ZS5yb3V0ZXM7XG4gIHZhciBuZXh0Um91dGVzID0gbmV4dFN0YXRlLnJvdXRlcztcblxuICB2YXIgbGVhdmVSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBjaGFuZ2VSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBlbnRlclJvdXRlcyA9IHZvaWQgMDtcbiAgaWYgKHByZXZSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudElzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgbGVhdmVSb3V0ZXMgPSBwcmV2Um91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHBhcmVudElzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpc0xlYXZpbmcgPSBuZXh0Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMSB8fCByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoaXNMZWF2aW5nKSBwYXJlbnRJc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBpc0xlYXZpbmc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbkxlYXZlIGhvb2tzIHN0YXJ0IGF0IHRoZSBsZWFmIHJvdXRlLlxuICAgICAgbGVhdmVSb3V0ZXMucmV2ZXJzZSgpO1xuXG4gICAgICBlbnRlclJvdXRlcyA9IFtdO1xuICAgICAgY2hhbmdlUm91dGVzID0gW107XG5cbiAgICAgIG5leHRSb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdmFyIGlzTmV3ID0gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XG4gICAgICAgIHZhciBwYXJhbXNDaGFuZ2VkID0gbGVhdmVSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuXG4gICAgICAgIGlmIChpc05ldyB8fCBwYXJhbXNDaGFuZ2VkKSBlbnRlclJvdXRlcy5wdXNoKHJvdXRlKTtlbHNlIGNoYW5nZVJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgbGVhdmVSb3V0ZXMgPSBbXTtcbiAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcbiAgICBlbnRlclJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlYXZlUm91dGVzOiBsZWF2ZVJvdXRlcyxcbiAgICBjaGFuZ2VSb3V0ZXM6IGNoYW5nZVJvdXRlcyxcbiAgICBlbnRlclJvdXRlczogZW50ZXJSb3V0ZXNcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29tcHV0ZUNoYW5nZWRSb3V0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldENvbXBvbmVudCA9IHJvdXRlLmdldENvbXBvbmVudCB8fCByb3V0ZS5nZXRDb21wb25lbnRzO1xuICBpZiAoIWdldENvbXBvbmVudCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuXG4gIHZhciBuZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkobmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgZ2V0Q29tcG9uZW50LmNhbGwocm91dGUsIG5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGZldGNoZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciB0aGUgZ2l2ZW4gcm91dGVyXG4gKiBzdGF0ZSBhbmQgY2FsbHMgY2FsbGJhY2soZXJyb3IsIGNvbXBvbmVudHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q29tcG9uZW50cyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudHMobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAoMCwgX0FzeW5jVXRpbHMubWFwQXN5bmMpKG5leHRTdGF0ZS5yb3V0ZXMsIGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb21wb25lbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBvYmplY3Qgb2YgcGFyYW1zIHRoZSBnaXZlbiByb3V0ZSBjYXJlcyBhYm91dCBmcm9tXG4gKiB0aGUgZ2l2ZW4gcGFyYW1zIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91dGVQYXJhbXMocm91dGUsIHBhcmFtcykge1xuICB2YXIgcm91dGVQYXJhbXMgPSB7fTtcblxuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiByb3V0ZVBhcmFtcztcblxuICAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHApKSB7XG4gICAgICByb3V0ZVBhcmFtc1twXSA9IHBhcmFtc1twXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZVBhcmFtcztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Um91dGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzXG4gKiogbW9kdWxlIGlkID0gMTgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhhc2hIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSb3V0ZXJIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShfY3JlYXRlSGFzaEhpc3RvcnkyLmRlZmF1bHQpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9oYXNoSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNBY3RpdmU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcGF0aG5hbWUgbWF0Y2hlcyB0aGUgc3VwcGxpZWQgb25lLCBuZXQgb2ZcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cbiAqIGluZGV4T25seSByb3V0ZSBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcbiAgLy8gTm9ybWFsaXplIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5LiBMZWFkaW5nIHNsYXNoIG9uIHBhdGhuYW1lIGhhc1xuICAvLyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBpbiBpc0FjdGl2ZS4gU2VlIGNhdmVhdCB0aGVyZS5cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSA9ICcvJyArIGN1cnJlbnRQYXRobmFtZTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZW5kIG9mIGJvdGggcGF0aCBuYW1lcyB0b28uIE1heWJlIGAvZm9vL2Agc2hvdWxkbid0IHNob3dcbiAgLy8gYC9mb29gIGFzIGFjdGl2ZSwgYnV0IGluIHRoaXMgY2FzZSwgd2Ugd291bGQgYWxyZWFkeSBoYXZlIGZhaWxlZCB0aGVcbiAgLy8gbWF0Y2guXG4gIGlmIChwYXRobmFtZS5jaGFyQXQocGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lICs9ICcvJztcbiAgfVxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdChjdXJyZW50UGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBhdGhuYW1lID09PSBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXG4gICAgICBwYXJhbU5hbWVzID0gW10sXG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuXG4gIC8vIGZvci4uLm9mIHdvdWxkIHdvcmsgaGVyZSBidXQgaXQncyBwcm9iYWJseSBzbG93ZXIgcG9zdC10cmFuc3BpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBleGFjdCBtYXRjaCBvbiB0aGUgcm91dGUuIEp1c3QgY2hlY2sgdGhhdCBhbGwgdGhlIHBhcmFtc1xuICAgICAgICAvLyBtYXRjaC5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcy5cbiAgICAgICAgcmV0dXJuIHBhcmFtTmFtZXMuZXZlcnkoZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmLCBpbmRleE9ubHksIGN1cnJlbnRMb2NhdGlvbiwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZTtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IHVnbHkuIEl0IGtlZXBzIGFyb3VuZCBzdXBwb3J0IGZvciB0cmVhdGluZyBwYXRobmFtZXNcbiAgLy8gd2l0aG91dCBwcmVjZWRpbmcgc2xhc2hlcyBhcyBhYnNvbHV0ZSBwYXRocywgYnV0IHBvc3NpYmx5IGFsc28gd29ya3NcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIGlmICghcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoZSByb3V0ZXMuXG4gICAgaWYgKGluZGV4T25seSB8fCAhcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGN1cnJlbnRMb2NhdGlvbi5xdWVyeSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyBhIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBpbiBhIGJyb3dzZXIgdW5sZXNzIHlvdSdyZSB1c2luZ1xuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxuICovXG5mdW5jdGlvbiBtYXRjaChfcmVmLCBjYWxsYmFjaykge1xuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeTtcbiAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uO1xuXG4gIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaGlzdG9yeScsICdyb3V0ZXMnLCAnbG9jYXRpb24nXSk7XG5cbiAgIShoaXN0b3J5IHx8IGxvY2F0aW9uKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdtYXRjaCBuZWVkcyBhIGhpc3Rvcnkgb3IgYSBsb2NhdGlvbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICBoaXN0b3J5ID0gaGlzdG9yeSA/IGhpc3RvcnkgOiAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMpKTtcblxuICB2YXIgdW5saXN0ZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgLy8gQWxsb3cgbWF0Y2goeyBsb2NhdGlvbjogJy90aGUvcGF0aCcsIC4uLiB9KVxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGljayB1cCB0aGUgbG9jYXRpb24gZnJvbSB0aGUgaGlzdG9yeSB2aWEgc3luY2hyb25vdXMgaGlzdG9yeS5saXN0ZW5cbiAgICAvLyBjYWxsIGlmIG5lZWRlZC5cbiAgICB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChoaXN0b3J5TG9jYXRpb24pIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeUxvY2F0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIGhpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgdHJhbnNpdGlvbk1hbmFnZXIubWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSAmJiBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICBtYXRjaENvbnRleHQ6IHsgaGlzdG9yeTogaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9XG4gICAgfSkpO1xuXG4gICAgLy8gRGVmZXIgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIHRvIGhlcmUgdG8gcHJldmVudCBET00gaGlzdG9yaWVzIGZyb20gaGF2aW5nXG4gICAgLy8gdG8gdW53aW5kIERPTSBldmVudCBsaXN0ZW5lcnMgdW5uZWNlc3NhcmlseSwgaW4gY2FzZSBjYWxsYmFjayByZW5kZXJzIGFcbiAgICAvLyA8Um91dGVyPiBhbmQgYXR0YWNoZXMgYW5vdGhlciBoaXN0b3J5IGxpc3RlbmVyLlxuICAgIGlmICh1bmxpc3Rlbikge1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoUm91dGVzO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24gPSByZXF1aXJlKCcuL21ha2VTdGF0ZVdpdGhMb2NhdGlvbicpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlU3RhdGVXaXRoTG9jYXRpb24pO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW251bGwsIHJvdXRlLmNoaWxkUm91dGVzXTtcbiAgfVxuICBpZiAoIXJvdXRlLmdldENoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHN5bmMgPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgfTtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShwYXJ0aWFsTmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgcm91dGUuZ2V0Q2hpbGRSb3V0ZXMocGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgIGNoaWxkUm91dGVzID0gIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGNoaWxkUm91dGVzKTtcbiAgICBpZiAoc3luYykge1xuICAgICAgcmVzdWx0ID0gW2Vycm9yLCBjaGlsZFJvdXRlc107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IsIGNoaWxkUm91dGVzKTtcbiAgfSk7XG5cbiAgc3luYyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0OyAvLyBNaWdodCBiZSB1bmRlZmluZWQuXG59XG5cbmZ1bmN0aW9uIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmluZGV4Um91dGUpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5pbmRleFJvdXRlKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5nZXRJbmRleFJvdXRlKSB7XG4gICAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICB9O1xuXG4gICAgdmFyIHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkocGFydGlhbE5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gICAgcm91dGUuZ2V0SW5kZXhSb3V0ZShwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoaW5kZXhSb3V0ZSlbMF0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRobGVzcyA9IHJvdXRlLmNoaWxkUm91dGVzLmZpbHRlcihmdW5jdGlvbiAoY2hpbGRSb3V0ZSkge1xuICAgICAgICByZXR1cm4gIWNoaWxkUm91dGUucGF0aDtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShwYXRobGVzcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgICBnZXRJbmRleFJvdXRlKHBhdGhsZXNzW2luZGV4XSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgfHwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgICAgdmFyIHJvdXRlcyA9IFtwYXRobGVzc1tpbmRleF1dLmNvbmNhdChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpID8gaW5kZXhSb3V0ZSA6IFtpbmRleFJvdXRlXSk7XG4gICAgICAgICAgICBkb25lKGVycm9yLCByb3V0ZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJvdXRlcykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByb3V0ZXMpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblBhcmFtcyhwYXJhbXMsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBwYXJhbU5hbWVzLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlcyAmJiBwYXJhbVZhbHVlc1tpbmRleF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNbcGFyYW1OYW1lXSkpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdLnB1c2gocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IFtwYXJhbXNbcGFyYW1OYW1lXSwgcGFyYW1WYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIGFzc2lnblBhcmFtcyh7fSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlRGVlcChyb3V0ZSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBwYXJhbU5hbWVzID0gW107XG4gICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgfVxuXG4gIC8vIE9ubHkgdHJ5IHRvIG1hdGNoIHRoZSBwYXRoIGlmIHRoZSByb3V0ZSBhY3R1YWxseSBoYXMgYSBwYXR0ZXJuLCBhbmQgaWZcbiAgLy8gd2UncmUgbm90IGp1c3Qgc2VhcmNoaW5nIGZvciBwb3RlbnRpYWwgbmVzdGVkIGFic29sdXRlIHBhdGhzLlxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9ICgwLCBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybikocGF0dGVybiwgcmVtYWluaW5nUGF0aG5hbWUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkLnJlbWFpbmluZ1BhdGhuYW1lO1xuICAgICAgICBwYXJhbU5hbWVzID0gW10uY29uY2F0KHBhcmFtTmFtZXMsIG1hdGNoZWQucGFyYW1OYW1lcyk7XG4gICAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEJ5IGFzc3VtcHRpb24sIHBhdHRlcm4gaXMgbm9uLWVtcHR5IGhlcmUsIHdoaWNoIGlzIHRoZSBwcmVyZXF1aXNpdGUgZm9yXG4gICAgLy8gYWN0dWFsbHkgdGVybWluYXRpbmcgYSBtYXRjaC5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICB2YXIgX3JldDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgICByb3V0ZXM6IFtyb3V0ZV0sXG4gICAgICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXRjaCRyb3V0ZXM7XG5cbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoaW5kZXhSb3V0ZS5ldmVyeShmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJvdXRlLnBhdGg7XG4gICAgICAgICAgICAgIH0pLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAoX21hdGNoJHJvdXRlcyA9IG1hdGNoLnJvdXRlcykucHVzaC5hcHBseShfbWF0Y2gkcm91dGVzLCBpbmRleFJvdXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhSb3V0ZSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghaW5kZXhSb3V0ZS5wYXRoLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBtYXRjaC5yb3V0ZXMucHVzaChpbmRleFJvdXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCh0eXBlb2YgX3JldDIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQyKSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPSBudWxsIHx8IHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgLy8gRWl0aGVyIGEpIHRoaXMgcm91dGUgbWF0Y2hlZCBhdCBsZWFzdCBzb21lIG9mIHRoZSBwYXRoIG9yIGIpXG4gICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBsb2FkIHRoaXMgcm91dGUncyBjaGlsZHJlbiBhc3luY2hyb25vdXNseS4gSW5cbiAgICAvLyBlaXRoZXIgY2FzZSBjb250aW51ZSBjaGVja2luZyBmb3IgbWF0Y2hlcyBpbiB0aGUgc3VidHJlZS5cbiAgICB2YXIgb25DaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIG9uQ2hpbGRSb3V0ZXMoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZFJvdXRlcykge1xuICAgICAgICAvLyBDaGVjayB0aGUgY2hpbGQgcm91dGVzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBtYXRjaC5cbiAgICAgICAgbWF0Y2hSb3V0ZXMoY2hpbGRSb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gQSBjaGlsZCByb3V0ZSBtYXRjaGVkISBBdWdtZW50IHRoZSBtYXRjaCBhbmQgcGFzcyBpdCB1cCB0aGUgc3RhY2suXG4gICAgICAgICAgICBtYXRjaC5yb3V0ZXMudW5zaGlmdChyb3V0ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIG9uQ2hpbGRSb3V0ZXMpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9uQ2hpbGRSb3V0ZXMuYXBwbHkodW5kZWZpbmVkLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbWF0Y2hlcyB0aGUgZ2l2ZW4gbG9jYXRpb24gdG8gYSBzZXQgb2Ygcm91dGVzIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHN0YXRlKSB3aGVuIGZpbmlzaGVkLiBUaGUgc3RhdGUgb2JqZWN0IHdpbGwgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcm91dGVzICAgICAgIEFuIGFycmF5IG9mIHJvdXRlcyB0aGF0IG1hdGNoZWQsIGluIGhpZXJhcmNoaWNhbCBvcmRlclxuICogLSBwYXJhbXMgICAgICAgQW4gb2JqZWN0IG9mIFVSTCBwYXJhbWV0ZXJzXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q2hpbGRSb3V0ZXMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uLCBjYWxsYmFjaywgcmVtYWluaW5nUGF0aG5hbWUpIHtcbiAgdmFyIHBhcmFtTmFtZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDQgfHwgYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s0XTtcbiAgdmFyIHBhcmFtVmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSA1IHx8IGFyZ3VtZW50c1s1XSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbNV07XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgbGl0dGxlIGJpdCB1Z2x5LCBidXQgaXQgd29ya3MgYXJvdW5kIGEgcXVpcmsgaW4gaGlzdG9yeVxuICAgIC8vIHRoYXQgc3RyaXBzIHRoZSBsZWFkaW5nIHNsYXNoIGZyb20gcGF0aG5hbWVzIHdoZW4gdXNpbmcgYmFzZW5hbWVzIHdpdGhcbiAgICAvLyB0cmFpbGluZyBzbGFzaGVzLlxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6ICcvJyArIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHJvdXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIG1hdGNoUm91dGVEZWVwKHJvdXRlc1tpbmRleF0sIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgIGlmIChlcnJvciB8fCBtYXRjaCkge1xuICAgICAgICBkb25lKGVycm9yLCBtYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGFib3V0IHJvdXRpbmcuXG4gKlxuICogRW5oYW5jZXMgaGlzdG9yeSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICpcbiAqIC0gbGlzdGVuKChlcnJvciwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCAobmV4dExvY2F0aW9uKSA9PiB7fSlcbiAqIC0gbWF0Y2gobG9jYXRpb24sIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHk9ZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYHVzZVJvdXRlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXJgIGluc3RlYWQuJykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydyb3V0ZXMnXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkob3B0aW9ucyk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgcm91dGVzKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gd2l0aFJvdXRlcjtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkge1xuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59XG5cbmZ1bmN0aW9uIHdpdGhSb3V0ZXIoV3JhcHBlZENvbXBvbmVudCwgb3B0aW9ucykge1xuICB2YXIgd2l0aFJlZiA9IG9wdGlvbnMgJiYgb3B0aW9ucy53aXRoUmVmO1xuXG4gIHZhciBXaXRoUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgICBkaXNwbGF5TmFtZTogJ1dpdGhSb3V0ZXInLFxuXG4gICAgY29udGV4dFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuICAgIHByb3BUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcblxuICAgIGdldFdyYXBwZWRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgIXdpdGhSZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAnYHsgd2l0aFJlZjogdHJ1ZSB9YCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSB3aXRoUm91dGVyKCkgY2FsbC4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRJbnN0YW5jZTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJvdXRlciA9IHRoaXMucHJvcHMucm91dGVyIHx8IHRoaXMuY29udGV4dC5yb3V0ZXI7XG4gICAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyByb3V0ZXI6IHJvdXRlciB9KTtcblxuICAgICAgaWYgKHdpdGhSZWYpIHtcbiAgICAgICAgcHJvcHMucmVmID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBfdGhpcy53cmFwcGVkSW5zdGFuY2UgPSBjO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgV2l0aFJvdXRlci5kaXNwbGF5TmFtZSA9ICd3aXRoUm91dGVyKCcgKyBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSArICcpJztcbiAgV2l0aFJvdXRlci5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcblxuICByZXR1cm4gKDAsIF9ob2lzdE5vblJlYWN0U3RhdGljczIuZGVmYXVsdCkoV2l0aFJvdXRlciwgV3JhcHBlZENvbXBvbmVudCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuXG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyBIVE1MNSdzIGhpc3RvcnkgQVBJXG4gKiAocHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQpIHRvIG1hbmFnZSBoaXN0b3J5LlxuICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIG9mIG1hbmFnaW5nIGhpc3RvcnkgaW4gYnJvd3NlcnMgYmVjYXVzZVxuICogaXQgcHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKlxuICogTm90ZTogSW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgZnVsbFxuICogcGFnZSByZWxvYWRzIHdpbGwgYmUgdXNlZCB0byBwcmVzZXJ2ZSBVUkxzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgZm9yY2VSZWZyZXNoID0gb3B0aW9ucy5mb3JjZVJlZnJlc2g7XG5cbiAgdmFyIGlzU3VwcG9ydGVkID0gX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgdXNlUmVmcmVzaCA9ICFpc1N1cHBvcnRlZCB8fCBmb3JjZVJlZnJlc2g7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGUgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGlzdG9yeVN0YXRlID0ge307XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0V2luZG93UGF0aCgpO1xuICAgIHZhciBfaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlO1xuICAgIHZhciBrZXkgPSBfaGlzdG9yeVN0YXRlLmtleTtcblxuICAgIHZhciBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICAgIGlmIChpc1N1cHBvcnRlZCkgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBoaXN0b3J5U3RhdGUsIHsga2V5OiBrZXkgfSksIG51bGwpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBwb3BTdGF0ZUxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuXG4gICAgICB0cmFuc2l0aW9uVG8oZ2V0Q3VycmVudExvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gICAgfVxuXG4gICAgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICB2YXIgaGlzdG9yeVN0YXRlID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBwYXRoO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSRVBMQUNFXG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgaGlzdG9yeS5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGhpc3RvcnkudW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuXG4gICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2tcbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oKSB7XG4gIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcvJyA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9BY3Rpb25zLlBPUCA6IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG5cbiAgdmFyIF9mb3VydGhBcmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzNdO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdUaGUgc3RhdGUgKDJuZCkgYXJndW1lbnQgdG8gY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBhY3Rpb24gfSk7XG5cbiAgICBhY3Rpb24gPSBrZXkgfHwgX0FjdGlvbnMuUE9QO1xuICAgIGtleSA9IF9mb3VydGhBcmc7XG4gIH1cblxuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2ggfHwgJyc7XG4gIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaCB8fCAnJztcbiAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGUgfHwgbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBrZXk6IGtleVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVMb2NhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBzYXZlU3RhdGUsXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XG4gIHZhciBjdXJyZW50ID0gX29wdGlvbnMuY3VycmVudDtcblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4geyBwYXRobmFtZTogZW50cnksIGtleToga2V5IH07XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0JyAmJiBlbnRyeSkgcmV0dXJuIF9leHRlbmRzKHt9LCBlbnRyeSwgeyBrZXk6IGtleSB9KTtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVW5hYmxlIHRvIGNyZWF0ZSBoaXN0b3J5IGVudHJ5IGZyb20gJXMnLCBlbnRyeSkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgIShjdXJyZW50ID49IDAgJiYgY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICBzdG9yYWdlW2tleV0gPSBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY3VycmVudF07XG4gICAgdmFyIGJhc2VuYW1lID0gZW50cnkuYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gZW50cnkucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGVudHJ5LnNlYXJjaDtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgKHNlYXJjaCB8fCAnJyk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZW50cnkua2V5KSB7XG4gICAgICBrZXkgPSBlbnRyeS5rZXk7XG4gICAgICBzdGF0ZSA9IHJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICghY2FuR28obikpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQ2Fubm90IGdvKCVzKSB0aGVyZSBpcyBub3QgZW5vdWdoIGhpc3RvcnknLCBuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ICs9IG47XG5cbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgICAgLy8gY2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHsgYWN0aW9uOiBfQWN0aW9ucy5QT1AgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICBzd2l0Y2ggKGxvY2F0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBfQWN0aW9ucy5QVVNIOlxuICAgICAgICBjdXJyZW50ICs9IDE7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBvbiB0aGUgdG9wIG9mIHN0YWNrXG4gICAgICAgIC8vIHJlbW92ZSByZXN0IGFuZCBwdXNoIG5ld1xuICAgICAgICBpZiAoY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSBlbnRyaWVzLnNwbGljZShjdXJyZW50KTtcblxuICAgICAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfQWN0aW9ucy5SRVBMQUNFOlxuICAgICAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2tleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHJldHVybiBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCB7fSk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnNsaWNlKCkuc29ydCgpLm1hcChmdW5jdGlvbiAodmFsMikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsMik7XG5cdFx0XHR9KS5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbCk7XG5cdH0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4Lmxlbmd0aCA+IDA7XG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdH0pO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEF1dG9Gb2N1c1V0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQgfHwgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4lcyAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIGNoZWNrUmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBvd25lcjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKGNvbXBvbmVudC5fZGVidWdJRCwgJ3VwZGF0ZSBzdHlsZXMnLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50KTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDaGFuZ2VFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNoYW5nZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2hhbmdlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSwgdG9wTGV2ZWxUeXBlcy50b3BDbGljaywgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcbiAgLy8gY2hhbmdlcyBvciB3aGVuIGFuIGlucHV0IHdpdGggYSBwbGFjZWhvbGRlciBpcyBmb2N1c2VkLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiAxMSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBpZiAoYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcblxuICBpZiAoYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIEluIElFOCwgd2UgY2FuIGNhcHR1cmUgYWxtb3N0IGFsbCAudmFsdWUgY2hhbmdlcyBieSBhZGRpbmcgYVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIGhhbmRsZXIgYW5kIGxvb2tpbmcgZm9yIGV2ZW50cyB3aXRoIHByb3BlcnR5TmFtZVxuICAgIC8vIGVxdWFsIHRvICd2YWx1ZSdcbiAgICAvLyBJbiBJRTktMTEsIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SW5zdDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEYW5nZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNTYnKSA6IHZvaWQgMDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogX3Byb2RJbnZhcmlhbnQoJzU3JykgOiB2b2lkIDA7XG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlIDxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBfcHJvZEludmFyaWFudCgnNTgnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGRDaGlsZCwgbWFya3VwKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0Rhbmdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBba2V5T2YoeyBSZXNwb25kZXJFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTaW1wbGVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBUYXBFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBFbnRlckxlYXZlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQ2hhbmdlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2VsZWN0RXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogbnVsbCB9KV07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlRW50ZXI6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VMZWF2ZTogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlciAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0ICYmIHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuX2Fzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBkaWZmZXJpbmcgc3Vic3RyaW5nIGJldHdlZW4gdGhlIGluaXRpYWxseSBzdG9yZWRcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZhbGxiYWNrVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XG4gICAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IDAsXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBhY2Nlc3NLZXk6IDAsXG4gICAgYWN0aW9uOiAwLFxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IDAsXG4gICAgYWx0OiAwLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IDAsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgIGNoYXJTZXQ6IDAsXG4gICAgY2hhbGxlbmdlOiAwLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2l0ZTogMCxcbiAgICBjbGFzc0lEOiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIGNvbnRlbnQ6IDAsXG4gICAgY29udGVudEVkaXRhYmxlOiAwLFxuICAgIGNvbnRleHRNZW51OiAwLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IDAsXG4gICAgY3Jvc3NPcmlnaW46IDAsXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiAwLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogMCxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiAwLFxuICAgIGVuY1R5cGU6IDAsXG4gICAgZm9ybTogMCxcbiAgICBmb3JtQWN0aW9uOiAwLFxuICAgIGZvcm1FbmNUeXBlOiAwLFxuICAgIGZvcm1NZXRob2Q6IDAsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IDAsXG4gICAgZnJhbWVCb3JkZXI6IDAsXG4gICAgaGVhZGVyczogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiAwLFxuICAgIGhyZWY6IDAsXG4gICAgaHJlZkxhbmc6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgaWNvbjogMCxcbiAgICBpZDogMCxcbiAgICBpbnB1dE1vZGU6IDAsXG4gICAgaW50ZWdyaXR5OiAwLFxuICAgIGlzOiAwLFxuICAgIGtleVBhcmFtczogMCxcbiAgICBrZXlUeXBlOiAwLFxuICAgIGtpbmQ6IDAsXG4gICAgbGFiZWw6IDAsXG4gICAgbGFuZzogMCxcbiAgICBsaXN0OiAwLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogMCxcbiAgICBtYW5pZmVzdDogMCxcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXG4gICAgbWFyZ2luV2lkdGg6IDAsXG4gICAgbWF4OiAwLFxuICAgIG1heExlbmd0aDogMCxcbiAgICBtZWRpYTogMCxcbiAgICBtZWRpYUdyb3VwOiAwLFxuICAgIG1ldGhvZDogMCxcbiAgICBtaW46IDAsXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiAwLFxuICAgIG5vbmNlOiAwLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IDAsXG4gICAgcGF0dGVybjogMCxcbiAgICBwbGFjZWhvbGRlcjogMCxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgIH1cbiAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgICAgfSwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgcHJldkNoaWxkO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgICAgLy8gQ3JlYXRpbmcgbW91bnQgaW1hZ2Ugbm93IGVuc3VyZXMgcmVmcyBhcmUgcmVzb2x2ZWQgaW4gcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTAxIGZvciBleHBsYW5hdGlvbikuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRNb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KG5leHRDaGlsZEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgbW91bnRJbWFnZXMucHVzaChuZXh0Q2hpbGRNb3VudEltYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbiA9PT0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaXNNdXRhdGVkID0gZmFsc2U7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuKSkge1xuICAgIGlmIChlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbi5sZW5ndGggPT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbltpXSAhPT0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbltpXSkge1xuICAgICAgICAgIGlzTXV0YXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNNdXRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuKSB8fCBpc011dGF0ZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudFxcJ3MgY2hpbGRyZW4gc2hvdWxkIG5vdCBiZSBtdXRhdGVkLiVzJywgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rID0ge1xuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoZGVidWdJRCkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xuICBJbXB1cmVDbGFzczogMCxcbiAgUHVyZUNsYXNzOiAxLFxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXG59O1xuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyKCkge1xuICB2YXIgcHVibGljSW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICB9XG4gIHB1YmxpY0luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ29tcG9uZW50RGlkVXBkYXRlV2l0aFRpbWVyKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICB2YXIgcHVibGljSW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgfVxuICBwdWJsaWNJbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpO1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIC8vIENvbXBvbmVudFdpbGxVbm1vdW50IHNoYWxsIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RQYXJlbnRcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0Q29udGFpbmVySW5mb1xuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gbmV4dE1vdW50SUQrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHB1YmxpY1Byb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gdHJhbnNhY3Rpb24uZ2V0VXBkYXRlUXVldWUoKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBkb0NvbnN0cnVjdCA9IHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpO1xuICAgIHZhciBpbnN0ID0gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50KGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBTdXBwb3J0IGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgIGlmICghZG9Db25zdHJ1Y3QgJiYgKGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgcmVuZGVyZWRFbGVtZW50KTtcbiAgICAgICEoaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNScsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLkltcHVyZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzTXV0YXRlZCA9IGluc3QucHJvcHMgIT09IHB1YmxpY1Byb3BzO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHNNdXRhdGVkLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArICd1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgbWFya3VwO1xuICAgIGlmIChpbnN0LnVuc3RhYmxlX2hhbmRsZUVycm9yKSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyhyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW52b2tlQ29tcG9uZW50RGlkTW91bnRXaXRoVGltZXIsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0YW5jZU9yRWxlbWVudDtcbiAgICBpZiAoZG9Db25zdHJ1Y3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0YW5jZU9yRWxlbWVudCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xuICAgICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0YW5jZU9yRWxlbWVudCA9IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlT3JFbGVtZW50O1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZzogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cDtcbiAgICB2YXIgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcbiAgICB0cnkge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJvbGwgYmFjayB0byBjaGVja3BvaW50LCBoYW5kbGUgZXJyb3IgKHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gdGhlIHRyYW5zYWN0aW9uKSwgYW5kIHRha2UgYSBuZXcgY2hlY2twb2ludFxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG4gICAgICB0aGlzLl9pbnN0YW5jZS51bnN0YWJsZV9oYW5kbGVFcnJvcihlKTtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUodGhpcy5faW5zdGFuY2UucHJvcHMsIHRoaXMuX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCh0cnVlKTtcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuXG4gICAgICAvLyBUcnkgYWdhaW4gLSB3ZSd2ZSBpbmZvcm1lZCB0aGUgY29tcG9uZW50IGFib3V0IHRoZSBlcnJvciwgc28gdGhleSBjYW4gcmVuZGVyIGFuIGVycm9yIG1lc3NhZ2UgdGhpcyB0aW1lLlxuICAgICAgLy8gSWYgdGhpcyB0aHJvd3MgYWdhaW4sIHRoZSBlcnJvciB3aWxsIGJ1YmJsZSB1cCAoYW5kIGNhbiBiZSBjYXVnaHQgYnkgYSBoaWdoZXIgZXJyb3IgYm91bmRhcnkpLlxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50OiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUocmVuZGVyZWRFbGVtZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNlbGZEZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBzZWxmRGVidWdJRCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmICFpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSB0cnVlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2FmZWx5KSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKCkgKyAnLmNvbXBvbmVudFdpbGxVbm1vdW50KCknO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQuYmluZChpbnN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgdG8gdGhpcyBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cbiAgICBSZWFjdEluc3RhbmNlTWFwLnJlbW92ZShpbnN0KTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LmNvbnRleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgIH1cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDcnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDgnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgY29udGV4dCB0eXBlcyBhcmUgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgY29udGV4dCBmaWVsZCB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0NvbnRleHRUeXBlczogZnVuY3Rpb24gKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xuICAgIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIHRoaXMuZ2V0TmFtZSgpLCBudWxsLCB0aGlzLl9kZWJ1Z0lEKTtcbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgd2lsbFJlY2VpdmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dENvbnRleHQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzKSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChpbnN0LnN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIGNvbnRleHQpIDogcGFydGlhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxuICAgKiBwZXJmb3JtcyB1cGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBOZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wcyBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB1bm1hc2tlZENvbnRleHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgICB0aGlzLl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCh0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW52b2tlQ29tcG9uZW50RGlkVXBkYXRlV2l0aFRpbWVyLmJpbmQodGhpcywgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0TWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcy5faG9zdFBhcmVudCwgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIHNlbGZEZWJ1Z0lEKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGRlbiBpbiBzaGFsbG93IHJlbmRlcmluZy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZW5kZXJlZENvbXBvbmVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAocmVuZGVyZWRDb21wb25lbnQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHwgdGhpcy5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgUmVmZXJlbmNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiBfcHJvZEludmFyaWFudCgnMTEwJykgOiB2b2lkIDA7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIE1peGluOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IFJlYWN0TW91bnQucmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cbiAgICAgICAgdmFyIHNob3dGaWxlVXJsTWVzc2FnZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCh0ZXN0RnVuYy5uYW1lIHx8IHRlc3RGdW5jLnRvU3RyaW5nKCkpLmluZGV4T2YoJ3Rlc3RGbicpICE9PSAtMSwgJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYSBtaW5pZmllZCBjb3B5IG9mIHRoZSBkZXZlbG9wbWVudCBidWlsZCAnICsgJ29mIFJlYWN0LiBXaGVuIGRlcGxveWluZyBSZWFjdCBhcHBzIHRvIHByb2R1Y3Rpb24sIG1ha2Ugc3VyZSB0byB1c2UgJyArICd0aGUgcHJvZHVjdGlvbiBidWlsZCB3aGljaCBza2lwcyBkZXZlbG9wbWVudCB3YXJuaW5ncyBhbmQgaXMgZmFzdGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LW1pbmlmaWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJyk7XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET00uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IGhvc3QgY29tcG9uZW50IHRoYXQgZG9lcyBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHNcbiAqIHdoZW4gYGRpc2FibGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTUJ1dHRvbiA9IHtcbiAgZ2V0SG9zdFByb3BzOiBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZSgnLi9SZWFjdERPTUJ1dHRvbicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcbnZhciBnZXROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2U7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG52YXIgSFRNTCA9IGtleU9mKHsgX19odG1sOiBudWxsIH0pO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbFxufTtcblxuLy8gTm9kZSB0eXBlIGZvciBkb2N1bWVudCBmcmFnbWVudHMgKE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkuXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMTM3JywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IF9wcm9kSW52YXJpYW50KCc2MCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBfcHJvZEludmFyaWFudCgnNjEnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMub25Gb2N1c0luID09IG51bGwgJiYgcHJvcHMub25Gb2N1c091dCA9PSBudWxsLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc2MicsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGNvbnRhaW5lckluZm8gPSBpbnN0Ll9ob3N0Q29udGFpbmVySW5mbztcbiAgdmFyIGlzRG9jdW1lbnRGcmFnbWVudCA9IGNvbnRhaW5lckluZm8uX25vZGUgJiYgY29udGFpbmVySW5mby5fbm9kZS5ub2RlVHlwZSA9PT0gRE9DX0ZSQUdNRU5UX1RZUEU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGluc3Q6IGluc3QsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaW5zdCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gaW5wdXRQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01JbnB1dC5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiB0ZXh0YXJlYVBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTVRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvblBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTU9wdGlvbi5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG52YXIgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdmFyIGhhc0V4aXN0aW5nQ29udGVudCA9IHRoaXMuX2NvbnRlbnREZWJ1Z0lEICE9IG51bGw7XG4gICAgdmFyIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIC8vIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgaW5saW5lZCBjaGlsZCB0aGF0IGhhcyBubyBiYWNraW5nIGluc3RhbmNlOlxuICAgIHZhciBjb250ZW50RGVidWdJRCA9IC1kZWJ1Z0lEO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KHRoaXMuX2NvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xuICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCwgZGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBbY29udGVudERlYnVnSURdKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBfcHJvZEludmFyaWFudCgnNjMnKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBfcHJvZEludmFyaWFudCgnNjQnKSA6IHZvaWQgMDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzW2V2ZW50XSwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BJbnZhbGlkLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG4vLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUhUTUwobGF6eVRyZWUsIGlubmVySFRNTC5fX2h0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4obGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAgIC8vIGhhcHBlbiBhZnRlciBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIGxhc3RQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUodGhpcy5fcHJldmlvdXNTdHlsZUNvcHksIHRoaXMuX3ByZXZpb3VzU3R5bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UHJvcCA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldE5vZGUodGhpcyk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhnZXROb2RlKHRoaXMpLCBzdHlsZVVwZGF0ZXMsIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfVxuXG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db250YWluZXJJbmZvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG5mdW5jdGlvbiBSZWFjdERPTUNvbnRhaW5lckluZm8odG9wTGV2ZWxXcmFwcGVyLCBub2RlKSB7XG4gIHZhciBpbmZvID0ge1xuICAgIF90b3BMZXZlbFdyYXBwZXI6IHRvcExldmVsV3JhcHBlcixcbiAgICBfaWRDb3VudGVyOiAxLFxuICAgIF9vd25lckRvY3VtZW50OiBub2RlID8gbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSA/IG5vZGUgOiBub2RlLm93bmVyRG9jdW1lbnQgOiBudWxsLFxuICAgIF9ub2RlOiBub2RlLFxuICAgIF90YWc6IG5vZGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsLFxuICAgIF9uYW1lc3BhY2VVUkk6IG5vZGUgPyBub2RlLm5hbWVzcGFjZVVSSSA6IG51bGxcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbmZvLl9hbmNlc3RvckluZm8gPSBub2RlID8gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgaW5mby5fdGFnLCBudWxsKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db250YWluZXJJbmZvO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gIC8vIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IHVzZXMgdGhpczpcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl9kb21JRCA9IDA7XG59O1xuX2Fzc2lnbihSZWFjdERPTUVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG5vZGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobm9kZVZhbHVlKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgbm9kZSk7XG4gICAgICByZXR1cm4gRE9NTGF6eVRyZWUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGluc2VydCBhIGNvbW1lbnQgbm9kZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb25cbiAgICAgICAgLy8gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVyblxuICAgICAgICAvLyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwhLS0nICsgbm9kZVZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRW1wdHlDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXG4gIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXG4gIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxuICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXG4gIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxuICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcbiAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcbiAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcbiAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxuICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXG4gIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcbiAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcbiAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxuICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcbiAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcbiAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcbiAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcbiAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxuICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcbiAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXG4gIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcbiAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXG4gIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxuICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcbiAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxuICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxuICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxuICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcbiAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcbiAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxuICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxuICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcbiAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcbiAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcbiAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcbiAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXG4gIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxuICAndmFyJzogY3JlYXRlRE9NRmFjdG9yeSgndmFyJyksXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICBjbGlwUGF0aDogY3JlYXRlRE9NRmFjdG9yeSgnY2xpcFBhdGgnKSxcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gIGc6IGNyZWF0ZURPTUZhY3RvcnkoJ2cnKSxcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgbGluZWFyR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmVhckdyYWRpZW50JyksXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICBwYXR0ZXJuOiBjcmVhdGVET01GYWN0b3J5KCdwYXR0ZXJuJyksXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gIHJhZGlhbEdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdyYWRpYWxHcmFkaWVudCcpLFxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgc3ZnOiBjcmVhdGVET01GYWN0b3J5KCdzdmcnKSxcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZlYXR1cmVGbGFnc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnRJbnN0LCB1cGRhdGVzKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShwYXJlbnRJbnN0KTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXMobm9kZSwgdXBkYXRlcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgOiBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlICE9PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3RleHRhcmVhJyAmJiBlbGVtZW50LnR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnByb3BzICE9IG51bGwgJiYgZWxlbWVudC5wcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG5cbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgUmVhY3RDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4pIHtcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBob3N0UGFyZW50KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJ1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICBzZWxlY3RQYXJlbnQgPSBzZWxlY3RQYXJlbnQuX2hvc3RQYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQgIT0gbnVsbCAmJiBzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgc2VsZWN0VmFsdWUgPSBSZWFjdERPTVNlbGVjdC5nZXRTZWxlY3RWYWx1ZUNvbnRleHQoc2VsZWN0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7IHNlbGVjdGVkOiBzZWxlY3RlZCB9O1xuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBzZWxlY3RlZDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xuICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgaG9zdFByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xufTtcblxuX2Fzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnI3RleHQnLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBfcHJvZEludmFyaWFudCgnOTEnKSA6IHZvaWQgMDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gICAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rQmVuIHNlZW1lZCB0byBsaWtlIHRoaXMgc29sdXRpb24uXG4gICAgLy8gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogJycgKyBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgdGV4dGFyZWFgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBfcHJvZEludmFyaWFudCgnOTInKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkzJykgOiB2b2lkIDA7XG4gICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIFdhcm5pbmc6IG5vZGUudmFsdWUgbWF5IGJlIHRoZSBlbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludCAoSUUxMSkgaWYgcGxhY2Vob2xkZXIgaXMgc2V0LlxuICAgIG5vZGUudmFsdWUgPSBub2RlLnRleHRDb250ZW50OyAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVHJlZVRyYXZlcnNhbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gdGVtcEEuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gdGVtcEIuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuXG4gIHdoaWxlIChpbnN0Qikge1xuICAgIGlmIChpbnN0QiA9PT0gaW5zdEEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0UGFyZW50SW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzYnKSA6IHZvaWQgMDtcblxuICByZXR1cm4gaW5zdC5faG9zdFBhcmVudDtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgZmFsc2UsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCB0cnVlLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgdHJ1ZSwgYXJnRnJvbSk7XG4gIH1cbiAgZm9yIChpID0gcGF0aFRvLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9baV0sIGZhbHNlLCBhcmdUbyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQW5jZXN0b3I6IGlzQW5jZXN0b3IsXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcixcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGdldFBhcmVudEluc3RhbmNlLFxuICB0cmF2ZXJzZVR3b1BoYXNlOiB0cmF2ZXJzZVR3b1BoYXNlLFxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IHRyYXZlcnNlRW50ZXJMZWF2ZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzXG4gKiogbW9kdWxlIGlkID0gMjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWUsXG5cbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHZhbHVlTGluazogdHJ1ZSxcbiAgICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgICBjaGVja2VkTGluazogdHJ1ZSxcbiAgICBpbm5lckhUTUw6IHRydWUsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIG9uRm9jdXNJbjogdHJ1ZSxcbiAgICBvbkZvY3VzT3V0OiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGd1ZXNzIHdoaWNoIHByb3AgdGhlIHVzZXIgaW50ZW5kZWQuXG4gICAgICAvLyBJdCBpcyBsaWtlbHkgdGhhdCB0aGUgdXNlciB3YXMganVzdCBibGluZGx5IHNwcmVhZGluZy9mb3J3YXJkaW5nIHByb3BzXG4gICAgICAvLyBDb21wb25lbnRzIHNob3VsZCBiZSBjYXJlZnVsIHRvIG9ubHkgcmVuZGVyIHZhbGlkIHByb3BzL2F0dHJpYnV0ZXMuXG4gICAgICAvLyBXYXJuaW5nIHdpbGwgYmUgaW52b2tlZCBpbiB3YXJuVW5rbm93blByb3BlcnRpZXMgdG8gYWxsb3cgZ3JvdXBpbmcuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gZWxlbWVudC5wcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eShlbGVtZW50LnR5cGUsIGtleSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhpcyBwcm9wIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcHMgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGVzZSBwcm9wcyBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlYnVnVG9vbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKCdmYmpzL2xpYi9wZXJmb3JtYW5jZU5vdycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBob29rcyA9IFtdO1xudmFyIGRpZEhvb2tUaHJvd0ZvckV2ZW50ID0ge307XG5cbmZ1bmN0aW9uIGNhbGxIb29rKGV2ZW50LCBmbiwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICB0cnkge1xuICAgIGZuLmNhbGwoY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0sICdFeGNlcHRpb24gdGhyb3duIGJ5IGhvb2sgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgZXZlbnQsIGUgKyAnXFxuJyArIGUuc3RhY2spIDogdm9pZCAwO1xuICAgIGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuICAgIHZhciBmbiA9IGhvb2tbZXZlbnRdO1xuICAgIGlmIChmbikge1xuICAgICAgY2FsbEhvb2soZXZlbnQsIGZuLCBob29rLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZmx1c2hIaXN0b3J5ID0gW107XG52YXIgbGlmZUN5Y2xlVGltZXJTdGFjayA9IFtdO1xudmFyIGN1cnJlbnRGbHVzaE5lc3RpbmcgPSAwO1xudmFyIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IG51bGw7XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRFxuICAgIH07XG4gICAgcmV0dXJuIHRyZWU7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRNZWFzdXJlbWVudHMoKSB7XG4gIHZhciBwcmV2aW91c1N0YXJ0VGltZSA9IGN1cnJlbnRGbHVzaFN0YXJ0VGltZTtcbiAgdmFyIHByZXZpb3VzTWVhc3VyZW1lbnRzID0gY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzIHx8IFtdO1xuICB2YXIgcHJldmlvdXNPcGVyYXRpb25zID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suZ2V0SGlzdG9yeSgpO1xuXG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gbnVsbDtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgaWYgKGFsbG93Um9vdCAmJiBkZWJ1Z0lEID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZGVidWdJRCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3REZWJ1Z1Rvb2w6IGRlYnVnSUQgbWF5IG5vdCBiZSBlbXB0eS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ0RpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0YXJ0IHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxuZnVuY3Rpb24gZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICE9PSB0aW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdXZSBkaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdG9wIHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWcgaW4gUmVhY3QuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgdGltZXJUeXBlOiB0aW1lclR5cGUsXG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWUgLSBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IG51bGw7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBjdXJyZW50VGltZXIgPSB7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZXJTdGFydFRpbWUsXG4gICAgbmVzdGVkRmx1c2hTdGFydFRpbWU6IHBlcmZvcm1hbmNlTm93KCksXG4gICAgZGVidWdJRDogY3VycmVudFRpbWVyRGVidWdJRCxcbiAgICB0aW1lclR5cGU6IGN1cnJlbnRUaW1lclR5cGVcbiAgfTtcbiAgbGlmZUN5Y2xlVGltZXJTdGFjay5wdXNoKGN1cnJlbnRUaW1lcik7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSBudWxsO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIF9saWZlQ3ljbGVUaW1lclN0YWNrJCA9IGxpZmVDeWNsZVRpbWVyU3RhY2sucG9wKCk7XG5cbiAgdmFyIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWU7XG4gIHZhciBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZTtcbiAgdmFyIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRDtcbiAgdmFyIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIFJlYWN0RGVidWdUb29sID0ge1xuICBhZGRIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2tzLnB1c2goaG9vayk7XG4gIH0sXG4gIHJlbW92ZUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XG4gICAgICAgIGhvb2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNQcm9maWxpbmc7XG4gIH0sXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbHVzaEhpc3Rvcnk7XG4gIH0sXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmcrKztcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luRmx1c2gnKTtcbiAgfSxcbiAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZy0tO1xuICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25FbmRGbHVzaCcpO1xuICB9LFxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGVtaXRFdmVudCgnb25FbmRMaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgaWYgKGN1cnJlbnRUaW1lckRlYnVnSUQgIT0gbnVsbCkge1xuICAgICAgZW5kTGlmZUN5Y2xlVGltZXIoY3VycmVudFRpbWVyRGVidWdJRCwgY3VycmVudFRpbWVyVHlwZSk7XG4gICAgfVxuICAgIGVtaXRFdmVudCgnb25FcnJvcicsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAoZGVidWdJRCwgdHlwZSwgcGF5bG9hZCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uSG9zdE9wZXJhdGlvbicsIGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XG4gIH0sXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChkZWJ1Z0lELCBjaGlsZERlYnVnSURzKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoaWxkRGVidWdJRHMuZm9yRWFjaChjaGVja0RlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25TZXRDaGlsZHJlbicsIGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZU1vdW50Q29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Nb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25UZXN0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XG4gIH1cbn07XG5cbi8vIFRPRE8gcmVtb3ZlIHRoZXNlIHdoZW4gUk4vd3d3IGdldHMgdXBkYXRlZFxuUmVhY3REZWJ1Z1Rvb2wuYWRkRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLmFkZEhvb2s7XG5SZWFjdERlYnVnVG9vbC5yZW1vdmVEZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vaztcblxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rKTtcbnZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG5pZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgUmVhY3REZWJ1Z1Rvb2wuYmVnaW5Qcm9maWxpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlYnVnVG9vbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWJ1Z1Rvb2wuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0VHJlZVRyYXZlcnNhbChSZWFjdERPTVRyZWVUcmF2ZXJzYWwpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRMaXN0ZW5lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChpbnN0KSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHdoaWxlIChpbnN0Ll9ob3N0UGFyZW50KSB7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIHZhciBjb250YWluZXIgPSByb290Tm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbl9hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBhbmNlc3RvciAmJiBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoaXN0b3J5ID0gW107XG5cbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAoZGVidWdJRCwgdHlwZSwgcGF5bG9hZCkge1xuICAgIGhpc3RvcnkucHVzaCh7XG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9KTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLl9wcmV2ZW50Q2xlYXJpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpc3RvcnkgPSBbXTtcbiAgfSxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSW52YWxpZFNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9jZXNzaW5nQ2hpbGRDb250ZXh0LCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSB7XG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IHRydWU7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHdhcm5JbnZhbGlkU2V0U3RhdGUoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNYXJrdXBDaGVja3N1bVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgaWYgKENPTU1FTlRfU1RBUlQudGVzdChtYXJrdXApKSB7XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBub2RlLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZXRNYXJrdXAobWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVRleHRDb250ZW50KHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVRleHRDb250ZW50KG5leHRDb250ZW50KV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIC8vIGBuZXh0TW91bnRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggbmV3bHkgbW91bnRlZCBjaGlsZC5cbiAgICAgIHZhciBuZXh0TW91bnRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdFBsYWNlZE5vZGUgPSBudWxsO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIC8vIFRoZSBgcmVtb3ZlZE5vZGVzYCBsb29wIGJlbG93IHdpbGwgYWN0dWFsbHkgcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fbW91bnRDaGlsZEF0SW5kZXgobmV4dENoaWxkLCBtb3VudEltYWdlc1tuZXh0TW91bnRJbmRleF0sIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgICAgbmV4dE1vdW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgbGFzdFBsYWNlZE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUobmV4dENoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0sIHJlbW92ZWROb2Rlc1tuYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLiBJdCBkb2VzIG5vdCBhY3R1YWxseSBwZXJmb3JtIGFueVxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbnNlcnRNYXJrdXAobW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCwgbm9kZSk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNWYWxpZE93bmVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTknKSA6IHZvaWQgMDtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyMCcpIDogdm9pZCAwO1xuICAgIHZhciBvd25lclB1YmxpY0luc3RhbmNlID0gb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgJ3Mgb3duZXIgaXMgc3RpbGwgYWxpdmUgYW5kIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmXG4gICAgLy8gYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXJQdWJsaWNJbnN0YW5jZSAmJiBvd25lclB1YmxpY0luc3RhbmNlLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFB1cmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cnJlZC4gYGNsb3NlYFxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAocHJldmlvdXNseUVuYWJsZWQpIHtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxuICAgIGNsb3NlOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaFxuICB9KTtcbn1cblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKHVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0RE9NVGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IHVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYXZlIGN1cnJlbnQgdHJhbnNhY3Rpb24gc3RhdGUgLS0gaWYgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoaXMgbWV0aG9kIGlzXG4gICAqIHBhc3NlZCB0byBgcm9sbGJhY2tgLCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSByZXNldCB0byB0aGF0IHN0YXRlLlxuICAgKi9cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlYWN0TW91bnRSZWFkeSBpcyB0aGUgb3VyIG9ubHkgc3RhdGVmdWwgd3JhcHBlclxuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeS5jaGVja3BvaW50KCk7XG4gIH0sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucm9sbGJhY2soY2hlY2twb2ludCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuX2Fzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlZlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuXG4gIHJldHVybiAoXG4gICAgLy8gVGhpcyBoYXMgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIHcvci90IGVtcHR5IGNvbXBvbmVudHMuXG4gICAgcHJldkVtcHR5IHx8IG5leHRFbXB0eSB8fCBuZXh0RWxlbWVudC5yZWYgIT09IHByZXZFbGVtZW50LnJlZiB8fFxuICAgIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgICB0eXBlb2YgbmV4dEVsZW1lbnQucmVmID09PSAnc3RyaW5nJyAmJiBuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lclxuICApO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGRldGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVmLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtdO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxuICAgIGNsb3NlOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaFxuICB9KTtcbn1cblxudmFyIG5vb3BDYWxsYmFja1F1ZXVlID0ge1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG5ldyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRoaXMpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vb3BDYWxsYmFja1F1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuX2Fzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICogSXQgZGVsZWdhdGVzIHRvIFJlYWN0VXBkYXRlUXVldWUgd2hpbGUgc2VydmVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcyBhbmRcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKi9cblxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIDo6IHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjsgKi9cblxuICBmdW5jdGlvbiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRyYW5zYWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0U2VydmVyVXBkYXRlUXVldWUpO1xuXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlQ2FsbGJhY2sgPSBmdW5jdGlvbiBlbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlRm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVSZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVTZXRTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXG4vLyBjb2RlIGluc3RlYWQuXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcbi8vIC0gY29sb3Jcbi8vIC0gaGVpZ2h0XG4vLyAtIGlkXG4vLyAtIGxhbmdcbi8vIC0gbWF4XG4vLyAtIG1lZGlhXG4vLyAtIG1ldGhvZFxuLy8gLSBtaW5cbi8vIC0gbmFtZVxuLy8gLSBzdHlsZVxuLy8gLSB0YXJnZXRcbi8vIC0gdHlwZVxuLy8gLSB3aWR0aFxudmFyIEFUVFJTID0ge1xuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogMCxcbiAgYWRkaXRpdmU6IDAsXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgYWxsb3dSZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogMCxcbiAgYW1wbGl0dWRlOiAwLFxuICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICBhc2NlbnQ6IDAsXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRlVHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogMCxcbiAgYmFzZUZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgYmJveDogMCxcbiAgYmVnaW46IDAsXG4gIGJpYXM6IDAsXG4gIGJ5OiAwLFxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gIGNsaXA6IDAsXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxuICBjbGlwUGF0aFVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRTdHlsZVR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIGQ6IDAsXG4gIGRlY2VsZXJhdGU6IDAsXG4gIGRlc2NlbnQ6IDAsXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogMCxcbiAgZGlzcGxheTogMCxcbiAgZGl2aXNvcjogMCxcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgZHVyOiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGVkZ2VNb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246IDAsXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXG4gIGVuZDogMCxcbiAgZXhwb25lbnQ6IDAsXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogMCxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXG4gIGZpbHRlcjogMCxcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxuICBmb2N1c2FibGU6IDAsXG4gIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgZm9udFN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb3JtYXQ6IDAsXG4gIGZyb206IDAsXG4gIGZ4OiAwLFxuICBmeTogMCxcbiAgZzE6IDAsXG4gIGcyOiAwLFxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogMCxcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICBob3Jpek9yaWdpblg6ICdob3Jpei1vcmlnaW4teCcsXG4gIGlkZW9ncmFwaGljOiAwLFxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbic6IDAsXG4gIGluMjogMCxcbiAgaW50ZXJjZXB0OiAwLFxuICBrOiAwLFxuICBrMTogMCxcbiAgazI6IDAsXG4gIGszOiAwLFxuICBrNDogMCxcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsVW5pdExlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAwLFxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlTcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJTcGFjaW5nOiAnbGV0dGVyLXNwYWNpbmcnLFxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6IDAsXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2VyV2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6IDAsXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza1VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAwLFxuICBtb2RlOiAwLFxuICBudW1PY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogMCxcbiAgb3BhY2l0eTogMCxcbiAgb3BlcmF0b3I6IDAsXG4gIG9yZGVyOiAwLFxuICBvcmllbnQ6IDAsXG4gIG9yaWVudGF0aW9uOiAwLFxuICBvcmlnaW46IDAsXG4gIG92ZXJmbG93OiAwLFxuICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJuVHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXG4gIHBvaW50czogMCxcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzQXRaOiAncG9pbnRzQXRaJyxcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZVVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICByOiAwLFxuICByYWRpdXM6IDAsXG4gIHJlZlg6ICdyZWZYJyxcbiAgcmVmWTogJ3JlZlknLFxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgcmVwZWF0Q291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkRmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzdGFydDogMCxcbiAgcmVzdWx0OiAwLFxuICByb3RhdGU6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgc2NhbGU6IDAsXG4gIHNlZWQ6IDAsXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcbiAgc2xvcGU6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJFeHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogMCxcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRPZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAwLFxuICBzdGVtdjogMCxcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxuICBzdHJpbmc6IDAsXG4gIHN0cm9rZTogMCxcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hvZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdXJmYWNlU2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldFg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICB0ZXh0RGVjb3JhdGlvbjogJ3RleHQtZGVjb3JhdGlvbicsXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdG86IDAsXG4gIHRyYW5zZm9ybTogMCxcbiAgdTE6IDAsXG4gIHUyOiAwLFxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxuICB1bmljb2RlOiAwLFxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICB1bml0c1BlckVtOiAndW5pdHMtcGVyLWVtJyxcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gIHZJZGVvZ3JhcGhpYzogJ3YtaWRlb2dyYXBoaWMnLFxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxuICB2YWx1ZXM6IDAsXG4gIHZlY3RvckVmZmVjdDogJ3ZlY3Rvci1lZmZlY3QnLFxuICB2ZXJzaW9uOiAwLFxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICB2ZXJ0T3JpZ2luWDogJ3ZlcnQtb3JpZ2luLXgnLFxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxuICB2aWV3Qm94OiAndmlld0JveCcsXG4gIHZpZXdUYXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogMCxcbiAgd2lkdGhzOiAwLFxuICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcbiAgeDogMCxcbiAgeEhlaWdodDogJ3gtaGVpZ2h0JyxcbiAgeDE6IDAsXG4gIHgyOiAwLFxuICB4Q2hhbm5lbFNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gIHhtbG5zOiAwLFxuICB4bWxuc1hsaW5rOiAneG1sbnM6eGxpbmsnLFxuICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICB4bWxTcGFjZTogJ3htbDpzcGFjZScsXG4gIHk6IDAsXG4gIHkxOiAwLFxuICB5MjogMCxcbiAgeUNoYW5uZWxTZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAwLFxuICB6b29tQW5kUGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge30sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9XG59O1xuXG5PYmplY3Qua2V5cyhBVFRSUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNba2V5XSA9IDA7XG4gIGlmIChBVFRSU1trZXldKSB7XG4gICAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNba2V5XSA9IEFUVFJTW2tleV07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbi8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2U6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkl0ZXJhdGlvbjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25JdGVyYXRpb25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnZhbGlkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnZhbGlkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnZhbGlkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5RG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5RG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5RG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlQcmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5UHJlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5VXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZERhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZERhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZERhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWRNZXRhZGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIC8vIE5vdGU6IFdlIGRvIG5vdCBhbGxvdyBsaXN0ZW5pbmcgdG8gbW91c2VPdmVyIGV2ZW50cy4gSW5zdGVhZCwgdXNlIHRoZVxuICAvLyBvbk1vdXNlRW50ZXIvb25Nb3VzZUxlYXZlIGNyZWF0ZWQgYnkgYEVudGVyTGVhdmVFdmVudFBsdWdpbmAuXG4gIG1vdXNlRG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU91dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGFzdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhc3RlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXN0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXVzZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGF1c2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheWluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheWluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheWluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Qcm9ncmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUHJvZ3Jlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByYXRlQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJlc2V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SZXNldENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Nyb2xsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TY3JvbGxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVrZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2VkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2luZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2luZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2luZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN0YWxsZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN0YWxsZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN0YWxsZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1Ym1pdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VibWl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VzcGVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VzcGVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VzcGVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRpbWVVcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRpbWVVcGRhdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRpbWVVcGRhdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaEVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVHJhbnNpdGlvbkVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVHJhbnNpdGlvbkVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHZvbHVtZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XYWl0aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XYWl0aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2hlZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldoZWVsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XaGVlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEFib3J0OiBldmVudFR5cGVzLmFib3J0LFxuICB0b3BBbmltYXRpb25FbmQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uRW5kLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGV2ZW50VHlwZXMuYW5pbWF0aW9uSXRlcmF0aW9uLFxuICB0b3BBbmltYXRpb25TdGFydDogZXZlbnRUeXBlcy5hbmltYXRpb25TdGFydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEludmFsaWQ6IGV2ZW50VHlwZXMuaW52YWxpZCxcbiAgdG9wS2V5RG93bjogZXZlbnRUeXBlcy5rZXlEb3duLFxuICB0b3BLZXlQcmVzczogZXZlbnRUeXBlcy5rZXlQcmVzcyxcbiAgdG9wS2V5VXA6IGV2ZW50VHlwZXMua2V5VXAsXG4gIHRvcExvYWQ6IGV2ZW50VHlwZXMubG9hZCxcbiAgdG9wTG9hZGVkRGF0YTogZXZlbnRUeXBlcy5sb2FkZWREYXRhLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogZXZlbnRUeXBlcy5sb2FkZWRNZXRhZGF0YSxcbiAgdG9wTG9hZFN0YXJ0OiBldmVudFR5cGVzLmxvYWRTdGFydCxcbiAgdG9wTW91c2VEb3duOiBldmVudFR5cGVzLm1vdXNlRG93bixcbiAgdG9wTW91c2VNb3ZlOiBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6IGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogZXZlbnRUeXBlcy5tb3VzZU92ZXIsXG4gIHRvcE1vdXNlVXA6IGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6IGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFBhdXNlOiBldmVudFR5cGVzLnBhdXNlLFxuICB0b3BQbGF5OiBldmVudFR5cGVzLnBsYXksXG4gIHRvcFBsYXlpbmc6IGV2ZW50VHlwZXMucGxheWluZyxcbiAgdG9wUHJvZ3Jlc3M6IGV2ZW50VHlwZXMucHJvZ3Jlc3MsXG4gIHRvcFJhdGVDaGFuZ2U6IGV2ZW50VHlwZXMucmF0ZUNoYW5nZSxcbiAgdG9wUmVzZXQ6IGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFNlZWtlZDogZXZlbnRUeXBlcy5zZWVrZWQsXG4gIHRvcFNlZWtpbmc6IGV2ZW50VHlwZXMuc2Vla2luZyxcbiAgdG9wU3RhbGxlZDogZXZlbnRUeXBlcy5zdGFsbGVkLFxuICB0b3BTdWJtaXQ6IGV2ZW50VHlwZXMuc3VibWl0LFxuICB0b3BTdXNwZW5kOiBldmVudFR5cGVzLnN1c3BlbmQsXG4gIHRvcFRpbWVVcGRhdGU6IGV2ZW50VHlwZXMudGltZVVwZGF0ZSxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6IGV2ZW50VHlwZXMudG91Y2hNb3ZlLFxuICB0b3BUb3VjaFN0YXJ0OiBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGV2ZW50VHlwZXMudHJhbnNpdGlvbkVuZCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBldmVudFR5cGVzLnZvbHVtZUNoYW5nZSxcbiAgdG9wV2FpdGluZzogZXZlbnRUeXBlcy53YWl0aW5nLFxuICB0b3BXaGVlbDogZXZlbnRUeXBlcy53aGVlbFxufTtcblxuZm9yICh2YXIgdHlwZSBpbiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3R5cGVdLmRlcGVuZGVuY2llcyA9IFt0eXBlXTtcbn1cblxudmFyIE9OX0NMSUNLX0tFWSA9IGtleU9mKHsgb25DbGljazogbnVsbCB9KTtcbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQWJvcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5VGhyb3VnaDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEdXJhdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbXB0aWVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuY3J5cHRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFcnJvcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnZhbGlkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkRGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWRNZXRhZGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGF1c2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5aW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFByb2dyZXNzOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJhdGVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2VkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3RhbGxlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VzcGVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUaW1lVXBkYXRlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFZvbHVtZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXYWl0aW5nOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEb3VibGVDbGljazpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbnRlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRXhpdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnTGVhdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ092ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ1N0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyb3A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvbkl0ZXJhdGlvbjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25TdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUcmFuc2l0aW9uRW5kOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRHJhZ0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0ZvY3VzRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oaSArIDQwOTYsIG0pO1xuICAgIGZvciAoOyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gQWxsb3cgJzAnIHRvIHBhc3MgdGhyb3VnaCB3aXRob3V0IHdhcm5pbmcuIDAgaXMgYWxyZWFkeSBzcGVjaWFsIGFuZFxuICAgICAgLy8gZG9lc24ndCByZXF1aXJlIHVuaXRzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhcm4gYWJvdXQgaXQuXG4gICAgICBpZiAoY29tcG9uZW50ICYmIHZhbHVlICE9PSAnMCcpIHtcbiAgICAgICAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IG93bmVyLmdldE5hbWUoKSA6IG51bGw7XG4gICAgICAgIGlmIChvd25lck5hbWUgJiYgIXN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSkge1xuICAgICAgICAgIHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXTtcbiAgICAgICAgICB3YXJuZWQgPSB3YXJuaW5nc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgd2FybmluZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYSBgJXNgIHRhZyAob3duZXI6IGAlc2ApIHdhcyBwYXNzZWQgYSBudW1lcmljIHN0cmluZyB2YWx1ZSAnICsgJ2ZvciBDU1MgcHJvcGVydHkgYCVzYCAodmFsdWU6IGAlc2ApIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCAnICsgJ2FzIGEgdW5pdGxlc3MgbnVtYmVyIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QuJywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLCBvd25lck5hbWUgfHwgJ3Vua25vd24nLCBuYW1lLCB2YWx1ZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG5cbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICByZXR1cm4gaW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIDogbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDQnKSA6IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzQ1JywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiB2b2lkIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKiBAcGFyYW0ge251bWJlcj19IHNlbGZEZWJ1Z0lEIE9wdGlvbmFsIGRlYnVnSUQgb2YgdGhlIGN1cnJlbnQgaW50ZXJuYWwgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICBpZiAodHJhdmVyc2VDb250ZXh0ICYmIHR5cGVvZiB0cmF2ZXJzZUNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMjYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDMnKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMjY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMjY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZXJzIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0XG4gIC8vIGluIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMjcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIE5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pc05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAoIWNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcbiAgICAgIGNhY2hlW3N0cmluZ10gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVTdHJpbmdPbmx5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzXG4gKiogbW9kdWxlIGlkID0gMjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9XG5cbnZhciByZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQoc3RyLCB0aW1lcykge1xuICByZXR1cm4gbmV3IEFycmF5KHRpbWVzICsgMSkuam9pbihzdHIpO1xufTtcbnZhciBwYWQgPSBmdW5jdGlvbiBwYWQobnVtLCBtYXhMZW5ndGgpIHtcbiAgcmV0dXJuIHJlcGVhdChcIjBcIiwgbWF4TGVuZ3RoIC0gbnVtLnRvU3RyaW5nKCkubGVuZ3RoKSArIG51bTtcbn07XG52YXIgZm9ybWF0VGltZSA9IGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSkge1xuICByZXR1cm4gXCJAIFwiICsgcGFkKHRpbWUuZ2V0SG91cnMoKSwgMikgKyBcIjpcIiArIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSwgMikgKyBcIjpcIiArIHBhZCh0aW1lLmdldFNlY29uZHMoKSwgMikgKyBcIi5cIiArIHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbn07XG5cbi8vIFVzZSB0aGUgbmV3IHBlcmZvcm1hbmNlIGFwaSB0byBnZXQgYmV0dGVyIHByZWNpc2lvbiBpZiBhdmFpbGFibGVcbnZhciB0aW1lciA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCIgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG5cbi8qKlxuICogcGFyc2UgdGhlIGxldmVsIG9wdGlvbiBvZiBjcmVhdGVMb2dnZXJcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IGZ1bmN0aW9uIHwgb2JqZWN0fSBsZXZlbCAtIGNvbnNvbGVbbGV2ZWxdXG4gKiBAcHJvcGVydHkge29iamVjdH0gYWN0aW9uXG4gKiBAcHJvcGVydHkge2FycmF5fSBwYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldExvZ0xldmVsKGxldmVsLCBhY3Rpb24sIHBheWxvYWQsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlb2YgbGV2ZWwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihsZXZlbCkpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gdHlwZW9mIGxldmVsW3R5cGVdID09PSBcImZ1bmN0aW9uXCIgPyBsZXZlbFt0eXBlXS5hcHBseShsZXZlbCwgX3RvQ29uc3VtYWJsZUFycmF5KHBheWxvYWQpKSA6IGxldmVsW3R5cGVdO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIGxldmVsKGFjdGlvbik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgbG9nZ2VyIHdpdGggZm9sbG93ZWQgb3B0aW9uc1xuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgbG9nZ2VyXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IGZ1bmN0aW9uIHwgb2JqZWN0fSBvcHRpb25zLmxldmVsIC0gY29uc29sZVtsZXZlbF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5kdXJhdGlvbiAtIHByaW50IGR1cmF0aW9uIG9mIGVhY2ggYWN0aW9uP1xuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLnRpbWVzdGFtcCAtIHByaW50IHRpbWVzdGFtcCB3aXRoIGVhY2ggYWN0aW9uP1xuICogQHByb3BlcnR5IHtvYmplY3R9IG9wdGlvbnMuY29sb3JzIC0gY3VzdG9tIGNvbG9yc1xuICogQHByb3BlcnR5IHtvYmplY3R9IG9wdGlvbnMubG9nZ2VyIC0gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBjb25zb2xlYCBBUElcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5sb2dFcnJvcnMgLSBzaG91bGQgZXJyb3JzIGluIGFjdGlvbiBleGVjdXRpb24gYmUgY2F1Z2h0LCBsb2dnZWQsIGFuZCByZS10aHJvd24/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMuY29sbGFwc2VkIC0gaXMgZ3JvdXAgY29sbGFwc2VkP1xuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLnByZWRpY2F0ZSAtIGNvbmRpdGlvbiB3aGljaCByZXNvbHZlcyBsb2dnZXIgYmVoYXZpb3JcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuc3RhdGVUcmFuc2Zvcm1lciAtIHRyYW5zZm9ybSBzdGF0ZSBiZWZvcmUgcHJpbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuYWN0aW9uVHJhbnNmb3JtZXIgLSB0cmFuc2Zvcm0gYWN0aW9uIGJlZm9yZSBwcmludFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gb3B0aW9ucy5lcnJvclRyYW5zZm9ybWVyIC0gdHJhbnNmb3JtIGVycm9yIGJlZm9yZSBwcmludFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcigpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIF9vcHRpb25zJGxldmVsID0gb3B0aW9ucy5sZXZlbDtcbiAgdmFyIGxldmVsID0gX29wdGlvbnMkbGV2ZWwgPT09IHVuZGVmaW5lZCA/IFwibG9nXCIgOiBfb3B0aW9ucyRsZXZlbDtcbiAgdmFyIF9vcHRpb25zJGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICB2YXIgbG9nZ2VyID0gX29wdGlvbnMkbG9nZ2VyID09PSB1bmRlZmluZWQgPyBjb25zb2xlIDogX29wdGlvbnMkbG9nZ2VyO1xuICB2YXIgX29wdGlvbnMkbG9nRXJyb3JzID0gb3B0aW9ucy5sb2dFcnJvcnM7XG4gIHZhciBsb2dFcnJvcnMgPSBfb3B0aW9ucyRsb2dFcnJvcnMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyRsb2dFcnJvcnM7XG4gIHZhciBjb2xsYXBzZWQgPSBvcHRpb25zLmNvbGxhcHNlZDtcbiAgdmFyIHByZWRpY2F0ZSA9IG9wdGlvbnMucHJlZGljYXRlO1xuICB2YXIgX29wdGlvbnMkZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICB2YXIgZHVyYXRpb24gPSBfb3B0aW9ucyRkdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRkdXJhdGlvbjtcbiAgdmFyIF9vcHRpb25zJHRpbWVzdGFtcCA9IG9wdGlvbnMudGltZXN0YW1wO1xuICB2YXIgdGltZXN0YW1wID0gX29wdGlvbnMkdGltZXN0YW1wID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdGlvbnMkdGltZXN0YW1wO1xuICB2YXIgdHJhbnNmb3JtZXIgPSBvcHRpb25zLnRyYW5zZm9ybWVyO1xuICB2YXIgX29wdGlvbnMkc3RhdGVUcmFuc2ZvID0gb3B0aW9ucy5zdGF0ZVRyYW5zZm9ybWVyO1xuICB2YXIgLy8gZGVwcmVjYXRlZFxuICBzdGF0ZVRyYW5zZm9ybWVyID0gX29wdGlvbnMkc3RhdGVUcmFuc2ZvID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0gOiBfb3B0aW9ucyRzdGF0ZVRyYW5zZm87XG4gIHZhciBfb3B0aW9ucyRhY3Rpb25UcmFuc2YgPSBvcHRpb25zLmFjdGlvblRyYW5zZm9ybWVyO1xuICB2YXIgYWN0aW9uVHJhbnNmb3JtZXIgPSBfb3B0aW9ucyRhY3Rpb25UcmFuc2YgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChhY3RuKSB7XG4gICAgcmV0dXJuIGFjdG47XG4gIH0gOiBfb3B0aW9ucyRhY3Rpb25UcmFuc2Y7XG4gIHZhciBfb3B0aW9ucyRlcnJvclRyYW5zZm8gPSBvcHRpb25zLmVycm9yVHJhbnNmb3JtZXI7XG4gIHZhciBlcnJvclRyYW5zZm9ybWVyID0gX29wdGlvbnMkZXJyb3JUcmFuc2ZvID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gOiBfb3B0aW9ucyRlcnJvclRyYW5zZm87XG4gIHZhciBfb3B0aW9ucyRjb2xvcnMgPSBvcHRpb25zLmNvbG9ycztcbiAgdmFyIGNvbG9ycyA9IF9vcHRpb25zJGNvbG9ycyA9PT0gdW5kZWZpbmVkID8ge1xuICAgIHRpdGxlOiBmdW5jdGlvbiB0aXRsZSgpIHtcbiAgICAgIHJldHVybiBcIiMwMDAwMDBcIjtcbiAgICB9LFxuICAgIHByZXZTdGF0ZTogZnVuY3Rpb24gcHJldlN0YXRlKCkge1xuICAgICAgcmV0dXJuIFwiIzlFOUU5RVwiO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCIjMDNBOUY0XCI7XG4gICAgfSxcbiAgICBuZXh0U3RhdGU6IGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBcIiM0Q0FGNTBcIjtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHJldHVybiBcIiNGMjA0MDRcIjtcbiAgICB9XG4gIH0gOiBfb3B0aW9ucyRjb2xvcnM7XG5cbiAgLy8gZXhpdCBpZiBjb25zb2xlIHVuZGVmaW5lZFxuXG4gIGlmICh0eXBlb2YgbG9nZ2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiT3B0aW9uICd0cmFuc2Zvcm1lcicgaXMgZGVwcmVjYXRlZCwgdXNlIHN0YXRlVHJhbnNmb3JtZXIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHZhciBsb2dCdWZmZXIgPSBbXTtcbiAgZnVuY3Rpb24gcHJpbnRCdWZmZXIoKSB7XG4gICAgbG9nQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGxvZ0VudHJ5LCBrZXkpIHtcbiAgICAgIHZhciBzdGFydGVkID0gbG9nRW50cnkuc3RhcnRlZDtcbiAgICAgIHZhciBzdGFydGVkVGltZSA9IGxvZ0VudHJ5LnN0YXJ0ZWRUaW1lO1xuICAgICAgdmFyIGFjdGlvbiA9IGxvZ0VudHJ5LmFjdGlvbjtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBsb2dFbnRyeS5wcmV2U3RhdGU7XG4gICAgICB2YXIgZXJyb3IgPSBsb2dFbnRyeS5lcnJvcjtcbiAgICAgIHZhciB0b29rID0gbG9nRW50cnkudG9vaztcbiAgICAgIHZhciBuZXh0U3RhdGUgPSBsb2dFbnRyeS5uZXh0U3RhdGU7XG5cbiAgICAgIHZhciBuZXh0RW50cnkgPSBsb2dCdWZmZXJba2V5ICsgMV07XG4gICAgICBpZiAobmV4dEVudHJ5KSB7XG4gICAgICAgIG5leHRTdGF0ZSA9IG5leHRFbnRyeS5wcmV2U3RhdGU7XG4gICAgICAgIHRvb2sgPSBuZXh0RW50cnkuc3RhcnRlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgICAvLyBtZXNzYWdlXG4gICAgICB2YXIgZm9ybWF0dGVkQWN0aW9uID0gYWN0aW9uVHJhbnNmb3JtZXIoYWN0aW9uKTtcbiAgICAgIHZhciBpc0NvbGxhcHNlZCA9IHR5cGVvZiBjb2xsYXBzZWQgPT09IFwiZnVuY3Rpb25cIiA/IGNvbGxhcHNlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICB9LCBhY3Rpb24pIDogY29sbGFwc2VkO1xuXG4gICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IGZvcm1hdFRpbWUoc3RhcnRlZFRpbWUpO1xuICAgICAgdmFyIHRpdGxlQ1NTID0gY29sb3JzLnRpdGxlID8gXCJjb2xvcjogXCIgKyBjb2xvcnMudGl0bGUoZm9ybWF0dGVkQWN0aW9uKSArIFwiO1wiIDogbnVsbDtcbiAgICAgIHZhciB0aXRsZSA9IFwiYWN0aW9uIFwiICsgKHRpbWVzdGFtcCA/IGZvcm1hdHRlZFRpbWUgOiBcIlwiKSArIFwiIFwiICsgZm9ybWF0dGVkQWN0aW9uLnR5cGUgKyBcIiBcIiArIChkdXJhdGlvbiA/IFwiKGluIFwiICsgdG9vay50b0ZpeGVkKDIpICsgXCIgbXMpXCIgOiBcIlwiKTtcblxuICAgICAgLy8gcmVuZGVyXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICBpZiAoY29sb3JzLnRpdGxlKSBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoXCIlYyBcIiArIHRpdGxlLCB0aXRsZUNTUyk7ZWxzZSBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQodGl0bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb2xvcnMudGl0bGUpIGxvZ2dlci5ncm91cChcIiVjIFwiICsgdGl0bGUsIHRpdGxlQ1NTKTtlbHNlIGxvZ2dlci5ncm91cCh0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyh0aXRsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2U3RhdGVMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtwcmV2U3RhdGVdLCBcInByZXZTdGF0ZVwiKTtcbiAgICAgIHZhciBhY3Rpb25MZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtmb3JtYXR0ZWRBY3Rpb25dLCBcImFjdGlvblwiKTtcbiAgICAgIHZhciBlcnJvckxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW2Vycm9yLCBwcmV2U3RhdGVdLCBcImVycm9yXCIpO1xuICAgICAgdmFyIG5leHRTdGF0ZUxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW25leHRTdGF0ZV0sIFwibmV4dFN0YXRlXCIpO1xuXG4gICAgICBpZiAocHJldlN0YXRlTGV2ZWwpIHtcbiAgICAgICAgaWYgKGNvbG9ycy5wcmV2U3RhdGUpIGxvZ2dlcltwcmV2U3RhdGVMZXZlbF0oXCIlYyBwcmV2IHN0YXRlXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLnByZXZTdGF0ZShwcmV2U3RhdGUpICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIHByZXZTdGF0ZSk7ZWxzZSBsb2dnZXJbcHJldlN0YXRlTGV2ZWxdKFwicHJldiBzdGF0ZVwiLCBwcmV2U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgaWYgKGNvbG9ycy5hY3Rpb24pIGxvZ2dlclthY3Rpb25MZXZlbF0oXCIlYyBhY3Rpb25cIiwgXCJjb2xvcjogXCIgKyBjb2xvcnMuYWN0aW9uKGZvcm1hdHRlZEFjdGlvbikgKyBcIjsgZm9udC13ZWlnaHQ6IGJvbGRcIiwgZm9ybWF0dGVkQWN0aW9uKTtlbHNlIGxvZ2dlclthY3Rpb25MZXZlbF0oXCJhY3Rpb25cIiwgZm9ybWF0dGVkQWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yICYmIGVycm9yTGV2ZWwpIHtcbiAgICAgICAgaWYgKGNvbG9ycy5lcnJvcikgbG9nZ2VyW2Vycm9yTGV2ZWxdKFwiJWMgZXJyb3JcIiwgXCJjb2xvcjogXCIgKyBjb2xvcnMuZXJyb3IoZXJyb3IsIHByZXZTdGF0ZSkgKyBcIjsgZm9udC13ZWlnaHQ6IGJvbGRcIiwgZXJyb3IpO2Vsc2UgbG9nZ2VyW2Vycm9yTGV2ZWxdKFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dFN0YXRlTGV2ZWwpIHtcbiAgICAgICAgaWYgKGNvbG9ycy5uZXh0U3RhdGUpIGxvZ2dlcltuZXh0U3RhdGVMZXZlbF0oXCIlYyBuZXh0IHN0YXRlXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLm5leHRTdGF0ZShuZXh0U3RhdGUpICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIG5leHRTdGF0ZSk7ZWxzZSBsb2dnZXJbbmV4dFN0YXRlTGV2ZWxdKFwibmV4dCBzdGF0ZVwiLCBuZXh0U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIuKAlOKAlCBsb2cgZW5kIOKAlOKAlFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2dCdWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAvLyBleGl0IGVhcmx5IGlmIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlID09PSBcImZ1bmN0aW9uXCIgJiYgIXByZWRpY2F0ZShnZXRTdGF0ZSwgYWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nRW50cnkgPSB7fTtcbiAgICAgICAgbG9nQnVmZmVyLnB1c2gobG9nRW50cnkpO1xuXG4gICAgICAgIGxvZ0VudHJ5LnN0YXJ0ZWQgPSB0aW1lci5ub3coKTtcbiAgICAgICAgbG9nRW50cnkuc3RhcnRlZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsb2dFbnRyeS5wcmV2U3RhdGUgPSBzdGF0ZVRyYW5zZm9ybWVyKGdldFN0YXRlKCkpO1xuICAgICAgICBsb2dFbnRyeS5hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgdmFyIHJldHVybmVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChsb2dFcnJvcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFbnRyeS5lcnJvciA9IGVycm9yVHJhbnNmb3JtZXIoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybmVkVmFsdWUgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsb2dFbnRyeS50b29rID0gdGltZXIubm93KCkgLSBsb2dFbnRyeS5zdGFydGVkO1xuICAgICAgICBsb2dFbnRyeS5uZXh0U3RhdGUgPSBzdGF0ZVRyYW5zZm9ybWVyKGdldFN0YXRlKCkpO1xuXG4gICAgICAgIHByaW50QnVmZmVyKCk7XG5cbiAgICAgICAgaWYgKGxvZ0VudHJ5LmVycm9yKSB0aHJvdyBsb2dFbnRyeS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJldHVybmVkVmFsdWU7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTG9nZ2VyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4LWxvZ2dlci9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gcHJvbWlzZU1pZGRsZXdhcmU7XG5cbnZhciBfaXNQcm9taXNlID0gcmVxdWlyZSgnLi9pc1Byb21pc2UnKTtcblxudmFyIF9pc1Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQcm9taXNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRUeXBlcyA9IFsnUEVORElORycsICdGVUxGSUxMRUQnLCAnUkVKRUNURUQnXTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gcHJvbWlzZU1pZGRsZXdhcmVcbiAqIEBkZXNjcmlwdGlvblxuICogQHJldHVybnMge2Z1bmN0aW9ufSB0aHVua1xuICovXG5mdW5jdGlvbiBwcm9taXNlTWlkZGxld2FyZSgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBwcm9taXNlVHlwZVN1ZmZpeGVzID0gY29uZmlnLnByb21pc2VUeXBlU3VmZml4ZXMgfHwgZGVmYXVsdFR5cGVzO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gcmVmLmRpc3BhdGNoO1xuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZCkge1xuICAgICAgICAgIGlmICghKDAsIF9pc1Byb21pc2UyLmRlZmF1bHQpKGFjdGlvbi5wYXlsb2FkKSAmJiAhKDAsIF9pc1Byb21pc2UyLmRlZmF1bHQpKGFjdGlvbi5wYXlsb2FkLnByb21pc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjb25zdHJ1Y3QgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGFjdGlvbiBvYmplY3QgdG8gY29uc3RhbnRzXG4gICAgICAgIHZhciB0eXBlID0gYWN0aW9uLnR5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHZhciBtZXRhID0gYWN0aW9uLm1ldGE7XG5cbiAgICAgICAgLy8gQXNzaWduIHZhbHVlcyBmb3IgcHJvbWlzZSB0eXBlIHN1ZmZpeGVzXG5cbiAgICAgICAgdmFyIF9wcm9taXNlVHlwZVN1ZmZpeGVzID0gX3NsaWNlZFRvQXJyYXkocHJvbWlzZVR5cGVTdWZmaXhlcywgMyk7XG5cbiAgICAgICAgdmFyIFBFTkRJTkcgPSBfcHJvbWlzZVR5cGVTdWZmaXhlc1swXTtcbiAgICAgICAgdmFyIEZVTEZJTExFRCA9IF9wcm9taXNlVHlwZVN1ZmZpeGVzWzFdO1xuICAgICAgICB2YXIgUkVKRUNURUQgPSBfcHJvbWlzZVR5cGVTdWZmaXhlc1syXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uIGdldEFjdGlvblxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVXRpbGl0eSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByZWplY3RlZCBvciBmdWxmaWxsZWRcbiAgICAgICAgICogZmx1eCBzdGFuZGFyZCBhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IElzIHRoZSBhY3Rpb24gcmVqZWN0ZWQ/XG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFjdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24gZ2V0QWN0aW9uKG5ld1BheWxvYWQsIGlzUmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSArICdfJyArIChpc1JlamVjdGVkID8gUkVKRUNURUQgOiBGVUxGSUxMRUQpXG4gICAgICAgICAgfSwgbmV3UGF5bG9hZCA/IHtcbiAgICAgICAgICAgIHBheWxvYWQ6IG5ld1BheWxvYWRcbiAgICAgICAgICB9IDoge30sICEhbWV0YSA/IHsgbWV0YTogbWV0YSB9IDoge30sIGlzUmVqZWN0ZWQgPyB7XG4gICAgICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgICAgIH0gOiB7fSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbiB2YWx1ZXMgZm9yIHByb21pc2UgYW5kIGRhdGEgdmFyaWFibGVzLiBJbiB0aGUgY2FzZSB0aGUgcGF5bG9hZFxuICAgICAgICAgKiBpcyBhbiBvYmplY3Qgd2l0aCBhIGBwcm9taXNlYCBhbmQgYGRhdGFgIHByb3BlcnR5LCB0aGUgdmFsdWVzIG9mIHRob3NlXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkLiBJbiB0aGUgY2FzZSB0aGUgcGF5bG9hZCBpcyBhIHByb21pc2UsIHRoZVxuICAgICAgICAgKiB2YWx1ZSBvZiB0aGUgcGF5bG9hZCB3aWxsIGJlIHVzZWQgYW5kIGRhdGEgd2lsbCBiZSBudWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHZhciBkYXRhID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICghKDAsIF9pc1Byb21pc2UyLmRlZmF1bHQpKGFjdGlvbi5wYXlsb2FkKSAmJiBfdHlwZW9mKGFjdGlvbi5wYXlsb2FkKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBwcm9taXNlID0gcGF5bG9hZC5wcm9taXNlO1xuICAgICAgICAgIGRhdGEgPSBwYXlsb2FkLmRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHBheWxvYWQ7XG4gICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyc3QsIGRpc3BhdGNoIHRoZSBwZW5kaW5nIGFjdGlvbi4gVGhpcyBmbHV4IHN0YW5kYXJkIGFjdGlvbiBvYmplY3RcbiAgICAgICAgICogZGVzY3JpYmVzIHRoZSBwZW5kaW5nIHN0YXRlIG9mIGEgcHJvbWlzZSBhbmQgd2lsbCBpbmNsdWRlIGFueSBkYXRhXG4gICAgICAgICAqIChmb3Igb3B0aW1pc3RpYyB1cGRhdGVzKSBhbmQvb3IgbWV0YSBmcm9tIHRoZSBvcmlnaW5hbCBhY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBuZXh0KF9leHRlbmRzKHtcbiAgICAgICAgICB0eXBlOiB0eXBlICsgJ18nICsgUEVORElOR1xuICAgICAgICB9LCAhIWRhdGEgPyB7IHBheWxvYWQ6IGRhdGEgfSA6IHt9LCAhIW1ldGEgPyB7IG1ldGE6IG1ldGEgfSA6IHt9KSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQGZ1bmN0aW9uIGhhbmRsZVJlamVjdFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGlzcGF0Y2ggdGhlIHJlamVjdGVkIGFjdGlvbiBhbmQgcmV0dXJuXG4gICAgICAgICAqIGFuIGVycm9yIG9iamVjdC4gVGhlIGVycm9yIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgICogdGhhdCB3YXMgdGhyb3duLiBUaGUgdXNlciBvZiB0aGUgbGlicmFyeSBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAgICAgICogYmVzdCBwcmFjdGljZXMgaW4gZW5zdXJlIHRoYXQgdGhleSBhcmUgdGhyb3dpbmcgYW4gRXJyb3Igb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW1zIHJlYXNvbiBUaGUgcmVhc29uIHRoZSBwcm9taXNlIHdhcyByZWplY3RlZFxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhbmRsZVJlamVjdCA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdChyZWFzb24pIHtcbiAgICAgICAgICB2YXIgcmVqZWN0ZWRBY3Rpb24gPSBnZXRBY3Rpb24ocmVhc29uLCB0cnVlKTtcbiAgICAgICAgICBkaXNwYXRjaChyZWplY3RlZEFjdGlvbik7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEBmdW5jdGlvbiBoYW5kbGVGdWxmaWxsXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBEaXNwYXRjaCB0aGUgZnVsZmlsbGVkIGFjdGlvbiBhbmRcbiAgICAgICAgICogcmV0dXJuIHRoZSBzdWNjZXNzIG9iamVjdC4gVGhlIHN1Y2Nlc3Mgb2JqZWN0IHNob3VsZFxuICAgICAgICAgKiBjb250YWluIHRoZSB2YWx1ZSBhbmQgdGhlIGRpc3BhdGNoZWQgYWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRoZSBwcm9taXNlIHdhcyByZXNsb3ZlZCB3aXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFuZGxlRnVsZmlsbCA9IGZ1bmN0aW9uIGhhbmRsZUZ1bGZpbGwoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgIHZhciByZXNvbHZlZEFjdGlvbiA9IGdldEFjdGlvbih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgIGRpc3BhdGNoKHJlc29sdmVkQWN0aW9uKTtcblxuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgYWN0aW9uOiByZXNvbHZlZEFjdGlvbiB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWNvbmQsIGRpc3BhdGNoIGEgcmVqZWN0ZWQgb3IgZnVsZmlsbGVkIGFjdGlvbi4gVGhpcyBmbHV4IHN0YW5kYXJkXG4gICAgICAgICAqIGFjdGlvbiBvYmplY3Qgd2lsbCBkZXNjcmliZSB0aGUgcmVzb2x2ZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuIEluXG4gICAgICAgICAqIHRoZSBjYXNlIG9mIGEgcmVqZWN0ZWQgcHJvbWlzZSwgaXQgd2lsbCBpbmNsdWRlIGFuIGBlcnJvcmAgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIG9yZGVyIHRvIGFsbG93IHByb3BlciBjaGFpbmluZyBvZiBhY3Rpb25zIHVzaW5nIGB0aGVuYCwgYSBuZXdcbiAgICAgICAgICogcHJvbWlzZSBpcyBjb25zdHJ1Y3RlZCBhbmQgcmV0dXJuZWQuIFRoaXMgcHJvbWlzZSB3aWxsIHJlc29sdmVcbiAgICAgICAgICogd2l0aCB0d28gcHJvcGVydGllczogKDEpIHRoZSB2YWx1ZSAoaWYgZnVsZmlsbGVkKSBvciByZWFzb25cbiAgICAgICAgICogKGlmIHJlamVjdGVkKSBhbmQgKDIpIHRoZSBmbHV4IHN0YW5kYXJkIGFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVqZWN0ZWQgb2JqZWN0OlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgcmVhc29uOiAuLi5cbiAgICAgICAgICogICBhY3Rpb246IHtcbiAgICAgICAgICogICAgIGVycm9yOiB0cnVlLFxuICAgICAgICAgKiAgICAgdHlwZTogJ0FDVElPTl9SRUpFQ1RFRCcsXG4gICAgICAgICAqICAgICBwYXlsb2FkOiAuLi5cbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogRnVsZmlsbGVkIG9iamVjdDpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIHZhbHVlOiAuLi5cbiAgICAgICAgICogICBhY3Rpb246IHtcbiAgICAgICAgICogICAgIHR5cGU6ICdBQ1RJT05fRlVMRklMTEVEJyxcbiAgICAgICAgICogICAgIHBheWxvYWQ6IC4uLlxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihoYW5kbGVGdWxmaWxsLCBoYW5kbGVSZWplY3QpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4LXByb21pc2UtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4LXByb21pc2UtbWlkZGxld2FyZS9kaXN0L2lzUHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaDtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnRodW5rLndpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB0aHVuaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC10aHVuay9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMjg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tYmluZVJlZHVjZXJzO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24pIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCA/ICdpbml0aWFsU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24pO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUJMQUVzQUFELy9nQmtSbWxzWlNCemIzVnlZMlU2SUdoMGRIQTZMeTlqYjIxdGIyNXpMbmRwYTJsdFpXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9rVnBibk4wWldsdVh6RTVNakZmWW5sZlJsOVRZMmh0ZFhSNlpYSmZMVjl5WlhOMGIzSmhkR2x2Ymk1cWNHZi8yd0JEQUFZRUJRWUZCQVlHQlFZSEJ3WUlDaEFLQ2drSkNoUU9Ed3dRRnhRWUdCY1VGaFlhSFNVZkdoc2pIQllXSUN3Z0l5WW5LU29wR1I4dE1DMG9NQ1VvS1NqLzJ3QkRBUWNIQndvSUNoTUtDaE1vR2hZYUtDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2ovd0FBUkNBRWhBTndEQVNJQUFoRUJBeEVCLzhRQUhBQUFBUVVCQVFFQUFBQUFBQUFBQUFBQUJRSURCQVlIQUFFSS84UUFSaEFBQWdFREF3RUhBUVFHQ0FRRkJRRUFBUUlEQUFRUkJSSWhNUVlUSWtGUllYR0JCektSb1JRak03SEIwUlVXSkVKU2NyTGhOR0p6Z2tOVGtxTHdDR05rZzdQQy84UUFHQUVBQXdFQkFBQUFBQUFBQUFBQUFBQUFBQUVDQXdUL3hBQWpFUUVCQUFJQ0F3RUFBZ01CQUFBQUFBQUFBUUlSQXlFU01VRVRJbUVFTWxHUi85b0FEQU1CQUFJUkF4RUFQd0RGSklkMm9YaDlaMy9mVDhxTWtKMkhGT0tNM2wwZi92UC9BS2pYWGNic2k3T1FEeldHVjdQSDBFU0ZuSlppU3c5YVRDZjFxRTlNaXBONGdpYlBUY01ZcUtPTWM5RFJBczBZeW8rS1h0OXFUYkRNYW1wS3J4eldTeklTa21JRWNqNjFKRWRMV09nYU0yY1RpWEE1R0RVMFFrd2o1elNZQXlzU3ZIRlB1RzdzWVBVNSthVnBxSnE1SjFDYk9PdFF1YW1hdC94ODN6VU1EbXRvenJpYThPYzhHdldISnBKcGs0KzFlVjFlVUI2YTRIa1Y1WFVqT1JqSklyd0d1UUh5L0t2V1hiamRtbVR6UFBGZWduMXFWQUl3UmdjbjhxYm5HWlRnWUI2VWJNaGR6Y0NwMGtmZDJ3OS9XbzhJN3VRWndjMFhqaldhRTVQbFN0RWdkYVQ5eS9QUTBWZ2NUSnVHYUVMSCt1Wk9oQnhSUzBoN29FaHM1OHFLY1BoOHlnWitsT1lIcWZ4cVBJTXlyamcxSktkT3RJa1ZQK0t1ditzLytvMU5SY2crbFE0ai9hTGovclAvQUtqUnZSWTBtMUt5aWtBS1NUb3JEMUJZWnBaMDhWWDFWZzBuR2NEenhRL0hHZUsxSDdWRXgyMnU0N08wQzJjU0lnV0lBRE9QU3FIYzIxeU90c3loK1JsZWFXT1c0ZVUxUmV3R2JkUGlwZ1NxM0ZjYWpDbzJCc2RBQ3ZOT3gzMnBLZWNFRGs3a3BlSTJzUVQ2VXBVeDFvQW1zWHljdENwWHpHdzBodGV1MGNBUUo3Z3FhWGpUM0ZsVlFEUzN5VVVlV1RWWVh0Sk9QdlF4Zm5TdjZ6c1FBYlpEanBocVBDanlnTHFuTi9QN05pb29GU3JxV0tlVjVTSkZaamtnRUVWNklJQ0NRWnhqSEJVZWRheENHYzBraXB6MjBJUXMwc29VSEI4SEkvT20ydDR0K0ZuYkhycy8zbzJFUTE1NjFPanMxa2JBdUZIcVNwNHIzK2paTnVWa1JzODlDS05qU0FCWG9GVFYwNlE1ekpHQlRnc21NWkhmUkFEZzV5S05qU0tBQmdvYWZlSGNnT2VSUzRyUXhNTXpReWJzNENzVFNFaUxTaGpOSHRIT0MvNVVHWGE0VUVPdEthWmR4VmdQWTFJakN5QUJER1dQQUc4Q285N0F3Wmx3QkluREFITklHN1JEM3VXR1FlaG92QmJuWVdCd0tHYWRJdUNKRDU4Wm9wM3BJMnB5S1ZPSVVvVmJqdy9mTlRZaGtEZFVDNGlJbkRkTW1pYUlvWExIbjBwa2FtSzk0bTA4NXFZQ01ESm9SSjRiby9OU3ZFM0trNHA2SjVDMmJtNUhsMzBuK28wZjBKekZxZG5Jb0JLVEl3QjZjR3E3Qm45SnVmOEFyU2Y2alZnME1iOVF0aDVGeDFxZVQ2ZUM1OW91elA4QVNHcDNHb1QzZVpMaHR3Q2dnRGlxOUoyVWxVNU03U0RvQWMxcGNjSmEzSVlEYUQ0YWFsaVZzQmNBaXVTY2xuVG91RXJQb3V5c29LWnl1N2tISjVwVjEyZHVJVkkvU0EyZkpaZWxXMjZURjJoTE5oUmpyUVM1UU5KSjNlY1pKQnFwbmFWeGtWVzUwUzVNbVhsT004Z1Bta05wbDJ4Wlc1QUhVUGorRldaVTNBK0lnbnlweUsyYVdUYUQxQjYxWG5VK0tsVDluN2wxSkF6NlpLL3lwaCt6VTNVcURnWXdwNXErdGF5ZDJlQ1ZESG4wcDYyMHU4dmI4eDJNRFNzdjN0bzRVZXBQUUNuK2xMd1pyL1YyVlF4a1I4QnNaM0RwU3A5Q3VWZy9VTzBydHllaHhqcFdvdm9kdGF5c3VyYXRieFlQTVZzRE0yZlQwcnBJT3pjQjNDMDFDN08zQjNrUmcvaFIrby9ObUV1Z3kzQmo3dU9jRmx4SnZZSExlbzlxOS9vUzhoaTJ3MmttNEh4TVNDVC9BTFZwOXJlNlZHQ2tHZ1JGQU1Za25ZMFd0YkMwdVhrVnRJaHRjREpZVE53UFgycFhtcytIT09WaWR0b0dvdEp0TUxnTnlTUmdEOGFPUWRtMHRnNGxZc3pEbGdlTUhHT0sweWZUa2czQlZDN20yamMzbUNDUDQxWHRVdTRiU0JBVlV5dm5DSWZWajUrL3RSK3R5OUR3a1VxVFRZYmQyVlJ0Y2pyMW9YYzJjS09UT2hJUFJvM3dEUjI5dWpKdTczQ3ljRnNlRUFFK1hITlFkVXM1RUc4czI3WmdncjF3T2xhUzM2aXdMaVMzczVlOGlNeU1RY2Q1ZzhZNTRxSGJSVzVCa0VrcDV3UENLSmRudFY3aTVGdElzVHdTWXh1R2RwK3RYaUsydHBCR1RCYnNHSCtBZXZXbmxsNGlUYk5aTlBkbURSckp0UG5JQUtiUU5BMDR6Z3FjSDNyVzIwNnhWQ1pMT0lxT0FSVkc3ZVdrVm5leHJCRXNhT21jTDUrOUdQSjVYUXVHdTFlc1pBa3AzRElOR3JKa0hpYnA1Q2cxZ3VTVGpwUllPc2FBRURQU3FwUTNlZ3lTb0ZIRzdxS2xPbzJyazlLWUw1SWJBQXB4bTd3SGJuNW9DSktDOXpnZkZUVVRDZ1VPVUVUWXp5RFU0bHo1a2V3cWttcmMvd0JvdVA4QXJQOEE2alZsN05qT3Eyb3hueGlxM2FETTgrUC9BRG4vQU5ScTFkazAzYXphNDV3U2Z3QnFPVDZlRFU1Mjd0VUNrQWVlS1loS202emhnTWRLbFk3eTJUY3U3STROTnhJZ2xZNDh2U3VGMWh0K3NiSyswTUNPbERPNDJSc3dKeUI1VlpIdFU1TzNKSThqVU9lMFh1WFlaWGF2UXQxNXB5bFlCUXdybkpWc25yVDBzUGc0UTd1ZVFLblJ4eHJqeE9QWElvNXBWaGIzVFNUM1QvMkMyVHZKeU9Dd3p3ZzkyUEZWY2kwQzJObkRGWVIzdXJNMGRvNUppaGpHSG53ZWNlaSs5ZGVhckxmczhTN2JXekJDcmJ3RENnWjh6MUorYWs2akpMcUZ4QkxQaFd6aEVIUkVCNFVld3FNSVFIbFlxdUN3L2VhVy93RHBocHM0aEs2Z2tCVzlPdFJaWU1Ba3V3eHhScWFNUDR1N1hMYzVGUWI2SUZQREdBT2VocXBVMkdOSnNXdVN5SklTV2JaaytXUWVhMVRzNTJmT3F5V05vOHNoaGpidjdsOXZEQlJ0UlNlaDV5Zk9xdjhBWjVwRFhMeXpTd3Irakk2czdNY1pBNkRQeis2dHU3TjJ3aHMybElIZVRzV0lIM1FQSUQyK0tjbmxsb1crT0llZXgrbE5JWmJxMlc1ZmJqZElPbnFhcWV2L0FHZTZMTHZtRVRSc0FjZ05nSDM5dnBXbnlEZzlNNHF1ZG85NjJVbU9PTW5qUDBxczhaak9peHl0dmJCdGM3UGFSWVJTaUdJaGh5RG5xYXA4c1N0RGRSVGJwRlh4cnpuYURqNjhHclQyem4yTTdLMlI1K3hxbHcza1luUkpaZTczNVF1Qm5nOVIrK2xodXpZejF0VXRiMCtTeW43Nk5nQUd6dkdPYzlEaXJ2MlhsL1N0SnQ1ZGdKWHduMk9lbFFOWHQ5UHZVTVpkbU9CdGJZTXFlT1R6OCt0U2V4NE5wWnZBU3VBL0hoeWZqUFN0TXJ2RkVtcVBzUkpsVkFHSDZFK1ZVVDdSWkEycVFMdHdWaXdQeHE2eHpnVEI4Y0Z2OFB2Vk8rMGFDU2JXMGVNSXlyQ3YzVDVubWx4LzdIbjZCdEdnRFF0SVc4SmJCQW90RFl3eTVMU2VFRE9mZWhtbXpQWmFjVDNZM08vQjlLbU16VzhaeElXRXZQTmExbkVLNVVsbFdOdU0xTGdVcEVRZlRyVUtQQnVEdWJvY2dVVm5RUEJoZlRtbUFXTWtUNTZuUDQxTnl3UEFxRUYyeWxRZWg2MU9YZVJ4VnBJc3YyMDJQL05mL1VhdC9ZNUMydFE0T1BDNXlmaXFoWWZ0WmY4QXFQOEE2alY1N0VJRHJDRWovd0FOaDArS3k1ZlZWeC9HaFFJRGR3UmdFQUFmdXFJSlhBbElZN3M4WlB2Um0wQ3ZxMEFDWXhuejlGTkRZd2dPQ0FBYTRuVWVnTXNrYThrK1hKcUJjTklMU1YyY0U5NEZWY2RjY21qRnNxNVJlTVpQTlFMa2dhZXlNcStLWElJSEk0cFFJWWtZb0hPMERIcFJ5OGxObG9lbjJpaGQ5MFAwMlllb1BFWVB3QVQ5YURNakMzR1ZHU3ArdEZ1Mk53WWRmbWhWZUlVaWhBSUJ3RlFEK2RVU0F6RHZiWWxjQUE5UG1rTmNJSVdLb003dWcrdEthNTIvb3l0RXVUR0NmZW95eXE0R0lRTXQweWZTa2FaYlJyY0JBVjVDODFCdjRRaVNESFBTaU52Y3d4VHNXUWtiVHh1eGlvMnB0R2tqREp3UXJZUFVaOGpSUFlxdzZOcWpqUURZQ0l0Q1NYbGVOZHpvTm9VY2ZKNjFldE8xeTYwN3NmYVRMYUM1bWpUdTJDdGdjYzVBems4YzRyTGRIbGRWSWVOV1dSQ0QxRzM2ajQ2VnA4ZWpXdmFMUnJCZ1pKYmEzYVF0RkZJVTcxeUFBQ1Q1RHI4Z1ZlRzk5SnkxcnNTMDd0TkZmYUZOcWF4N1VoUXRLcElPMGdkS3lYVy90TjFEVjd0clRSSW9HaWt3QTdqOGZ6cTU2aG9BN0gvWnpyU1dVRWNVazBXd0lzalNzQnp5em5HNXV1VGdWbVgyVVJRTE5QYnJIQVpKWTJLU3l4N3lOeTdXSFhvUi9Hcnl0MTJtYTMwcG5hWFZwN3VDUW1XenVIemhqQWZ1L1NxWnFidTFvdlZXV3RxMXo3UFAwTzhXUVRXTVZvc1RLa1Z1aEc0ZFFPUmdjKzFZOTJ4a2hqdTNoaXpubzJUazd2T3RPT3k5UkdjdnVvODJvckpFWmtPMGtIY2hIblE4Nmpjd1hMU1dzem9HeU5vUEJvZUhadHFrbGx6OTA5S2VzdTdpdjR2MG1OcFkxZmxFR1MyT25GYmEwejIwclNaYnFTMnRKTHRBdHgxWlFNRE9lUHhGUSsxZHVzbDdHOG1WQk9YSTh4UlhSNW9yMFdrdHV4a1J4bGNqSDA5cUZkdCs0VzdaUXppNVVLZG82QUdzSi9zMHZwVjVIM1M5ekVqQ0lObFdZZGFkdVlKSGgzdStWUFRIbFhPanlXZ2xJeEdwMmoxTmV6M2RyYnhxc1lja2pvdzZHdFVCc0VNbVJMNVp4ejFOR2xjaUlwUXI5S1owUlJIbFFjMDdGZnNjcTZaejB4VldiSXdveEtjK3RFb3lkdkdEUTQ4eW5JeGswUVJncTRHYW9qbWxXVTBzY3N5TGxPOGJuNm10UDdOV0VWcnBwdUZ5WmNZQlBsMHFwZGp2N1JaaUdQa2gyM2ZpYXZkckJOYndtTnVJeXVRRDgxemMyWGVtdkhQcXk2VGw5VmpQb3JIbi9JYUV4TVFxNTlLTDZKNHRTSkp5QkZML0FQek5CVkJDcjhldGN6Y1R0bFppcFVFa2s0eHo1VkR2eHMwdEhmN3pTTVFQUEhTbjdaanVCSWtHMGV0UjlkNDA2d1ptSkxveEF6MDhScFQyZFJtWW1LREl3T092K2FuTzFXNlh0WHFtNG5JdUpCLzdxWnVBZjBUY3ZrcEkrYUthdEIzdmFDNGxtWEN6aU9ZRWVqcUdxdDZTRTNiTUxoQTM5MEJPS2JpSWFZcUF3NUpKSG5VbTZqRGFqSmpPMFBnZlNtYlRLekZqeU5wUEZBZUpsREl3VU5qR01qenFNWmpKZlhJZHNrdU1rOWFsa0s4YTQ2czRKb1pLVkYzT3d4bnZPUGZtbkJWZ3Nwbk5vM2lJWE8wRFBXdE8reVM4RW1sYWhBNXdZYmpmay80V1grYW1zbHNybmRad0tGQmJMTVRWNCt5cTl4cW1vMndZS2x4Q051Zk4xSlA3aWFyQytPV3l5N3hFdnRpN1RMWmRnWlpWczdsMnV3VmpIZGs0R2NiampvTWV2clh6ejluV3V2cCt2MnBoZ2tlQ1FFVDV6dzJlTWVsYVRyT2hkdHRZbHZaaERKSkREdmlCa24yZDRWOGxIcHowNmNWa0dxYVZyR2xhbEpDMXM2TTJBeXh5QitmcFdrdmx2YUwvQUIxcHJYYmZ0RThVWTdsaHNJeVBZVjgvZHBYWjlWa2R6bG04UjlzMVo3ZTcxRk5Ha0dweHlCVm5DUWIrVGdqa0g0NHFyOW9vKzcxSGs1WXFDMVZ4WWVLYzh2SkFoMmhaR1pzTUFOdnJtcDJsYVJjYWt3YUhLd2dqZkw1S2ZRZXBxRmJvcExOS0pPNVVlSXBqZDlNOFpyVXROczlPc3RIaEdqM010MWFPVEwzOG9DdXhJSEJBNEJIVEh0V21lWGlqSEhhVnBFYVcwOEVjUytDTlFGejdWV1B0R0VoN1EvcWlBbmR4N3l0V1cxUDlwRzQ4ampIMXIzV3V3bXFkb05abGV4YU1Rb2lPV2M0SkczT0t4eHlreTNXbG01cUtOY0dQdUVTTXNFWHhFMUR1RWduSWZmZytRelJMV05MdXRPa2x0NVZKSk9BVk5WeFV6THRjN2NIRmI0OTlzNmt4eWd5N053V00rbkZlZDB5emJCbk9lRFRiVzhpTmdvVG5waXBNVVRGd3M1WlNCd0tvaVNkejVQTkVZbVFvQ0FQeG9hQmdzS0oyaUtzSXlTQ1RtbVN3L1oyNEVOeWNjOThTZmpOYWRkM242WEZBRlVLRlFMa2VZckcreGwwWWJoNDJKQ3lzY2ZPYTFYU1ZtTnZNWkVidXh0RVpJNFBYTmN2TlA1YmE4VjZXcnMxR0cxY1pJSVdDVmpucCt6TkNad1dDRHpBSkl4eFIzUVdFYmFqZEVaYUd6WUR5eVdJVCtOQXJ2S09vUFBCRmM3YzVHQXFCaVR1eGpBTkR0WmtCVzFqSVBoalhHRDg1b2hzQmpYYXA1QkhKelEzVjJhV2RGWUR3ZUJlUEwvNGFKN0ZPTTZ2YkFMbnA2MGFkbG0wL1M3MGtudTIvbytmMks1YU0vVlNSL3dCdEFKQmhEN0R5b25vVjB0cS9jM1NzOWxkS1k3aFY1SUhWWFgvbVU4ajZqenBranpBQzdLaHNueEZzL0ZlYWZDalpNc29TUGFkeDI1SG5UV3FhZE5wMm9tMm5rRE1FM0NSRGxaRkpCVmg3RVlOSWprZGRQa2oyRWwrTnc5T3Y4YU5EWmNTcmxRRGdMbnA1VUZ3VE94SlU3Mzh6UnVJQVNzWEdRaW56eFFNeWJGRElxQTd1dU1uenB3cUx3UXhkMUZFbWQ3RXNDZ0RIa2NESHpUdW5UejZaSWtrVEdHN2hseUdiKzRRQmcrL25VS09kM3M0WlhYOVlnTzBqakl5S1hGZE9iVlN3QUtrbko2azljMEcyenM3ck9uZHBkRWxFbmQ3bEg5b2hCKzZUNWp6Mm4xclBlMno5bmRFdFV2ZFBqamVOdDJYQjVZKzUrYUQ5bnIxcHRkMHUydHJnQzd2TGlPQWlFL2RRbkw1LzdReHhSTDdTK3g5bFo2L2IyTFBMQnAyb2d0Wk03bDQrL0hMUXRuN3BJd3luend3OHF2VnltNzhUdVM2akE5ZDFrM2Q5dGpYRnVzbmU1OHVubFFOYk9lL3VYbm1CVldPZmZIOEsyclYvc29sdGV3T3M5bzdzR0NXMWlhZUMzenlVUWpMdDhqSkE5T2F5blVOZWlNSWgwcUxMQmN2TXkrRmZnZWZ5YTZNYjExR04vc0cxSXJGdHRvaGhWNUk5NmxkbjlibDByZkMyNTdLVTduUWRWYi9FdjhSNTBKTEZtSllsbUo1SjZrMHBrWk1idU0xZXBacXAyMHl6bFdlYU9XTnd5a0FxNFBCR2F2RnBmeTJ0aGN5bU1uS0FCZzJNOFZnK2wzMTNwMGdtdEd5bWZGRzNLTjhqK0lyWGRFN2I2RnFHaTIxbk5FYlcvQlBlclB3Ry93QXJkQ1B3TmMvSmhZMXd5VlR0UUpvN1lYekVoR09DT3RWaGJRVHVraUJ1V3l4UG1Lc2ZhbTZmZmNSeHFCWk9PTjNrZmFnbW16TTFxRjZBY0ExcmoxRVplMHUwZ0RYT1QwRk8zNm9HTFlHY1VpRnhFU2M1YWszYkY0aVNjREZQNlFaRkdKSmp5UFdpMGFLVUhoelFlQmN5akJvMUJFeGpIVTFkU0I2UmVKQTZzYytGeWZ6cmJ1elBhYURXdEJpdHJlRm96WnNGa1psKzhTQ1I4MWdsbU1nNGJISi9mV3AvWlVBdW0zN08zVzZRWTlmQi92V2ZQak5iWHhYdlRYK3pUMlcvVUxmVXJscldLNGlSRmNKdUp3d2JINVU1ZVd2WmRzbDlVMUFqb2RzQTU1b1ZZd204MVcxdDR4bHBKVVFENTYvbG1wM2FPd2U2N1NOcGVud3JKZXU3U3lTa2tBOEZncWpwdEM0NTh6WEhIU2NlRHN1TmtaMURWWXdSa0V3QTVOSW4wenMzUGNBcnJ0ekVoSndYdGVuKzFCYm9sTGlMdmdWTVp3d0k1R09DS1phVUc0ZkQvcXpuQXgwNXBiL29hR1o5RDBWMktRZHA0Ry96VzdEajVxRUxPMmcxUzNpdGJ5TzlqS2xqSWlsUUQwNkg0cUVXV0tJRlR5V3grQXA2eklqUXpFa0V4bnA4MFdpSml5UTNkbEZwZDFLaVhOdmcya3pId0VNM2lpWStYUElQUVVOMWkzdWRQZExTNWhNTXFnc1EzbVBieUk2VXpNVk03alBHQjVVU2gxbVNLM1MwdlVXK3NHR0JETjk1Qi95TjFYcDA2Y1VBRTd6TVJiazVIbDlhQ0tRMGFxdzZuUEh4VjFtMG14dllzNkxxRVFtYmxiTzdidTNiZy9kYjdyZkdhcU92YWRlNkNJeHFkck5idTJBTzhYQUo5UWVoK2xYaW12TlV2WUlMZUNHMzhjbXo5WUNlRit0Qko3MmU4bHdYd3ZHUW5DZ2ZGUjFZeVErWUpZNS9FL3lwRjVkUjZmWlBNM0FRRWdBOGsrUXJTWTZaMjdXcjdON2krWHQ3WUhSN2FLNG50VWwycEpuYVpIUWdFNFBrT3Z6V20vYWxlYWhOcDB1bmRwcmJTNTlNaUVkekoraUdTT1lPdmlEUnVTUXB5Q09SMEo5YXJ2OEE5Titsc05ZdmJtUVptdDdkQklUNVNTa3UzNEJVSHhRMzdlTmZmVU5TL283VEpZMVc4blNJeU8yTW9BRno3QW5QMHFydldwUk5mVFhhRDdhOVI3UzIrb2FOb21nV2gwNjVzNUlKNWJndUJDaklWWWxoeGdBK2d6MHJGQnBxMlZvbHRuZTdjdTVHTStnL0RuNjFjMzFGcmJRWU5CdG0yMk1MR2U2Sy93RGp5K1dUNXFPZ0hxU2ZTcTd0YTRrWW5xVHU2K2RYS213R2hza1I5NUhQdlRHcUlxeEpqQnlmS2l0MnUxdkNNWjZmTkM1d3JYVnNwd2N2NGhtcmxUVTdUN00vb2lBam5HVFMzdEVCeHNCejFIa0tLUUtFZzNFWTRyb0VWdkVSa0FaUHZVN1BRRmV4eWR4M2JTa1JMeUZPY0NuOVBrak1DcXAzQlJnK29xSnJUc2JnTG5DODhWQmlrYU53NkhEQ3ExdUpXQkZWcFNSeUtUZFlFREJpUm1oa04vUEdjZ3Fma1VxZTdrdUNOKzBEMEFweURaeXpPSlBhamxzVDNRb0JiL3RGd2V0RjEzZ0RiVHBSQjB2VGtjM0dSOXlFU0Q1TmFqMkF0RXR0RFYxWG1XVGN4K0ZGWnpwYXYvYlN2UVd5MXFIWTNkRjJidEE0enVjbjhoV1BOZW1uRjdXZlRyMXJDOEYxR29hVlVjS1dPTUVxVno4ak5TZE8xNlN6dnRJdVZoM1NXdHViVnp1NWxYbkh3UmtENlVIbk9JMjZlMUpnOE1pdmdZQzF5dHoxeTVYYVMyN3dzU2ZVNTVxSWttNVpDdzJqR0RqMXFjUXFRUnFjSEtFa24xNXFJb1JrS2ZlNkRwOFVvZEl1RzJ4eEtDUWM1K2FlV1Evb2prSG5hQWY5cVp1aW0vSVBHN0EvQ240aW9nUVJsZHdYeGZKWS93QUJUSkNuTEswcDQ0QUdLZzZ2RzBrWWpFanhIQWRXVThrVVR2Q1hudUJrNExmeUZScjhiNUkwSCtFS2VmUE5PRlVTU1hjRjV5TzZZSEp6ejA2VUM3UTNzODlpbGs4ODBrS0FpS0puTEtqTnh3UEx5cXdQQ2Q3S0FQdUhna2VacXFZZVRVNVdZaG9rSmJyeUd6d01mbldtS2Nqa2FkeENrWlBpQUFKUFU0RkE3a25WdTBkcFlqbTNnYnY1dmdlWDFPS0phdGRpMXRaSm5QUWNVUDdNd2JOQnViMS8yOTY1eTNvdTdhQis4MXBPcHRuZitQb2Y3S1NkSyt5L1c5Vys3YzNRa3VkMmNFS3dLeGYrMEJ2KzZzSjFLUnJ2VVp0UW44WDl5MlU5RlVjYnY1VnUzYWVhMDBuN0xkVnRES0VOeHFrdHNrYTRCZFk1Tm9VZXdTTlFmYXNFMUdiZmNKRXZpbGNnYlY0Q2oxUG9NZVZML2lxaVRIRUNnSEJrYmNjZW5sL0d2WThJRDVacERIdmJuSSs2T0I3VXFRNVVrY3BrZ0VlZUtwSU5yelRDQU5FMkVCOFlIWDZVUDBhQVNUZDYzTzA0RkdibDQxZ2xNdkNZT1FmT2dtaHliYmhsQU9DTTQ5S3VlazMyc2VvVENHd2Jub09lYTYwbkkwVlpobmRJTWo2VUsxMjR6Q0k4OG1pV25EZHBWcU53V0dPSWIyOVNlY1V0ZEg5VnU3Mzk4VEl3TGs5QWM0cG9VN2NzaHVITVNqYVQxUE9hYXpXaUNsNHFUQjkxL2ltclVLMDZLL0NzY0UrbWFma2lhQ1dTUE9jSEZBTHQvd0JvdEc0bndnNm1ndHFDWkFQT2lxTVFvSFdpaDVwOGswY040VEdWRFc2REpIV3RUN0tzZjZxV1Blbm9XL2VLcUhhbWFLVHNKcEYzRENJcFpaR2piSG1BS3RIWWttNTdKV1VraHdHM1lId2NWaHk5emJUajlqTWhYQTgrYTlRbmZFdVI5M0pGTk9jcjdCaURVbUZGWUE4N3NBRWUxY3pkSU1QK01uYU1aWWRmaWtCMEljaFQ0UUFPbnJTWmNreHNEbjArS1NxLzJYQis4NzgvQUZJMFhVUkNaQWtjeWtvdTQrRWdENjFFczV4R3MyQ0hVS3BKOHZQK2RlMzJWTXBiQkxLQVBnR3V0WS83RWZEeXdITlZQUmZUMTI2YnBXL3Y1SG5uR2NVM2R1SElZL2UzTHpUY3dMZDZDY0hmL0trVHFCSHlTQ0NDZndvSndiYkpLNUk2ZWZselZYakcxR1ArSml4cVhxOHJsUkZHU1M1M0gzOU0wTjFTZGJlMVluamFLMHhpTXFxM2FxNmU2dVlyS0hKWjJBd1BVbkFvM3FYNmpTSHM3VVpaRUVVZU91UjAvTVZWZElrTSt2UnpQeWNsaC9DclpkMjBwdCsrWm5ndHkyMldSZW9Ib0Q1ZTU4aFcyVTFxTTUzMnNIYS90TkwybDF5WnJQZkhheHNYSVlncGJzK0drQytSWm15ZllZejZWVjRYUnBMcVdOU0lveDNhQW5KTEhxU2ZNL3pxVHFQZDJPbDl6QWl4b0J0VlY0d0tIeUtZYkNDRHBJNDd4dmsvN1lxWkR0UFdweXB5T0Q1VXhKTDNNclk1amI3eS93QVJTcmQrN2kyK2ZsUXkvdWU0aGFicXg4SUh2VlNFSDYzZGQ1S0lWUGdUbHZjMHZTNGU2aWFSdUMzN3FqV2tRMm1XYkxNZWVhVlBkbFFVVGpyV212aWY3TjZoTjNzNXgwVVkrdFdCV1JOSWdEa3JHRUd4QjFQSEpOVlU5RDcxYis3QWhpWGJ1SVVlSnZpbGtJcjNjeVNGaUl0cTU0OHNVeTY3V0l5RDhVV3ZDN01WM2RQSWNVTGxqMkVEbW5LSzhISXFVV1pvKzhZa2xqeVRVVmVsU0VMR0xieGdITk1pNFdLc0NPdEZVVXNvTkM0VjNPQm5IblU4U09CZ1V3T2RvOVUweTg3TGFQcCttVEIyaGRuWWVtUlY2N0VRYk95R2xEY3hKVitCL25OWXBwa1lNYWVJOUszYnNlTm5aTFNVWEF6RWNuejVZMWh6VFdPbW5GM1JCb3hHaEo4VGtuanlGUHhEeFI1YkdTTW4xcjE0OFJnS01EenJ5VTVrQ3BnNHdhNUhRUktDQU00R0FhUVpNbE05QUdQOEtmdUdIZHhvQWMrZWZtb2tnNG01KzZvR1RSQUgzYjczS2hRM0dLbjJhb1lBSmQrRlVZMjRQUEZDSWdYbkxmOEFNZnlxeWRtTk1sMWZVb2JLSWlONTVDTjdjN1ZBeVRqMkE2VlZueEllMFlPV1lZVXlkUVBlaXZhN3NwTDJkN0svMDFxbDVIRU1xelcrd2xrQjlUNmdkUmlyQnFVNmRpZFZ0KzY3SmFycU1TU2h2MDJPTDlJY24xVURoZm9PS0dmYWQ5cFZoL1V5R2E3MDU0OVFtbWI5RnM3eFFNa0hoM1RydEhYQkF5Y2V0VmpqL3dDbGF6VFU3VnJZVzg4ODhDVHlnc0xUSjc1SS93QzY3am9vYkp3RHp4bXFMMnd2OGxiYU51RHkxRFo5ZXZaWmJpV1NUZkxQSzAwMHpIeHlzZk1taGx4Szg4anlTSExHdW5ERFhkWTVaYldic25wcFZSZVNEQmNlQUgwcXdTRXRIaDJZeEU1RVpQaFB1UjlLZzZLNC9vNkpKcEVoL1YrSGR4bkhwNzFJaWxXU0ZXSUs1SkhQb0QxK0NPYWpMdW5QU1BjWnVycU9KdWVlZmloK3B6ZDlxUks5QjVDaTBLZ1N6U25JQ2pBUHVhcnpFaTliSU9Pb3FvVkVkeGVJOUFjWitLcTkxTWJ5ODlZays3UkxYTHZ1b2hieHNkN2p4SDBGRGJjQ09QSjZtcXhuMHJUcnZoY2NnWStLSHVkekUwN081SndLWUhTcmlTaHlRUGNWY1oyMjdRY2RPQm1xamJBRzVoQi94cisrcmEwVytRdmt0N0E5S25KVVJPN0JjbnpvVmZqYkpqR1BmNjBmS2phY2RSUXJWazJnSFBuMHhTeHZZb2FsUHhuQUlwaGFkVHJXaVQ4ZkJHS21KSmhlY0ExRGk0WmM5TTFLY0tXb0FacEtreEw0OERGZlFIWlVxblo3UlluTzBpMlVnWTVJcjUxMG01YjlGOHZYTmZRV2d5RCtpTktKWWhsdEl4Zy9GWS81RTZYd2pWMHcyamE0eDdWRU55c1RCamsvU2xkOWJzY3ZNVkpHU3UzcFhqV3NNNmQ1M29LanFlZ05jam9NM0Y5SDNzSmtERGNNa2VuTkludkl0cktBMlg4WE5ROVlqaVc4VkZZOEpnZ2M1NXBrOTJHYmVTeEE0NXA2TFpwcFJFWWdDZkVDZVBlck4ySzFXSzA3UTZaSzB4Z0g2U3NUdXc0QVlGU2ZqbXFwY2lQZXVDMjBjRG1rallZSFJqaEdZZWZ0VmFMYmRPMjkvd0JvOU5oa1cwMUhSNDhJZjJqeUpJUWVNNHdRRDE4NitXUHRMMXUvMWU3dEJxYmFjN1cyWTFOcXVDZU9TeDZuK2RiVkhkZG5lM2ZacTlqdXJmVWJydFJvZHVrVXNObE00a25VRHdNRkI4UThpY1pCNDh4V0c5bzdEQWxlUFMyMGUyakpEdGNnOTR4OU1Ibk5hNHorVzZ6eTlLckwzU3FWaVl2NGpoeXVNank0cnJVN1owTzBNUjBGTTU0cWRwTUlrbTNzRHRYMC9PdDJTeFdqbDNSbis4bzQ5alV0czRMWk9ldFJlNWhrdVpEQXJwYmtaVGRrRW4vNWltWm9Db3dra2lzZitiTlpyRUxocEJwZ0krOHhMSDNIU2dkMUtzRnQzN254SGhWOHlhc1dwcXNGcU56SGJDZ3lmZ1ZRYjI0TjFPOG5Lcm53cjZDbmhOako0aGFhY3ZJU1dQSk5TWm1Bai9MbW84SDNSeDcwcVR6eitOYUlNc2MxNVhlZGRRQzRlSjQvODQvZlZ6aWhDcUdZbm1xVUNRUXc4am1ybkFCTEVzZ2JjdTNPQjVDcHpWaVRPQ3g0QjZVRjFNc2NBOU01bytYUXhrQW5wVmR2VzNzM1hnMHNSVU1WTHRKQkVYeW9PNFk1cUl2V25WclJLV0RHelp4c3AzQVBSMXhVUmVhVitGRUFUcG9UdUQ2WXhYMFBhb3gwdTBtaVVKSCtqeHJ6NVlVQ3ZuSFNqbTNIbm12cEd5dW9wZXk5cWpGbGtWUXY0QVZsL2tmRjhLR0p6RFBoc0VBY2lsaThjbkVMSFlvSkdWeUtITy82ODdneEczajNyMkdSWUxhYkpZazhZOVRuaXVheHJLOWU3a2tJN3dndGdESUFCcEx1RmQ0cEcyRWRhU3VacFZraGp5QndCOGNVMVBCSThrakdQeEhraW1EYy9PVHZQaHB5UnRzRHM4cXE0WWVFK2RNUEM2ZytEcUJVS2FWNWJ5YUxiK3o1eC9ocDZKVVp0VnZ0QjdaemFycGR6TGEzaVRNVWxpT0dBSUdSNllQb2VDS1IyaHZialU3YjlKMU9aNTlSYVF6VFNsc2h0ekVESGtBZVQ5S09Yblo2TzhtdUxtNGtsTzdhd1ZTQUJnWStlUUtFZHBiU0d4MDVGaUIzVHlybko2S2luQUE4aHpXMHN1bWRsVnJHU0I2OFZacldKTFMxUlNCbDhLTTlUNjBIMGF5ZSt2MFJPaStKcXVOekdSYVNXaXFnQndUS1J5RHgwOCtLcksvQ3hpRTF3bzR3T3ROMjdkL2Z3UjRJRE9NL1NwYlJvU2RxZ2Z4cGhabHMybHZKQUNMZU5uQTlUakFING1wVWhkdE5RRzhXVVRjbnh5a2VYb0txdEtsbGVlUjVabTNTeU1XWmo1azE3RXVlVDAvZldrbXBwbmJzdE9CNkd1YytneFRpRGc0cHB4ak5NRWV0ZVVvREorSzhQRk1QUlIzUTVuRVFrWnRrTUJ3WFA5NGY0UjcwQkg1MVpkRGhkYk5vN21NQlErOWNqSkdldWFuTDBjS2U2U2JKVWptaDE0cmNsUngxSm90Y1JMRzNpUmRwNk12U283UnIwOGpVeW5RVmV0T0NsM2tJaG5Lam9SbWtMbk5hUkoxQjBwZElYcFN4OWFjSUIwbjlrbkhwKyt0ZTFmWFcwcS8vQUVlSHZIdHRpdUkrTUtTT2hySTlHWHdSWkJBeU1uMnpXbDlwVnQ3clZaWjdHN3Qzajd0QnVEZFNCNVZISkpiMmVGNk50Mm12SGtJaXQ4bjEyZEtpemRwWldCUnl5cVNQdUp6bW5vdEx0QnBhenl5M0RYVXBZb2tiQUlvQnh6U1JwT2xTVzVFYTZpYm5jRGxuR3pIbitkWi94WDJsMm5iTzFzdzZKYlN5N2VVYVRDL1BGRkU3YzZNMFc5cmU4VTlHRzFPRCtQU3EvSG90amNuZHR1WTJMRUU3eGo4TVZ4N04yYW94bE55L25sR1VmdkZUY2NGVExLRDk3MnIweWF5TXVsYmxsWGgxdUNxayttT2FyNTFxNER5YWd6eHFzellZa2NFcnppbjdMczVwVnlRSjd1K2ljdHVLcGJveS9Ua1Y1cUhaelRJSXNEVXRSNUprQS9SVjJnbnk0TkVtTTZGOHIySDNHdlNYU2t2Y1JnTTNDcU1ITk1kdDVHTnpaUlNITEpFV2I1SngvQ250TjdQWXZiZVZwSkRHamh5SFFET0RrVUc3UlhxMzJyenp4bmRHTUloOVFQUDZuTlhKTjlJdTlkalBZMTR4YnpoUWU5MzVadmJ5cWJjWHBRT0hSMWJkNGxLNElwN1RVZzBYU0E3TnNaVTcyU1RIT2V0Um1qS3U4enQzaGwyc3JiY0RhZVIrK3A5M2F2aUhKcWFBWTd0eDlLSDZsZENXd3VkcE80N0FjK203L2FpNGdVK2pmVHBVSFZyWlJwbHlVVTdodGJwNUFqK2RWTkZWWlJTellGU1AyYVlINTB1MlRDNVBKUFd2THdaeDZlZk5XaDdhcnVRa2ltcmsrUEFHQlVtd1hLSFByU0w1VlVER04zbWFETlFvV1hvVDlLUkltMDRPTWlwMXB0YTFBNHlPdk5SMHRiaThMdEJHV1VIRzQ0QXo4MDlrZDBpMnVKcnVLU0dFdkdqZ3N4NEdQUG1yVnNhSnozYkFJM2sxTlB1dFZnSEN4TW9YYUQ0Vk9LNXBBUEMyUUQ3NUZaMjdYSm80Wkl3b0V3QTllZXRBTGk1V0tSMWlPNVNlT2VsTzZpU2pGU2VDT0RRa2RhckdGYWR5emtzeHlmTTB0YVFnelRpajNxMGxpbGo1cEk4cWNBUHhUaEl1alE0Z1hieWNEQXE3YURwTXdVeVhKUVo1eG55cXM2Wm9OekhwVnJmUEhJdHJNU2tjbTdxUlJXSFQzQkJFMHY4QTZ6V2VkMzlQRWQxMWU1a3QwdEdqbGpWTTVYb1RucFFPTzR2RVp6R29KUGxuaXAxdkcxdWl3bG1iZ3NNMGhuWGQ0ZnZIcWZlczUxMHRGZ3ZaMEQ3b1NYeU9qOFZNWFZaMGpZZm9ySFBVaCtvcENsU0NNNU9jbmlwVWl0YWFUL1NEOTIwVGtwdEJ5eWdlWkhrS0xvelExa2lKOTFrNGJHT0hBeFNMaldGTUFqYTBuTGtjN21BeDhWSDcrM21qM2JzZ2pqRklMaHhqRzVzMGFnMlJxdXJ1bWlNc2F2REpNM2RLR1BPM0hpSS9kOWFxUTRBSUF3UEtpV3ZOSi9TVWtNdkhjQVJoYzlQTS9tYUhWcGpOUkZ1MXM3UXpHODB1MWpnKzdjeVJvQ1BRMFgxR0g5RmloaVk1S3hxTS9BeFVUVGJKcm5zL3BNdHV1WllaWTVDQ2NaVlg1L0xORXRYQ1hYZjQ0ZmdxZmlzcmZpLzdCUklBQUIrR2FSSzZ5SThaNERqYjE5ZUtZSjJvWFpncUQ3ek4wRklpU2U3WWkyVGJHUisxbEdCOUIxTlZvZ2JhRWNvYytFNHhYT3U4SHFNMU4xQzNNVnhqZUhCR1N3R01uei9PbWRuR1I4MWUwa3c0aWlKUEhGRDVYYWVYZ2RlZ3A2NmtiWnRIMW9qb2VuTk1keEh5ZlFVL1hZSnRyU1FRQ0tKR1ozSUJJSEM1OHo2VWNpa1MyTFdvUlVqVGlQamdpcFcwV3lCWThBZS9uODFDdlpGQkFZZUU5UWZJMUc5cTFvdWY5WkUwYmdGU09nb0xOTExhbnUyT1UvdXNldndhbjk4SWx5Q1NudnpRclVMb1M0R09sUEdGVE56TTBtU1RrVkhGY0dPVFhxMWFUaWRPYWRBNThxYlVjVTZvcGd0ZWNVNXRieXJ4QWNDbmd2cnhSQ1FyRHRIZlQ2Qlo2WklSK2pXemwwNTV5YWt4MzB3QXhuOGF2WFozVE5JYTJpM2FKcGJuQSsvR1RuNTVxMTIrajZNdk12Wm5RblFFZElXQngvNnF5eTVaUGk4Y0xXY1diUFBhVzBqdDRpcHlNK1ZLWmZQQkJyVjdldzBRd0VSOW50Rlhaa1k3aHVQTVk4VmV5V09rcEdDZXoraUUrOExjL3dEdnJMOVkwbkhXVVkyL2RKQjlxYXVMWVNvVll2dEk1QU9BYTB2YnBrazVpaTdONk94Qnd6QzNmQzhkUHYxSkZocFNmdGRDMFlrOCtHR1FmLzdvL1NRL0JqcVdndDJ3bWNlbnBUb1E3aDZIcldzeldHakRaM2ZaclI1V1lCc1lsOC8vQU5sTVBwdW1PTXlkbk5FVDJMVEEvZ0hvL1dGK2RZcHJReGZzY2s3bFU1UDRmd3FCeVRnZFQwclFQdEtzYksxMDYwbHRkSjA2emtlZmFKYlo1U1NvVW5hZDdFZmxWRnRJbm51b1k0MUxNV0J3UFk1cmZETGMyenltcTByUVlqYTZYQmJucW01UjduclVYVVAxVnhNY1lVNVlZL0dqY3R2bUp5Z3dRMjRVUDFleW51RWplQmVXOEp6MEhyV0V2YlRYU3JSMjhWemNkNDZsbURkQ2NnWjlxSzl6SSsyR0NONUpXNFZJMUxNZW5RRGsxSjB2UnIyV2NRd3g5N1BMaEVqalFsbWJPQUI3MXZ2WWJzcW5aZlRyaXl0aEROMm11b2MzdDJUbExLTTlFei9BY3NSbm9CVlhJcEdFeC9aNTJpdTdhR1o3U0t6UnprTmVUckZrSHp4eWZ5b2dmc2wxZFZYdnRTMHlNTWhZTXZlU0tmUVp3T3ZyMHJSZFhGcmFhaGE2WDJZc1pOWnYxUWlkcFZEaGVmdnNUNFVINEQzb2JOcUdvYWU5dzJ1NnJhZ0szRnZFcGM3UVB1cXh3QVBqMHJMOU0valNZWXFIYmZaRGRUenFaZTBlanJEbkJaSTVYNmRmSWZ2cnp0Qm92OVdiazJSYU9XSStLRzRqKzdNTVp6OCsxYUxvbXFHNWlhYlRpSTlPSWJlalE1TGZEVUUxYlVyUFdvVzB1TnhQQ1BDNVlBRU4xQkI4aUtKeVpXOWk0WXlkTXp1TGpnak9mUTBPdUgzakI4NmUxdTJsMHZVSkxWNUZrQ253dXB5R0ZESkhadW5XdW5HZldOZXZLRlFxVHdPaHFCS1FXeU9sUE9qdjE0Rk1PdTBnZWRYRWtBYzBwUlhBVTdFdTdqbk5NaWtIRlBJSzVZdVBDYVdxTm5wU0J4QnhUdVBuOGFhUlRrQ253cDlxQXN2WjdXcm1PQk1kejBIV01HclZIMmx2U29IOW1JSC9BT09uOHF6blFaQjNTWk9PS3MwTFpHZXRaWll4ZU5XZ2RwcjhxVC9aaDVjUUtQNFZ3N1QzeTRQNmpwNXdwL0txNEg0cmk1SXdNbkhwV1hqRitWV01kckw4TWY4QWhqN0dCTWZ1cHVYdFBmTmdtT3hQc2JaUDVWVzJmbk9CWEdRNG84WVBLalo3UlhxbHYxVmt1NGNrUUFmeHFPK3UzYlpMUldaNS93REovd0I2RXM1SXpnVTJUajk5UHhnOHFSMm0xQ2U4aHRSS3NTTEd6RUNPUFoxR0tycTdNL3M4ZkJ4Umk5VU9NRWc0NW9jRVZaQWNnZ256clRIcUlxVkd3VUlPRkI2NXpTSjJHVzYvSUpwYXNuZzhROWgxcnBPUXd6blAwb0M3L1lkZjJPbmRwNys5MUZsajdpeWN4VHMvTUxFZ0VxcDZzUjRRZkxQdlYzUGF0TlhzNys5aTFOYkhTQmNHR1MzZ1lHNGQ5Z1lsblBDcmpqZWM1UEE2Vmkra3pTMmx5enhzUnVVcVFEbklQV3JHSXJTNDBvSTBjUXhJWDVVWjZBWS9Lczg1dXJ4dW90R2w5cmIvQUZLMkhaL3NmcGtNWXVaZHZmYjlwbmJCOFRzVGx6Z0hucHhRUzR1OUQwSFVEUHJNL3dEV0srS3NFNEl0WTNIb25XUVpHTW5qMm9IWUJMQ2VLU0p2dU1Uc3lRT2g5T2xDWnJHS2VkNUdadDVITE1TU2FKak5pNVUxcmZhblU5U3U3aWVhWjRvcFNEM2FIQ3JqMEE0RlE3TFc1YkpQN09IYVFuT1NLV2RQWXVRVzRIUW1wVVZwRkFtNlhhM29LMTFqSnBIYXM2aGR5elRibkRiODVPNmx3UHZBSThxazZqYmlYTElwREw5MGZ3b2RFU3JaSFE4VmM5SlNaWlFvMmpyVVE4bjNwWkJ6Nis5ZXF2Tk1pUU9LV0FlS1VGd2FYc1BISEZBU0xmTHFNNGI1cVhHbm9jZlBJcUZHV1hHMDFOdDVpaDVGS21rSWdPTnlidmNVaDQxRGVFa0NpVFN4blI1WEFpTXJ1cUE1OFNMeVQrUEZEY0NpVVVqUVFuY0lSNlZaSVNNY1lxcjZDbzdpUGpuMXEwUlpJSFRGVGtNVHlFRGs0UHNhOFlCczlCOFVwVlBwOUs5QUlQcG4yck5acmFjOVJYaFFucno5YWtNckFZeHo3VTJVSjZyUUREUi9OSU1mSFQ4NmU3cmtubjRyakdjR21FS1NOaU1yZzgvNHFnc0czRUV2OFlvcTBTbkpZTm4ycU0wQ2xnQVhKOHNuRk1qS2c1WEFmOEtVNmxnZVNQclQzZGhTQXdZZTFjWXhqaEQrZEFSMFYxNURqR001RkVJcG1TRWhqeVI2VkdTTmljYmNmQnAwcXl4bklKb29Ja2s1emdmaFRHOTl4L2QwcFFjZjRXK0tUblBSU2ZtZ0dTempJR2VmZWt0dllZWXFmbW53M2hBQSthOVlER1JnbWdCN3hFY2tDaGw5YjdKTzhRWVZ1bzlEVmk4VGNCQ2ZZQ21Ycys5TG95akJIUW5INFZVcFdLNkJucFhvWEo5cWtUMnpRVE5HNDhROC9YM3Jrang1ZmxWcE5xbmh6WEZlZXRTQW50WHJSMEEyaTRBcVRHdlRpa3FocDlFeFNNdU5WQkpJUEl3TUh6cjBBZjNnYy9PS1dvUHhUa3FsMjN5U0JuYmtrbm42MEF4cEgvRFFmNVJWaVQ3Ni9IODY2dXFjaGlrbjluOUtjais2MzAvZlhWMVoxWlE2SDRwTXYzcTZ1cEdUNS9TbTVQTC9BT2VWZFhVeUptKzRQaW9MZmMrcHJxNm5DcGNmUmFkUDdQOEFHdXJxWm1iZjc1K0tjSFgvQUxhNnVvcGZFZC8ycjBsK28rYTZ1cGtZbC9ZL2hTdkt1cnFBOFg3ZytSVHpmc0YrYTZ1b3B3SjFqOXBIL2svalVTSG9hNnVxNTZSVGkveHJ2OFh4WFYxTUhVKzdUMGYzdndycTZrY08vd0IybFI5RDgxMWRSQ2YvMlE9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvRWluc3RlaW4uanBnXG4gKiogbW9kdWxlIGlkID0gMjk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCSlJtbHNaU0J6YjNWeVkyVTZJR2gwZEhCek9pOHZZMjl0Ylc5dWN5NTNhV3RwYldWa2FXRXViM0puTDNkcGEya3ZSbWxzWlRwTVpXOXVhR0Z5WkY5RmRXeGxjaTVxY0dmLzRnSWNTVU5EWDFCU1QwWkpURVVBQVFFQUFBSU1iR050Y3dJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIM0FBQkFCa0FBd0FwQURsaFkzTndRVkJRVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOXRZQUFRQUFBQURUTFd4amJYTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXBrWlhOakFBQUEvQUFBQUY1amNISjBBQUFCWEFBQUFBdDNkSEIwQUFBQmFBQUFBQlJpYTNCMEFBQUJmQUFBQUJSeVdGbGFBQUFCa0FBQUFCUm5XRmxhQUFBQnBBQUFBQlJpV0ZsYUFBQUJ1QUFBQUJSeVZGSkRBQUFCekFBQUFFQm5WRkpEQUFBQnpBQUFBRUJpVkZKREFBQUJ6QUFBQUVCa1pYTmpBQUFBQUFBQUFBTmpNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwWlhoMEFBQUFBRVpDQUFCWVdWb2dBQUFBQUFBQTl0WUFBUUFBQUFEVExWaFpXaUFBQUFBQUFBQURGZ0FBQXpNQUFBS2tXRmxhSUFBQUFBQUFBRytpQUFBNDlRQUFBNUJZV1ZvZ0FBQUFBQUFBWXBrQUFMZUZBQUFZMmxoWldpQUFBQUFBQUFBa29BQUFENFFBQUxiUFkzVnlkZ0FBQUFBQUFBQWFBQUFBeXdISkEyTUZrZ2hyQy9ZUVB4VlJHelFoOFNtUU1oZzdra1lGVVhkZDdXdHdlZ1dKc1pwOHJHbS9mZFBENlRELy8vL2JBRU1BQmdRRkJnVUVCZ1lGQmdjSEJnZ0tFQW9LQ1FrS0ZBNFBEQkFYRkJnWUZ4UVdGaG9kSlI4YUd5TWNGaFlnTENBakppY3BLaWtaSHkwd0xTZ3dKU2dwS1AvYkFFTUJCd2NIQ2dnS0V3b0tFeWdhRmhvb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LUC9BQUJFSUFSOEEzQU1CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBR0FRTUVCUWNDQUFqL3hBQk1FQUFCQXdJRUF3VUZCZ01HQWdZTEFBQUJBZ01SQUFRRkVpRXhCa0ZSRXlKaGNZRUhGREtSb1NOQ1VySEIwU1RoOEJVV016Umk4WEtDUTFSems4VFRKVVJUWTVTaW82U3lzOFAveEFBYUFRQUNBd0VCQUFBQUFBQUFBQUFBQUFBQ0F3QUJCQVVHLzhRQUpSRUFBZ0lDQXdBQ0FnTUJBUUFBQUFBQUFBRUNFUU1oQkJJeElrRVRVU015WVFWUy85b0FEQU1CQUFJUkF4RUFQd0Q1NHhNdCs4S3lOaEtTU2ZUK3Q2Z3FpZEI4cWs0aFBicUN1V2xSSTFrMGxCbmhFNmplbGJXVUtTdHRTa0xHb0tTUWZuWEorSVVubFZsV0tvZzZ4NDE0QVRFVWdFbjlhOTBxVVdkeUk1RTBnam5TZUE1VjRkRFVvaDBGU0lyd1VaSnJqbkZkSHBVSllwSi9vMTVLNDEvU3VENDd4UzllWXFVUzJkRlJJNVYwRnlQM0ZOQ05OaFhRZ3hDaE80QXFVU3hWS01UdFhpbzgrZGNLTUNTZkRXbHlrR0lnMUtKc1hPZkNhNzdaVTdKSC9LS2JNVHFUNTBrZ1FSOWFsRldQaDVYUEtSejdncHp0aUJHaFQwcU9SSTBGZWpyVXBGMng0dUFnUWxJSTVnUWFUTVR2OWFiOUs5dnZWVVMyZGxaQjAxcjNiRXBnSlFCL3dpdUJFZVBXa0JBRUVhMUtKWThxNGRVQ0JBU0JIZFNCWEhhcWpWUmprSXJqUUdaU1Qwcnhra3lSUE9wUkxaNExJSXEzd3U0YVJiRU8yS0xoV2JSWnpiZE42cGxDRHk5S3NjUHVpeXdVZ3JBelQzVHBVSll1SW9pNGMwQUdZaUJVR05mV3JMRUpWY09HWkJVZGFncUVUSTBtcVJHTUVhanFlVklScEhXbkNOcEVWd1JCSjUwUlJ5UUtYV2E4Sml2YTV2NTFDSHVuS3ZHQnBwU3hYUE9vUTZIMHBlc2FlTklrR1lBa25haTdnbmgrd3h2RW5MRzlVK2w4dDUwS1E1bEEwNlJyc2VtNHEwcktiU1ZnZ2Q2ZnRMWnk2ZURUSWxSMThBT3Bvb3Z1Q0x5MXgrNXNsT285MmFVSWVPaFVraVJDZXZMcElxWGlOazNodG9HTE5BUzFBekttVk9IcVRWTXRiSGZacmgxZzd4V2kzdUxacTlMVEMzV20zbDVVdlBDQWhKNUFiN3o0MXExMmNHeHQ5V0Y0emhTRUpRaEN1eFd5RzNHbERjcDAxVFB6SEtzZTRZU3RqR0xaOEU1aW9oSUIxTTZUNUN0OVlZWTRnczJ4ZEVDNmExUzRQamJWMUI1ZzFGdlJKS3RtWmNUZXozRWJHMEtzSGJ0OFF3NHlVdVc5czJtNWJCTXdTQkpIa2ZDSW9HZGJ3cTVWZHNZb3dMVytSM20zTElKWkJWK0ZiUjdvNTZwQVBoVy9sKzh3SlpidWtrSm5SeEdxVkhyNFZXOFVZVGhmRmxpNnRQWnM0cTBQczdvQ1FmOEFTdnFEVjErZ1UvMllKL1pOb1loKzVCUFZDRlI2eUorUXBWWU5hSlFrb3U3aHlkLzRkS1NQL3FHcGw1aHdSYzNGdSswV0x1M1VRNGxHd1BXT2hHdFZSVTYwc041OHhPMGFrME5qT3BOeHpoZS93bkRyVEVURCtHM1NRcEQ2QjhNeUlXTmNwa0Via2VQS3FFN3hzYU9jQnh1NnRjS3U4SnZRSDdGNUNqMlozUm0wSkhJOVlQT2crOXRGMnhRc2Q5aFVoRGcyTUhZOUQ0R3I5QnFpTFBTazllVktCQk03VW1rQ29XZThxOUo1aEo5SzhOYTlBQXFFUEErQTJyMGlEM1kvU3ZhVjQ4Nm9oenpuWVZOczJuSEdaWkxvQUpCeXRaaFBuNVJVSTcxTnRBLzJYMkM4cVoxMDU4NnNoTXZrcWJmVWxTWUlKbUROUXlOTmQ1cWZpeWk1aUZ5dFI3M2FLNXp6cUZHMzdVQ2VpMnRqUzBpTnA5S2FVbUJydlVzcDE1YjAycEVueW9paUtVblVpa2pYYW4xSTd4K3ROcVRzUHBGV2loc2ZyU3hyUG5YaHBJTktkTlFLaEMxczJMZTN0R2JseDRHNlU1Q0djdWtkVkhrYWxZTmpEdUI0OHpmTkpuczh5VkQvQUVxQkIrVlZ0NHc0d2tXcm5kVWhLVktIU2RmMXB0ak5jR1VrcVg4T1VEVW5rYU51Z2ZUYjM3ZTN4YXlhdjJGQk55V3dRNENWQjFKRXBrSGZjNjZjNkhMZ01PSDNlL0FRcFdxRkE5MVhrZXZnYVhneEdNWWRoNmJSb3NsczY1WEdWT0tSUElRcE9XUEdhdHI3RDNzUkRkdGRMekFLS2dqS2txRTlNb0gxSnE1T0w4QmdwTDE2SlBCL0I3dmFLdWx5MjBzd2trU29wblRUbE9sSGRsWlA0SmNwTHNGcHlJMGtqenFvNFJ0c2N3cDV0eTBXbC9EV2hCdEwxd2xVRDhEa2QwK0JrVWZvVXpqQ1VkazI2MWNxays1WEtDaDFVYmxJUGRXbnhTU0tGUlFUYkhCYXRYN0syblVwV2hTZmlqUWVCck11THVEK0lzUGJlL3NCS0xpM01xN0lLQ1ZBOUJPaCtsR2J6MTVZT3J0bVVyYlFDVHQzdm55cU5jWXZlSVRMV2QxemtwU2lmcHpxMjAvU2xhOFBtdTRHSVdXUFBuRjJMaHErZEJLa3ZweXFVZHZLUEt1cmUxRENaVVNwMVVGU2grUXJZdmFiYXB4VDJjWDE2NkE3ZTJaUytDUnFrNWdESFFRVFdRMlRqMklwUUxkSVZsK0xYVStsSmt1dXgwWk5uYlRKSzF3c2pUcFhUMWtnc0tRNGdxYVdSbVJNRWtBd3BKR3loSjEyT3hrVThodFU1VlNtSTNFVTY0bFNrRTVTWTAxRlN5Tk9nVHhiRGxXRHFjaXc3YnVBbHQySW1OMGtjbERtUFhhb0hMOUtNYnEzTDF0Y3NyVVFndExjai9XaEpLVCtubE5CL0lFUkZHbllMVkNWNmtJMXBmTGFvUTlYbzhhOUhTUE9rMjZWQ2hKR1lUcjUxTFFXMHRObFR5a2xRbktVRXhySEx5cUdSclRyaVZLUzNxZEV4cjVtb1dYT0taZmZiZ28rSHRGeDRpVFVRQ3BtS2ttL3VsUVJtY1VxRHkxcUlCQ2VtMUF2QW42SU5kdXRMR21zelhSZ2FiVFNIZnhtTkRWb0ZqYmlBUUlpbUNneVpxY0V5Q2E1VWdFN2FWWlJYclRCZytsY1IxNTZWT2RhR1dVa1ZGVWdneHIwcXlEckQ3ejd3QzFGMXhXZ0t0L25SVHc3YnBiY3pzcEJXa2QrNFZvbEk2RDk2SHNPYVRuekxKeURmS2RWK0ZISER0Z3JFMXA3UklSYk5mOEFScCtFZUhpZGZTaGxPZ293Q0hEOFFMTFFSYjJ5M21OTXU0emVnMWlybXl2TWJTRDdwZ2phRTlRMnFUNmt5YXY4RHc5bGx0TUlBNm5laXUxWlRrQTB5NzBsNUdOampRQW5HK0tXR2toVmlVWlZhUmJLVVBvYWxXM0hGd29kaml0aGJQOEFlQ2cycDViQmtjeEkwUGpOYVRhMlNWZ2tEVG1SWGQ1Z1ZsZVc2a1hOdTA2ZzdoWW1xV1NmMHkzaWo5bER3L2krSFl4OWphS3VjTHVVcFVyM1o1d1BvZUViNXBKMEo1R2ZDbGVzVGNXN3p3WjdKMXR3dFBOWmdySXJjUVJ1a2pWSjVpZVlORDJMOEpQWUE4TVV3QXJXaGs1MTJoTW5TZThnbmN4T2gzR25TaURoN2lLMXhLMFJjV3kyQTY0bUZvYytGWS9Db2FTSm54U2FkanlkdFM5RTVNZlhhOEtkbTNTN2RPMkZ3aEp0TDFvdEVMMUV5Q0o4eUFQV2czMmoreXBWbzRyRnVFR3kwVzRVcTFhT3FkTjBlUGhXbTRqWmRwbmV0Qm1iUjlvcEIwY1oxKzhONG5aV3g4NnZFWENnQXJLa3VkZWRPVVU5TVU1Tk96NXJ3QzV0OFpVYlcvYVN4aWFCL3dBSWNINGdQekZSN0cxVUc3MFBnL3c2OHBIV2RhMFgybThHMitKTU9ZcGhhRTJtS1c1N1JaYTB6ZjZnT1JuZnJXZTROalROKys1YVlrazIrSXJJN1FBNVVPcUFpZHQ0Rlpwd2NIbzBSbDJRMWF1Q3l4Q3h2WEV5aTNmUThzUk1wQjd3MTNFVlpjVmNFMmVKcWZkd2RwRnBpQ0pVRzBqSzFjcDNHbjNGRVJIS204WHRGSmFJUWdGR3NqYytJclI3dXh6WFRTaHJPVk1qd1NBRDhoUlEzc0dlajVudUdIYmQ1eG00YlcwOGc1VnRyRUtTYWIxQjByYWVKK0hMYkZ5Rzd4ays4Z0ZMZDAxb29lZjRoNEdzcTRod1YvQm4wQmJpSHJkNEV0UEkwQ28wSUk1RWRLWUFtVlIxODZUcFhxVG5VSllsU0ZTVU5rcHpkMFJvZEtqbmVuVktVRU5nZDJFL3FhaEVYbU1KS2NSZXpITVNvbjFxRnFvZ3o1MC9pUlB2MXhtM0Rxd09mT282RGwyM3BhOEdQMGNPcG5vYVZHbmVVSkZKQkt0ZEVqV25VcGtRT1d1cDJxeWhBbFN0ekFGZUFJRWNxZVNNdW01cFFuS2RmS3JUS0dDa0JPeEFqWHdxTytrRFlST2dxZTRrNVRyb2FpcWp0VUVnUUFWUnlPLzhxdXlxRllsdHhDRzU3UTgvd0RyNTFxdkJMQ1dzTlowTUtPb25RVmxPSGQ1NTl4UkpoTy9qV3ZjS0lXbXdZUVV3cUFhelpYczBRWHhOQnNGQUlUR3crdFc5cTRBVHJRNjJwVnZiRnd4Q1JKOUt0TUpVcTRPY3pJSElVcHV4a1kwRmRpN2xUQTUrTldLRkpqU0lPLzhBdFZOaDZvRyt1K2xUd294bU02Y3dLT0RwRWFzUzdTREpqZjhBT3NTNC90SGVIOFcvdE8xYnpZZGNyL2lHUnBDejk0SDdxajE2aXRudW5JVHpnYjBHOFoyU2NRd2U1dDFBbk9uNjlhS1N0V1ZHU1QzNER2REhHRGFsMmxyaUw1WGFPcUh1bDhRQXB0ZkpLL0hsNDBkM0dPMmRyZW9adm90SEZySkJXWWFWSE5DOXRlaDFGZk45aytxeGN1Yks1QlZidUhLNGs3SkkyV1BFYWVsYVRaNC9hWWx3bS9oT0tMU01SYWE3RklWLzBta0pXUFRmK2RPeFpiV3hHZkQwbHJ3TE1ReE5oYnpMMXU2MjYyNjB0SnlLQmhXY2twTWM0SStkWWo3U01IUW0vRnpiSUFCRWtEcC9LdEJ4eEZwdzFqb2JkU0djUExUU0hIRXBoTFRpVXhtVUJ5T3FTZktxWGk1anQ3QnQ1aFljYkt3cEt4QkNrSzV5T1dtOUhMYjJLanJ3QWNLNGl1TFFCbS96WE5zTkFvbjdSSGhQUDFvd3d2anhGa2h0dGI2NzZ6U3BPVkpoTHJZQjExUHhDT1ZDZDdoYWtQOEF3ZkZvb1JwNTFVUFdvenRBSkVxSlNSNGlsK1BRejFHM1A0eFlZa3lYY0p1N2Q1THdoSVc0RUVFbjd5VHFQS3M3OXFiZHZiWWRoZHEwc0tXMHRYZTJLaEdwK2V0QkNyZk00RXBiU3BlWUFRTlpuU3AvR1dJS3Y4YmVsd09KWkpiQ2svQ1NOeVBBbldtcDJMYW9vTnZTdkhiblhqcURGY25lS3NvOSt0ZHVCUlMzQUVCT2tqeE5jQVNhN0lWQ2U4QnAxOGFvdEZ0aWFoNzljRWMzRkdQV21FQ1NTZHpVbkdBa1loY0liSDJhWFZoUGlNeDFxSzJET3czcGE4R1AwZUpsT1VhQ2R1dE90SjVrZU1Wd2taaUNtbjIwcDNHdzFtb1NoMUtGS3BmdlFQbnZUcmNkbWVwT3RLa0FUQUJNYlRGU3lVUjNkUWRDREZRTG9sclBCMTdvSFBsUDUxYnVDVzFFeDNZaXFsOEJUNmlxSkJ6QURhclJWRXZBclp4YlMxNkpUbTNOYU5oT08yMXVwcHJ0RzVBQTBJMTUvd0JDczJ3cEw5MGhMZHYzbFppRE9nQTZrNmFDcllOWUs0Z3NveEs0ZHVnSlZrdHprK2Y2MW15SzNacngxMVNiTmdYaTdkN1ozYmR2Q25BeW9nSjYxTXNzYU9Ib0MxTnFVazZ3QkoyNlVEK3gxdDI0eGQvT0ZPVzZDbjdRalJKMTBOR1hIN3B3aGhMalRJS1gxNVFScEJOSjh0c2M0K1JYMldGdDdRYlZ0eExhdXhubUZLTXorOUZPRDhVV1dKSHMyeWhEZys3TllkaG5FVEdHWFNPMFFIWEZyVmxBdEFXMUVCSk9aY3lCQ2svTVZxRnZlMmQ2NHEwdWJKV0c0cTJuTVdGYkxING0xY3g0SFVWYTcxYlFMVUxxTHNMcmxaVWt5QjQrTlZkNEpZVkdzZytsUDRZOFhXQ2gzZE9oVWVZL2VtcnhDZ2xSVUVnSGxUWXlZbWNUQXVNN0wzYkduaUIzRnF6RDlhWnNYa1gxcjdrNlA0dTM3MXM3eklHdVgwamFpdjJnV3BkZlE0QnJKRWdVQk5qc1ZCd2tvVTMzcG5VR2dUNmpldjVGUVo4VVl1TVg0Wlcrc0QzMVk5M1dqbVhDUnQ0SGVoSXZZbmdyOTNiMlN3cXdiUUZLWmVUbVFTSXpLQTNTU2VsVDI3cGJhamVOdElkYmN5bDFCM2JXTmxBZE5UcjQxQ3g3RVVPNE5lT0oxZEtja3pydnYrVmE0eTdHT1VYRFJLc3VKY0t4RnBLOFIvZ2xCV3VZeWtnRDdwQW1mQ1BLYXBNUXU4R1RkRmRuZHFXaEpLa0QzZFkxanhBNjBQSmFVcXlLeE95VkQ5YWhpTnZHbU9LRktUTHB2RTJiVzdadVdDcHgxcDBPb0dTRWdqYVNkZC9DcVFTRUFFa3dJbWwzMnIzalZsSE8wYlVuMXJxa05RZ2czSE9sV0JsUjNvMDZ4ek5JTkNLVXdRblRsK3RVV2k2eE1KOTdlSTFsWjFtZGVmNTFIRzU4REZQWWtvbTl1Qm1sUGFLanltbUFaMDFqZnpwUzhHUDBsTklPVXpyTWJiVStVbFJBaWRkZGRxam9jT2RDUURFL3BWZzNva1paTS9TcVlTRmJRU0lrbWVoa1Yza2xSQ1NaMk1HdTBpQUlBZ2JrMCswZ1pUQm1QR0tsbFVLR0FHU05TQUkxTlVlSnRkbTRGaUlJaWlMcys0QW1ZaU9WTTM5aDd6WXVKWlNTdEJ6amxQV29wVVZSVjRGaHJ0L1pPc01BcVc0ZmhtQVJPczBjWGRyYWNQNEVVczJkbzFjS0FTQWtBcmNWNG56OGFFK0g3eDNEbERzNENpQ2xVN2pXaTNoVzFYajJPQjI0aHhMRVpVZFZjdmxXWExPU2swZExCaVVrbitqU3ZacmdyZUVZR2xKQVU2dnZMVnpVbzZrL2tLdnVMTE51KzRlZFpLRzFPRWhUYWxDY3Foc2FrMjlvcXl0bTJ5U3BSU0NRRFZiaTk4UVV0TFNVaVkxNTBPMTZYWGFXZ0x3bGh5MWN5MytHWjBCWVZLV08xUXNpSUowazdEZm9PbEdUOXRiNDJwTGwwaDR2em5RNlFXbEpQK21RSzd3ZHR4dDNPVG1ibVFEUktseE9VYzBtaWpkVllFNHBTdElxN0REdmRsR1huSERyQVVZajZWN0VsSkRaQU1DTmRkNm1YVHFXMGhXbSsxRCtKWG9JeWdtYXZZdWtDWEVyU0gwSFNmT3MweHkxTnU0cHRZSVNwVWlPZWsxcVY0bVVMY08zSVVMOFFwdDc1eEp0MEZmdUNDSENOTzhxT2Z6cGM1VU93UjNZSW91ME50OXF3dVNBWkJHbmlENFZWNHFXM3NLVzViSldoRDR6S1FUT1RYWUhucVByVWpGbEJocDA1UWxUaW9nR2Q5QUtnNGhsWnc5dENwMFJBOFNZclZ4VTI3Wm41elVkSTR3MXNYR0JKQkkreWV5WmZCUTMrYVJWQXBCUTR0QjNTb3BpZWxFZUFvVU1Ddm5SOFBhSUFFYzVtWjlEVlZqNkV0NDNlcFQ4UGFaaEhpa0d0aldyT2NudWlDWnBOdEpwUnFETmRmblFoRGUyMUo5SzdPeDFyZzg2aEQxZVVZaUJQclhnT1pyc21BTnhQUTFUQ2o2V2wraEllZGprby9uVEtCM1oyRlNjU01YVHFSc0ZIODZpbzFVT2xMWGdiOUhtd2N3MTFKalNyYTBJSUFubElOVllPb01kNEhtS2wycnBDeHJFYmVOQ3kwWERhSVBkMkhLTlRyK2RQb1FnSjcvZFBXS2pJSmM2UVJVNWhCUWZoMDMwSDVVRENIME1wSVRrMTVDUkJIclU5aTNpRkRXUWU2ZjNwbTNhV1ZxeW1BZFozNVZZTU55WUlnaWRxQ1RJZ1Y0bnN4WjNTSFdSQ0hRZHZ4RGVtc0Z4Ui9EU3Q2M2U3TnhTaEd1KzFYdkU5dUZZU3R5Tyswdk5NY2p1S0U3Tm5OZE5xS080RkFubG9LQ3V5MmJjVTNHT2phc1A0a3h6RTdmdDhJdDF1Qk1TbDFKU1Q0YW5YMHF5dFU0emp5MzBYOW1MVkNHamtjUGRsZklmTVZBNGZ4TVdkdzVtT1Z0ektaSExTaVpmRUZzdnVkcEhtVHI1MEtoYTJ5NVpWRnVvblBDdUpDN3R1eWZBUmRzL1p1b080SU5YYTNVbzBPbmhRVmVPMnpsd3Urc25BM2ZORE1vSmdkcWtjaVB5TldyOTkyelRhd1Njd2tIbWFrTFdpU2xHWHlSTnYzems3dW8zOWFvRkJUaXAxeTFaclVWTkdkbzJqZW9SSXpraUI0VXpxS2N2MFZsOFVoc2hSeXBrSkJPbXBJSDYxUThhWEZyaGVHT2d4Q2dFcFFCb1ZSdWVwcVh4U2wxOXBxMXR5ZTBjVkk5TmYwckp1SjcyL3U4U0xONDZWRmd4bEowQjYwSFR2T3ZvTlRVTWQvWkdkZkxyaVhya0RNVERiWVAxcUhpRHkzTXlsNlpSdDUwMDBGRzlSSmt6R2dxV3UzRDY0ZVdPekJnTnRDWUhqMHJvWTRwS2tjekpKeWRzTXVGOEpUL2RkQWRuN1IwcUtlb0FBSDVxUCsxQU9PQlNjWnZFclZuS0hNc2ptQm9QcEZheGhGL1pLd290Mjl5dzBxQ2xLYmhRUmswZzh6UG1QbFdVNHhsVmlsd3BDZ3BCV1Nram1LZlBTcENJWGJzaEowM3IzSTcxMElBNlRYUFg5cVN4eHo5YTVNVHZYWEx4cE9SNmRLb2doMTJOZGt3QUk1ZGFiQTFwNG5RWllHbFJoNDlzc3I1eEs3cTRXa0NGT0tJanBPbE02QVRGTzNKSWZkQkd5bGJlZE1na0hXU1FkYVdFL1I5czVSNG5lS2ZRTmdSejBxTTJvRXBKaytIclVsRyttdlh4b1MwWGRwRUlKaVJwQTUxYXNHRkoxR2cwSGhOVTJId2pLTmZJYjFic3BKQUpIbEkyOUtYSU10V3drQUVwVEorVlRteUJFZkVCckhPcTlxUW1Na2tSQS9PcFdVcEkwTzNMNjBwa1IzY29SY01LYWNBQ0hVbEVIeDUwRHRQT1dTNFdWSld5Y3FoQS9XamdxeW9UTUdPWDcwUDhRMmdENkxvcDdwaERnQTM2SDlLaVkzSEtnMzRjeEhCM2JPMER5M2gycVFDNHNIUlI1RWcwVHB3dkRGTjVjeUMyZGlKbjV6V1k0Rmgxd2xoeTNaQ1hXRkswQ2lRVW56ZzBkV05wY3NzZ1ByUVNQOWN6UUpXelRLZXRJbjNXQVlhaTNjZXNtK3p1RW83cWdvNitCMXFNaFpTTFpINFJtSXA3dGlFRlBYZVR0VVZiamJiaEpWQkkrVlBqR2pKT2JaWUM0SldyVFNtSDNrcGxRSUExMXFDYm1kRWE4NG11MnJOeTcrTlJTM01HUHZVVFZBZDlqZG1sVDc3dDRSQ1VqSTJTTitwckdlSzBrNDdkclNRRkJVR0RGYnRpQUROaUcyaGxBRUpIU3NZNGlzVVhUV0lYakNnSFdWTFV0UDRrQTdqb1JRdzFJS1R1TEJheFNGWGljM05KL0tpUERHRXFKUXl6bkNlOG9EbU52VHA2MExwZExMZ1VuVlFtSi9yV3BLTVZ2VzdaOXBwNHRvZlRrWGxFSEx6QTZUL0t0MFdrWXBKdndQYmJEN2Q5YlpkdGphc0xjN05MbmJKQUo4enkzMnJQc2FVaGVLM2haUUVOaDBwUWdhNVFOQlREanpyamFHblhscmJScWhLMUZRVDVBN1UzeU5YS1NaVVl0ZWlRWlBXdVJFYmIxNDZjdDY4SmtVQWFFaXVhN1ZzSzRQblZFRlNBU1BHcG5ZTFFsUGFJeWtpZTl6MUlxR0RCcWFKY2JSbnlIS0lCS1FURWs3K3RETHdiaFNjdGtpL0o5OHVTWm50VkgvNWpUQ054cFhiNWwxY2ZqUE9hNFRFRW4wb1NQMFZKaFVFeUtrTnVaWUNmaU81cU5PV1Awcm9MMUVSVVpFWGxtdE9ZU3FJbmxWNVpuUDNrOGp2em9hc0hSQWdFMFNXSy9oSkkwL3FLWElOTXVHdFc5QnZ5TlNFSzdvblVqU2FiWm5LQkltSmswK2xZSHhIU1NPdTFKYUxSMGtBaVRwTlFjU1EwTFY5VDRQWkJCQ3RRUFdha3JjU2ZoQWtqbnBRaHh0aUFhdGhhdHJDbEZXWlVLK0h3b3NlUHZLaXB6NnF4L2h6aVJXR0pVaGFWT01reUNtTzZlWU5IVnB4UFpQVzZWOXVTU05VOHhXSVlmZGx1NVJtWGxCTVpvMDlSMG9rUTcyS3dseXpiVzRvWmtxYlhBY0hoVFpZK3ZoRlB2czB2KzMybmlRd3VUb0NaaW5yY201SVVkZkhsUVhnV0wyaHVPenVMTU1jcFZycitWYU5ZTUlmWVF1MlVnb2pRVC9XbEIyb0p3Yk9yVmlTQ3ZicFA1MVpXZ3pPUVBoVHlOTU1za2FLa0Q1Vk9RVU1OS1c0Y3FVaVRPd3FydFdEMXJSWGNST2hqRDNscVZCQ1RyMEZBV0VZUXAvQjhYZGRRVDJqU3Jkc0hjcVdaanowK2RFdU1tNHhlN3QwcFFVVzZsRlNFUnF1UHZLUElEbFZ5N2FwUmcrRDIxdWdKUXAwdUtLZGMwRWlSMUcydlBXaXhSdDJ5OHN1cXBIemJjdEx0N2wxaHdmYU5MTGF2TkpJUDFGTkUrWm9wOXBqTERQSE9Lb3Rpa0pLa0tWSDR5Z0ZYMS9PaFZXcEltdFZHVVdmMzByMjA3VWczTWcwcGdUNFZaQnRXbkt2Y3hYUjIycENQQ3FMRU1jenJYSjNFZld1aUQvdFNLQSt0UWh6OTZyUzNTT3lUTWJEZnlGVmNDZldyVzFBVTBNbzBBU1BYS0tDZmc3Qi9ZYmNFT3FCblFuV3VkTlBQYW5Ma1pYWEFkRG1OTXFPb2puUWd2VEZKbmY1UlNKTkxFalNrSGo2NjFaQ3h3NXdod1Q4SkVSRkUrR3JKU05ZT3ZMblFqYW5Lb0hUVHhxK3M3dEZ1MHBia0lUMVZ6OG9vSkpzSk9sc0sybGhMYUVoVXp5RzVxcHhQSGJXektnODhuUDhBZ1RxcjE2ZXRER01ZL2RPb0xkb1N5eW82cjF6Sy9haDBJa3laSkoxSjUwY2NGUDVDM2x0ZkVJc1Q0cnVId1VXcU95VCtJN21xQzV1SExoV2QxUktqejEvV3B0cFpzM1FsQktTTjB6cUtkZHdnaEpMWkpqbFc2SEdtNDNGYU1jdVJCU3FUMlZFS0ExRXBOWCtEWXFHRzAydCtnUFdxeEl6QTkwOVFScUNPbzhqSXFtY1pVM0lBa2N3YTgwK1VJS2RZQTdwNlRTbkJMNHlHcWJlNG1vNFRhNExjQkNINys0c1VxSGNkZVFtNVlWL3pveWxJOURSVGhtR1A0WmN1c1c3cmJ4YklNMjdtWkNnUklVQWRkUVJXTTRDOWZNT1hCc1NoOXRwcFR6N0NqdWdmRW9EcU56RmEvd0FLNHRhWXJnell3MTFhbjJtMG91R2xDRk5IVUR6QkFHb3JMbHcyclJxeDVxMUlLTzNWMllXNUtZL0VJcUxadUt4ekUwc3B6ZTZCZVJLWWd1cUhJVFVpenRVQnN1SXpCZk5KMUI4RDFHdFUxdmdIOXJQTGJRcDFWdTB2SWh1TlVBOHlPcEkzOUJTdnh1MHZvTlpGMWIrdy9zdUVYYjF4MjZ4KzFjdE1LWWpLeW9aVlBKQm52SDhKT3lSNms3VTdpZUZ2WWc2bFNuQmJzcFNRcExhUjNFYmtBOGdCR3NjcG9EYndqaVhnekNyL0FCckQ3ODNOZzBBNjlocmh6c09JQmc3YXBVSkIwMXFLdjJxWWp4SndqaStIdDRCWldBZWFUYk80ZzFlSzdnY01FWlZEZkxtMk9tOWFvcEdhWCtHU1lqZG94dkdidDVRUFozajYzVURZZ2ZkSS93Q1VDcXk2dzExdGNOL2FvRzNXcHlMSXFWbnRaUXB0U25FSVdDRkJLUUNESGlKb2hTdzNkMlROL2FnZG10T1lpUGhVTng4NjI0TWNNa1hHWHBpNUdXV0tTbEh4Z0FRUjFOZU9sVzJKV3pUZDI2MlJsSVVZSTg2ckhXMUlWeVVPUkcxWnBSY1hScWpOU0c5Unkzcnc2MTZJSXIwYWRLV3hnaEVkS1RXdWxDQlhKSEljNm9naG5lTmF0Y09HWmdtT2NmUVZWeHJKcTR3bEpWYkU2L0YrZ29NanBEc0N1WXpkS3pQdXFPNmxxT3ZuVWMrRVZLdmhsdW5rYlpWbFB5TWIxSDI1MUVDL1RrenlweEtTZEJxYTRuSkdhZGRoek5TR0dWdktsWXlvSjBRUDFwMkhCTEs2aUp5NW80MXNiWGNKdHlFcEFXN0gvS1AzcEdYMUZ4SzdrbHdUcWVsVy91QXVraG9JT2NmQ3BJMXF1dmJKNjF1T3pkMFZHaDVFZUZhM3huZ2ZiMHlMa1J6ZkV0RzdaRHdUSUMwRVNPa1ZWWWxoanRvcEtrZ3FaVjhKUEtwZUMzZnU5d2xEcXlHRjZLNXdlUm93VGhvdmM3VDBobFNjc2o2RVZxZlRrUS9UUmpjNThiSiswek9XczdLMHVKTUZPeHEvdzE0WFNBcElHZEpnb0E1MHVKNEkvWlhIWk9nbEN2Z2NHeWhUZGd5NWg5MTJxUVRCN3lTWTByUHg1eXhTNnZ3MDU0eHl3N0wwbDRyaFl1RUZ4S0NsVzJicjUwTVhObXR0Wm5mNlZxVjR3Mnd4WnZFaFRWd0ZOdUVIVE45MC9uVkJqR0ZTc3FST1F6RWo2VnB5NDQ1RlpsdzU1WTNUQS9EYmhkdGZ0UHRLVWxhRlNjdThFUWZwTmFiN0hXVk40Ymk5K0VOcWFRNjB5NlZJekJLWUpCOEJQT3MydjdCeHBTVkpBOEk2MVo4SmNZWXR3dzY4ckQzRUtZZjB1TGQxQVVsM2xyem1KRmMyY1hGT0xPbkNTblVrZlJxYlpzVzR1YmRha0kyY1FvekI1S0IzaXJQaHl6WWF4SmJoU3YzWktFcGNlUUNRRkFnek1SQS9TaHIyVFkyeGo5czZsUUlMYUFweE9oQmJKeWtqcHZFSFk2OUtPTHF6ZnNIczdEcXUwYkdkcFkwRHpaMkI1VHlJMmtlTkpTMVkyeXI5cFRqV0g4TjQrN2FPbFBiMmltbkcwbVlXU0VoUS93QktwT3ZuTllEWVAybjkyTVV3eHp1TFNROGxUaGhCV2tnQkk4U0orVmJkeHd3TWQ0ZnZHN0FodDRNb2NTaFJBU3BYYUFsSTlFbVBIU3ZtL0dHNXZuMXdVaGF5cVBNMFYvYUlrWE4rMDVlTW91YmQ5VXJiU2wvc3lUTzhsUU1UNUFuNlZaOEdwYjl6ZHQ0VUdzNis3K0Q3dzgrdm5WVndkZUR0VjJDem82bVVBSkc0bUJQcWE5ZTVzTXYxS1RDUXBLa0UrWTBQemo1MXV3S1BUdXZUbmNtVW5QOEFHeWtYbXVycFR5dDFxSkltWTEycXl3N0RCYzJEbVpLYzVXb2E3d09kYzJ0dUliV0VraGFaVDRpakN3dEExaHR1VUpTNGxTUVFvZFpxc0ZOdHNQa3R4aWtqTk1Tdzl5MGNnaVJ5cXU4cU0rTGtoTjFialE5eVk4Nm9QY2hjSXpKSVNjc3pPNW1LUmt4WE54Z1B4WnZncFRLczZnMHY5UlRqN0RqQkljVEhpS2FwRGk0dW1hRTAxYUZqVWJWWjRXU0xkWGUrOTE4QlZXYXRNTFVFMnhrVDNqU3NuZy9BNm1MaVFDYnk0R3NCMVkrUnFDcHhRVUVKR1pYSVZJeEpYOFUrcFFqN1JSSWpiVTBtRldxbmw1enBPNTVBVTdEaWVSMGpQbXlLQ2JZNWFXNXpKS3htV282azBRWWZaSmRNUVpqUVJ1Zk9vYmpHUktjaVNNdXA1Vkx3bC90bncyQVF0SXpheUpqcCsxZHJIQlkxMVJ4c3MzUDVCTFlXQ1dtd2xLUVNSenBNVXd4dTlzVnNxQ1FzNm9XVHNvRFQ5QlNXTjhFbEticE1TWUNnTlBYcFZ4bVNwdk1BSVZxUEVVdWQvWW1McmFNcmV0WExkMVRUeU1yaURDazd3YUx1RE1RVTZ3cXlkTXJhR1prbm1qbVBReDZId3AzaWJEYzRGMmtKa0RLcUVhK0JOVW1GT0l0TGxsWnk5MHpycEZZMS9IUFIwcFZueC82RzcxcUwxeEZ1cmJLVmdjcG9XeHBuc2x5RWtLTzgvbFJoYXdzQjV2VkxpWUJISWMvMnFzNGxzMHVOOXVZU2hjQXFqUkt1Uko1QStQT3RHUko3Ums0OG5GOVdSYkY0WC9DZHhiay9iV0RnVURHNkRHdnltcGpUYUxteFM3cm5uSXZ6Z1I5S0hzRGRMTjI4M3BsY1NVT0ovRWc3ajBxMndXNDkzdkhMSjRrSVdySWZBOGo5UnJUTU11OEsrMEJ5TWZTZHJ4a1c4dzFHcFV0S0Vrd0NvVUlZN2h5R0ZCeTNXQ1NkY29nZWxhZTdiNVlTNEFKT21rMUJ2TU9hdW1GTnVKRUh3MjFvY2tWT05NckRtZU9WZ3o3SytMLzdvY1VNWGI0VjdtczluY0pHZ3lxMFZQVVJCODBwTmZWMXU4bSt0T3haU3pkYTlzeEtpbEtra2FoS3VVaUNLK01zY3d0VmxkclFwTUorbGF6N0hPTDhTYXdWVmlxNGFXNWh4Q1dlMlJtbG9nNVFJSU1KNzMwcm10T0xwblppMU5XalF1SjJtUDdJdThSd3BxNUp0UHRMMnpCQmNDQjk1STJNSGZwcWVWZk90OEM3Y1BMQ1FsTGkxTENRY3dUT3Y2MTlJMnVOdVhXS203Y2FSYjNidXVab1EyNHFJSXlrblVqeGc2MWt2dFM0YnRjSHZrWCtFcExWaGZPSFBiQlBkdG5ZbUFmd0sxSUc0Z2pvYUZVL0E5b3oreVVwaStaZVNwV1pwWVhwb1NPZXZsUmh4aFpoekMzTGxvUjNBNG54SFQ1VTV3R3BrcXVXSDdORndqc3k0cFNnTkFQSHg1ZU5YV09BT1dkMEZ3QXBLekEyUUlNSkhscFdyai9hK2pGeTZ1TCt3STRUVW05c3V6SmhUU2lVeHJFLzBLMEEycVVOcGJDVXdsSUFJRlpqd000cHJHQzFBeUtBV1JNYmYxdFdzWWtVMnlWclJPVW96bzlSKzlGaDhzRGxPNUtLTTY0MVpLcjVLMGtxU0VCSk1UQkgrOU1ZTFo1cklraVZaNG1EckExSDVWMWoxeVE4K2xKQzBreFBoRy9uVi9nVFRUR0MyeEp6TFdrdVFOZFQvUW9zRC9rN0ZjaDljU2lEMTFaanMxRmVxZGlDTlRRM2lGZ3BnZG8yRmRrVEJubFdsdTJMTHBVMlZQU055R1pIek5WNjhLdzRwVzJMNlFydWxDMFJCTzNLdGViRkRMR242Wk9QeUpZMlpxT2tTS3RjT1ZsdCtzbWFqWXBaT1dOMDQycEpTRUtLVHpnMU13enNQZEU1czRYSnpkSm5TUFNLNE9kT0Nwbm8rTTFOMmlGZWliNTFwUkVJV3JNWjBNSHJWM2c2VzFwVjJha3JXa1NValUrR2xVK0lKQ2IrOHl4bDdkeUNET21ZN1ZPd05TbTJaUVFGS1ZyK2xhOEdSNDNveFpzZjVGc3MzQ3JjcDFuYm5VRzU3VzF1VXV0SElzUXNSeXE2QlB2RFFNNXA3MmsvMXRUV01Xd0xTQ0FuOEpVTnZYcFhRV2RUWCttQjRYQi90Rm5aS2J4RzFTNjBDRkg0a2prYWZ3aStjc3JwVmxjL2FNVE9jQW5KNCtWQzNEVjA1YjRzeXlsVU52cnlFSGFlVlhlUDR1OWIyeVYyUkxTQXBDa0wyVTRTcjRqNFJPbnpvN1VvN0VTeHRUcEJzcGxEaURzcEN1ZzNCb0Z4M0NsV2w2bEFuczFUQ3pwSS93QnQ2TmNGdUVQMjlzN0dWcTRSSWc2SVVOQ1A2NjFJeFMwTHRzNDNsU3BRRW9uOFEyL2IxckxraGVtT3c1SEIyVS9EYnFXUWhoUkhacU1UT2sxZlhObTA5YnVNdm9CYWM3cWg0ZEtETFM0UnFWWjBrejNRSlA4QXZwUmxnOSttL3RvY1REcVVnK1k2eCtkU0V2b1BMRGZaR2IzRm05aE9LWEZvc3FLbVNTbFVmR2prZlVmclVlN3ZReGk0S2RNNlF0Sm5uV2g4VDRVTDYyTjJ3a0c2dFVTay9pVHJLZjJyS01XU29MUzRuWkdnNVIwL09nVTNnbGE4R3BMUENuNmF2Yk9HK3NyWXM5OXg0QURXcEh1N0RHanF1MUo1SkVDcUQyZFhxYjFxM2FtRkFxU1FEc1NDQit0RjlxR2paRTNJTU02bUR2NEd0VW5iMGM5UnIwQytOTEJ1NHNYSEZOZG1wS003WjZpaFRnTzQ5eTRpaDF3byt5WE1IUlVDUVBXdEF4Y2kvdEgzblVrcm5id2piMHJOK0hyTis1NHF0TFpwQldRN0tzeGdKU0pLaVR5QUdzMWo1TWZHZEhoenROR3ZHNk5saVZ0Yk52SEk2NGlkZFJLaHFEeWtmUTBBY1M4WDNlTjJLYkZ4cGxtM2JkN1JXVTUxdUtFZ1NvZ1FBQ2RCMXFUeHJpeVVGaE9HWFVvV2xXZGFVL0VrZDBCSzl3bUIwRTc3VUkycmJTbjBHNjdWTnVvRklVMlB2UWNvQjhTS3l4UnRiTlE0WXRPeHd0Z3VJQUNrQmNxU0VyU29pY2hqY0RlZDZhNGpsdkI3eGFqbTdzbVQvcVNLczhKYVd6Wld6YnFnWEEyaENpbnFCcjlhck9OMHFid1p4cE1ITzRsSm56bjh3SzNWMFZITGN2eVR0bVo0YW9zWXd5Nms3S014V28zVjhnNEZicW5ObE9RK0tkNnpLMFIvNlFUKy9PaUcweElyQ2NQdUZISmxnU3JmbUQ5S0dPb09oczFlVkZiZXNseThVMmtGU1NvSkFGSDRzRFpobGdpRW9RRWdjdHFwT0dXQTVpOW90S1FGb2R6S0hJWmRUK1h5TkcrSXRkcmJqOFNUQUlxOFB4MkJ5dmtraWh1dEFoY0FFa0lWNHpzZm5RYmlxMTNOeGRvUW9FSlZsR3VoZy95b254ZDBNNGMrdVpLRko1K0lvVndJZTk1eXM5MXgxV2s2Z1Z2VHJaaFM5WTd4RmFKZVNoU2tDRnRKSmtjOHRETnUxMktWSldEOFdtbkt0SnhHMWJjYlpLbEJDQWdTcFdnQUdsWjlmTGwxSkt3TkRvQm9OVFhMNXNWS0thOU92L3pjampLbjRWK0l3cTVmVWdRaFRpaWtBenBtcXh3MDluYWdpQWMyOVFiNXY3WlJnRHZxRVRzUWR2clUyMFRETGNnZzUrVzhmNzB0TFkxdlJiMnlpcGFYRmxJUkpIakcvd0N0VzJNc2dZT1VFbFNnQVZhL2VJa2lvTGpFTk5vNTdxbmxVMjZkVzlncFdzZDUxNWF3QnlBU0UwendYOWdFcHd0WEU1aUZCUVVsWGxWenhyY09LZllLTkxlNFY3eGw1QmYzbzh6cjUxU1lnZ2gzTVFSeWpwVDl5NHAvQkdXaVZLU3g4SU91WFdkS3RaWDFjV1U4UzdLU0REZ2ZGRzhpckM2VjlnNnFVbi8yYStvL1d0RnRWS2ViTFR1ajdPaXZFY2lPb3JCc011Vk1QSVdPWm10Z3dTK09JNFV5L2JyL0FJKzBRTXc1clIxOGVucldtTWxPUFl4WllmamwvaEV4L0NBaTc5OGIwYVdmdGhsbnZIWlZOMi9hV3EwS2JudW1RZHhSSDd3M2MyK1pBaVV3cHRRbnpIaUtwSFcrd2RMWm5zanFnOVBNZUdvcGJWYlF5RSsyZ210cnRDMlVQSU1wVUpJNkhtRFFCeHhnNldndDVoSURLcElBKzU0R2lMRDdnVzl3VWx3RmhXOGNqMXF3eFMyUmRXYmpRUGRXa2lTTk5xSnJ0RUZTL0hLekorQ2NST0g0dkJWQTNqMUg5Zk90WHhhVGJyTGEwTnQzSkNrNWpBQjVwUHJXSlBKZXcvRUVyeVpYV1hOVW5xRHFEOWExK3lmYnhQaGQ5VEpVdHRiU1ZvOENEcjZqV3BnbmNhL1JPVENwZGw0eHZEaWJXOFMxY3RGS1hCQkhJandQT3MrdUxkMW5pazJ5Q292T09PV3lkZFZITVU2MWFXMk12MkdleXV5cDYzQ3U2U2UrMzRwSnFadzJ5TVQ0MnRiN3RSY0MwU3U1Y1ZseXFuU013NnlSOWF2bFkvalpPRzZsUlNjVnV0cnhaeGkzSkxOc2tNQW5ubDBKK2MxTzRGc0RlM0NubnN4dHJkWWVLQ0JsVXZVSUJuZmFkUEtxL0g3WExpOTgzYnFCU0hDTzZOQVNkbzg5UE90RndmRFA3SndTM3RsUVhoL2lFblpXNVNQQWJDc21LTnlzMmNtZldOTDdMS3lCY2VpVHFhbytQWEV4Ym9WSkszRlJCMmlQM29od3dmeEVjdXNVSGUwUWt1MnhCSWhLakhyL0FDclJrZEdQQ3JraWl3dXpTcStTVlJDYzBBOVNEVUhpTmx5eHZMUjlQd0h1ajBxLzRiTGwyVzBxRXFRU29xNndEcC9YV28vR3R1bFZoYUVKQUhhS1RNenkvclNodjRNWTNXWkZud1UrMnJFWDF6MzFOQlNSOGdaOGRxTW4zTzRjc0VIV1pyTlBaOC9sdTFCd3dwS1lNN0ZNNm42MW9UeWlHOWRDUHJSNDlxeGViVXFBL2pKMEl3eDdYNDFKK1d0VXZDRWRtMlNQaHpHcDN0QTB3NDY2QWlxL2hmN0MwWlh1cHdIS2s3SFU2bjl1ZE83cGFZcU1HNGEvWVU0cTZnNFVsTWtMQ2tvMzBKSkJqeG9BeEFRK0FrUUFQdzc2bldqZDFwYjFvODNxdFNGQjFVUk13ZGZReFFqeElFdFhWdGtUbHpNSlVkZHpKazFoNUZ5Vm5SNHFVSlVQS3QwKytBRkNEM2pHa2dFOC9wVnF4aHJMOTdiTXFTRWdPSktnbm5GUWJZRlY4M21PNnBCMm1pRERVazRvblVkMGJEeHJwT0VldFVjdDVKS1ZwamVKMmltR0hpZ0Z6TW5OSUhUbHBTS2I3UEJHa3JHVlhaamZxZFRWcmZLTGFpclJPbTRIOWVGZDRnem5ZUTJVa3BTaE1FRDRUSDFGWlpZZFhFMFE1TzZrWlhpR1lvV1ZES2RKSkIzcm13VDJ0aGNwR3BBekRUVVVSY1Iybzl5Y09YdkFUb0lPL09xbmhab1AzYnRzVkRNL2J1SlQvd0FXV1JXVnBxV3plbW5HMFVMSmhCSFF6Ump3bmpEbUhQdHVJVU82b0RYYnlQOEFYT2c4Z291RnBPbmhWbmhTNHVteG9RVkNhZHg1MDZZamtRN1JOa3VHYlc5Y1M1YXZDMEFtUjJaa0dlczFFdjhBQWZlYlpUUnZXbGFnZ3pPbzZpcSszY2hBVUNyeXFlMi9sNWdIci9LdGNvNm81a1pwTzE2Q3JWc215dUpOOHlsd2F4MlovZWpuQTFvdTdGUU1abXhNY2xEbFFyaWlrczRva09oS21YcFhPMFQrZjg2SWNFZFJhdU5TRWxoenVLSVB5SXJQRjlaVWJwL3lRVWdLOW9HRUZ1NFZldEk3cTlWZ2NsRGMrb2crZGQremZHQmEzdnVGeVI3cytTTzhkRWs2SDUvblIvamRsYlBzRUZCS0ZpQ2s2aXNnUTB2QzhVVzJzVGtXVWtibU9SL1dobW5COWtURTFrajBsNmkxNHZ0RllmaUQ3S3lWNVRLVkVicE9vb3Q5a1ZtdHZCOFJ2VkloRnc2bElVVEVaUWV2L0VQbFF6eGE2Y1F3dXpmQnp1S0dRUURPL3dBUDYrc1Vhcld4aCtHWVJ3MHdzZjJqa1NIZ1AraUtnRkxXWTNJMWdjanFkcUhQTnpTUTNCRG9tMlVlQTRRY1E0cXVzUmViSHVUTDZsdFNtTTY5dlVEZnppakovVnBzbm1zNzg5QnJVaTFiYlFBbHRPVnBJQVFJQTlmUG5UTjJnQkxLWkVTcFVlby9hamhEcWpQbHlkM1ozaFkrM0U3eDhxRGVQMDkrMFdQOVFIelA2VVo0ZUFIekIxeWtlUmloUGpYSTQ2d3lkU2xCNTg1TlNmaGVEK3lHT0R4RnVpUU5BcEpQeWluZU9XRkx3eHBTSktBNkZBZWtWN2d3REtRVkVqTHFDZFRxS3RPSUdRcXdDQXFjNnU3STJNZktvdjZoUzFrc0JPQndvNDJ0bFFFclpjU05OaUJJK29yUWlzdVdxVjY1akJqeDUwRGNMb0RIR051bFc2d3NDZVhkTkd6Q3BaY1J0QjUrTkZnOEE1SytRR2NmS0F3OEE2ekEwOERWUHc2N21zQUZTckwzUUlrNzdEcnZ0VS8yaHFpMWFtSktvRWM5L3dCcXJlRmxPTnNyY1J1bGFranJCb01qL2tHOGVQOEFFR1dCcVZjTlhKVWtKVVdWSklCMThqUFBTaGJpc0w5OXRvMjkzVDk2ZEpWRkVuRDJSaFpVNG9BTEhlNUozMGorZFFPTTdWQ2NUWkFRU093RUgvbVY0MGpNL2dhTUt1WkJzSlZlQ1lsS2psQU1nY3Ywb2t3MXNKZVErTkFZbnhvY3c1T1M5RFozRWduU2pMREVabVlJcnEzOFVjZWErWjFldHBXbFptSVVuWHhpdTc5U29TVWlZMU5lZElVMnNLRXFLa2pYbnBUcXdsU0NJR21tdThVc2pLSzdiYXVnc0JBVXVOVW1Db2VNYzZvTUl0RU5jUUlkUTNsS1ZLV2tiQ1lORVY1YWhhczdVSmRUcWxVeDlhWnd5MGN1TVZOeGNaR3dFd3FGRHZLOEI0MFhXTFZseG5KYVJubkZkdUxYRzN1ei93QU5mZlRyT2g1VXpoYm1XNFpWbU9paE1iMWNlMEZySmV0cktZSUpTYW9yQUEzRFk2a1ZobEhwbHBIVGhMdmlUWnFGb29kZ2xKVHZzbmMwK2x6STVNRStZcXR0M1d3MkVreXFOT2RkcnZMTkVqTzR0WFdOSzMwMzRjbXRqK0pCTjR3a0xUSlNEbElPeXY2RlFyRjlWdVN3aEp1T3pWcTJoeEpLZXRLckVMVlFJUTY0Q1pFeHRWTmlDTTl5aDlwU1FWa2hSU1NreUJ1ZVd0WjgyTitwR3pqeVg5Wk0wU3l4TkYxYS9hQjF0WUdYN1JPWDg2RnVKc09ZZFVIczBsUkFDaHlQajFxcnRjZXZMSjFJVGVkNUJncGRVRkE5UWVjVmVZaHhSWis2TnFGdGJYRHpueGYrNm5uQTBPdmhWUWwyVk1rOGJqSlNpRDZGdXNvdG1yY0s5OVFTR2twQlVRc2tkNEFiOVI0bndvaDROdEc3Zkc3dHQ5U2hmTTIrWW9jTUxVVkh2cThlaDU2MVM0YXBWdmlXSDRtdFJTVzNIRW9CMENWWkRsMThkYWF3VmJydkZsbzZod2xiVGlsTFdEQUNlWm5YUXp0RlpvLzJwRzJhK0ROWllaY3lFdUp5aFdtdFI3MXdkcUFnZ0pHazAyM2Z0cVFDdHh0S3RnQXZ0RmZRYVYyMDAyNG9yQ1huRkhiTm9LMUhQZS9CeTE3cmlOSUJrOVROQlhIMXlCam5jSVVVcGhVZUdsR3BTVU9oYTRDVTZtUHBRTnhWYW00djNuR1VGUnpFd1ZSSU91bEttUHc2ZXl3NFJRbjNkeFJNRUNZam1mOEFhclRIei9BWlVxR1lLTzUyMHFGd3kyRTJpODJrWlVudzArZFNzZlA4TWdLakxySlBNQ2lYOVFaZjNBekFuTTNGOWtjeFVRVjYrSVFUK2xHbHdzTTNDc3gwV05BUHkrZEFmQ3NKNDBzNWxRVXRhZE50VUVDajNGb1FwdHd3b2lQenE4VHBGY2hiTS84QWFHNEZKdDB5SUs4MGVocXY0Wkt1emNBVnJHYkxtcDcyZ09oeThaMkNnRkhUeklybmd4YUE5Y0Z4S0lEY0NmaUpQNFkyMjNwY2wyeTBPeHZwZ3NLOEphQUhidndXa0VFQ2ZpVjBpcXppMjZMbUlNcUtEUFlqL3dESlZXbGhjbDVhMjNjb1Zta1JIeUZWWEZES0ZYbHVvbUpaR2cvNGxVZkp4ckhqMkw0Mlo1TTFqRnBjMi92NWhhQ1VMVmxLVTVSeS9uUmpoYXUrTXBTVVJ5MWlwYjNzZDR5VGZMZnRlRkw1S1kwUXU2c284djhBSDg5ZnBYbWZaYjdTV1hpdHJobTZScklpOXRQL0FEcWtjNnJaSjhXVGRvNVdoQ25BSTVra2M1cHBRa1FWYVFEdlYreHdGN1FsTlpidmhLN3p4R2R1K3M5Zm05VDZPQXVPUVNmN29Yd0Uvd0RYTEk2ZjkvUi9sZzE2S2ZHeUorQWtvQ1NraFhQblVETDJGd0ZIVkIwbmVqbDMyZGNhdUt6SGhQRUFabi9OV1IvL0FMMUdlOW12SFRoZzhKM3FnTmlicXpCLy9lYUtPYUg3QmZHeS9veTcya296Mjl1K0FNcWlOdXNVR1c1eWxCL2tLM1RpWDJVY2U0dGhqTnUzd3BkSWNRdlBLN3V6Z2FmOXZRc3g3Q2ZhVWdqTnd3dlEvd0RYclgvemF6WlpwelRUTjNIeHlqanFTS0cydUErbHBBTUpFWnhwbVVmQWRLSVdMVkFBTFZubjAxVTY0QjlCVnJhK3hUanpNbnQrRzdvUnVSYzJaK25iMFEybnN1NHl0a1pmN3NZa285ZmVMUDhBTDNtdGF6NDY5TWsrTmt1MGdQRGR6a0NReGJJU09TRC9BQ3B0OUtWc2x0eGdFYWlVbjlxMEJIczc0MGlGOExZZ0QxRDFrZjhBeE5JcjJaOFhsS280Y3hJSzVIdExMMC85WnFubmgrd1Z4c3YvQUpNZXZEWk5BSnVVdE9LUU84SEFRUVBEd3FPdGVGRktSYU5mYWlWblNFbUJ0cnJ6clQ4VTlqWEdWK3RsdzhOUG9kSHhyN2EwelJIL0FHNUdoOE9kVmxuN0V1UExkMStlSGJ0U0NoS1VFWEZwSk15VC9tTlByTlpjbVJYbzNZOGNxK1NCbkJwdTdsbGhDc3pVak1Da0VLQWdrUWQ5aDhxTmJIQjhON2J0bUxkdER1NEtSb2VleHFidzc3SitNc052Vk92OEwzN2lBMlVJaTRzcGtrU2Y4ZndxK1J3THhpMHNsdmhURVNrbVFQZUxJUi85eFF3bEZiWU9hRTVQU0szTUcwOXhEVXhyTFlINVV5NWV1QUVFd2tiaENZbWlKZkJQRmkwSE53cGllWWlQOHpaL00veEZSMThCY1ZxTWYzU3hMek4zWmZQL0FCNmQzaCt4RHhaUDBVNlZwV2dwU0ZFbm1USm9LeDE4T1ltNnBBekJLc29IU09sYWMxd0p4YzJBUndyaVdiZi9BRE5tUC9FVlJPK3l2ak40NWw4TlltRkhVNWJpeTM1Nis4VURuSDZZekhqbW5iUlRjTkw3SzBjTDZaU0ZqTEdoQU14NjF6eEhjdHQyNkVFeDJxaUFsWFFEclJoaDNzNDR0dHJBdEs0YnhOYmgxbFQ5bnFmL0FJZzFBeHYyYWNhNGdsdENPRnNRU2xBT3B1TEtKOHZlUDFxbGtWVVgrS1RsYlJsR0VvTEhGK0hkNU9ZWENZRTZRVC9PajNGM2dFSktTUkcybW56cml5OWovSHpPTDI5MDV3MWRscHBlZVBlTE1rUnNQOGNkS0pMdjJkOGF2TjVSd3JpVTY2KzlXUTM1ZjVpcEhKRkV5NHB5K2pDK01GOXJpYmFoSit5RUdJNnpYZUFrVzVCQTFPNW85eGoySmUwRzV1bTNMWGhtNUtRbUNITHkwVHJKNlBIbFRsaDdHZmFHeWdKZjRWZk1hOXkrdE5mRC9HcG1MSkNNM0preVlwdkVvcEZQWmdGek5uMEEwZzFENG9kY0YxYTZhKzdpY3dnL0VxdEZ0ZlpaeG9TUmNjTFlnQW9hS0YzWm5LZisvcUJ4QjdJZU9yeTZaTnB3dmVGdHRySks3dTBUSnpLT24yNTZpcTVlV0dTRkxZdmlZTW1PZlpxai85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL0V1bGVyLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUI5QUgwQUFELy9nQkNSbWxzWlNCemIzVnlZMlU2SUdoMGRIQTZMeTlqYjIxdGIyNXpMbmRwYTJsdFpXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9reGxiV0ZwZEhKbExtcHdaLy9iQUVNQUJnUUZCZ1VFQmdZRkJnY0hCZ2dLRUFvS0NRa0tGQTRQREJBWEZCZ1lGeFFXRmhvZEpSOGFHeU1jRmhZZ0xDQWpKaWNwS2lrWkh5MHdMU2d3SlNncEtQL2JBRU1CQndjSENnZ0tFd29LRXlnYUZob29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS1AvQUFCRUlBVUlBM0FNQkVRQUNFUUVERVFIL3hBQWRBQUFCQkFNQkFRQUFBQUFBQUFBQUFBQURBUUlFQlFBR0J3Z0ovOFFBUXhBQUFRTURBd0VGQlFVSEFRY0VBd0FBQVFJREVRQUVJUVVTTVVFR0V5SlJZUWN5Y1lHUkZDT2hzY0VJRlROQ1l0SHdKQlpTVTNLQzRmRTBWYUt5WThMUy84UUFGd0VCQVFFQkFBQUFBQUFBQUFBQUFBQUFBQUVDQS8vRUFDUVJBUUVCQUFJQ0F3RUJBQUlEQUFBQUFBQUJFU0V4UVZFQ0VtR0JjVktSb2RIdy85b0FEQU1CQUFJUkF4RUFQd0RUdFZ1VTk2OGdQS01MNENETVZscnlvN2k2aHdiYm5JRUU3RlZSRFZkcktURHFDRWpyeVJQVEZHZFIvdEt5NG9BdExDc0F6SFdhTGFjYnU0S09RcFJNN1F2TlZDZmJYSVdGSVhQOVZUQVpqVUc5a09OSGJKa0FabWdZNWVNdUVBa3AzR0NaVjRhQWFYYmRLaXJ2RlRrWU9Lb0lrdGxSQmRXREVjMEJtbWtqSWVJU29jN1ovRC9PYWlxMjdaQlNBQ1ZFY3lreUtxRVEyRUJKYlVFeGxSZzhFMEM5enVVU1hFZ2dTSUpKK05CSUxLMHFBM2lBbVJCaVBuUUdVd3Z1SktzS21BSXoxcUNNbEtrbE11Z2VtTTFSZ3VTQzJFdkpWdXh0M0NSbUlxQlh0VEtrN0FvSlVNeUFKeDZpZ0EwOWNTRnFlVUJIQVVPS29NbHk1ZFVQdlZHT1NDVG55b0NGeTd5SlZBUFdvdmd4S3JvNFVWQW1CbFZFRSswM2FFdGhTbFFSZ1pGRm5zSnk1dVZnd3BZSCs5Sm9tR0p2THZiQUpBR2VvSDFxaDdWOWNvV29oeFFrYzdpWW9hS25VN2xJSSswdURQOEF4VkNvdkxZdFcwdTlGeTRwVEIybFViaElxS3BYZFB1a0orOFpkU1BubjFxcGtWcjlzK3lvNGRUQTRNMVRFSndMVENSdUFuSVVLSUdIVmhlTmlpQVp3S0J3dUhBa1FrZ3gwbWFCemwwNmtBZ0hwa1JrMEdKdWlFQlJTRFBta0dnUTNTWUtsQkVsV1JHS0JWWGJRV0NBMzRRT0ROQThYYUZwbklJK2Ywb0g5NE9wY2crWng4cUJVdXdTQTRvR09DUHpvRHRMQVVvYjlvVi9NQWFBNjN5MlkzNGpQSmlLTDRRTHZWbE50QUpVTVl3VFExVHVYbHc4a3FTVEV4Sk1VUU5DSFhEQTNFL2dSNlVFeGpScjE5UGh0blY3aUFBa0hQcFFZNVl1TXJLWGJkNUNnWUlVa2lJb0psdFl1TkR2ck5UcEU4QUF4OFJOQlphZHFDWEhRMWRxUzBZZ3FLWUNqNUVkRFVXSjZFSjd2YjRKNU9UUmNNZUNVYkoyRlVIZ21lZWFIVENDNG5adFNUL0taRVRORFRGMnJLMUVFR1pCS1FzRGpwSHhvbHhpME50TktBQU82ZXYrVFJSTmlFNCsrSHlpZ202aHFxMDNTL2VTaVNKQlAwb0sxM1czeGhiajRqZ2hYeHBpYWpYT3NQT05KU3Axek9aVVo2OFI1VlRVUmVvbGFmRjd4T1FwQUlpaGFZM2RvVlBnYWc4d21pQ3B1TGNpRjJ5RnE0RUVpYzBHT3FzVklPNjJlU1JKTzFRd2ZyUVIxczJTZ21GdlQvTnVINVVDcHRMUlNWUzhmNlFPZktnakcxaFNTMnZjWS93VUJFV2F5a2xSQkl4Sm9NREt5SThFSk1aQkhYUHh6UUZUYktVVkVxU1R0NktBNG9DTjJqb1dGb2dpZUpGQkYxTmJxU1Fza2srdVBvRFFVU1FYWEFrazVNWW9PNGV6djJRUGF1MHhkYXVsYk5xVWxRUjFqRVQ1VlIyclNmWmQyZlFsT3pUbVZ1bE8zdkJPMVA4QWVwaHZwdVduZGtkSnNrSHVMVk8rSW5iUHdpckRVRFZPekdqM0RhMFAyTEM0RSs3elVXVjV1OXRmWlZuczdjMnIrbU45MnhjRXd0Sk1nOGtZcUxybmRodGVLbXRRSlVEZ0trU2FKNDVHWld0THZjSVVwYWdmQVZHQ1JRSFdMdnZEdGJkZ0RJQm1ocGl6ZWQyUjNWekh3bnIweG1ob0tYbjBtSWNpWVZ2Ymo4YXVHc04wVlFEQVZCd1VpbUdpRjBuSGxqaVk5S1pUVS9VMUlEem9LWlJ1enNYeUtpS3h3STJrcVE1SXdCdW1xQXVJU1U0RDB4QjNEay9TZ2pLYlNGSGM1dEk0Q2s4K2xBMWJTZHFqS04wd1BDUjA5S0FSYktVSzkzSGtyTkFSRERvbFcxUkVHYzlhQml0NGJKQVZKZ1NSUU1RdGFFcFVrN2toV1FmT2d4THk1a0hKOWMwQmtYS2traFFCQnlNZm5RS2JsUThRR2VRVFFGRDZVTkVLQlVwWTkzOWFDWW03VUcwKzlJRXlGSE5CUWF0Y3FkV3JKNXhSZUd4ZXliUmthMTIzc1dIa2d0TlRjS0I0Skh1ajYwaE1lMXRMUWkyWWJiOEpYQXgxK01jZldvWXYyRDR0Z2xhd21DVGtUenhXdFA0bWxvRk1JVHdNa0RGR2NWMTh5NmhCVW5LUnoxTWVmNDA1VnlqMnlhS25VT3o3ak55eHVVbGFYRzlzK0JROGowa1lQeHFMSG1mWDJIckZDWWFBdHlZYWRMWUczK2srdnA4NkZVcjEwcEMybmtTa3B5UFE5UlJWczNxam0xQ3RxaWtnWlNaQnFZbXBiZXV2RENRdVlBQi90UmRTRyswcnFJUzRUUHdCeFY1T0VoWGFXM0FFb1JLanR5Z0NmOGltMDRGL2VtbXFKTGpLQ3FjN1dKcHRGWnFxcklQdS9lS1NrbVBkNEU4VkU0VnppTFpTU3BOd1FPSk5WRE82UW9EYmRKR1lHZnpvR0thY2tIdjBySEJnOFVVMG9kVW5QZG1CUHhvaU9wQy81V2tLQVB5TkExZUNrRnBhWXdvaFg2VUNoUkJUbHdEcFFJbDRsSnlzUmpLSm9FRGdNa3FRWXhsTVVCbXkxc0VocmpyUE5BUUpRc0ZPMW9Ia1F2aWdNbExZVkJRbnhDQkJIUTBCSDFON0ZxTGZDU0NBZURRYXRlSys5VnlQblFkaC9adnNtMDZqcVdxUHJTMjAyRXM3MXdBbitZbWZwVXRrV1I2bXNHRUlXbTVqZktOd0o0T0tkcTVsMng3WTZ0ZTlvclhUTkt2WHJDelNncXVGV3RzdDkxQ2p3cGV3R0JINjFQcjlqV3g5bHV5dXRYbGhaNnBwZnRJdXRXZFNRcEtWdEorekxJOTVDa2pJOHZNZVZKUGg0VGE2YmF1UHZXcVJlTmx0NERZNG1aZzlZOHhpdGRIdFU2emF0WEZvNDI0bEtrcVNkcVZqbFFHQlRTUE1YYTNTN3UwVmNXYk5vc2gxVzhOSkNTaFlQRzBLNEk5RFRLcmtGNXB4TjArd2c3TGh1ZHpLc2J2VWVvOHFKZEgwZExidHFFT0JaY1NZS1JQRkNMWDdwSVR0YlVrcGc3VkFuY255TlJRTzdUdVFBRmJ1bTJpY0hKdEU3QzQ4cHdvQnh0U0ptTWZDaThGN2xDL0VRb3o1MEZucVdsdC9hVmhOd2tBSzRWbkZFeFZ1NllnRWp2MFJueEF6ejVWVXdCZWxRcVV2TUNjeVNJK2RGd0plbkxTUUIzYXY1dDFDc0ZnK2hFSjNRcnlYTkVDY3M3aEhSUXdSUCtlbEFNc1BKZVVueERjVEpJb0ZkRG9DZ0FvbzU2ak5BRXBmQVNOcGdkSW9GU0hzRlNKeGt4UUViRHBJOEJKR1Qwb0pURFN5VkVzZ2lBVEpHUjUvR2dJR1Q0dnVwS1V6QlBrZWFhdUlHcEZMTFd6dTFKVVpNNWlLSTExeFhqVVp4UmV1M1EvWnoyZnY3M2ZjTGJXNVoyYWtxY3QwdkJDeVZDWlNGUWxTb1R3U0tsay9xemg2SjdPOXI5TjBhMzBoTEYzcVd1NmE4d3E0Yit4V2pqejdhRW1GSldoUHV3Y0dlRGpOTS80Z21zM3J1aWFGWU42TmRvYnZkVGNWZFhUNEcxUmNXbmVCSjRPUW5QQUZMeVloK3pOeldlOWNkVTgvcCt1NjViS3VsTi9aMHJaYkxTa3BMcWtueEZ5RmhQSUNvazlLdjExTFhSRzlBN1kzQTNIMmdPTjRtR2RHWVNmL0FKRlZYUGoxZC83bi9vMzhSNy9zbDJuK3lrM1BiL1ZId2hTVndpd3RXekFPWWhITlQ2L0g5LzdKYTFkNzJjTWE0VjI2OWExNjQxQU5GWWVmdkkySzZIYUVoSXowaWtueDlMZW1tOXRmWUgyZ3V1ejZOUloxRzJ1ZGF0bVNWMnlBVDN4RW1FS0lCbU9oNjRtdFNmSHBuWG5kRnlXMW9JUXRKaUY3UkJKL3Y2VmxxTFZMd2RhUVVod2JlbTdyTlFJWGpQdkxFLzdxcHpSRGt2cjNwRGJqeVViaVZKbVpCRUFaOVlvdktXSGVZa3dlVEUwRmpxT3BrUG5jaGtrbkhoRkUxV1hWOHBaUGdiQTRqWUtHbzdqNUtRRkliZ1o4SXpRMDh1N2s1MkFqTVJKUDQwTFQybndrN2tvUnV5VGd4SHdtaE1QZHVBRWJWMnpaUnpCSnlUMTVvYUdYMXVLS25XR2dxQU1UOWVhRzhzNzh3QWxscmFreVptZnpvYUtIUUJ2N3B2ZDh2bjE5ZUtIR3NRNkZqWjNiUVVldUJGQ2NwRGIrMUNTQzBnZEFTRHp6MG9vWmZCSjN1dHdBTUpCazBEVnZibHJVanZGRFBDTXgwNW9OYzdSTFVwWktkOFRqY2VCVkVQc2lOUFYydTBST3RyU2pTamZzQzhXcmhMUGVKM2t4L1ROT3VTdDBldTJrOXIrMFduMkxqN1dtM1JXbGx4UTI3RWhSQWNIVGdtRDVHcCtuNDlBZXhLeVJvV2dIVVhtUzA1cVAzclRabmEyMEFJS1Vra2pjWldSUEtxcFc2M21sdXMyNzZMSFRXTmMwMWF5NjIwaDFEYjFxcFdTbng0VWlaSU1naVl5S2J6d24rajltTlAxRzIxSi9WZFh0bUxlOGRZRm5iMjdUbTlOcXhPNGhTdUZMVXFDWXdJU0t1WG8yTnhzVUJrZys4bzhrODBQWTdqbmVJMnEyaVNFa2VWRmt4QXRFaGk5VzQwbEFPMEpPUGVBRlB4TDB1RzFrcFNGZ3BXUk1IOGFnK2Z1cDJsdmU5c05mZHR0aUxNWDl3cENFcWdGSmRWdEFxYXVFVXdsdFI3dTNkV1A5eEx3bm5wMG1nRXEyYVUwaHhMVnlVbmNBUkJ6UEI5UlFPK3d0bkErMWhVRWtsdEptZ0tiQzNFQmEzd2ZMdTZDSnFqYjRkVnVNa2tqM1BXcXlnYmxKVmxJVVpuM2VQT2FBQ255Q2R6YUFmcEZBRXZySzB5Z1pIbkUwQkV2N1JsdEFFOEU4MENLdWxpWmJTcmpQTkEwM1Npb3lnY21UUUtpNUpBSVFrRUdnZVgxbFpKUWd4L0xQUHJRUFRjT3FVa0pRamJ5Y2NUMW9ES3ZuQzV0SENmQ0lUbmlpNllwZDJzWVU3azlFeFV3MHFXcjNiQmJmTXlUR0ptcWFLTkd2TG9BQzJkenh2elJHdmFwcHIxbTZvUE5sR2ZLZ3RlektYOWF1MDZZdTRDRkt0M1dtbkZKM0s0RUkrQklId3B4R3RqMjdwZXRYTG1oMk9rdHQyMmw2dzB5bjdRMWR0RlFiQVR0M3BBSTNKSkdEUEZUbE5pNTB4d2xMS0xwZHY5dERVUFBXeUMwaFN1WkNDU1krZFZkYkF6dHVXNUpCYzRKR2FheWFsa05rR1RQa2FpNlZRQ3ZjeEpnQ090WGZacU82MEZQb2FPNGxTdUoyNCtOUXZNVS90RTdRc2RtT3ltcjZvVU9QUDIxb3ZhZ0dTbFJFRFBUSkJxMm12RG1sdnVwdEZGcEtuQVRsUlNWU2V2NDFGMGI5NE90WElXb0RmMDNKd2ZTT3REWU05cWpiUlNwbExZVXZ4TFNabEtvajVqMW9haWZ2QXFUdUNVYzRneFEySlNid1pBUzJBREdldERWcGY2MWNmYVNzc3NyZ2tnbHRNeGowcGhxclZxdTE1ZTYwdGtaMnloRVV4TlJYZFJaV3BXNjNUOGRrZlBtaHdBYnl6UHZOSk1Ia0EvM3FneHVMQmFWTExPU1NQZFA5L2pRNE43L1RsR1ZwTWRQQ29mclJDcHViRUxQaEhJajN1dk5SWUNxOHRVd2xBNjR3cis5VTNncWJ1MzNZYjNKSndOaC9XaWRKYmVvSlEwVkp0MnlDY0F0ajhmblFLMXJxMjNGZHhiTkFFVEJRTWVreDUwQTN1MG1vWkc1Q1FQSVkrV0tGUlY2MXFEZ252MVpJT0VtZ1JtL3YxbUM4ckF4TUFVd1Vtc3V1dU9IdlhGTGtua3pReHNQc2FTbHoyb2RuVXU1UjlwS2lEd1lTVCtsUzlEMURkYXFiM3R2ck9vdXRYVGxuYk1zYWVoRENkeWluSzFLUHB1SUErRk1xNVcxMjNhblJ4cUJzYnh0QXVGSjNBc0h2UzJlUUZsSUlTY2pCTk9hWlczNkhjcGVhS2twV2xBMmtCYVlJbno4cXFMSjliWVFva3owcGhPVU5pNEJ1aUJKSUVpbUdLdnRNWEZXRnlQRVBEaFdjZWY1VkxEdzFEdFRadDZ2WTNtblhJMjI5OWJsQm1Ta0VqcjUrZExESGxxMVNuUVB0V2thaGFCOWR2Y3JBY1BnS3ZobWwxWkdMdnRMZUpSYzZlVm9QdkR2amtEeXppbkpoak4xcGJpTnJ6YnlpSjJPQmVZL3FFUkk4K3RERFF2UlZUNGJoSkhQWDlLR0RxWjBlVEQ3b2s4YkIrdERGZnFqTXZMSWJCQVVmZCtOVkZWY0ZTVnJsSzJ5cno5YUNJNHRzcUIzcVRNZzRvRUN0cXRxWGtxNUI4cUFaV1RLcFNSeDBOQVFxVUVwVUVKNHhJcG95UUY1UWtTWm1DTWpwUUlod2tvVU5vSTZHYUJkNnlsVUo4UEpHWUZBcmx6a2tvVHR3T0R4LzVvR0p1QVdqdUNnRmN4OWFCZ0NWcFVGRWdBVEJTYzBDQlpBSUNOczVNek5GMFZKeVZoc3BUMW9uK0s2L0NsRXF6NjgwWFVuc2hxbjdrN1Q2WHFLcDJXejZWcWcveThIOERVcHIxenJUVGQxcnVnV3JBMjJsOWJyY3VGdFRMdzVRa3gwR1RVM1Z0ZEw3T0kwMndzMHQyMW8wd2xJQTNDRG44Z2ExclBDY2w0TlhpM1drOTN1RWt4TzZyb3hOMnAxcmZ4MWdabjFxYlYwUFN5VnVLV1FvZ2lEdTZDa3VHaWF3Z3F0Z2p4RlM4Q2ZXbTZXN0ZPL2FKY0NWT29La0pCOU14SFNpNjh3ZTI2MmIwM3RpdGFVbEtybGxMcWtxRWVMSTYvQVVUWE5ITGlTSU9ZOHVhR205OHZhQnVJVDF3SW9iQ0lkVVZlSlUvd0RTRE5EVTN2UWtrS1NpWjZwUDk2THFmcWJhdnRMc0RFa0dDRE5HVlMrbHdTU0ZBeEpvSWFsS016NVRrK2xBTkxqaUNOb1NuMWlpN1UrMDE5MjNWdVhwMmtYTThwdUxCQ2dSOG9vaXhQYWUwVi9HN0lkbUZwTVlETHpaTWVxWFJUYXZDRnF1dWFaZHFTYmJzdnBWaUFNOXpjWEozSHo4VGhqNFVTWXJibDlsNTBPVzFzTFJvZ0R1a09xV1BqS2lUbWd3UHNwdDFvVzBzdWtlRjBQRklULzA4SDYwQUFFclVwUldxVXBrVHpOQWl1QnVjVUFPbldnVXViVWtkNHFQT2dSS3lrS0ljVUNCejUwQlM4b1FsSzNDbm9EUUNjUWgxSlYzaXQwNUJGQlZyRzFSQkVlbEIzUDJNZHRycTh1ZEowdTV1RDM5cU80YldlUzMweWZMajVDczJEMC9waHQyZDRkQ1ZFQUZFNENoMS83MXJRTFZkUlNTaTNzZHJqamhneElBR090VGZTSmJFakRyaEhrbEo0UCtUVlZiV2JTVWlRREFpZWhOUUdaWWN2THhTNFVHQkEzRUNGZkNnNTE3U3ZiRjJaN0JGMnhzUU5hMTlHRGJOT2VGay84QTVWNUNmK1VTcjBITkxSNVU3Yzl2TmE3YmE0TlUxNTV0VGlVRnBsbGxzSmJZUVRPMVBVNTZrazFScnJrbFNRQ2svU2didlZQdXBKNlVEMFRNQUlKOHVwb0paV3NxVnRaUVJQblFUOVd0QVhsYkVrS0JKaWFpOXFsMXAxcFJncUg2MVVSVklXSkJLd2VvUEZBaWtyZ3FKSmp6b0diZkVaQ1FmUHJRWXBPVHVnS0dLQVJTREJLY255TkEwRGtIejRvRUtKNkdPS0JpQkJCZ3hQcFFFVTNnWU1DU1pvR2xJSU1nZ0R5SEZBN3dnWkdaOHFCU1FsVTVCR1pqclFGYmdvVm5ubUlvSWwwMEpKam5waWdqV2QzY2FmZXRYTm02dG00YVVGSWNTWUlOTUhvSDJmZTA5eldnaGpWNzE0UElBQ2tKQVNrWWdxeHlLem1MbXV5Mm5hTFNXa2Zjdk5sQVNBU3RRQlBXUDFpb2ZWc09oWEs3OVFGaWdPR2Y1SUlTT09lbGJpTER0VDJtN1BkaWRPVGNkck5UWVpVb1MxYkFsVGpoOGtvSGlWOFlqemlwYklzanpMN1VQYnhyL2FwTHRqb1pjMExSektZYVgvcVhoL1dzZTRQNlUrY0VtbWV5eHhaUzBwU0FuQTZpbUdHZDU0ZHNLam1xWWNsWkVlWFQwK2RFeElhQWZYNFZRcnlKb3VEcXQxQ1U1d0prUlJCMFd1NEVxeEpNVFF4YmF1RS9hSEZGUUNpWWhSTkRwVTNJM1lTZDIyZXYrWW9JcWsrRGtTUFNhQUpTb1lUS3R3Z1NKenpRT05zNnBMaWdsZUVoUmxQK1RRTUREMlNFcU9NbmJNZmhRQ1V5NXVUS1ZEb2ZDYUJxMHFDQVNGVE01RkFITXh1SWp5b0VQRUpKNDV4NVVEa2srSUVxS1l6RVVDYnNFcTNUbWdjbGF0Z2txeGlJb0pTVzByaUpBUFNlS0F6YlVDVktKMjlBWW9hYzd0Q0NVcFVKQWtVRlRmdFFrS2lLQ1BwMTVjYWZldDNObzVzZWFPNUovUWpyUWUydllOYTZGMnU3SzJ1cXZ4Y1haR3k0Wlcya0JLNHlQVWRSNkdrdUZxSjdmdmFkZWV6NVZsMlg3SVdMVm5kWE50OW9WZDkyTnJEWlVVZ05waUN1VW1TY0FSZ2s0bDJySGxUVWIyNjFHOWV2TCs2ZnZMMTR5NWNYRGhjY1dmaWMwa3pvM1VPNTI3WTd4TWdTU0RWTlEzRHVNSU9PWlBXaHBNY3lENTVva3A2Q21keE9LTHB5RmdxZ0RpaHFXeTY4Q2traFE4am1ocXliZWJLY3FRRDVWRDdOMTFEU3RRRnk0VTJUNGhSazdVOGs5TVV4ZS9DdHVkTHZWSE5vK014RUFmOEE2MVV4Qy9kK29GYXZ1M0VZSi9pQVpucmlobE1iMHpVRkZKVnNnS2p4WEVmVFBOVFREenAxNHJMcnR2QU9GRzRHUFNkMU5NcUt2VDNDRmI3dTMrVDQvd0Q2cW1WRWMwdDVPd2k2dDFoV1JEK2YvdFF5a09sUEZNbCszazhudnhqL0FPVkV4Y2RrK3h2NzZ2N3BXcDN4c05Jc2JWZDdmWGpZNzFUYll3a0pUT1ZxVVVnRDQrVlBHbUJkcWV4bDkyZTFRV3FIMjcrMGVaYnU3UzdiOEF1R0hFeWhlMDVTWXdSMElQTkR0UnQ2VGQ1QzJWQUtCaVR5ZnBSY3BpOU11RVNweHRVZXFmUDVVTXBQc055UVFXMThpUEFQN1VSSVJhM0trZ0ZoWVBNN1lCaWdRVzd1NEF0NVBwLzNwbWd4dGxodVZOR1lrcUtjUjlmalZ5aXQxSmhRdHlWSWdBeHgrZFFhOHMrTlI1azBIb2Y5a0hXTldaN1MzOWxidE9PNlN0cEJmVW54ZHk1TUpNY3djZ2tjUUttRG9mN1lta1c3blpqUk5jQmJSZVd0MGJZcFVvQlRqVGljZ2VjS1NrL00xZDhEeVl0OGlBa3ppSlBGQUphbE81SkpQd29HT1lPMktETjBESVB6b0hJV0FSK0JvSEpXWkFBSkhTZ08wVHN5RHp3Q0tBeTFncUpraVQ1MEhTOVlOMGJoeENyaC9jbGVVN2lheXV0ZnVVdkFsU2lSbWZFbzUrVTFjaUlEclRnV3J4TjdqSklKNG5wbnJWd0tobmZFaEIzSG1CUEdhTFNyWlNrTmxSU0Vua21EUkVkMWtGQklXMHNKampFL0tndHV5M1k3VnUxcnk3ZlFHYk80ZGJVaENrT1hMYko4VXhDVmtGUUVmeWd4VGoyRDl1ZXhWMTJTdnJLenZydXl1bnJtMFJlZjZWQ2toQUtsSjJuY0FUbEJ6RkwrQzk3Rm5SclQyVjlxbGRvR2J0eXkxSFZMT3dXN1lyVDNyTzFweDFEZ1NTQXNCVVNra1RKNmdVNkdyOXZOYnRPME90Mnl0SVlmWjB6VDlQdHROc2szRWQ4V21ra2JsaE9Bb2trNG9LQkxDMEtpVmxZRXpQVHBGTURWaFo4Skx5QU9Ocmloa2ZPaXdvVzdrQmR5bnd4QWNWVWtLbGZhYjFHMEp1cnlRbm52Q2Fwb3JWOXFLWFJEOXlWZzRrejlLR25QNjFxVnMwVXJmZFNBbkFWdDgrYUd0ZDFUWDd1OVIzYW5KUjVGQ2Y3VU5VOEVxODZJbVdMMXphaGIxcmRMdDFDUDRicFFvK1VSelVzbDdXWEJMbTl1cjU4T1hsMC9jdUFRRlB1S1dSOHlUU1NUbzBnVkNSSFBYeXFwb3BVbFNmNWdmS2NmR2dFVEo1NjRvdXNJbnFZak5EV0FTUkpPT2hORUZUSUlqazBCMjBuYWQyUFE5YUdudUpKY1Z0T0pQbFFkVjF0eFgyaHdmNlluY1pLWEFGVFVYR3V2SmNCV1VvUWtqL2RVazUvVE5EQVZod0tIK25KVC93QXFTWjlEUk5GWmxxVDNUcVNnays1MXdPblNpMUNlZklLWkN4Q3VOaEhTcWdMbHlnZDRwMVkycUI2a0ZNZGVPS0RwMWlXdlpmMlJhMUpZYWI3YjY0d2ZzQWRFcTB5ek1ndTU0V3ZwOU9oQlgvaXM1NWFkMjU3VU45cGRVdDdwa1BKYXR0UHRySkNYWEFwY3RvZ21lc3FLam5PYWsxRmoySVlPdTlqdTEzWm0yKzkxTmFXZFcwOWxLazduM0dKRGlBT3FpMnFRQm5GWE5xK05KMmc3TDlteDJGdGUwblpMVjlTdmJkTjRqVHIwWHR1bEFMNm11OEpid0lBNElNODgwL2lLQi9TRk1kbXJMWFE4aGJOeGVQMkpiN3NTMHR0Q1ZpVE1FRktwK1ZCVVhLa0JNb1NrZ1prQUFtYUJxRW1jSUFIblBRK2swQjFvVXNwVnNTTUErLzhBNUZDQ3V2TldkdXA1UVNDRW5iNGpQNTBYR2wzMTQ1ZDNCV3BTaVBVMUpFUlRIVG1xSG9FbWNSUVB5b1JVd3c5UGhJUG5WRDBrZktPbERORkt2QmtjQ0lvWVp4SEh6b1RrWlNWQVJHQVppZ1NmRmdTQkZBWklBSlVZK0huUUVrcmlFN1VVQnl5VnFVZG81TkIwYlViTWk4Y0FkdFZLQlBJVGp5cUNwZjBVS1VWdGkzenlnZ1lQbHpUVndEOXo4cFNsb3J4QUMxWitsREQxNlZjQWU2NGtHSUNYRkQ2VVdtTzJGd2xLbysxRkFPRkJjeGoxb2xiUjdPZEJhYXU3N3RQMmtENnV6K2hCTHEySElQMnk1UDhBQ3R4ek1tQ2NSRVRnMWR6bE1haDJtMXJWZGYxNisxZlYzM0hMdThWM2lvU0NsQS9sUW1lQWtZQTlLa2kycWh0VDRCOFVJR0pVMEQ4S3FGdDdtOXRieTN1Ylc0K3pYRnVzT3N2TklLRklVT0ZBak0wczBYdmFMdGoybzdSV050YTYxZnQzTm8wdFQ2VzAyaUdrbHc4dUtDRWpjc3lmRVo1UG1hZnRxNnNiZSt0cmoyUFhOaXB5MC9lREhhSkZ5MHdUQ2xJWGFsQ2xCUE1Ta1o0RlR5WTBwOTlZV3VHTFdTT2lDS3FITXVxVG5aYng4K2Ywb0pqbHlyYnZEVnNRUmpKRkY0YTdydDZYbmRnRFlDY2VDYzFEVlpCQ0pQSk5WQ1FTWTYwQmlnN3dsSndubWhyT2hINVVYV2NnZEtJZTJJZ244YUEwY3dQUWVsRjR3cVVFK1ZEdnM0cWdqYVptaWJoMk55U29ZVHpSZEhRZ0JJTHNTZjhBelEyaUlsUU1BaFBFOWFJa0xLZDN1Zy9FMEhwQnpRZEMxQzlVdGpXR3JWZTRMN202V2xUYXZUZVVBajUvV3BzdmE1YWhhbDJPR243VGRQMnlFT3lVcWNEUlF2NExDZ0Q5YVhPNFJUM25aRnRhWmFlMHBNOEh3NDlNT0dwOXBmSmxWRjdvdmRvSlZlNlFWQWorWnhPUGxNZWRObnRlVUsxMHE2dnJpM3RMRjJ3ZXVYM1EyeXkzZXFHNWFqQ1JCRldaYm1uaGUrMFRVcmZUbWJQc3JwRjQwN3Bta0Q3NTFGeC82bTlWUGV1SHpDVEtSUEVHbkY2UnpweDh1ckFkV3BTUmt3Nms5ZlVWU0VQMlpSTzV3NDRBMlFmS29ZRzZHZ2tBdUNEamhNajZjVlRBVUlaQkk3NXFkdURIV2hnbTF0bUZoMWplbE9NR2FHQzl5bDVTZnZXZHBSS3Rzd1RpUnppb1lLbTB0MHFIZXVOcVppUkJPNER5NS9HaGdkMHBwaXpXc3VzYmcyWUJreFF4ejI0WDN0d3BSaVNlbFV3aFBpM1JnY1VURWxscll5WFZEeGRCMW91Qng0VDBQNTBRaFZnOFJ3YUthT1JRd2RrbEtjUUNSRkREaEo4K0tHQ3BVZDNoUHlBb1l4TWJ4Z0VlaG9ZTTRDaEhIVUQvQUxVTVlsS3p6QjZ6UkJVS09KVUFmaGswWEJGTHlZUUZEem1pT25YQlIzeWc3dUkzZEhjL2owcUxvOWhyVjVwWjJXTDREQnd0aHhZY1pYL3pJVUNEOUttZWpmWXI5NzJaMUNUcVdqdWFZLzhBOGZTMWQ0MFQ1bGhmSC9Tb1ZyYjVQOENzT3lWbHF1bzJiRmxyT2xydEgza29kZkJVMjZ5a21Db3NyZ2tBWndhbXJkYkNlejU5bUZucVdyNnFRMzJqNzU3VDlGWkNNYllBVmVEZ3dFcVZ0OGlyNmF2SEVUdHkxMUNBVDkyZ044bzNBeDZrbWZ4ckl6V3JCL1JOWnV0TjFHM1FpOXRIQzA2bEIzb0pnRUZKbklJSUlQclZSSFRjSU8zS1VrKzZOc21QaE9hY3J3VUxTaFFUdENUeGx2SHFlZktpY0U3MW9EK2N4ajNZb01TNGd5SUJqekJvdkFQZXR0cUJHd21lZ1BUNTBKY1N4Y05yVnZXMmdxT1FUSXhQbk5URFZaMm92QUxaQ0VvUWtyRXhFbXFjTlFTQ29uYmswUTlDQ1ZnSGprME5IdVZId056QUFrLzJvQmpnK1ZBeFhTWW91aUJHZVFLSUppQVpHT1BoUmRPYUJUdTNZSDUwcHZzVUFIakUxTlRSbTBoSUtoNzNVRFArQ21ycEhsaFNFQk9mRnhOSlRhZktsWUt0dFUya0tRSS9VVVFZYlJJVUNUSjRvT282cVdBdHdCMWU4S0lWdUdPYWxGYTVjTklTcEMzRnFBT01nVGlpeEdMekFDdHppNDRqdy9YMG9nTHJ0b1NvT2x3d21CSlRqRkdtM2RxdTJGaDJtMGZSN056UkxwVjFwdG8xYVc5K3E1UGVxQVREaVZpQ0ZwSkFLVGdqNTBtMHhRcFEwOWFCbFdpT3JXQVVsWVV2YzV1UEtzR1FPZ0VWY3FlZW0vOEFielFrWC9aVFFlMTlucHEzN3A2MFpaMU5sYW5OelNrcDdwdHdBQVlVV2lrK3UzenA0UmMyMmlvMHZSUDlrRTZCYXJ2ci9RYm0vd0JRZUxTbExSZDdlOFlaM0hJMnBRUVFPcEJwdk9IaHlWZWhhcTZwSzJlemJwTUJXVzFSL3dEYXAvOEFkcmdhK3pXdnBsSjdQWElCaktXaVpQeDNWY1FuK3pHdi93RHNGMllJOTIyY21pb2JuWmpYMEVxWDJlMUNEbURhTy9oaWdUOXhhNEVlTFF0UjJua2l6ZEFnZjlPYVpUR2s5bzB2b3ZTaCszZFlJL2xjUVVuNkVVeEZWdHlSeUI1VUVwbndvS2lmVWo4cUFKVVNTVlpVZktnV2NrUmlnd1p6UVBtVmVubFFLSko5UFNnSWozVmZQcFVCV0hKTzFWVCtCd0pCQVNmaFZBaVNYazhnVlJJQ2lOcE1Zb0NsSGVaVm1jMEQ5a2xXM2lUUWRtMUM4UWJsZXcycVZDYy9aRUFEUGxGVGF1S204dnU3ZDNOcWJSMEpGczJDZlVHUHhwdEVCMjhjUGlSY3FDVTlRaEF6OUtBRDEyOFFEOXR1QnU0SUk0bkhGQkdYY3ZLVVNMKzVJblAzaXVud3BnYXRieW5DazZsY0tSSXp1WEg0bW1UMFYwM1F0WGIwanNwMlB2OEFVR2pxT2loV29hRnFyRVNYVzFPQjl1SlB2Sm1SeHdSaWFjK0VSdXpXdXAxcjI5MmV0TzcwVzJwYWk0eWJkNHlRMjZ5cGxLVDA0aWtXdVlxMDk2M1VXMXZ0a3NxTGVEaVVram40Q2hiU3BzbExjazNLRWdJd04zSjhxY0lhbXhmU29wUmRtU1ovaVZNbnBlUlUyMm9JVU50ODczZlFvZk16NWMxY25wQWI2ODFleXNsbE9yM2FFa0ViUmNMajg2bVQwYTBPN2ZkZmVVdDU1eDFlWlV0UlVUOWEwQlJ3bWN6bWdLNHJHMEhGQVBwSVBGQTdNRStab01FQVlvSElJeEFvSHBPT0lpZ2UycUVaRWRjMERnSlBYcFFFM21DRCtWQml4NDJ5T2VEUUdFZ2NVQldaSjhoMG9KWkNkeXBTazU1b09pNm84Nzl1TzExQUNTWWhQWHlIcFVXS1p4VDdpdG9kUkJFUnRPYUlodXBlQ1ZLNzVBQTRPem1qV29xMXZyVVEycnhBa2xLRUhrRFBGRW9EaTMwR1BDbmZ3b3pIMHFqRVB2bUJ2Yk1lZnBSRGhjM0NsaG9xOEcvdk83TGgyN2lJS280bU1UUVBSZFhEVGpUckpLWG15RklXaHlGSkl5Q0Q1aWdZdDUxQ0VxREs1S2VabnIwb0hKdUZ5SlE2azg1QWdtZ1JkeXRMaGpDVmRGSW9CT1h1U29LUUFJRzBHQlFWZXVhZ3RiS1d3b0ZJeGhjMEd2cDhUbm4xTkE5SEtsL3krdEFrbWNwK00wRFNDRS9yUVA0VmlNZXRUc1lUNGFvY2s1L1dnVXFrY1lOQW9DdVl6RkE5c3FITXdNMEJnWlB1MEdLOEpUNUFqcHpRR0JoY1NlZXRBWmpBTTllSW9MQkliVkpVNGxKazRJb09sM25jdVhCMmw1SUt2ZVd5Q0FmclRCV3VXd0NWT0pGeXFKRUpZRUQxNXBuNEl5N2NtZjhBVDNxaUVnQ0dCeWZuVEtIVzl1d1hFcWNhMUFKSklCRENUSDQvR21YMHRxVmQyK21vWjJseTlBT0R1dFFlbU15SXFaZlFndHNhV3BTQzVlWERSa0FKVlpxUDQ3cXY4TkVYcHVrZDRqWnJOdWdLeDk1YnVKbkdSaVlxYi9xUUZXaTZjbFAzZXM2YXBLdWZFNGlmcW1teGNzN1IwNklsYXR3dWJOU1NKMnB1QW5kbkhJRlA2aHJtaFBnQlRYZHFYeUNoMUtnU09BTTFReHpScjQrTkNIRkhkbnc3cy9JMEVPNTBtN0NTcGJUZ1FEazkyZjdVR21hdXNtNFVDSWcrVVlvSWJZUGtjMEJDSVNCQW1aTkF6Y3BTcEprK2N6UVlEMStkQmtFS1VPYzBCRXBKRWNVRDlvRUNlS0RGS3dDREU5YUJ5bkl6QXo1VURFclVRZktnZWtueFNzQW1nY1NybmVER2Z4b0RtUXNDQklQbjUwQmc0RXlGQ0FEUUdLeHVWOGZLYUQwbTQ3ZFc3cmdGcUFRcVNTRVRIeEt1YW9WbCsvRHVWSlRJd0ZCZ0g4VjVwL1FLODFlNkc5RGhjbVA1RnNKK1poVlp0VldyMTY5UzRkamFpT1o3OW9Db3RtcGRuMnR2MnZmdG0zQU9wVTBxQjFFU0pwdDlwa1R4MnhlMzdqcE51cHNHQ2syNkZGSTh6Q3pWKzE5cmdEbmEyeDcwbTg3TjZhcE1rN0hMUGFSNVNSTlg3ZkwybUloN1RkbkhsZmVkbk5JVEhVdEZPWTZlQ24zK1hzd0pXcTlnbDI0VmVhQllrSCtWcDRwUDZZcDlxV01mdlBaUTR5QzVwRjZ6ME94NVVUOFFxcDkveUlxTDArelJDa2QweDJnYVJtRk5YQ0ZaL3dDb2ZyVDdmZzFMdFpmZGtHckZTdE92KzAvMm9xSlNGRnJiQm5raUR6SDQxTm5yL3dBamtqemhjZVVvcVVxVHlveWFvYzFIZUFxNEh5cWdyeEVoUU1xSW5CNEhRR2dHVTdSeEh4NlVDUmdSK1ZBUWVIa2NtZ1dTZUkrdEFRSlZ1QVRCSk9DVFFJV0Y3VUVyUVFSaUtBZXp3eVNPS0J5TWdaQWc0cG9WSUlIaEtaNTRvSERjRlJLUHBRR2JXSUtESlBCZ1VFbHRVZ1NBbFJ6UG5RU0drdUszRVFCdVBUbjFvT3ZYaWJoYmlpRWU2U01MQkZMQldQM0lZV1VPS2FRZHZIZXAzSDVHb0dPdkY5U0Z0OStVd0RDQnVrZWtET1JWeTFaVlU4NDZvS1cySDFJR0pVSS9Tb1VMN1ErQ0ZOcU1tQ1FWZ1I4Wm9Tbko3NVM4Z1pFUjNvSHdHS0dITGJlZHdwYUZxQWdLTGhNZk9oREhyWlNFcUVOQ2N6Q2ljY3dhR0JJdFFWd2w1bVRKOXpuSEVrMDFNWWhiQUpsWlhFR01RVC9hZ2hyZXRpZ0pDMzFHVEdRQkgwcWpVOWVkU3A5UVFWUUQxTlFVODFRVkp5bVFEMXpRS2s1NTlLQnlsSHp4OEtCQ3N6T1pKbkdLQk4zaU1rRHJrMERrcUFHQ0pqNDBCVzNBa3oxNmhJcWFDZmFONkV5bGVQZU9JcWdLbk53NjhjUkZBM2Vya0NQblFPVHVtU1RRRVNDRlltZmpRT1lRc0trZzh5YUNjbUNNeUFjeUtBeGFWSjVnR0JtS0QxbnBuc0lVZE9jdXUxbXMzbC9kQkpjT242WWZzN0pNSHdCWHZxSjg4ZkN0U2ZEck5UbE10ZlpqcEZwWjJyZjd1czlOc1hJVzgwaGc5NnFVenRXNnVWa0Rya1RWdFNXdDVZZDdLdElMU0dyUU5OSkNZQ2ZkOHVrRGlzNm83ZWxkbnJ4NEtSYjJpMTVsUVNGU1Q2MCszb0ExRHNObzkwa3JYcDltNENOc3FaU1JCK1V6VmxIQS93Qm9iMmNOOWtPejdIYUhzOHU0dGttNlExZE1wSUxhUW9HRkFIanhBRHl6VXZJOCtIdEJxeUFRYnNtZXBRSnJQMWlzUGFIVXlBRk9vWEJ3Vk5qRk1DLzdRM3B5VzdlZlBiSDYwNUQyZTBUZ2MrL3RtMUppRDNaS1NCVGtBdWRkZFU3OTBsSGRqb29jMDVGZGVYSzd0Wlc3dENqbkFxaUtNbk5BV0NEMG9GaUpuRkJ2ZllYMlVkcmUyaW1YTkwwNHMyVGczSnZMczkwMXQ4MDlWZklHdFQ0KytCM3pzZCt5L3BObzMzL2FmVVh0VmM2TVd3TnUwUGljcVA0VTRuUTZIcFhzbzdINkx0K3hhQllKMm54TGRiNzFVL0ZaTkw4NzRITi8ycE94Mmt0ZGhtZGEwelRySzJmdEwxcERqckxBYlV0QzBsSlNZNUFPMDFMOHJaeVBLaGJJT1JrZWxRSVVBR01ZOUtEQWlRWm9GUTJKTW1COEtBZ1J4bk5BNUNNWjRIa0tDUXlDUjV4bk5BVkNUdEpnZUV6eDA2MEU5Q3RvejFNOWFEcy9hRDJoZTBIc2d0eS8wL1U3alVFdjdXbHB2R2c4aE8yZHBTQUJ0bVRKNjllS2wrUG9keTdLKzFEUTlkN0RONmxxVjlhTTNZdDBGNjNDeDNpM05va0phbmRsY2dETlB0bkhrWFdoNjJ4cU9wdmhxeXVMYTFkUWdoVHJRQ2QwSHdxSFNSVjIrUlYzV2h2OW1TNDVvNm0zZFAybGFiUndrS2J6a0lWeEdaQVAxcS80SldpOXFWUDNBdDEydDJ5L2lVdW9JeDhlSTlSVXdVdjdTTENiejJKOW8xdnludWd5OGtER1V2SWlhdFI0VWZiQUlqSS9Tb3FPdE9kcEJCR0RRSWM5UjhZb0dsQW1ldEFpa2dKbnI4S0JpNDJnZzVvR3BIQTg2QXdnS3dQeG9QU243T0hzYjdOOXErenJYYWp0RGQvYjFkOHR0T25JVnRiWlVrd085NnFKd29EQWdpWm1yUGxKL285STMydDZmb3pDMFdMSzc1OWxBQlp0QWs3WUdBVkVoS1I4U0t6OXZRb3V5SGEzdEQycDFCNUN0SWIwaGkyZDJ1aHgwWEJXa2lVbEtrK0VnOVltRGlhU1h5TjJkU0V3WDNFN2o2QVpvT2ZmdEMyaUwzMk5kcUd0b1VwbGhENlQ2b2NTdjh2enF3ZUVicHZhczRIbVBXZ2pwR1pKajQwR2JUSElnMEJVSUpHSWpreU9LQW9ncThQMDVvSHNvQ2lCd1RtYUF6S0NwUUkya0hPUlFTdzBKM3AvQTROQVJTWVVSdDQ5SmlnOUVYOW96S3liWkJUT1VsUWlmUGpOVWNyN1c2TTcyWDdRV3ZhNnp0RXVOdFBCVHRxNElTb0VRWUl5SkI1NlUzZWgzZjJlYXU1MnQ3RnVhemNodTEwNjhYdE5xMjR0d2twVkNVS1Z5VkhIQUZabjdSMGw1b25TZFBhZFNsbGJvVVEwRllRWUJDZmlQenFpRmNYSDJNdGx0eEsxTkt5QVkvT25RMEw5b3Z0aHBUM3NwMVRURTZ0WmZ2RzZYYm9UYmg1SmNJNzFLbGVFWndCSnFmYVhpRHh3NlFwd0hjREdQS3FBeUo2Zk0wR0FjVHhQTkJpa25jWWllS0Fad3JhVGlPb29BT1k4UHo0b0hKVEE4K3RBZENPRDUwSG96OWxkbTIxalJkYTBOTHB0cmhOeDM3N2lRTnltaWtBUVR4a0g2MU5ua2VqTk43RGFCWnNOTmh0YjdiUkt0cjd5bHBVbzhxVURnaytacTdPeHN6Ymx2YnNodG9vU2xDWUNSVTNSVjZoY3BTbmU2UnVHWkhRZVFvTkM5cE91S3VleFBhSzFiY2JTMHZUTGhLbEtBSW5ZY2ZwUWVIaTl2YlFwV0ZFZWY0VlFEaFVjZjUwb0Y0U1RBK0VVQlcxU21BSmlneUNZSUlVUFRrVUJFQXBNQXdUMWlZb0piUUd3a2tnRGdpZ0trcU81S2laR0tBZ1Z6Szhna2NUUWVobE8yU25GQlRiWldaa2haQk1lZWFxNUVlNFZwYnlIVU90b1cyUnRLRmJpQ21NeUtteWRHS1BUL3dCM2RuTHAxZlo5MjYwenZQRXR1M2ZVRUtJNFZzTWlmVVZtNWU0dUdPZHA3NUxTbVhkWjFwVFpPNEpVL0pSSFFZeGduaW4xbm9VdmFIV3pjNlZmTlBYZCs4cGJSL2pQS1ZCSEIrTk1pT0lOZnhRRE15ZnlyU0paSUNoSmpyUU5QaUlpZlBIU2d3U1ZjRWo4cUJYQUZLeHdLQWE4R1RPQVpvQUg3eFpOQWNKd295ZkRpZ1ZCSk1FeFFiSDJLN1VhdjJQMWc2cG9GeWxwOVNDMDRoeEFXMjZqQjJxSHlHZWFsbWoxTDdKTzN1b2RzOUdMN3FkS3VMd0tVaDJ4VnFIY3VOd2ZlMkVaU1FjR1Q1VUc2M04yNXBUaCszNmU0MmsrTHViWjVDeWZTU3FuQnF1MWp0TXpldGhURnRkSldDRU0yUzFKM3ZMT2NoSndrZFRTanoxN1llM3kzdSswZXd1R243a3BLTHQxbE8xbG5vV214L01mTlJwK2prRFBqWVJBakhVK2xVTlNSdEVEek1VRGxLRUhyaVBqUVlEeVNvR2dNa2dBU1pIMG9NN3pBRWlCSEZBVnQ2UVFSUFNnTUhJZ3pnOEdnS2JoS1NRQ0Juem9PL1BOc1pVbEZ3QWV1MFQvQUovblNxbjJ0UTFLYlM2cERiRGhRU1Y3MW1NOVlqenJINjFxcjFKaEpNaTNmSWtaM2pIemlyYWFnT1c2aTBBcXljZ3E4d2VSUXFEZHNwQ1hoOWoyK0FqeEtrakhsSE5CeHNDTGh6QkcwbjVWVUUzWVRBOUtESk9BUEw2MEdTUW94Z2VtS0JRcVRIVDFOQXg0dzNBODZCcldHeklOQVFBQm5NNVBQeXBvYzJQR1JFQ090QWRBS1d3T25GVFlHd0FwS2hJV09ETUVmTVZSS3R0WjFLMGMzMjJvM1RhK0o3MG1mclFTMGRxdGZSYlhGdTNxdHlocTRHMXlEQ2xEeTNBVEI2NXpVd1ZWdW1TRXh6MEZVS3hEYUZJUFJjY1VHTEJRbzlPdU00b0JxV001d2FCb1hnbnhmSVVCZkhJSVNmUW5GQm5kdUV6S2ZoT2FCNlF2SWtEMW9DUVJCd1R4bmlnc0xhM0x6WlVTeUR1SThUZ1FmcFFlbHJ5MVh2azI2eXFEQkN6OHFyVW1LbHpUbkZvVk5zNkFBREpVWlBTYWszREVaMndjY1FweGR1Q2hzRENsRW1LbVdHSzEyMWNERGhOdWtwQUN0eEp6azU1a0hOUXhXM0xDSEVGQllLUWNaUVQ5RDg2R05SZDdENllTcGFuYjFHN09FRDZWZFRBMGRrdEZFZUs5V0FreVNvRE5OSkRIT3pla3RyU0VNWEN3ZXFwNCt0RENwMGJUZThocXhRNGtZQlVsUW44YUlicldqMk5ycGdXTk1hUThGS0JWdVBUOCthRG56NCs4VjVEZ0F6VkQ5c05nbnlvQ0wvZ29UNXlab0ViSmdsUm53OWFDVGtOZzRrOUtBU2lPZ29HU1pIcHdhQnlaTTgwRG0xcUtTa0dFekp4UVA3dVhOd1VSUGxRTlcybVJHVDVsVkFwU0pFSitsQTdZZHZXYzlhQWdTZG9rUkZBWnRCQkdCSnptZ1JUY09RTTRtZ2NwQlZ1elFQSU1uSFdnOVgzU1FzQVJJeE81eUQ4cW9oN0ZBcUd3eUpKVUhCQUZEVUs0Q3lzb1F5b1FUQTNBOGVWU3JLaHFaZFVuYjNUeWVSTzRFd2M0ckJVQjFwNEFBQzZrRG9KM1ZyRFVWMXAxU0NTaTVBeUZiVWdnVXcxRVl0aUVibHRYTWhKQWdESXhVSWhKdFhubHFUM0RwOFc0bFlqcGdEcjYxVDlOT212eWQxcXRSSkFHNVlUZ1VMMnFPMTdhMk5MMkthWVFJSnk1dUk0R1BLaU9SdllXZU9UVjBQUEFrY0NLQXozdURtTVIrdEFOTWJzNWlweURxVjRRS29aSkVraWdiQUpCUFB3b0VQV2dlM3dKUFRtZ09na0tBODZCRm54NStHYUJTQnhPYUJRQ0FjQ1BoUUdhSGh3TVFQblFGQ1FDSXdQd29FY1FRc1RKNlpvRElTQWlDTW5pZ09pRTdoRStJK2xCNjQxVDdJeHFUbGszYXNQUGdGWGhWRzRBaWVhdG9wMXFhQ2lwZW5ia3lUSVdCank5ZWxUa1FidExMWktFNlVVcEtjL2ZUTk9SWHJRemdJc2xTSUdYQitHS3ozVnFFKzR5V3ovb0hCQWsrS0NSV3VlQ0lDcmxrZ0EyVjAzdE00Y3pJSEhxS3lpUDlvdEVFS0xHb0R2RlNCdndmN1ZSRmRkczFGSkZyZnVUbElMblhvUHBVV294ZHQwcU8zVG5Ea2dCYm1DRDB4bXFWclhiUjFZc3dGV1lhZ0VrcVVTYytkSWptQ3NxNmMxUWZhRGpyNWlnSStEM2NHTXBHWTlhQmlFZ1FBUkVmV2dPcEkybVBlb0JoUGtURkJoNU5BeFV6K1ZBOUhNRVRIV2dNa2xKOE1nbWdhN0svRW95VDFvSE5Ed2ttZUlGQTVNaEpGQVJvRXBIUXg5S0NZMkRnZ1NEbVNPS0FhazhuTStYblFTV205NllQd29EcFFQRkVISjVPYUQxUDdTclp1ejdZSmZUY0lJZXRWRUJ0d3BBSVdKRStmbWF0NUdzWExnVEFTdFVaVEhlOFk0SG1LelpvZ3V2dmdMS2x1QktSNzNmakUvK0tmVVFuTHR3RGR0Y25NSHZoenovQUhxTFFIWEhGTktsRDZnTXlIQkFKRkNLMTl4UVZ0aTZCV0FKQ2daNjllUGpWS2hxWmNMeUN5bThVNkRJQ1ZnaytjRG1rbWtvbHd5UnRiQ0x3QklnSlc0QVpvdW9TMnZEdktIRWs5VlBrZ0VlZ29sN2F0MnZiU2hsS0laQ3RzbUZLSi9HaU5FUUpXbjFOVVRHMGVMcjhhRExrUVNUQTRFMEEwQWh3Zys3QTZVRWxhZkNQOTBad2FCcVU3Y2ZQbnBRTnhuRWc0azBEQ01rOUJuSjU5S0RFd0J5WWlnSUFKQTZIMW9IclNBa2M4VUdKU0loVUdSOUtBaVVwamdBbjQwQm1VRFltUm5wUVMwTm5iT1krblNnWXNTUkIvR2dPaVFtRXdzeG1LQTdhUnR5Z0t5ZVJtZzlWNmxwTGwwNlRkV3o3aTIwYk42MGozWm1BZXVhdUN0ZjBCSmVUTmc2MnRDQktRQWNucjg4WW9LMS9zKzJvcURqRHdDekJLV3dTUGpuem9JQyt6N1llTXNYUW1RRTl5Y2ZHRG1wa1dvYnZaK0Z1QW91c2txSDNTaDh6bW1STlFoMmVXNDRWSWF2RXBqUDNTNEErTlhBOVBaTjl4YWl4Ylg1UFJiYUZBaWZYR2FXVHpGbEhIWTZGTnFOcGRPdUVFZU1aOVRKVmlwbm8ybmY3SE5sU3dpMUc3bVhGTmlQUHJUandsYWI3VWREYTArMENrcHQwcGdFUTZDbzRQa1BoVUhHa0pCS0k4Nm9zRzJvSUpBSVBNWnpRTnUvZFdRQnh6MDU2VUFtMDdIRWcrOE9WQXpRU2w3aTJnRUlDUmpIT1Qxb0FiQ0pJUHh6eFFOVW5PQkpvR0VUeUlHZmpRTHRBR2VQcFFIS1lCSW1ZQjR4UU5JS2dET1BqbWdWdElKQTg4Wm9ESlNRaUJCOWFBallBUU9ZeG1ab0pTZVBFVFBReHovZWdjNkNxVkV4d0FmTDBvSE13RStFVEJrRVVFcHBhUWdBaWFEMnk4dHJ2SENHeTRTbkVvZ2ZETmExbmZDc3ViZ0pFcHMyb0lLZ1ZHS3kwZ1hOdytwSmNWOWphYkdRbVJqOHFDdGYxQUplVU8vdHR3V1pLWUo0K05Db0YxcWhKTTNiQU9JbFJLZ2ZrS245RUJlcUhlZSt2OSs0a29odFpQMEFxOUNKKzhRVkgvWHZxUVNJQ0dEK0U5S244SWMzZXRHVWQvZmdsTzlRUWxLUkh4SnFjZWx3b3UydG9Lbk5TS2M0RHlFd2F2OEFFcm4zdGJ2bVYyTzFLTDA3UkV1dm9WT1BTZzRveUNYRUQxam1xTEpDZHpTcGdSNVptZ2ozUmxLNW41Q0tCaWR2ZmtxSkNjWUhXZ1B1Q2t5RGduaElnVURRa3FVU0ppY1JRTlh1UENUSFVuSW9CTDR5VDlLQnlTUWZQL09sQkxaV2xNbGFpQndSRTBBVkRKQUdKa0U5YUJXOHFFampyUUZWdEFPZWVZRkFyUkJTQXJHS0NZM3UzSlVNRVJKLzdVQnk2aFNGQUloU3VJeVBXZ0dIRXF5a21aRURnZ1VCMkVTakNVblBKVWY3VUhzSFZ5RUU5MDBvRUtKZ0lKblBUTldWcmhyenp6cTFnRzFmSEpqYlVNVjd2MmtvSlJZUExVVXhHM2FSbnlxbkNBV2RYUkliMDFTVUtoT1NFeVBuV2VTNGpLWTFSU3NzMmlGeHQvOEFVU2ZvRFVuWndqWEZscWdCSWZzMGdrUXFKZzlSTlhhWEVZYWJxQlg0cnV5S1NKanV6Z2VYRlMxSU1uUjM5d0t0U2FaVVk5MjNKSkhsTUNpMUp0OU1XbExiZjI4cU01VUxVNUg0ZFJSTDIwRDJxYWV1M2JVVGV2UEJTWU81c0pBZ0QxcXhISkdCOTZnRTllUFdxTEZrQW1WQWdlUU1VQXJ0b2d1UWs3Z2ttUEtnak5wVnV6TzZBRFBuUUZLQnNVZU1jeFFQU015Um5pYUJpaElnekp5YUFKVE9DUHdvRlQ2bkJOQk1iUUZwa3JnZnI4YUJYRW5pZkQwTkF4TUQzZ2M4elFLcy9qR1BLZ0dsWHVTWUJvSmJEcEcyRm1PWW9DOTZTdVVDRXJFd2tIRkFqYWZFbFNjNHo2VUZneSt0RFlDQUkrQW9hOWNYcjF6S2tvdVU1UEVLeE5CcnQ3ZFh1OWNQTkZBa0FLY0lNL0NtQ3VldTc4NFVHaTRuK3ZjVG5yUFdtQU54ZlhxZG9MQ0Z6TUV4ODR6elV5clVXNDFhK2NRaHA5aHhUYVBDMm52STJ6NUVVNTFFSnk2ZmRTWEYycTVWd2R3RUg2MDBRZTljS3lPNHVrazdvSWNFeVBPbmZLdzBKVXBzTFd6ZGpxWmNCa2VVMFFWa05sMUtCYXZBclZ0U1ZQUkpNUk9mT21qUmZhT1dDaHdJWmViZFNEbGF4bUkrdldybzV3bEpGeWs1SVZKa2ZpYUNlMklrakppU2ZPZ0hkSkpTdVpqYWZLZ2pNd0hGVE1jVFFTQ0RKVW1UOGYxb0JGQmlGUm5raWdhNXdCUHdvQjVLdW9neHpRS2xPUnpIQm9KYU55aENTWUhsUUs0Q0V5TXdla2lnRUVxa2lTUjhhQnlnb3RrRG1lcG9BaE1KQm1BQkV6UVRyWHlQeFNmODZVR0dTbzQ2bWMwRG1NcktTWTIrdUtDVWdxQ1lUTUR5TkI2OXZFdnJSdTdnaEVLeEptSjgvam44SzB6S0N1MjNrclMyRmIwaFpWeHNKQnhrVkZWMXdoYUVBcGFJZzQyckIzVkZWeTBFSmxURHBqQVZQTW5JcHl0UUxwamR1bHB3R2RvSlNEQTh1S0lBNWJXNVdZWldrRGtLanIwbjR6UVZ4WVkvaHA3d0tUa2dJU3FJNTQ2VTdEbVcyeWtSM3dBNmxvU01ZSEdhbVVNV2xsTHFDVlBrKzl0RFFFRTQvU2w0SE9mYWFVTnJoQ0hQR1orOFFBWndQMHBCejloUDN1T1VrNGpNVlJhVzZVcVI3Mk9ESE5BeDlwSzdkOElHNVcwai9QV2dyMk54TzRpRkVEQi9PZ21JYklUTW4xUHhvR2hzN1V3WUhVR2dFODN1UFBpRXo1VUExb0dNS0FuaWdZa2V2SFNnbEpCQ3VoalBGQVJTQUd3VWt4UURRZ3dCSWtnMENxUnp4SGthQUcwd0RBK2ZsUVRMTkNWWUlJbmd4TkFWNGp3Z2dtZUJIMW4xb0dJY2xTb0orUE5CTlpKN3NTbWZnWW9QYWR3NXNDQjNpOWpneUVPRHp4MXJWbDBSRlhSdUVRZ09wVUVSdExnNTgveHJJQ3BnS2I3d0p1RXFsU1IzWVQwSE0wRVp6U2RwMk9OWElRdnhDR3daeGttaTBydW1GeFFXMjFlcUdEQlpCUHp4UmxGYzBkSWJBVmJYU1QveERhYmlaSTYwMVVaclNXVXBVbERWNkZOcUlKTmtPdlQxazBHR3pzTFo4VytxTGNzRU9FdDIxeXBnbHB6ZHdoWmp3TEhrY0hvYUFxT3h0czh0U1hiNTFKUVNZREpnR2VTWW9PRmUyN1RXdEwxRnRsbTVXNmQ4YmU3aU9aL3oxcURtRENRWDJrN2VRb1RpcUxXM1FBa2pCbEpFUnhRWnRsYWtnU1ZJNEhYbk5CQXQyeHVLU29RT0J6MEUwRTBNWUpVRHRnU1JtZ0F0cFhCRW56RkFKYUNDSUJnZWVhQmltcFdZeVFlVTVvR2hzRDNoQ3ZLT0k0b0pMVUpWdEF4eG40VUQxSlQ2U0FCdEk2MEFZU0lDdUk0OUtCNmdRbUl4eUJRQk9XeGp3Z21LQTl1ZHF4dGpIVTlSUVpjSlYzNWNWS2twNDNET2V2MG9JMjdabU1BNStGQlBhY1BkcDZpTWRLRDNSYnN0T2Fxb09Ob1VBMENBcElNWlYvWVYwK1hURTdoamxwYjdTZnM3VTdsWjJDb3NDMWUyWSt6M1gzTGVDUVBDTVlvcUV3bFBlb0VDTndFUi9UVXlhSnFQQ2ZEalBUNFV2Y1VaaGF2dVJ1VkcxZUorRlZBN2wxd3VxQmNXUUVtTW4rbXMrRmJOWUlSY1dKYnVFcGRiV2toU0ZqY0ZDT0NEelJGVGV0b1NrYlVKSDNnR0IweFdoNVovYVVTRTY1WUZJQUtncVNCeldhcmo5djhBeExmNGZyVUY0Z2ZjRTlkcy9oUUY0dURHSjNUSFhGQlhXdjhBQWRQV1U1K1JvTElBQlJnRGo5S0NPL3g4RmZvS0FJeVhwekNmN1VDWFlBYVZBQXlhQ0U3NzUvNWdLQ1FQRVNGWkc0ODBDeWZCbm1aK3RCaXdKU1lFd244alFZZjRLdmhRUjJ2NGEvOEFtTkFhM3cwc2prQ2dWOGtoWkpNa0Q4NkNHc254WjZVRWtPTFNsSVN0UUVjQTBILy8yUT09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC8vZ0JLUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPazF2ZEdobGNsUmxjbVZ6WVY4d09UUXVhbkJuLzlzQVF3QUdCQVVHQlFRR0JnVUdCd2NHQ0FvUUNnb0pDUW9VRGc4TUVCY1VHQmdYRkJZV0doMGxIeG9iSXh3V0ZpQXNJQ01tSnlrcUtSa2ZMVEF0S0RBbEtDa28vOXNBUXdFSEJ3Y0tDQW9UQ2dvVEtCb1dHaWdvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnby84QUFFUWdBNVFEY0F3RWlBQUlSQVFNUkFmL0VBQjBBQUFBSEFRRUJBQUFBQUFBQUFBQUFBQUFCQWdNRkJnY0VDQW4veEFCREVBQUJBZ1FFQXdVRkJRWUZBd1VBQUFBQkFnTUFCQVVSQmhJaE1VRlJZUWNUSW5HQkZES1JvYkVJRlNOQ3dUTkRVbUxSNFJZa2NvTHdvc0xpTkhPU3N2SC94QUFiQVFBQ0F3RUJBUUFBQUFBQUFBQUFBQUFDQXdFRUJRQUdCLy9FQURJUkFBSUNBUVFCQWdRRkFnY0JBQUFBQUFBQkFoRURCQkloTVVFVFVRVWlNdkFqY1pIQjRXR0JCaFFrUWxLeDBmSC8yZ0FNQXdFQUFoRURFUUEvQUwxMmExNWlZbGxVdytCY3Zva0VaZER0cEY5SG5HVllucHpra2lReERTRW52R2tEdlVKL09qaVAxaTk0Y3JUVllwak15eXZNRkpCT3NZRFJwM2JkazZuWVFZQkhDR0V2MmhZZUdzUlJ3NXFOanBFYmlTaFNlSktTN1RhZ202SE5VcUdpbTFjRkE4NDdsUElTa3JjVWxDQnVvbXdBNm1NYzdVTzJXbjBtWG1LZmhkd1RkU0lLVlRRMWFaNTIvaU1NeDQ1VGRSSWxOUTVaajFjV2ltejg3SzkrSmh1V2VXeUgwRFJlVTJ2YUdLVlhKVlYwdTZGSi9OeGlpQ3BURFRqdG5NNFdzcVdGNmhSSjFKaDZXbkpWeFg0MlprMjNHb2pUZWw0NUR4YTI2THhOWWdsczJVSnZwcGxnU2RmbVZvZVRMNWhmdzNKMkppbnl5NWE1enFXdS91bTI4U01sT2V3c3VaMGdOcTFCM01BOEVVcVNIK3ZLWGI0TEhXcHRtWHczN0hjRXVxU2JjU29HNU1QWVM3U01TWWZCWnB0VWU3aHBYaFllL0VidHlzZHZTTS9uSjljM01aMW13R2lFMzJFSWxuQ2wwbitLSFIwNlVhbHlaMmZQNmtyajRQUThqMi8xbnUvOHpTcEI4OFNoYWtINGF4WDY5MnJWaXR1azVsU2pSL0sycS96akxKZHdoWFE4STJic1A3T0dzUlAvQUg3WDJTdWlzTHN5d3JRVGJnM3YvSW5qek9uQXdtZUxGalc1b0dFcFM0UVdDc0pZcHhwbG01TlQwdElFL3dEclpwUlNoWCtnYnI5Tk9zYmRoYnM2RkJjYmQveERWSDNSNzRBUWx0WCswZ2tmR0xpMCtrTm9RMmhDRzBnSlFsQXNBQnNBT1VQQlpQTDZ4VGIzRFc1SU1NSkd5MTM2Z1FzSlVqWTVoQkJVSG1zTlk1UkFkbkpXcDZZbEpGeDZYRGFlN1NWckt3VFlBYTZEZVBLSGFwMnQxZkZLSGFkSlBxbHFRRkVLRGZoVS9iK0xpQjArTWV1aVFia0hXTWI3YU95YVh4T3c5VnNQTnR5MWRTTXkya2dKUk9kRHlYeVBIakQ4VFNsOHdMamE0UElNMnJNVGY2eEh1V3ZwdEVyVVdYWmVZZFltRzF0UE5xS0ZvV215a3FHaEJIQXhGT2FLUEtOU0hSV1l5cmVDM2cxNndSNHdaSjNVU29McE5XbFo1RFljTEtyNUNiWmhhMXJ4YzVydFBuQzJVeVZObDJGbjg3amhjdDZhUm54Z2Nkb0NXS0UzY2tHcHlYQ1owMUdkbWFsT096Yzg4cDU5ejNsbjZBY0k1cjIzZ2VjSFlIakRFa3VFQTM3bnZLa05CZEJsV25SZEttUmUvV0tUTEtkd1hpYnVWWCs2cHhmZ1BCdFo0ZVJpN3lNN0pxcERFeTFOTUdVUzBrOTduQVRZRGU4WlgybzlwZUhuS1k5VHFhbjd6bXpvSFU2Tk5ubm00a2RJODdISEtmQ1JvVGtrN1pzdnREUWxUTUxkUTJ3Qm1LMXFBQUhVeG5lTE8yUEQxRXpzMDhxcXMyblN6T2pZUFZmSDB2SG5Tdll1ckZZWVF4UHo3N3NzMkxKWnZaQTlCdjZ4WFhYU1R2cHlFWGNlaTh6Szg4Ny9BTnBkc2JkbzFkeFM2b1RzMFdaTzV5eWpCS1VBZGVLdldLTTg5ZmN3MnRkaHI4SVpjT28xaS9ER29xa1ZuSnZzRGFteTRRK0NFSy9NTjBIbjE4b2VxbE5tS2M0MkgwcFUyNm5PMDhnM1E0bm1EK2tjaDNpVHBsWFZMU2Jrak5OaWFwcnh1cGxXN2F2NGtIZ2ZyQnl0Y3hDVmVTMGRtVGttdHFvTVRpWlpTN3BXanZyWHRhMmw0bE1VMUdtTVVxWmwwekVzSEhFbEliWXNTZmhHZVQxT1V3MDNOTmZqeVRwczI5YmovQ29jRlF3aEZoY0pId2hIb3hsTGZZYnlOUjJoc2pWT2J5anRRTmlON3h6STFVTGJYdkhlMG00NlE2UXRGczdQTUx6T0w4VHlsS2xzeVcxblBNT2o5MHlQZVVmb09wRWV6cEZtVXAwaExTa28wR1pHV1FsbGx0STBDUnAvem5HVjlndUcvdUxCQXFUcUNKK3NrTzZqVkRBOXdldXF2VVJxVFNVcVFYcHBXUmxzYUE2WDZ4bFpwNzVmMEx1T08xRWt6TWhTRktTbEtVRGRTem9CemptVFhHMU9GTEtIWGtqZFk4S2ZRYnhVYS9pU1VTZ3FuSmxxVHA2ZGc0ckxuOU56RWRKWXBuNmludThMVUdabTBIUVRFeCtBejU2Nm1KamhiVm5OcXpUbXB2dkxFb0tQTXc2SENUb0NmU01ybloyc1MzaXhCaldrVVJQRm1VUWxTeDB1clg1UkgvZStISEQ0OGE0c20xY1Z5NkY1ZmtpMFdJNlcvd0Q0eFRta2JJVnFHL3poTGlncEp6ZVVaR3hWcU9sUUVuMmlWcVRjL0ttb01rcC82a2lMRkkxREV6YlhmeWt4UjhVeVFGMUtrMWhsKzNsY3BKZ25wV3Z0ci92Z2haRXpLUHRQNE9aUTB6aW1TUUV1bGFaZWRBRnM5L2NjUFhUS2Vla2VhNWk1VWVZajJ4amwrU3hwZ0N2eU1xbDFFNkpkV2FWZlJrZWFjVDRraFNUMUdoR2hqeE5NRzZzMXVHb2gyRk5mSy9Bdkp5N1F5cm5DWVVkUkNlRVdBRUdZS0RFRWRvNDZ4VnJ3VitrQkowOVlWNjJqaUNhVlB6SHNpWmZ2bmU1R29hem5KOE5vNWxQRlhHRWtGUzBvU0NWcU5rcEF1U2VRRU96TWpOU3FFcm1wV1laUXZWQ25HeUFmV0VMYWg2eFRsRnlTdElZS29iZFZ2ZmJwQnFzZGlDT1loa2trNjNoaUV5VkJsWVBEV0d6cVlPNDZRazc2d1FJUjJFSDFnSFl3RTY2R0pKSk9pVlpkTVc0MjQwbVprSHhsbUpWZnVySE1IZ29jREhiVUtLZ1N5cW5RblZUbEwvT2svdFpiK1Z4UC9jTklnSTdhVFVacW1UYVptUWVMVHlkTGpaUTVFYkVkSVZLRFQzUjdDVXZERW9BSzBrY2ZuRjM3TThNS3hiakNuMG9naVdXcnZabFkvS3lqVmZ4MEhyRWVpV2tNU0tDNmVscW5WbmRVb1RabVlQTnNuM1ZmeW1OdSt6dFNQdXVpVnFxenpLbVptWWZFa25Pa2hTRzJ3RkxzT3FpUGhDTXVYNWE2WTNIRG0vQnRrdXlqSm55SVpsR1VoS0FTRW9TZ2FDNTRBQVJRY2ExNmVxaE12UjVsbW0waHMzbUtyTkMzZVc0TklQNVJ6Ty9DSTdFdUxhOVhxek9VbWxVMWlVa1pES0ZPVGJsa0M0dUZFRDN6YXg1Q0twTjFDaTA5OFROVW1sNGtxaURaQ0RaTXMwcitWSThQMU1MdzRIZHRESlRMSGgyUmszSFJNVUdsVEZmbmR6VnFxdkt5RHpUbTRmNlI2dzVXcXJUbTNGdDR0eGpNVFdVMis3S0MyVU4rUldOVDhZcEZieEhYSzJudTVoNHRNSDNaWnZ3TkpIVURWWHJERlBvVGl3bGJZc2JEM2xoSStKSUFpOHNGZk5rZGZmdi9BT0NkOThSUmFXTVcwT25hNGV3WXdpMno5UVdNeDYyMVB6aDlYYWRpRzREQ2FkTHA0SmJsMUtIek1SMGxndWNmUm1YUHlES09rMDM5Ym1KQm5BU3IyRlNrMXFQSHZ3cjZHR0tXbWozeityQmF5c2ZiN1RxMHRKVFB5Vk1uV3VLWEdDbjlURGt0V3NJeno2WFptbVRlSHA0bnd6bFBjeXBCNW5Mdzh4QzA5bmRSY1JhWG1aVnkrM2lJK2NSTmR3VFg2TktxbUp5U3ZMRFV1dExDd25xYmJRNlArWG45THAvb0xmcXg3NUxnN05URGMvS08xU1pablNsQmNsS3V5QVBhV0JxdHAwRFRNQjRoNVI0MHFEcVhwcDl4dlJDM0ZxU09oVVNQbEczVm5FUzZOZ2l2U3hVYlBJQ1paSi9JNnM1Rlc1ZUVrK2tZU3ZRVzRXaXZMSHNtMEZ1dElKT3VsakNSdHJmV0RCOFhXQVJZMjR4eHdTZDlkb1ZhL1dFd29hcHZIRU1KTy9uQzducDZ3ZzZXTUxCNjJqam1hYmdoZE1Zays4Uk15cnI2bEF1TVRMTGZlTk9XdGRDanFSMCtodkZ2UzZzbFNrdXFGeHJyY2ZPR3BKaW1GeDJYbXFiSXlTZ1FHa2hsTzNuYmVFVE5MbUdscVd5NEZKQU5rcjFTZkk3aVBQNUpLY216Nno4UHh2VDRJd2pUcjJ2OS92MklMR2xFYm1wSnR5VHBxSFoxWnNIRUtEUUFJOTRuUUs1QUhuR1hUakRzck1PTVREWmJkYlZaYUZEVUdOSXJsZXFsRFEwNGxodHlVbUJhK2NxUVZjVXFCSEw0NnhtczI5Mzh5ODczYmJXZFJWa2FHVkNiOEFPQWpTMGFudHA5SGpmOFNQVHl5N29KcWZsVlMvUHJtL2V4c25uQlh2QXZCSDFpOGVZQkJwMElOK20wQThiYndYQWdSeHc1YlNEYnRuTitNRW54SkJ2ckMwRHhEcm9iUnh4Mk1XRjFFYUo4WFdQWUdEcEIrbVlNb2twT3JXdVlSTEpkZUtsWEpXb1ppQ2Vsd1BTUEt1RlpSRS9pR2x5YWdWSWZtMlcxRG1Dc0EvS1BaZFR0blhsMEZ6OElvNmo1blJadzhLekFlMStaZlJqTnhMU25QWnZaMmt1dGhSeUZWaWIyMkpzUkVESytFb1d0S3JuWUFlTWprbFBBZFlzbmFQTUJXTTZ1eWxSekpibHpZY0Rrc2YwZzhMeTZPN2N6cFNYRGxKWGJVaTBGazF2cFFwTGtkaDBpeVN0dmdPZ1V4YytzbVpVdGhvL3VrSHhmN2xmb0lzTXpSV0plWFNtVGtwUlJHL2ZOMzA4OTRiUW4yWjBGRjhteHltSlJtYlN0TnMxbGJhUmk1dFJreXkzU1pzNGNNTWEycFVaM2lTalRLbHFjV3hJclVEYnVpMGU3U09sdVBVeEVOMEt5a3FZWVo3elFIdXo0Ym5seGpWSDVHWm1IQ0daZ05NMjkxVFlWYnl2ckRMRklsV2xFTjNMaVZXVzVZRWs4dWtOanFHbzBUUENyc3IweFNSSTBsYzJYbElEYUxnaFpUL3d4QTBUSDJLNUNvb05LcktpMWV5cE4xZmZOTFR4U3BLaWZsYU5OcWtnbWFwUzJiV0J0Yno0UlU1TERFclB1cVJNT1dlQ2dUWnNKVUNEcDUyZ3NPWlJUYkZaTUx5Y0ZCN1lLbXpOemttaVRhTXNoM05NT3l0Nzl5dlFaYjhyM3QwTVowZXNUdU9wdE03aXFwTFFmdzIzbE5vMXZvazJ2NmtFeEFHTnpHMjRwdjJQUFpFbE4xMEZ4aGF0UmVHK0lNT0NEQVlnd2FEcnZBOC9uQmNZNGtVUm9lRUdrQWlBTEcvV0VwVVFMYXh3SnMyS2F1NnFacUU2bVhiKzZXMzNHZmFsTDNXa0M0U09aVWRQV0tNNWphckZkMjNVTnB0YkxiTmYxTWF4Vk1JeWs1Z21lWlMySlpKYlUvS2xSOXdnNXM2aWVLcmE5TFI1OEp1QkdYby9TejdxWFROcko4UjF1T01WdmFWY1Z4MStSWnA3RmJzNVFINmZOTnBXNDZwSkRnc0FteHZjZlMwVmdrWDNoTjRCalFoampEaUpSMU9xeTZwcVdWMjBxL3NHRHBCMzZ3ajBnZWVzTUt0QzdqeWdBNjd3Z1IwUzBvOU0vc2tlSGl0UnNrZXNjZFFsc2dLSU5vZVlaVzZxektDc2plM0QxanZacDh1d0VxZHZNT2Nob2kvMU1QR1pBYlVsdEFTZ2ZsVG9QbEVma0Z0OXl3ZG5iS1pmRzFBY21GcFNFenpSeWczSjE0OG85WXVxUzRMa2p4SFhvT01lSzVlYmRZZGJkWk9WeGxRV2cyMlVrM0Vlb3ExWHN1Q0hhbzNvcVlsa3FhQTRyZFNBQVBVbjRSVnlRYm1sN2pZU1czOGpJWEgzYXppUEVsVXNWTk9PNStpUVZGS2Zra1JQMGhZWWRiQk5ncEZyZFJFL2cvRGFKUEQ3MHJOTjVIcHNabmp4QUlza2VoK1ppQm5KVjJWVXRoMUpTK3lxeDh4eGlycm9yZHgwWDlESzFUN0p4NGxUT2RJMjFBdnVZS1FCQVM2RjJGckZOOXlOekRkTGNEemJhMUh3cE4xSjRYRU9UU2t1dE9KbFZoQjBLbGxRQkY5N1JsMXpScXhmRnM2cHVhZWRZVzNKcVUya0R4T0ozQnRzT3NPMGlhay9Za055NzZBOEFDcTUxS3VOeEVkTHphR21RaEtaa0VhRkhjRWdpSXVvSWtadGFWS2RSTHpLRlpncHhCUWJqbGNRYWpmQUxrMjdMdlB2SmJrSG5nb1hTa0VBSGpjQ0tsanZGYldHNmVwYlNrR2RtRUVNSXRyZitJOUJISFZaOU1oVGx6VTA2dDJYWkFkV3BDaFpSdjRVanFUR01Za3E4eFhLcTlPeldpbCtGQ0FiaHRBMlNQK2J4WjB1bTlTVnZwRlhWYXYwNFZIdGtTK29xVXBTbFppVGNrOFR4TU1HRktoQkdvamRYQmdBMDQ3d3NIYStuU0dqdkNnWTQ2ckZtRW1ESTBFSk1TY2hTRHJDeWtLMTBFTkNIRW5UZTBjUTBiWjJnU2RWcVVvbW5xbm5HSkNXSlN0cHNiNjdxQjFJMnRyYnBHUzFHbHV5ODg0MDQyWmFYYkFVWFZLempMdGUvRWs4QnhqWGFtL09QMU9ZbW5wd0xVK2xObThvTFl0cDRTT0ZyQzJ1MFpmaWVkbUtqTk1TSHNUemN4THFVTzdCekZkN1dJU09uVXhrNk55ajhzZWc4bVNVNXUzWkF2cVFwWjdwQlEyTkVnbTVQVW5uRFZ4YUpobWxKYWY3cWJLbnBvQXFNcExxRjBBY1hIUGRRQngzUE8wUmN5RUI5WWJLU2ptZ0VKOUw2MjZtTkdNaytFQ05tQmZhQzRHd2lScHJDUWt6TG9CQTl3SGllY01zbGNqMG5JTnRvNzJkMUoyYTIrUDhBU09oNmM5MUlIaEFzQU5oMEFqa2VtQTRyeFczdXE1T3NNWnhyYlFYMkppVkcrd25KTG82SEpoV3BIaDZuV0V0dTZXdllFZVVjNVVsUk8xNzZRYlpPYXdCaWFBYkgyRDRySG5HK1lEUTdpVENkQ2wzdkZLMDV0d3JPdmlkQ2lsc2Y3VTYrb2pBbVJaNjBlb093YVhEblp3bGR0VXpycWZUTUQrc0xuU2FZVVBLTFF6THF1Z20xeTJGQyt4dnVJaWNYMEF6emFaeVNUZVpRTXFrYkZ4STRmNmg4NHVEc3QvbFdGQWZzeVVIeUp0L1NFT0lLMmxFNWN3RmllZm5GVExGWkZ5V2NjM2pkb3h1bFBLWWNlQ2tLUDVTazZFSGxydEVnMnRwYUVJU2l5eGZVS0l0cHQxaTRWYW5NekFjVyt5VXJBdDN6WUFXUDYrc1ZhU29jNWNwTTZYYm4zM1VpNEhYS0JHYkxUeXZnMDRhdU5jZ2FhbWluUUJZR3dCLzRERFRpWnZ2VDM2WEZCUjBCU0lqcVhYRTFDZVZKU0tpN01JYzdySmxJdWIyRmp0WXhENDdyMVFha3A2U3BrczZwMWdXblpwb1preTZDYkd4R20rbCtFZERTWlhLdHRFeTFXS01iVWluWStyeUtuTmZkOGpsUklTemhOMGZ2WE5pbytXb0hxWW83eDFOOTQ2SEU1RkMwSWNBV2tiY2hHM2l4ckhIYWpGeXplU1c1bkNiY1liVkRpaGxVUmJiZUd5ZElZS1FSMzBoUU9rSkcyOEFHSVJ3NENPSTBnamFBazY2d2RvSTRSNjJ0Q2dxdzEra0ZiZUVra0hTMGNjYlM2d2hoUGN0T3VPa2k1Y0lGaW82MjZIall4VmEwSnBwYnl3NGlUa2xKSGZUYVJkMWY4bk1jb3RnbkdaeHR3VGJiekVxbHdsSzBMS1ZMS1JwbUp2bTE0RGI0UkExU3MwOXBsYlZUQlcwNzRDMFBHb3B2dncyM2pFeGJvdmhXTXp4anUzUjgvZjJ5bHJkZW5tVnlkSmxsTlNLUEVzWEF6Vy9NNnM2ZWhOaEVTNG5Jc29DMHJ0K1pKdVBqeGl6eUx6RlFLbnFvcEthSkxPcFI3SExPaGtxS3JoS3o0VDRRYlhVUmZXdzFpTHJsTFZJcjd4aHFaTXAzaTJlOGNSNEM0azZwUW9IeGpLVW0rbS9xZE9Fa250QVNkV1JpRWxhd2xPcEpzSTc1dDI2VXRveWhLZkRZUnh5MXdyTU55YkNGT2l6aWxDd1BVeFlTT3VrRFMrK2c0d1BMNHdrS3VlV3V0b1ZzZDd3YUFFaTR1YmpoeGh4QnNvV1BXR2w4eERqSjhYSFdPT08xcE5uRUhlL0dQVm4yYlVkLzJjemJkaDRLZzVsNjNTa3g1VVozVDBNZXEvc3NCWndmVkNSZENhaFlkRDNhWVRrRGd6U0EwRnRPb1Z4Y0l0NWk4Y2JUWmJjWG5zTEpzcTR2NnhObGtDWW1NdTEwcStzS1F3a3pDU1FRRmVFMjhvVEdJeHlLM095U0pwbFFRdFNWSkdZY1JGS3hvNDVTNkE2cEpIdFQvd0NHMWJmVWFrZVFqVVo2Z0pXbFNtMU9EUWpMZlFtTW03U3B0Z05zU3lVSUw3UXlvTzVHWWVMMDBobVBCNmoyb0NXVlJWc3gybUpja0hzaUgxTUxtSnhsbExvUGlRa1hLMUQ0eGU4VTFtV1ZYSk9rc05wVGhFSU1tNkpRNVhYMEZRekVLMHZjallibUtpc3BSWFdGQm91b2xVcVdVRDh4STIrZ2pmY1VZWWJxUFoyWktXWlEwNDNLb2NZQVQ3amlVaFNiZW9pN3E4WHAvTEg3b1JoeWJ1V2VTOFVVbEZNbm5HbUhDNHdWTExPY1djU2dLSUFXbmdxMXVrUVI0L0l4dC9iZEttcDBEQ1dLZTZMVDAzS21TbTBrV0lkYjFGL25HSk9weUxJNVJVeHUwbU9aeXFIZUowOTRRd2JiaU9oUnl1M0hIV0c1aEFTY3cwQjVRMW9HeGtIcWJ3TC9BQWdoQjc3UXNJQU9vc1lXRHBEWU9naFNUckJJZ1h4MGd2ajZRcTkrc0dBVHRIRUptMVNzaEl6TTRIWjFiNmtFQUphQ2hrUFE3RzIyZ0lpT3hUZzZrVkNjRTBpb3V5Z0tCNEVTdWNxQXZZRUFnaFhMUTNHc1M5THB6N1RDWEpxYnM4c25PZ0FLQ2R0YjczMytVU0V6VTVORXNFeTB3Mm03cVczTzRhQzhvVnBxTCs3Yk1iYlhBNG1NQ0dTVVpmSytqUmpna3NiOVRpLzFabDAvaGQ2UmtuWHBXVnROeWpwYW1tNWdwY1VsV2ExbXdMcFhwcWRPT2x4ckhCUmFwTkVWRmlmcTgzTEZjdFpvcW1GcFYzaVU1VzAyQUpJeUtVaTNoQUN0OUxIVUtuVTJLVzNuZWNSbkE3bHBHVXJremNrRnpMa09YWWxRVnFPUmpOY1ZUSXF0TmtwM3ZrdnFaV3FXemUyb0p5M0tobFlQNGlSYys4U29jTDdBYUdLYnljU1g5eXBLS2owUjFabDZkTFQ2VTB5YUQ3S1VETmx6RklVQUFiS1VCbUJOenNMYmRZakZXSkp0ZnBCSTl4UjVtMEMrbXNhRVZTb1UySk4wblVid2FlTy9sQ1Q4ZVVFRFkyZ2lCeFh1bmphQ2E5NjN6aFF1WVEzY0wwaVNDVmw3NVVmNnJhamFQVnYyWGZCZ2lvR3l0YWtyWGhidTB4NVVsaCtHMzFKajF0OW0xa05kbXEzdFB4Sjk2L093Q1Ira0t5ZGtybzFGa2Q0N05xSTRKSDFnMUk5NU50ZHdlUmh5bWVPWG1YUDRuTGVnRm9ZblhBMjRDVHA1d21LSmJPUEVGUzd1VFVzdUJCS2IzT2dUcHFUSG5qRU5RKzhhbS9OaFJVMGs1V3lkTGdjZlVtTHoybVZsYms0L1NXRmVFcUNuU0RzQ0w1ZjFNUVUxUm01ZnM1VFVWZ0Y2cFR5V0U2ZTQwM2NtM1VxSHlqWjBlSlkwcHZ6MFVjODkxeFhnaE96cW1lMTRya1ZPSXVYbmlxeXY0UWtuOUk5TFNrcW51UWhhYjJRbjZSaHZaYXhueG5UeVB5SmNXZjhBNEgrc2VoRzBCTHFnUllaRWd4WCtJU3JJa3ZZWnBsOGhuWGJqaHh1cmRtRlRhbDJrSmRrVWljWkNVMjFRYnF0Ym1rbVBFODZnQllPaENocEgwY3FFc2lha1hHSEJkRDZGTktITUtCSDZ4ODhxN0pxa3B5YWxGZ3BYTHZMWklQREtvaUtFV1drUUxtcVFkN0cwRURkQkJOeGFIRmc1VkRjYS93RDdES0NSYzY2Q0xLQll3dE9WV1hydkNlRVBPQzZRUnZ0RFJIcEM1S21FdVVGWStjQzl6ZUFPa0gwMWlEZ0lOb2NCdkRZK0VHTEhoZUpPTmFaTlJxenlROW5ia3MxM0NQQWsvcXFKK1ZwRXBJbFMyMjg3dGlPOVdiblU2Z2NoRE10TlpYTzdkOERxUnFoR1pTaGJtTFhoRGxmcHJGMmx1dUJTVFlvRFJKQjh0NDg5UGZMaUs0TnZCSERCNzhrazVmMVpUZTA3Mm43d1pxQ1hYRXFXaFVzdktzKzZiK0h5SUtoMWlnZzJKNlJwZU5abVZxVkhlVEw5OTNpYkxUbllXaTl1cEZ1Y1pva1hOdnBHcm8yM0JKK0Nqcll4V1M0OU1YZndoT21tc0ZjODRDamRWNFR5aThVaGVZOE40SlY5ZWNBUWUvQ0o3SUVvVWRoRG16c01uUlVPcDk4Unk5aUdURW9EbGJ2ekpNZXlleDJYKzZPeTJrSmN1QzlMR1lWY2ZtV29xSDFFZU9hZTBYM0dXa2U4NFEyT1lLamI5WTl4VXRnSlJKeVRla3BKdE5vODhvQ1lDWjBlaTEwaG90VTFwS3ZlS2Juek1WREg5WEZIbFZPSEtWZzJRbS92SzREK3NYSngxTXZKM1ZiYlRTTUN4eFYxMXV2T3FiS2xzTXE3cHBLZGN4MnVQTTZRelJZUFZuejBMejVOaXZ5SXdiU1Y0anhLZmJsbFRLRXJuWnRaT3BTTlQ4U1FJbGNUanVPekRCY3RZaGJwZG1MZERjajVMRVMyR2FRckRqR04xUHVBek10U0VwY0kyUXRhRktLUjVhRHpqaDdUTE0wN0IwaUJaVEZMU29nam1FRC9BTFRHbjZucVpvcGRMcjlQNUtqanN4dHZ2K2Y0RWRqY3VYTVZ2dUVhTlNxclg2a0NOMUNmeDFnYmxHbC9PTWo3RkdyVFZXbUQrVkRUWUo1bFJNYTYyYnpxd1RzTFJtZkVIZWRsclRyOE5CekEvQUI1RUg1eDRtKzBEU21xZGp5cGxsR1Jic3dzckhBM0FVaytkaVI2UjdjbUIvbDEvR1BKdjJxWkxMaXRNeUJvNHcwNWZuN3lUOUJDY0hLa2hrdUdqejJxOTlkVGZhT2E5cjZ4MUxCQ2pZK0xlT1E3cTg0YWlSU2RScnNlTUlVTjRVQ2V0b0pYTWJSTWx3Y3V4dXhBdVlBNkRlSE9OdCtjSVVsUUpNTGZBU0VtK2tHUE9CZlNEQk50eEE4RThvOUJWZkR6bEhkZG1uWlZxWVpjVUZoL0tWSlNTRGE5OXVQbWJSenNMU2tudUdrdFpqZXlQNnhxcmhaOW5YTHJRRk5xQlNVSFc0Tzk0ekt0VTlkR3FQZGEreXVrbGxaNGorRTlSR0hseHRLemIwYmpGN1VxWkdWbHRjeEtQSVdWZUpKR3AzdUl4UUlVMHR4Q3RDZ2xKOHhwRzVQM1VrbmhiU01reFhMQ1VxOHpiWjFRWGJnTDd4YStIeXFUaUI4U2hjVkwySVdBQVlJR0ZBL0RyR3NqR0NzUkNnZWNLZ3JnY29OSUVRNERiU0Z0RHhKMUlFSVVVMnNERGpCc29IZTJzRDVPZlJlT3ppbnFxbU02UEtwc2MwMGxSdnBvbnhIL0FPc2V5R1phcUlSbmwweWljd3pXSlZ4anpYOW1xbEdmeHlKaFNiaVRsSEhmOXlpRWo2bVBWTmRxY3RRNk8vT3ppck1zSTJHNmpzRWpxVFlRRXVYUkhSVGNiNHducE9pTHA4ekpzTnp6eU1qYnJUbHdFN0ZSQjFIOVlpZXlERHBuNmlxcXpMWU10S0x5TUpJL2FQOEE4WGtrZk1qbEZQa3hQWXp4S3RicHl1T1hjZFVuVkxEU2VBOGhvT1pNZWdxUXpMNGR3em5RaExjdkp5eW5MWDJzQ28zNjlZdTVmOU5oOUdQMVM3SzBmeFo3MzBqUDV4MVUxaGZHOHdra3VWU3JvcHpSL2lBVWhIMEtvZysxMTlLOGJ2UzZQY2xaZHBoSTRBV0t2KzZKK2hzS1ZSZXorbktINDFScUs2czhDUHlvek9YUHhURkJ4blArM1l1ckw3UksrOG0xb2JDZFNyS2NndDhJc2FaZml0K0ZmN0w5aGVaL0lsOSsvd0M1cDNZbEszb2RTbWxEOXBOcFFrODhvSDZtTkhZMG1scTExSStjVStqS2xjRFlHcGJOU0tpK3RXWlRiWUJVNDZxNmlCcmJUbjBqam1zZnVwekdXcGlFS1ZheGVlSnRib0Irc1lPczFlTlpwT1ROWFRhUExreHJZalEzOVdYTGNvd243UU5ERlVlQVcyQ1YwYWF5S0k5MTFxenFma0ZEMWgydFlobmFtNjI5VVo0QUpCS0VvT1JDZklBNzlUZU9SMm9mZVRLVXpUMDNOdEpiVzJNNFc0TXEwNVZXNUFna2VzVThmeEtFSk80dWk4L2hHU1VVOXlzOGp1b3pXVUFkUmVPRlZnVGZlUFVjdmczQTc0Q0hhUEt0NjViRmJqYWgvd0JWNHlIdG93dFE4TTF5VFRoMlpVdG1aYUxqakNuTTVaSU5ocWRiSGdEeU1XOVByWTVudFNvVnFOQlBERGUybWpPTTRCTzhIbUI0V2hlVUZNTkVaVHJ3NHhkZG9vY0JnM3VCdERsdVY0WkdtMExTdmE4QW5aTFRBcFBLRWJhWHQ2UStueEM0K01XaWg0Q3hEVzZlaWVrWkVHV2NKeUtjV0VaZ09JQjRkWUdjNHc1azZKaEdVM1VWWjZMOXBkbDMwTXZxS2t1SEsyNkJZcVYvQXJrZVJHaDZHSXJIcmlFMFV0RkYxcC9FS2lDU2tqa2VHa1RSbGZhV0h2YVU1UzRNcUNGV0Y3aXhISWdnSDBpdVYxYXAya0lUTVdFeTZsYUhVaFp1RjJJSXZ0djlSRlhKQlUwaXpESTFKTXEwaTZsOXExd1FZelR0Q0lUWHU3Qkp5dHB2cHppNjRWY0xrdmRWeVU2R0tMajV4SzhVVFNVYWhDVUlKdmZVQVgrc1Z0SEdzelg5RFExMHJ3b3J3RnlQMWd5cTBKMjIzZ3N2TzhhNWloa21BRTYzSk1GMEZ2V0ZaZFFGRTNPMGNpR0JZQVRwQzJ0VkFDQVdWVzhCQkhVMmdrK0EySTE2d1Zja2VEMDU5bFZodHFScnRRZEtVSnpOczUxV0FDVWdxVnI2aU8vdEh4YTVpaXFzeWxPQzFVNWh6S3doSTFtSERwbnQ4a2pyR1dZT3hLcVR3SzFSWkZTa0dZbUhINTFkclpoY0JEZCtWazNKOGh6alcrem1tcHBVZ3hpT2VaRDlRbWxkeFI1UldoY2NVUDJoSEsxemZna0U3a1Jjd1lvNDE2c3VYNFJVeXpjcGJGMTVORHdiaGh2RDFEVkxQaEpxTCtWYzJwSnZZL2xiQjVKdnJ6SnZIWDJuVGppTUJUTW15UUg1OWJja2dBNnFMaXdQcGVJa1l5dy9JUEprNmhYNmVIMEg4UlMzMDVsci9NbzIydWRoeUVaaDJpZHE5T25wcVIrNUhuWFZ5TDZudzlrQVFYQUxKdGZjSjFON2JtSzhhbGwzell4eGFodGlpOVlxeFZMNFp4OFhFc2w4VWlscGtKTnNIS2tPcnNWS0o1QklBMGlxNEdZYlpVbkVOVUpUSnR1bFRRT3BkVnFTZXV1Z2pNS0pXZnYvQUJRdzFVbkhGb2ZVcFRpOHhVNDRRQ2NvUE5XMStFYWhVWFhaMWhpK1J0cHRKUzB5MlBBMkJwWWVsdGQ0VHJOZmowME5tUGxzdDZQUVR6eTNUNlIwWWt4SE80aHFMYzNNM1MwMXBMeXlEY05KNCthanBjOU9VT3JtZ3FYemxTdVF0YlV4WHU3WG5VR2dTdTFzd09nSElSMzBoMUxJTGIrVXBWdGM5ZGJSNWJJM2tlNlI2ZkVsalcyS0VHb3NzdlptMlcwcUp1VktBQ29jR0tLYklnTG5KMEljM3lwOFI2K1hySFpNZXhyYlUzTXlpRm9Wc2hkaVQ4cnh5dHlkR1NyTWlreWdKTjFabXdzL084UXR2bERMa3VoMy9HRkVtbXJHWWJjRnYzaVFxMFZudEVvdUZxaGdxcjFBUzh0THo3S0F1WG0yVWhCV3ZRQkJ0NzE5ckg5SXNzelNxSlByUy9NVTZXUzYyUitNMjJHei93QklGeDV4VGUxZWp5akdCSFptVWM3c3NUalJVZzY5NENDQUFlWXZmeUVXTk1sNnNkcm9yNmpuRkxjcjRNRWNaS1YyS2hDUEVOL0VPVWRiMlZXaDFCMnRIT2REWTY4akhwZHA1aHNaT2xyYlFJVXNhWGhFSW10ckdMbEU3Z3VSbHFoaUdXYW43K3hvL0VkQS9NQnc5VGFQUmN0WFpmdUVCc3RCQUZraEpzQUJzTGNJOHZTVTQ5SlRBZWwxNVZqNEVjakZ2bHNaUzVhSHRNczhsM2lHbERMNlJuNnZCTExKTmNvMDlEbng0b3RQaG5wSjBKY1V0SVNGSXkyVU12VGdlQkhPS3JYWmhhSmxocDkwcVdTVnBYbUFMZ0JGd2VvK1kxaXpQVERXZFRFdUMrdEkvRUtmRWxJNm5hOFZmRUtDNjIyRlp2QlpZeTJCQkd4K0gxaTNPQzdLRmxSb3NtM0llMXNqZEx5MWE2V0JOd1BuR1RZa2RMMWRuM0ZDeEx5dExXMk52MGpVbTNGL2VGUVNvaEtnNWZRV0JGdVhDTW5ydHhXSnpNYmt1cUpQbVlyYVJWa2t5N3JIK0ZFNExtRHRjNndRc2JRcStrYUtSbUJnNWZPRkk5N1hlR3hwcWQvT0ZnMlNUeE1FaUJTVDNydVVIS21IcFZJQ3huVGRXMm9qbmJOaUR2ckhXRmdtNEF1ZVBXRFhJTDRKRnA1VFJUa1VVamJReFpaL0dkZnFSWlhPMVdiY1d3eVdHeUZaTXJaM0F5Z2JqUXhVQW9td1BBOG82bTdFQUM4REpzNU02UytRTk5QU0VKV1ZGVndUWS9sTUlDYjJ2ZTU0d3BJQUtocnc5MHdzTTdLWk1ya3A1aVpSWkNtbkV1WDNPaHZIb0VLNzFWZ0xwS1FVa213WGNYQUk4ci84RWVkbTBnblJGd2VLbzNMRE5WRTFobWxPZ3E3MURLVzNWWmJwQlRwYzh4cHIwTVpmeEdGcU1rYXZ3NmRYRTYzRUxObWxMRFJOeWtFWHZiVTI5UGxITExMUkxMYi9BTTBvZUlxekFES0xuckhWTU1yTHBLY2l5Q1Juekp1anBiZUV1dG9XTFRhMWthQVpySjRjaHI4ekdjbytEUmM2NVpLUHZ5MDJ3b1RUYUhXN0FLdWtrRXhEekZHdzg4MkVKWVMwMkFUbFM4dEFIb0REaWxGbFNSVDVOeHRWaitLRFluMDQrc1Zxc1Y1Y2g0S2cvVTNGNWlGaG1YQ01ubVNiSDBoc2NFL0F1V3B4K1dUQXdwUVZLUThsK2RRc1dPY1Rxd0VwdnFiazZDM09NWXhuV0ZWQ3NUakV0UFRFeFNKZDRvbFVxY0pTVXAwN3kzTTY2eE1ZMXI2YXJMcGthZXFiTW9EbmNjbUYyVzZlQXkzTmtqNW1LUTVvbnc2V01hbWowOG92ZlBzek5acWxKYklkRFM3NzN2MWhwUTZid3ErcHRzZG9TZGhwR2taZ2c2aTF0WWJoYXpmYmVFQ0U1T1JzUVFJQWdRRkJIc2xpbnFZWlN3OG9LekFxQ2s3RThVMjZjT25ySEJVcE5DV2xvc0FTazY1UitzU3MvUEpXMHBwaEpVOExFWmlidG5nYkFINFJXcXE3T1RMQ2xGeExLN2xLa3R0MnNvY0xxTjlmNlIwbXFwQTAvSlFaK1ZMYzVQZDBsYWxLc3Z3SkpKc0xmcEdRMXpLYXJNRkJ1bFNyZ3hvbUlxOC9ocXJvUUd1K1E4eGJNZERtQlBIWTc4SXptcHpLNStjZW0xSUNNNnRRTmhGYkJCeG0yK21YcytTTThNWXJ0SEZCanoxZ1FPTzhYTEtGQXZ6aGVwQXY4WWI0N1FzYldKdEJSWkFwSEs4T0pOdGZoRGFUcjV3cmZhRFRCWjFJTnlMNms2eDJzcjBGcmdia0VSd05rV1R2empyUmZTMnR0STZSMFRwTGxpQVFJRGFpWHQ3Wmh2YUVKRi82bUhNbGxKSlRmcHdNS1lZOGc2NnFKTWEzMlBVMmFyVW8reExPTm9ibFhQR0ZKdWJMR25wY0dNb2FhVVNMSXRmYm1ZM0Q3T2xNcTh0aWFaZGVwNzZLVzlMWlhYWFVGQUNnUVVaYjZxTjdqVG5lRnloR2ZFbGFDVTVZK1l1bWFGSllIVXBkNXAzTmJRSlNrRFNKRVlNYVMrQWpMcHViY1kwQkV1bExpTk5iMlB3aDVVdURNS3R2eCtBamtzY2VJeEZ5eTVKY3laU0Y0U1NsSXRZcUFLdmhITFVzRnk4NmxSVzBsV2RLZ0FSeEFCRWFNdG9Cei9hcmgwaHRwb0psRUtBdVVMQ3ZUUVFlOWV3dDdtdXp6Zmozc2RUTk0rMVVPek00VzFMN3EzaGRLUmUzUWtSNXZuR2lSbU56NTdqcEgwUG5wVk5naEpDVkpkS1cxY2lRY3Z6dEhsSDdSV0MyS0xWSld2MHBzTlNOV1Vydm1kZ3hNQVhVQjBWcWZNR0R1UGFSRVc3cG1ISzNPMElVZE5yeDBUakxyQVNYUW02dHJHT1RmanJFUElxNEhxRFRwZ0pndlNBTDhJRUw3NUNCQitjRnhNQ09KUjdMbEZvVExMQUNBcEFVcENyYTZlZThSOHlWS2NEaVhFcVE2TXFrbEFIaUE4TzN3K0VLSzF5ekRxL0NBdEJRQ1Nia24rZ0h6aVBtSGNxTXF0YitIV0JjZkZBcG1aZHNsS1FtV3A4MDNMMkxiaFM0N21ObFpnTkFOdENQUFdLQlQ1Qmg2blZGeGF5RWhHbkd5aHJmOUkycXV6RW5OeUxyVlZTSEpjTm52V1Vxc1ZDeDF2d3NRRGNheGk4M05wazhQTXk3TnM3OXlTQnVPY0l1WDBvdWFkUnFVcGVGL0JYQnJyQXZ2d2dRTHhhc3FVQWJrY0lBT3NBV2dlbnBFcGtVTEc4TFRxSWFTUU5UYzJpODAzQUUvTU1NT3ZPaEhmSkNrcFMyU1NDTklQZkdQYkJhYjZLazJrbXc0Mmp2WmJVUnFQakdoU0haaTZwd0JicjJXK3BLUUkwVERuWk5KdDVYSG1TNS93QzZiajRSRy9kOUtCK250bUpVcWpUbFNjU2lTbFhIMWZ5RFFlWjJqVXNJZGo4NVVPN1hVbGhDVCs3YjJIbXIra2JUUmNMeU1neWhDV2s2YUFKRmhGbHA3YW1TcE9WQWFCR1FKQkNoenY2OG83YlgxRVBKL3dBU280UzdNS05SbGhhR2tsNU83aEdaWjlUK2tYK2xVNW1WUmRwR3QrT3RvZFNnSlVGQzJ2empyWlVCNFlYS1hGSWhXK3pvVW16N1k1M01QSkE5cldPRmg5STVuVjNtV0NEcmUxNGViVVRQTzhnQVBsQ1d3eGF4ZFl2d1NZUzJuL0txVDAvU0RXZE5OU1FSQ1dWRHVySGlEOUlpenFPR29wU3BKV1JvVW9VZlJRdkdTL2FNcFltZXptcmtwOGNtODFOSjZBcnNUODF4cTA4VDdFYm5VTktId0YvMGlDeHhUR2E1SnpWT2YvWTFHU2RsbGNnVDRrbjBJaXhCOFVMZlo0QnFDczBybE83WkZqeHRFV2VjVEZibEhwR2JtWlNaUmtmWVdwbHhQSlNUWS9NUkR4elZjbGhTY2x5Q0Rnb0IyZ2JKQkF2QTQ4b09KT1BWazFOS1ZOc3RrSEkya3JTTDdIV09PZVhaS2xjaC9lQkFpVTN5QzEwVXV0T3FibDU5U1FteUpWeXliQzM3Tlg5WXhkOVNsTENTb2xLQlpJSjJFQ0JDMkhENlJvanJBdDg0RUNPZlpBQUlNQ0JBZ285SEJvSGlBUGxIcXpzMUtKekErSG41aEdad3lnUVRmZklTa2ZKSWdRSXNSNnNUa0xlQ3lnckNXZHR0ZjdSTFVxb2p1c3BhSnltdzhYOW9FQ0lsSjBRb3Bra21wb0daUGNIWTY5NS9hSEJWMGxvcjluT1lmei8yZ1FJclNtN0dLQ29lKy83SUI5bk5sYmp2UDdRNmNRZ2hLaEtrRzQvZS93Qm9FQ0FiQzJvRGVKUjdZRkdVUGcwQTczL3hoWnhRRzVoeFhzWkpOaCsxNmY2WUVDQWJDVVVLL3dBVWdxMWt6c2Yzdi9qQ1Y0b0RhVWoyTW00UDczcC9wZ1FJNnp0aUk2Y3hVQ3lVZXhib1YrKzZXL2hqbXFlSjB2T1N0NUt3U2JmdGR4c2VFQ0JCeGt3WENKNU83Znd3MzJqVGIwdXozUW5KZG1aV2tIUUxLYktQcmx2NnhtbHJ3SUVPay9sUkVWUVZvQWdRSUFNTXdCQWdSMXM0LzlrPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvTVRlcmVzYS5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC8vZ0JaUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPa2R2WkdaeVpYbExibVZzYkdWeUxVbHpZV0ZqVG1WM2RHOXVMVEUyT0RrdWFuQm4vK0lNV0VsRFExOVFVazlHU1V4RkFBRUJBQUFNU0V4cGJtOENFQUFBYlc1MGNsSkhRaUJZV1ZvZ0I4NEFBZ0FKQUFZQU1RQUFZV056Y0UxVFJsUUFBQUFBU1VWRElITlNSMElBQUFBQUFBQUFBQUFBQUFBQUFQYldBQUVBQUFBQTB5MUlVQ0FnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUlkzQnlkQUFBQVZBQUFBQXpaR1Z6WXdBQUFZUUFBQUJzZDNSd2RBQUFBZkFBQUFBVVltdHdkQUFBQWdRQUFBQVVjbGhaV2dBQUFoZ0FBQUFVWjFoWldnQUFBaXdBQUFBVVlsaFpXZ0FBQWtBQUFBQVVaRzF1WkFBQUFsUUFBQUJ3Wkcxa1pBQUFBc1FBQUFDSWRuVmxaQUFBQTB3QUFBQ0dkbWxsZHdBQUE5UUFBQUFrYkhWdGFRQUFBL2dBQUFBVWJXVmhjd0FBQkF3QUFBQWtkR1ZqYUFBQUJEQUFBQUFNY2xSU1F3QUFCRHdBQUFnTVoxUlNRd0FBQkR3QUFBZ01ZbFJTUXdBQUJEd0FBQWdNZEdWNGRBQUFBQUJEYjNCNWNtbG5hSFFnS0dNcElERTVPVGdnU0dWM2JHVjBkQzFRWVdOcllYSmtJRU52YlhCaGJua0FBR1JsYzJNQUFBQUFBQUFBRW5OU1IwSWdTVVZETmpFNU5qWXRNaTR4QUFBQUFBQUFBQUFBQUFBU2MxSkhRaUJKUlVNMk1UazJOaTB5TGpFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRmhaV2lBQUFBQUFBQUR6VVFBQkFBQUFBUmJNV0ZsYUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFCWVdWb2dBQUFBQUFBQWI2SUFBRGoxQUFBRGtGaFpXaUFBQUFBQUFBQmltUUFBdDRVQUFCamFXRmxhSUFBQUFBQUFBQ1NnQUFBUGhBQUF0czlrWlhOakFBQUFBQUFBQUJaSlJVTWdhSFIwY0RvdkwzZDNkeTVwWldNdVkyZ0FBQUFBQUFBQUFBQUFBQlpKUlVNZ2FIUjBjRG92TDNkM2R5NXBaV011WTJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVpHVnpZd0FBQUFBQUFBQXVTVVZESURZeE9UWTJMVEl1TVNCRVpXWmhkV3gwSUZKSFFpQmpiMnh2ZFhJZ2MzQmhZMlVnTFNCelVrZENBQUFBQUFBQUFBQUFBQUF1U1VWRElEWXhPVFkyTFRJdU1TQkVaV1poZFd4MElGSkhRaUJqYjJ4dmRYSWdjM0JoWTJVZ0xTQnpVa2RDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHUmxjMk1BQUFBQUFBQUFMRkpsWm1WeVpXNWpaU0JXYVdWM2FXNW5JRU52Ym1ScGRHbHZiaUJwYmlCSlJVTTJNVGsyTmkweUxqRUFBQUFBQUFBQUFBQUFBQ3hTWldabGNtVnVZMlVnVm1sbGQybHVaeUJEYjI1a2FYUnBiMjRnYVc0Z1NVVkROakU1TmpZdE1pNHhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjJhV1YzQUFBQUFBQVRwUDRBRkY4dUFCRFBGQUFEN2N3QUJCTUxBQU5jbmdBQUFBRllXVm9nQUFBQUFBQk1DVllBVUFBQUFGY2Y1MjFsWVhNQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLUEFBQUFBbk5wWnlBQUFBQUFRMUpVSUdOMWNuWUFBQUFBQUFBRUFBQUFBQVVBQ2dBUEFCUUFHUUFlQUNNQUtBQXRBRElBTndBN0FFQUFSUUJLQUU4QVZBQlpBRjRBWXdCb0FHMEFjZ0IzQUh3QWdRQ0dBSXNBa0FDVkFKb0Fud0NrQUtrQXJnQ3lBTGNBdkFEQkFNWUF5d0RRQU5VQTJ3RGdBT1VBNndEd0FQWUErd0VCQVFjQkRRRVRBUmtCSHdFbEFTc0JNZ0U0QVQ0QlJRRk1BVklCV1FGZ0FXY0JiZ0YxQVh3Qmd3R0xBWklCbWdHaEFha0JzUUc1QWNFQnlRSFJBZGtCNFFIcEFmSUIrZ0lEQWd3Q0ZBSWRBaVlDTHdJNEFrRUNTd0pVQWwwQ1p3SnhBbm9DaEFLT0FwZ0NvZ0tzQXJZQ3dRTExBdFVDNEFMckF2VURBQU1MQXhZRElRTXRBemdEUXdOUEExb0RaZ055QTM0RGlnT1dBNklEcmdPNkE4Y0Qwd1BnQSt3RCtRUUdCQk1FSUFRdEJEc0VTQVJWQkdNRWNRUitCSXdFbWdTb0JMWUV4QVRUQk9FRThBVCtCUTBGSEFVckJUb0ZTUVZZQldjRmR3V0dCWllGcGdXMUJjVUYxUVhsQmZZR0JnWVdCaWNHTndaSUJsa0dhZ1o3Qm93R25RYXZCc0FHMFFiakJ2VUhCd2NaQnlzSFBRZFBCMkVIZEFlR0I1a0hyQWUvQjlJSDVRZjRDQXNJSHdneUNFWUlXZ2h1Q0lJSWxnaXFDTDRJMGdqbkNQc0pFQWtsQ1RvSlR3bGtDWGtKandta0Nib0p6d25sQ2ZzS0VRb25DajBLVkFwcUNvRUttQXF1Q3NVSzNBcnpDd3NMSWdzNUMxRUxhUXVBQzVnTHNBdklDK0VMK1F3U0RDb01Rd3hjREhVTWpneW5ETUFNMlF6ekRRME5KZzFBRFZvTmRBMk9EYWtOd3czZURmZ09FdzR1RGtrT1pBNS9EcHNPdGc3U0R1NFBDUThsRDBFUFhnOTZENVlQc3cvUEQrd1FDUkFtRUVNUVlSQitFSnNRdVJEWEVQVVJFeEV4RVU4UmJSR01FYW9SeVJIb0VnY1NKaEpGRW1RU2hCS2pFc01TNHhNREV5TVRReE5qRTRNVHBCUEZFK1VVQmhRbkZFa1VhaFNMRkswVXpoVHdGUklWTkJWV0ZYZ1ZteFc5RmVBV0F4WW1Ga2tXYkJhUEZySVcxaGI2RngwWFFSZGxGNGtYcmhmU0YvY1lHeGhBR0dVWWloaXZHTlVZK2hrZ0dVVVpheG1SR2JjWjNSb0VHaW9hVVJwM0dwNGF4UnJzR3hRYk94dGpHNG9ic2h2YUhBSWNLaHhTSEhzY294ek1IUFVkSGgxSEhYQWRtUjNESGV3ZUZoNUFIbW9lbEI2K0h1a2ZFeDgrSDJrZmxCKy9IK29nRlNCQklHd2dtQ0RFSVBBaEhDRklJWFVob1NIT0lmc2lKeUpWSW9JaXJ5TGRJd29qT0NObUk1UWp3aVB3SkI4a1RTUjhKS3NrMmlVSkpUZ2xhQ1dYSmNjbDl5WW5KbGNtaHlhM0p1Z25HQ2RKSjNvbnF5ZmNLQTBvUHloeEtLSW8xQ2tHS1RncGF5bWRLZEFxQWlvMUttZ3FteXJQS3dJck5pdHBLNTByMFN3RkxEa3NiaXlpTE5jdERDMUJMWFl0cXkzaExoWXVUQzZDTHJjdTdpOGtMMW92a1MvSEwvNHdOVEJzTUtRdzJ6RVNNVW94Z2pHNk1mSXlLakpqTXBzeTFETU5NMFl6ZnpPNE0vRTBLelJsTko0MDJEVVROVTAxaHpYQ05mMDJOelp5TnE0MjZUY2tOMkEzbkRmWE9CUTRVRGlNT01nNUJUbENPWDg1dkRuNU9qWTZkRHF5T3U4N0xUdHJPNm83NkR3blBHVThwRHpqUFNJOVlUMmhQZUErSUQ1Z1BxQSs0RDhoUDJFL29qL2lRQ05BWkVDbVFPZEJLVUZxUWF4QjdrSXdRbkpDdFVMM1F6cERmVVBBUkFORVIwU0tSTTVGRWtWVlJacEYza1lpUm1kR3EwYndSelZIZTBmQVNBVklTMGlSU05kSkhVbGpTYWxKOEVvM1NuMUt4RXNNUzFOTG1rdmlUQ3BNY2t5NlRRSk5TazJUVGR4T0pVNXVUcmRQQUU5SlQ1TlAzVkFuVUhGUXUxRUdVVkJSbTFIbVVqRlNmRkxIVXhOVFgxT3FVL1pVUWxTUFZOdFZLRlYxVmNKV0QxWmNWcWxXOTFkRVY1Slg0Rmd2V0gxWXkxa2FXV2xadUZvSFdsWmFwbHIxVzBWYmxWdmxYRFZjaGx6V1hTZGRlRjNKWGhwZWJGNjlYdzlmWVYrellBVmdWMkNxWVB4aFQyR2lZZlZpU1dLY1l2QmpRMk9YWSt0a1FHU1VaT2xsUFdXU1plZG1QV2FTWnVoblBXZVRaK2xvUDJpV2FPeHBRMm1hYWZGcVNHcWZhdmRyVDJ1bmEvOXNWMnl2YlFodFlHMjViaEp1YTI3RWJ4NXZlRy9SY0N0d2huRGdjVHB4bFhId2NrdHlwbk1CYzExenVIUVVkSEIwekhVb2RZVjE0WFkrZHB0MitIZFdkN040RVhodWVNeDVLbm1KZWVkNlJucWxld1I3WTN2Q2ZDRjhnWHpoZlVGOW9YNEJmbUord244amY0Ui81WUJIZ0tpQkNvRnJnYzJDTUlLU2d2U0RWNE82aEIyRWdJVGpoVWVGcTRZT2huS0cxNGM3aDUrSUJJaHBpTTZKTTRtWmlmNktaSXJLaXpDTGxvdjhqR09NeW8weGpaaU4vNDVtanM2UE5vK2VrQWFRYnBEV2tUK1JxSklSa25xUzQ1Tk5rN2FVSUpTS2xQU1ZYNVhKbGpTV241Y0tsM1dYNEpoTW1MaVpKSm1RbWZ5YWFKclZtMEticjV3Y25JbWM5NTFrbmRLZVFKNnVueDJmaTUvNm9HbWcyS0ZIb2JhaUpxS1dvd2FqZHFQbXBGYWt4NlU0cGFtbUdxYUxwdjJuYnFmZ3FGS294S2szcWFtcUhLcVBxd0tyZGF2cHJGeXMwSzFFcmJpdUxhNmhyeGF2aTdBQXNIV3c2ckZnc2RheVM3TENzeml6cnJRbHRKeTFFN1dLdGdHMmViYnd0MmkzNExoWnVORzVTcm5DdWp1NnRic3V1NmU4SWJ5YnZSVzlqNzRLdm9TKy83OTZ2L1hBY01Ec3dXZkI0OEpmd3R2RFdNUFV4RkhFenNWTHhjakdSc2JEeDBISHY4Zzl5THpKT3NtNXlqakt0OHMyeTdiTU5jeTF6VFhOdGM0MnpyYlBOOCs0MERuUXV0RTgwYjdTUDlMQjAwVFR4dFJKMU12VlR0WFIxbFhXMk5kYzErRFlaTmpvMld6WjhkcDIydnZiZ053RjNJcmRFTjJXM2h6ZW90OHAzNi9nTnVDOTRVVGh6T0pUNHR2alkrUHI1SFBrL09XRTVnM21sdWNmNTZub011aTg2VWJwME9wYjZ1WHJjT3Y3N0lidEVlMmM3aWp1dE85QTc4endXUERsOFhMeC8vS004eG56cC9RMDlNTDFVUFhlOW0zMisvZUsrQm40cVBrNCtjZjZWL3JuKzNmOEIveVkvU245dXY1TC90ei9iZi8vLzlzQVF3QUdCQVVHQlFRR0JnVUdCd2NHQ0FvUUNnb0pDUW9VRGc4TUVCY1VHQmdYRkJZV0doMGxIeG9iSXh3V0ZpQXNJQ01tSnlrcUtSa2ZMVEF0S0RBbEtDa28vOXNBUXdFSEJ3Y0tDQW9UQ2dvVEtCb1dHaWdvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnby84QUFFUWdCTGdEY0F3RVJBQUlSQVFNUkFmL0VBQndBQUFJREFRRUJBUUFBQUFBQUFBQUFBQVFGQWdNR0J3RUFDUC9FQUVFUUFBSUJBZ1FEQndJRkJBRURBd0lIQUFFQ0VRTWhBQVFTTVFWQlVRWVRJbUZ4Z1pHaDhCUWpNckhCUXRIaDhWSUhGV0lrY29Jem9oWWxRMFNTMHVML3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUJBZ01BQkFVRy84UUFMUkVBQWdJQ0FnSUNBZ0lCQXdVQkFBQUFBQUVDRVFNaEVqRUVRU0pSRXpKQ1lYRWprYkVGRklHaDBmRC8yZ0FNQXdFQUFoRURFUUEvQU9GNWlqVUdZaFF6TWFyZUxlUVNUNXg2K2VGRzRIdEs3aUFBS1pKR21BQno1OG9nWUFENnF3QkVNVFVLbnpBdkVramNkTGRjWXhRNkVWR0FZNk5VblZ6NmJlbU1ZSXk2bGtBTTk0VEN3WW04ei9rNEpqMnBTUkZwQ3U2SFVwSU40TjlNVzg3K1pHTVlxVHV5Q0VaMExXTTdlbzh0OFl4ZTZwV2VFY0dEQVdvWUF2Zjcra1l3ME95dXFsS29XSnFIU29NU29JbjE5ZWZMR0x5NkkxS1pwdURjZ2srSGNramRldk00eE11M2FucTFBaElNQy9wNi93QWpHTVZWYU5Pb05XbFFDU0ZKOVI4N2pBZWtEVDB5eE1wVWN5bElNc1hrN2p6dmYxeExtUEdEWDZGMUhKWmdKVktvekFxb0pDU3UvUDRHS1hFcXNjK0FSUTRkbWFpczFNRmJFaTBXNWlmNUdKM0FuREVTemZDc3hTZ3NXSkIxRFNkeHNQM0l3MFp3Ym9lVVpMb1dkeXBnVkdtUVRDQXlMd0lQemluTGpwQWpwVXl6TFVnbFJUcFNvb0lJTzhTZVU4amV4NWdZMTNzWk1yYVdJbFUxTnliWUg5anZnbzFFcXlBSzBCV0ZvSnFFUU9vOXliK2ZuZ2twa0dSQlhndllNQUQ5YlJ1TDRLRkwxMTJGUWFGTXFIQ2pZRGw3SDk4WmpSN0pyVllWWDFqVUNBcE0vcDI5N2JZRlhvYVhSVWxYdkFSVU9vYVRvS2tpRHkrcHh1RmJKbHROeXRDUkpiVlBxSkp1VGFOdnBpYjdNV21RWGRIN3pWdmFJOHIzdGhqRlFZaHBPcGJhdkVJdGE4SDMrTVlrZlplanFUeFVWWXlSZW9peDhtL3JqRlFYTTEwTmVzTklQNXAxS0ovVlBQenNEakV1WlozbE9tNGZ4VkRVSGhIVW5sUHBFK1U0dzNKRkJjMWFpK0lxeTZWWWl3M0JNLzM1UmpHNUlzSDZpV1ZnU2JxdE9BYmt5WjlveGdOMnlPcGRVQm1SVkFMU1p0SG1mTDc1NEtsUkJhYVZGVmRlc3laV0NaZzdEbk54dGpBYnNzeTFNdlJOUXlRSlk3SFZGL2kyTUFrS3JYWUxxWGJZZzI1L01FNEJqeWl6YXRJS2hqRitreUorWjljWU5zaFVKL1JZRFZzdzlCOU52bkJOSHNrd09sa2J4SVloUTBTZG9NZjd3SDBQZGJQRnAxblZGcDB4ZVNQTWtDRGY5dksrSi9GZXg0eGxQMGJIZ05Hanc4aWxuYUNHcTZNZ016REgvanlPOFRjN3h5eHk1YWwwem9oR1VQUnFNcnhSQmwzRmZoNjFPOFVrb1g4Q3hzQ1BJQXlmWEhQT0hMcC8renFnNVI3QStPcFR6MllxVmVIclNEc0FyMHhwcFV4QmdSdVppOXhjNGJEYVd5T1RjdENLclR6T1hBTmNkNG84ZmlZRWZIbmpwaEpDU0ZsWlExR2YwRlYxTllFeHNZai9BT1U4c1dVdGlQb1RGU2F0MnB3b0JVeWJXSjJHS3AyS3VpeE5CWTZXMERvdDQ1azlkNHdib3pUWjZzQjNwbldycnlJRnBpRzM5Y2E3TWxYWkdzaWhEM1pMc1FIc0RzWjJIdmhvZ2xHd2RTWnFsU1kzQU93dGFmcjhrWWRBaEdtUzFrbVFBTzdZa1NTSUhYOXZuQVl6TDZDcG9CTHJOd3dBM2t6djE4OEtMTG9uVVJwL0xZUUNMRTJNYmZ2KzJNVExxVmVvUU5SMEVzYnFBU0k1ZmZUQ0dLMXFoSFlOcVl1dktiV24rMkNZK3BtbWdJRWdFekJVV3hobEd0Q1hOUDhBbTVsV1VHS3JBbnlreDA1R1A5WWFqbXBFKzhhb25qaldKVmpCdUoySHo1ek9BR2p5clZJaGxJQVZ0VmpHNTJuMk1EMXdEQkI4ZElFRzRsbW1wcUU4d2JBOUQ1SEdNVk1TYUxTSmIrZ0VtWVBJaVBMYjE2WXdTOW1Vb1VGUlhNUmR0N25hUFRHTWZVYWlFQm5wbGdmRXhGcHRmYjArbnRqR0NLVmRUVFVVbEpiU1lLTjc5TFlER2lSYndlRUM1SDlYN0FiZjR0NnIzN0dwSDJYb1ZjeTYwcVM2M1pnZkNsNzh2Myt4aFhKUjdZOGNiYnRIUnV5bi9UZHM5bHFOYk0xV1ozQ3VBRHBXSU55ZWYrZVdPTHlQT1MxRTdzZml4a3RtbmZzWndYSUVpdlNKY1JjMFNRT1V6ZVA4NDQzNUVwZE1zc2F4OUkrZks1VElJejBhTDBnNFVOVlpDS2ppZjBKUDZSZTU4eDdHTTVTRFBvVTFxMVhOVXFpMGN0U3AwUTdPNFlyU3BoTDJMRWprREp2TTlZeFdNV0xLUW1yOFJ5bFVGNnkxa1F0Tk5paEFKNWlSRWRkOFVVTDBtYzhwcGJTRXVmTkduK2ZscTFXblRCa01USmpyUHJiRjRScFVKSjN1d0NqV05YT2FhcWQ5U0FCQlVNR01jaC81RzNVV3c3MXNXSWJUNElYcHE5REo1anVwMU1WQVlqY1R5bXd4bGxINHIwUW84UFJIRDBsSldsTE1haWFTSUhuNzRwenRtNGdWZW05SU1qTFJwa25WcE1XOWVtR2IycUZrcUI3bzRZNlBCdkt6UExma1BqRkUySXV3Y04zUUhlQ1dWaVQvQUIvSHpncHNMUEpwdlZxTUF3VWsvcUVnY2dRQ09VM0hyZzlrNVBSS2lWVmZ5d3hhQ1FRSkFrOHNFVk50MHlSckkxZVdxS3JBbGlRdTRpeHQ5N1lESFNYMEVVUnJwSXJ5Q0Z2cDViMjlMakNqVXE2S2lOWDZsTEJSQWdBUmFmOEFXTVJQYVNycHZZVDRmVEdHNVAySWMxSXJWU0pKNzFway93Qk9venRjN2UzdmcyYzVGUlZFNmdGTUU4Z1RBdEo1YjRCZ2xHUmtVc0F3bVZZclp1Yyt3Sk1lZm5nbVBWcjk0b3BnTXpkWkVDOGZ6MHhqRmxKMVlBTy81WUp0UElmcTg1dmZsZ01LN0pVd0gyQUFCS3NJRnI4K2x6dmdCYW84TkhVQ0YvcEovcEh6L0dNekJPUkg2bldCSWtpTitRUFRDU3ZWTWFLdXhsdzNnZWI0cFhWTXZTclZGYUFTTEtKdmM4cHdtYk5DQ09qSGdjNG5aT3dIL1Rwc2pVb1p2aTljUktNcU1kSW01NStYemp4czNtZWtqdng0MUJXZEh5OUhJNUhMcmw4bzlRdG9Db3FBd0lCdVl0Zm5qai9iYUtXSk9LSm1jMHIxcTcxTXZUcGhkSzAwSlVXTUdCdWQrcDlNV2c2UnJYUmxlMCtYRlBMdlVpb0dOd2pFeVR6TEVic2VnMjg4ZEdPYlhRcnZvdytibzFLbFNrdFNrd3FLWlpxalNmUURrQmpxaS9qWkdTR1BFaS9GVnA5NW5zelZyWmRWb3JUelRsdENnQ1NvSGhBK3BqQ1JuWFJvcU1sVmJNdHhiSnRsbXIwcUZSbHl4YTdYOE1pOEhyOUxISFZHYU9mTmg0cXdMc3psMmRtMVZLTUpIZ2szSm5udUlNUWI0TThrYXFnZVBCeTB6cGZEdUgwVzRjUm1jM1RTdXZpVmU5RW01STBFRGFCY2RaeHk4cVpmangwQmNTb3UxR3JXVjZUMXRtVnhBWUV3VDVqWWk4V3haVHZhRnZSbXVKVVhGTWFZS09xandURnoxTzNQSFFueTZacFI1SkdjekFRRW51U1NTZjZ0aHlHL25peTE3SWNXZ0RQQmlBd1FoWE9tQWRySERSYXNSOGdVRjJGWFRxWHhrRWNvTzhqNCtUaDdYbzFQMkdKSlJtaUdNa2d4Ynk2MjVZRENvcXkxNmFHTHNBYk1MU1FOdHZ1MkZzWkk5TFV3emgxR2dndElBSjh0dWMyeGdrcWRJTUZWWEJZb0pzUEVlZjArTVlYZ3ZvbFRvbXJyY0xvSmE2bG9nNFMyRGgvUWpxbnVjelhxdXFIOHg1MUh4ZlBJbTIzbU9aeFE1U2IwVksrQmU3OE9raWJjL0Qxd0Fud2FuVkRYZFdYYVpKSzc3SHpBK1NkempHSTBNclRxYWhUVVNvSE9JTWVHeCsvakdNRVVzdTlNTVRvTEM4ZWMzSDh6L25DdGhTTHhTN3hVY3NBNFk2aVJGd0NENzNJL3ZqV1BPT3l5b1dnYXdJRUZTRnQ1bVBnK3M0VnR0b1dtTk96M0RqbmE2cWFidEk4VENUQS85dlUydDU0am1uV2kyT0IyVHN6a3Z3T1NlblJwaEtxd0hZQUVVeGVWSFh6UFhIajVKU2NqMU1TU1ZGK2I0aFdwNTNMOTFVTlRNRUFLSEdvbFFEYzhsNjRLeHA3Wm1XTng2dFJxcnF6RHduNnhTWDlVQTNuK01Cd1NGSEhEdUpVYTJXcDVuTlZxMWdybFhJVWpsZTg4dGdNSzROOUJWR1Q0NzJuVE1abHprS05XdS82S2RSaENJdlJCN2I0dmp3eXEySzVtY3pONllxMTE3ek11VjhLQm1hSTNNWXRHbHBoNHQ5Rk5iaDNFQXdxVjh0bXN2UWM2Z1dRZ1FCRXpOaGd4a3JvRW8zc0RxNXBSU0NWWGVwcEIwenpZK3Z0aDBudXlNM1QwRTUzSnZTeW1Uek9UbWhrKzZoVFZqWG1IdkpWQnNvUFBvTjc0MEp1NlpwU3JvckNzb0ttV1ZWV1Nwc3BNaVJmYjYzd1crU3NaSkpVZ3NDdm11SDFrcU1XYkxLTlRGeVNxa25jZjhiZ1R2TXpoVTlBVWJXenpNMG1yb3dyMGdFUXF6MDJBa1FHOFhtT2Z2Z3BoVGFSbnM5bGFCV28vY2o5VUtkTzQyMjYzTnY3NHZHVkM5OWkvTzVJakxxZkFFcHdTWmtSMG5Gb3RFWkpJVmtvZ1lGS2FuZEQ1ejkyeFZVS1ZRcXMvZGFkQmFBUVpLbUJ0OThvd2JEU1BxYmE2dmRucFlONXliMnZNZnZqR2VsWk5ZVW94RGlSQjVraUlQODR4TG5JbTdNUWxnVUlrYy84QWY5OFlQTmxnZlNBb1JhZ0ZoQ0F3QnNNQ2tVRldhUmU5cjZBVWhtQWtUWUVuL3dEcmduRFlSbEtldW40UTBjaW91dzNnbjNrV3hqV2VvbFBRRDNqQlFRVFlpOWhCNWMvZkdvTm50SFFHY2xtbVovU0lBSnZFY3g1ZWNZd1NPWHFrbVhWdElFQWt3RGVlVnV2MXdyQ2kxU1NqRUIvK1VxT3YraGdEODJVclNVbGhKUkFRSm1RTHlZbjc5Y0M2WnViN1NOLy9BTlBxRFZVYzBocXJOQ0pBZzA3anhXM2lUOGpwanovSmx2WjIrT3VXenArY3JaYmhYQzFvNU5RYWpnSlREdDRVTUU2bTlOL1U0NFY4dWpyYWFNNjFVclVvWmZMbFhyTW41ajZpeFlRVEpNYmI3NHVyaWhiOWxXZDRvTWdBV2JLWmdGRmJSVWtFU0NOV3duYXc4dVdOeHRhN0ZjNkFNeTJXNHJTcHM0Y1ZHVUg5ZWtBZ3lUcFA3SEJVZUsyTXZtQlAyYnJadk9NdVRMdlVad0ZDVDRmY255LzBNVVdaVlROTERJMFhDT0haM2hkWlJTek5YVlRkVlptME9OWC9BQjgxc1QxTWVtSVRtc2l1STBNVFhzMTlkVjQ5d3pNMEs5R3BYekxOcVE2Q2pDQkYydnBBSXRIVEhQVGpOTnNmVVZSeWZ0RndQT2NPcDBlL0ttdFVsVUZFRnpNV2xqMDYrV1BUeDVJdlNPVE5pZW5FeUJ6dWFGRE5VbGZRYTgwaWdBMUVLQzBBN2pibHZpcWh4MmlEZDZZL3A1bGNyVlY2dXFvcFFDVUFod1FMU1RieitlV0VjVzlJZmxUR2xYaVl5cFdwUXpHV2NFZ2xhWjJCbVF4RzlpUnp2R0p2RzEyVi9JdWtIWlROMCtJVkhwcHFlbnBsR2VXSUlCQlVuekh4aEpmRFpsOG5RcTQraTViTDk3bGxRNWVxWTBNYm80c3l4NllyamFrckJLUEJpV3BUTE5WTkphaXpMTUZJaUJ5ZzJ0ZkZreWJWb0F6TkZKS0JkeUNCQkFKNmp5eGRTcFdpWFRBRWZTRy9RSmxTR3NJZzdZb25ZU2RPbnFaWHAyVmdUSGxHd1BUQk42bytYWldJWUM3RWJIcDlNWVQ4YUlNSUN0ckZ4Y2dScUk1ZXVNYmdqNm5UcGxZZHhUS21JTGo1eHJIUXZyUE5hdmNBR3NRQ0NSenVmTGFmZkdPQWxSckZhUytBaW9USUF2ZU9XTVpLd3ROSUJDczJpb0pNSGMzdWZLZjQ2WXc5VVJNc2dVZ0I3cnRHM0w1d0d3MGVva2tBd0xDOENaSEsrMytzSzJZc1VLMUF3QVF4TXNBQlBPRC9BR3RlZWdPTU00MTdLNmJTOU5pUUFiRVhqcDkrdUExN0dpdXpkZGlNL1R5SXBrS1UwMHFvRElSekd3SHhqei9JaTMwanJ4eXBVaDdVNHY4QWlDOVdwbGkxS2tnS3JhNG1BQWQrbnhpQ2cwdElzc2piMkRaempLME1zY3RsTlJlcThPNWlJQW45OFBISEpPMmJuRnVqTFp6T0R2cVZObU5SbWdFc2VWNy9BQjhZNklwY1c2Nkp1UzVVZE83RjhEVTVXbTlTb1dKdGJ3Z2JkTWVkbXl1MmVqaGdrck5wVXlncFpYdTZDdlRKNXJJdUQxanp2amplUy9aVnB2c29xY0I3eFdmTlVXSWhUSU1CU09YcGdySlVkQlRTZENiTjVUTVpLcldwNUh2d0M0aXFTZE54c1FiOU1XaEpQc1A0MDFaa2VPVnM5VDRmVVd0UmxZQWFxN1RON1JjM0pIK3NkZUJ4dHRITmtnNm96SER1QW94eTNlVWlkY3I0REoydWZJOWNYbm1vaGo4ZHRiR2VZNEkxUEwxQVZZTDNsbGlTYmN2TG42NG5IeUhaMFM4YTQwWW5QVXN4d3dtV1ZxTEFhSEhMZjUzMng2RWFtZVpraThSZHdqalZYSjZTaGFtSWd3Yk1SeW4yK2NESmlUVkNLYnV4bFY0NHZFZTh5NVVVNmxZaGdDWTFNT2g2a1FQbkVsRGgwUDhBa2Nuc0xvNWdKbWFOSE1aWXFLczkyOUkyY3pCZzhpT21NMkdMYmUwRGNZeVNBRnFUa0k0QkJpLzMrMThOR2V3empSbGFpTlRWd0dFcTBpKysxOGRhMVJDNjBFMFNCVkFZU05NNkkzbWIvZlh5d2JHQ21iVlI4WGlLcWJpMDlmakdCMkMxQ3dWZjBXQUZ4K3JjL2ZyZ2pGNmR5VkhlRlZNQUQ4b0dSR0JZTE05bW1wL2lhaWtUTlVpWWdtWm5mMUozeGpnUHFjbW1DMTRpSU85OTRtZVEzZzJ4Z3hWQjZWRDNLTmZYSWdFeE1qZitjSTVVNm9aa3FqNlpsb3NmNnR6MFB2Z3Jld2xaZlM4MVZndVNTUzRnR0p0NlkxR3Nwb2xtQkxTR1lHUGoxNjR3N21td2xHREZOSU1LTEVqN1ArOEI5RFJvZThCUjZvcFVrWUt6c1Fwa3hkaWY3ZmM0NXBmSHNxblZVTytKUCtIUkJUMW9qQVVwa050Ym9lazlJSTg4UlZ1UjBTK01kaUhPZVBNT1dkMTFId3dBQnQ2eGk2MHRrK043UVJsOHUyWXpPVzBhbFdtcWw5U3g5bisySnlrb0pyN0tZOGZKMmQ2N0pwM09WcG9GWXNSSmdpV01DVDYyeDRma081T2oxOGFxSnQ4bTZsU0hVSFlqcGpuUkhKZm9PdG9JMGlNTmJxaUc3c0R6bVV5OWFrUTlCWE84YUpJNllISmxvVGtuMllIdE53VVZLZWhZZUJBWFJwaVJhM1gvQUJpdUhLMWRuV3FrTCtFOW4zSnBhUW9FejA1YkR6OC9YRHl6V1BYR0pMakhDMnk5TjFZa2liYVNSSjVld3dJU1pydFdjdTdjWkI2SlVxQjNVeWZEc2VSK21QWDhiSmJQSjh1T3RuT3F1Y09RenBDelVRUXdRdElCTzg5ZjR4Nk9wSGt5ZEErZXpPdW94eTdFb3BrYVJFYzQ5UVFiNFpKTHNSemw2TmYyUzR2bnVJMThya1hJcVZxbFZhTk1oUklKSW5sYllZNXNxbzZzTTNQczFIRTJRMXMxbHFiL0FJbkxyckNQZFM4RWpVTFc4OXRzU2l1V3pvbjJaVE1VaUthbVVhV1liek8xOGRNWGRNakxzRGR0TDY5UUtnUmNiZTNyaXRpTjdJYXBRLzhBTlZ0TmpNL1l3UTlFMkNsam9qU0J1MEEyNnllbjdZSEluK1QrajUwcVcwTDNnamZXby8zNjQxbEtFR2NxZC9tS2trRU1TRGE1TS9XZVh2Z25EUmJTcUFhYWpBS2l3V2k0dE56NWJpMkNFOUNsQXZoMEZCckt0QTJOejV6djZZV2doSGRnTlVkZFJEUU5oekYvM0h6T01ZckN3bEJxWldIblV0d1R2TjhhekZ0Q2tqRkEwdlVlMXBNa3g3NGxrZTdIaEJTZXpVOE40Qmw0QjRpYWxJc0VidXFWUFcwRnh2ZUJmbDlNYzhzai9pZHVQREZMWnY4QXMvd0hKVTY2NWpoK1JlZ1ZRMGtxWmdRUVNDQ1lIcnlIeGpseVpXK3kvQ0syVmRvK0JwUXlGSlZwajhOU0doSEU2cWpra1g2RGMrL1FZT09hbHRCY2VUTUx4WlZTb0dobVNZSmFZZ0RwL09PbGRFWGNYb0o0RG5EVzRscXFFdzZxVy84QXVFbjBHSmVTNml5L2p0M3M3dndNMDZTVUdLeFVXbUpDM09xQjliNDhXVHRzOVR0YU5UazZqRmZHMGpicVJpWFJMSXZwQmpWdE02V255SXhwU1NkTmtlTjlrRG1DVkRNaFVSTnlJT0YwSGd1a0FaMTZOVFdzRGtMaS90UFBESjB0RjRSa2tnWWhTcFpMUVRCdkpGclNPZlhDTDdaVy9zejNHS2xLdTlSM2NzZ0lJSUpDKzE5c1dqM3BhR1hWSE8rMWVXR2J5OWZ1MTFLQUdMR1Q0UVp4NkhqejR1MmMva1E1eHBJNHAya3BKbCtMdFRRbHdGR3JsZm1lblRIdXg2djdQbk15cVZBT1VxS2dOL0hxSWplMXBIMzF3WDBUajdScmV4MmF5K1M0dFNhblNiTU83YUtlbHJna0UrM05lV09mS3JXanB4VkZHczRoV28wR3FVU1BFVjFPWUFra0dkdHQ5c1RoR3RGNXlTZGlOQ0syVkJVU0RWblZGdlh5eGFPdEUzdll1ek5KaEpSWEY3NlZ0NzRvbUkxZXlWQ2pOTkF3MG9SQUV6SEtSKzJHdEJzSTdxbko3dUlleC9uK2ZMQ1dDaUxLaFBqUldPOXRoTi8zSndSZG1hcW9GemJWREVqTUVnRzBYWW1mcVoydUJoemtzclZIYkxvdmlZbElobHVienkyMm1NRUpZRkFvdTRVdGZUNFIwM2tlUUY0d0FoSGRhZERFTUJwWXFUTVJBa1JnV1luVlY0VUVFS0YybmY4QWY3K2NCakpOanJzMWxLbVl6L2Uwa0pOTUdDSThKZzNQempuelM0bHNTcDB6YVpOVXlkT2xjZDQ2eVJ1WmtHWTl1b0F4eHR0N1hSM1duME5jdnhpdGthK3FqVlNvV2tFamtDTmwySHJoWENNK3d1WDBGcjJzNzdKUGttU2ttdW1hZFN2VVlhM0ZyV3NzeWI3d01Jc0tqTFhRZWYyWi9pbEhndFNraFd2UmZNT0JxV21qOTFURUdBSnV4dnVUejJ4Wk9mUzZOOFdMK0ZVNmRUak5PaGx1N1ZEb1FRYkF6Y3lmUDd2Z2VSS291eHNNYmwvUjBqaVBIcW5DY29UbHFZcVpvd2xNRWM0L2UrUE5qaGprbGJQUmN1TWFSaE9JY1k3UTVpam1LamNXcUZVYjgvdVZJcDB1Y0J5WW5yRTQ3NFlzVWU0bk8zUHZrSTZ2YlRpdENtYUZMaWpVeVJBTk91b0E5QURoNGVGaGw4dU9qbWZrU1RwaG5ETzNQYUhKS05mRmExZW1aL0x6SUZSZnIvZkFuNG1LZlVUWS9JY2V6ZGNGN1I1dmp0U2pXeWl2VHk5QWw4dzdMcWxvc1BLZXZsano4bmp3eFNwbnFZY3Y1WTJLODkyelNoay93N2w2cFVrdXFpREFhd25sNSt1TFI4UnkwMFR6WjR3YlNZcVBiMmxtWEsxY3JTcGtuWm1JdjVYMi90am9mZ09DN281VjV1dEVXN2NaYWxScUsrUnFQVUpzUTNoTTJuejN4bDRMdTI3TS9ObCtyT1VkcXF0S3B4V3BWb1NLUkVyNlJzWjZXeDYyTkpSU1BGenljcE9RTFFvZDVvcHdPOFdia1NDQ2V2eVo5TU15Y2ZzMmZZN0ppbm05VGFkVGZwT21BSUlqM3h6WlhyUjE0NnZaYnhKeFU0cFY3MWpyWU1RUlBvQ1I5UFMyR2pHNDhnWmI1SkU2S29jbnBaenJGWHhDSldDUHY1d2FkaHZRS29aR2Q0TEwrcUNCTzNYcmhnSHF1eVNCcDByZVc4d05pTU1LZXFEcFFxUUp0MTFEcGdVTlo5QWU1Sk8vTHp3UmRHWHJtbWN4VUZYUVZlcXlpK3Irb3pIUWJld09IT0lqbDVha3ROYWprS0FRSWtnRWIvekdDTUVVYWVxbXpBeVNxN2p4Q1JlT3ZUMGpBQ0cwaE5WU1ZCRWFEQUhJVDlldUZZU0xRMUxWM3N5Ymh6YzdHL3h0T0Y5MFBGcGRtdDdBOEh6V2ZxMWhsOUk4QmZ2R2JTRkZyK3VPVHljaVdqc3d4M2JON1M3TzVoaWdwMDFyMUN4UUJSTUVnR1NldmxPT2I4M3hwSFM4YVlzNHB3K3JRTExUaW9FcDY5UzdSWUVqbUJKQWs3bmJES2FxamZqb1ZWZUg1Z1ZLdE90cVJxZFBVNEkybllZZUxWZ2txVmlUTmNNNGhtSzlDcFRmOHNFS0ZCMGhWQjNQV1pJOU1WNXhTSS9pZkt4cDJjbzFLUEY4dHJWVDNkV1drM0FFUUQ1N2UrSWVUSzR1a2RIanhjWldkbnpuWlRLOFl5c1ZFQ1ZHc1dRSFVkL2FUTytQS1dad2xwSHB1UzQ3T2VjWjdGNVRJWmxLZWVxTzJrbnVxVlVnVVhXUDZlUVlHOTkvMzY0ZVZmb25rOFZaSS9GbUQ3WGRrczd4SGpCemdyNWNxOU5GSmVvcWhBQnBsWXRwNWhlV1BRdytYRlk2UE95ZURjN1RHblp6c2svR2MxV3lpa21uVHA2bGVtMnhBNmtYQi9uSFBtOGpnZGNQR2o3Tzdkait6K1g0SjJiei9ERVVBTTdBRVhZZ2dDNTUzbkhrNWM3bk8yVmNlRW84ZWo4NmR1TWdjdjJxemVVOFMweHBxQUF4cTFiejZZOTN3cHA0bEpuSDUrT1g1V28rL3dENGhUbmNvK1Q0VlV6bEZhQnFyVkE3bDZaWmdKM2cyNkcrT2lHWG02Wnp6ZzRMUW95MmVxMWxGYXJSUWpWYzBBRldOOW9pTHhpN1Y5bk5HVGs3Rm5GSDFacFMvaUlBQTJ2UDdtMk1sUnp6ZDJFOEpVdWxOYUkxa05zTjRFejZlK00wYVBWRzE0UFRwS2hGU295WmtrMU5MckdwZ2JGVDZjclk1NUxSMGJURE9JRExWcUsxQ0hWd3BRK0VTYndmN1lYSEpwVXlrNmUwSzZlcW1kTE5PdnlIUWduZTNMRmxzbjEyUlptV1hKQUJNNzhvUCtjRU9pQ2VKM1lhWVBVSGZ5K1BxTUVVc3BhdTdETkJEVFlqNHhqRWFxaDMxUFVRbnpNWXhqS1poV3JabDFMRlFhckFCaVJzU1FaMkhJZStIT0k4QXBBVkhDU2RFZ2dhU0QveTZuMFByZ2pCRk1nZ0NucTFFcUY1V2diemdCRHFMRm5lN0VTUkdvN2dSRy9UOThLd2hlVG9NMVNrcFZsWFhFbHJRUHVQUEU1TkozWlNNYlIyUHNOazZXVm8xV3pET01zR1FoTklKZHVVZWR2NXg1UGtPVW5aNk9OcUtOditNeVl5ZE5RR0ZIVWU2cEpjMUdJaUZqckJsejdSdmptcVdqbzVwQzdpQ1pXalVwMUhUV3FrTUtkSC93RFZaYnFxL3dEaUNmNXhTTGNkbTVwbmpjQkZUSzFFekZlbWMxV0tabW9hYkFnUGN4MWdHRkhYNXdIbGZJYmxGNm94M2FwNk9YL0FJdFFJS2daU0I0QUZCdVNSeTNQdlBwMFk3YlJITE5MU01Id0xpU0srVlUxQUh1cFluYXdtL1dlZnBqb3pSdUxRbUhMVXJaK2tleU9lcDE4cFRlb2RXcFFzemVSeTllcHg0V1pWSTlPYWM0Sm9aOGY0Vmt1TlpUdXN3b0ExVE5yeGpSblNKNHB6eG1EcmY5Tk1oWHJOb3pKSkJuUUtRZ2ZYYTJPaGVaT01kSFRMTEgyalk5bnVBY1A0Tms2NlpQU2F4QUZTckZ6Ymw1WTVjbVdVMlFua2x5V2l4YWJLK1lBV1hha0NDTG16UkgxeE5yWlJ0V242UHo3L0FOUmU3ekhiclB0U2ZRVktxaldzd0J0OHpqM3ZEYi9BMGlIa3IvVmpaVm16bVh5N0s5SVppaTJreEVuMWpEeGZ0dWhKUWJWVS93RFl6bWN5ZFROMUJUeWVTRkNqTXM1cDZRZW44V3gxd3lmYk9LZUxpK2pGOFdYdTgrNmFRU0UwbVp0eS9qN25IUW5hUE55S3BNYzlqYVJxNW9vaWp2ZkN0TGNCbk1naWVnRW1lVVlubDYweHNTdVJ1TXpReTFXaFFSVVZnUHl6VVc1WXpNbjNGamptaGFXem95YWRvQ28xaFVHbDJKcm9JbVkxbFJ1Zk9CaHhZdDNzWFZxcXM2R2w0ZzRKRjV2ZTg5SjY0cEEwdXlrTERPSEIweHFKQXZOekk4by9iRkFFTWtPK3JhYVpZQmxBZzMxZVlQMXRqQXNJV25vcHFEVVJRR0lnalliWDg3WXdhSlphZzVwbUVGV0RHb3FRZlE0VWF6TjV2THM5V3ZwVXlLekhUek1NZnBmNllvY0JSVHFWV2d6clZmQ1NSWTMvQUxlbUNZdHkrb09vMU5EYmsvSlBseUo5UFBHR0Q4cW5kdTBJMGpscEI4aUo4enRpZVFaRFRobVpIZmlZMHM0RVIvU040OWZtM25pVGpjUzJPVkkzUER1SUwzQ28xTXNpc3p0ZUo1UjVBQVQ3NDVaUXM2SXlHMlY0bTdWKzhjQUt0SXhwNUNOaGYvY0RFWlFMeFlaUzRzYXowY3ptMlpJY3dxRVFDZmZvQVBLUjBPSnFOV01tVThTN1NWdSt6Q3JVZFhkRkpabEJZV3RwNkFYQStjTkhFbXRoNVZzNXAyazRnOWFoWFYzWldSam9MRXlFOWIyMngyNFl4UnpaSDdNM3doalV6cW9mQ1ZNeVRQTytPbktvdGFKNFpIZk94SEZtVEk1ZWRXb2VGcC9iL09QbmZKaDhqNkx4WCtTRkhSOG5uVG1xYkxZd1NDTnBnNDQ1TGlOUEdvc0pSa0VsQXFrK0lnV256T0E2SnRNRnE4U28wYWxYTFpZTXpVQithVmd3VHlIVXhocUhoamMvbElPeUpVVlhMV0FweGZ6dkdCN0o1ZWxYMmZtNy9xRlRGSHRsbjFtSXFCcnphNUFIcHQ4NDk3d3RZMS8rOWt2TWplVGwvai9oRDdoQW5KMHd0V2FUSFVGdEhuL3JITG5UdTBlaGhwclpYMmpOUDhJZEpJanhBVHB1SklJNjM1WXA0L0tUVE9meStFRlJ4SGltazhSelV0RUVRQ0RjOCtlUGJ0TktqNVhMK3pHSFo2dlVvNXRYcDBucWtLVUpVa2FaOVA2WWtlZnBoSnc1SU9HVk5tL3lpMUg0ZTcxc3U5TU13S2h6NGlTSjVjNVBsamtlbWRqanF6dzBGQnBWSDFNSkpZS2YxRG5CamNEQlRkZzQyWjdOVk5UaWdhWUNBSFNEdEdzamZwRVd4YVBSSnVuUkN1U2N0V1Bka05wSlZqNWRPbDV3eG4weW5LMXRPYlZVRUEwVk9zYjg1TitmUERFQTZuVUg0aXA0UVZZUnF2QTVmTUVmR0ZPaGxQZUY3bW5ySElxeEZ2bmZEQ21kemltcG1hZ21RenNRTjluMlBVenp0aHppS2FkT3l6dTE1SjJPMER6MmoxeGhocGw2VVVuYVZPa1drbUZ0ZitQakdDV3UyeFFxQ05Qd2ZMNzN3b1Q3TDVscURzVVZkU1RHdHJ5WkgrdmJDUzNvS2xUTlIyVnJ2bTZab254UDNkUU40cDh6TnNjczRjWFIwUWRvWnJXcUxSZFZlUzJsVkN0dUpOdlhFMms1S3pxaVdaTnFwcDVkR0toRnFYQmZ4TmU5dVgrTUNVVmJvTGROQTdablZuNjNmT2toU0FKa2F2ZitlbURHUHhET1d6RWRvTXhycVZhSXNOTEdKazlOOGRjRlViT1RKSVhjRmNMeEhLaG5qVVkxZWQ3NHBsNkZ3U3RuYSt5bFAvMGg4Q3FvYUJ5Z25rVDgzeDRuazluMGZoUFIwTGgrWVhMbzBBR1YwK0swL3dDc2ViS1BLUjJTWElKL0Y1emlOYjhIa2lWZGg0cW9XZEFqZjE4dWVHVVdtVHFPTDV5RWZhemo1N0M2YU5iaE9hekdYckVWS1dZU29xeVk4UUovNTJKUFdjV3c0ZnpLb3lJeXpLVVhLK2h2MlI3YjhNNDlscXpaVFZTcXBUOFZLcjRTa3gvbkU4dUNlQjBTakpaa3BJNXgvd0JUOC93Yzhkcjl4VUQ1cXJsV3BabFZQT0pFSG1iRGJvTWQvaDQ4bEpyb0diTEJMaSt4TDJXelR0azJwdkd0WUlEWDViN2VtTFo0WHRqK0hOUDRvVzlyczZ4cUlrRWdLV1k3VHZQdklHTCtIajluSi8xRE0zcEhOOG5sSy9FZUlMVHB2ZDlXcldSQ0tkelByajBPVldlRTR5ZjdHbjRkdzdMSm1LRlBnaGVxNitGNnpqVExIeTZiaTUvakVuSk5PeStPTHZRL1hMNTBWOHEyZnFFSXFscUZOaloySmdrbm1ONytXT2U0OGREemkxSk5oR1pyS0tTTFRNaHBJSkI1OVNPZUJGMDdMVE0yMUdhaTFyRlNTbXJydjliL0FFeGRTMGM4bGJvTGFtcnZVRlU2aTZtRlUyTWpsZ2NoZUFxek9XcVVzMnRXZzJuUXkydHBkVGFBUG42WXZDWXNvYkdxS3BrbXdRUVBVakNGZlpXMVpVT2x3cy8rVk1NZmN6Z1VKd010VXFNTTA3RWxHTHVMYlJKQi9mNHhjNVN3RkdwT1ZEc3F6QWlJbTBqb1pIN1lBUTFDUHc3U3hFU0FRMGlabVBQenhqSHdxRVZhYWo5S2dBVGMvVDRqQ3NJZndUaGVhNDFtTzZ5eU1LVk8ydWRJQUVuOVZodkVranB6eExKS0VlK3l1S0xmK0RwUFpmcy9WcDFjeFhGTlFjeFIwMHd6N3lwa2tjdnM0NE1tU3p0aEJSYW9ONFgyWmFxK1hScVFPb0xCQjJGNEVFZFlPSnZMVVVpeWpjaE54WExmaE9JWjZtV2JYU3JIVTRYY0RZL3Y5Y1BqbGFGbEdtMlordG1TbGF0VWRDcHA2MllIVEw3UmNkVFB6aThZOHRITzlNd25HMmlyVGVTWEpaaTM3L0ZzZG1OVXFPWEpQWlR3Tm1iaTJWVUJsQXFnYWh5dU1OUGNXUGpkdEk3OTJjSlRMS3BRa2lwcGkwQ3dCSDkvVEh6MmRmSm4wdmpTcUtOZmxLWXFWa29tRHFCOUlCL2J6eHlzNkpTTkZsY3hsT0U1YUEvNWxkcGd4SnRFYmI5TVRhbFBvNU16NXlQT0pQVDRwbENqMGpWcGF4S3ZBTXpIT3diQlVYamZ4REdOSEZlMm5aUFBaRGpBL3dDeFVXRkhNVXl0WW8zZVV6QkIwbURZZjN4NjNqNVk1TVQvQUM5cDZKNXNEbXVVVG5HWm9Wa3JWQm5HS1ZaSUt4OW1Ob08yUFR4NUxWSGxaZWFuYk5Md0dxVUhlS3VrYVZWcFBrWm42bkhObGpaNkdHZXJZcTdUNW85MW02NlNHU25vQTZFdEFNZGJIbHp4YkJqNHVqajh2SnlSbmV6Vko4N25seXRCOU5JcXV1Sk1rbUJBL3dDVWsvUFRGcGZGbm5SbStrZDA3RDhCNGZsOGlPSTVtamx5RlpnaHVBZXIraE1nWThmeU16Y3FpZWxpeEpSUUoybTRkV3pIRjgxbkdOTHZHcG9sT2xUdUtGTTJXZldaSFRuaXVHZkdLVDdKNUlKUzBadXBSS2xSVFpGV20yaERzQ2VROTdRZjc0Nlo3MkpWR2J6dFIzVmxCOGVvcklNUVZ0UGtZbkZzZlJPWVdlOTc1eXdEZ29DUUJaaURhM0t4SWdZRXV3eDZBa3I5NmFiNmwvTUVOSnNTT1I1OU1Od1pHYzlsbVVyaFVBcVRJVWlRb2c5SkdOd0thUGFJWlZPZ2tTWklaUnZIcmhqR056RlE2NnlzUnJWM3VDUi9VVHY1amw1WXVjWVRRWXNoTENDcXlHWnJOWUg3OVRoUjRTWHNKb2FUUkNDNTJFR2JUdC9PTUNYYkcvQnNnY3huU3VteUVOTEdKMmozMnhESkttUGpqYk9vY0l5U2pLTXRHbFRaQi84QVVlUEJISUFXNjQ4L0pLNVd6dGdxVkIyWEdacDFCVHBVRFFwQ0VZbGZFeGlkSko5dkxDV202S05iMGFic3h4TjZHVnB0M25mRUV5ekFBQWFqSUIrazQ1c2tYWlJXak1kcnhWZFRYeVZMV3l0cU5QYnZCRjV0eUczWEZjRCsyTk5jb21Kem5DVG42TFBrcTZDa0hIZXFCcFpWbWY4QTQ4emZwanNqa3FWSExLUEtOZXpuSGFPcFNwNTBpaThxcEpFN240L2ZIb1Eyck9MSkJSRjNESEZITzBYRmdESUhNUmVjR1N0TkJ4T21tZDU3SDUrbG1zc2hacEJFZ0F6NXo2WEdQRThxRk5uditGbFRWTTNDMTFTclNxTHFrQmtGckhuSC90eHdVZWhOS2hWbmVFWnZ0VHhpVXp0Yko1WExMS3Vxa2t0eUVSRTJ4YU1vNFYxWnpySFV1VmliamZaTGk5TnU4em5FODVtbEJudktjTUYvK0JpOStXR2ptaEwrSy8yT3pIaWpMM1FqRkt2bG1lamwrS1VTR1dQekxhZllFVGFOOFhTeFB0RHloeFRTWm44N2xxdjRrRDhYbEdhUDEwNmVyU1BuL1dPdUdTbG84VHlveFR1OWcrVWRxSXpDR3VXcUhTVUxpTlFqZnoyR0tTZHF6bWpNei9hV3RVVEk2WUFhclZZUnpnR2Y4WTZzZjdML0FBY2VhZW1nWHNsbW15K1phblQxbXRtSVFGYlJZOHh6L3dBWTJSWElqamFYL2s3bncvaWpEaEZBVk0yQzlGeDNOTXNQR1FBRkJnY2hKSTg4ZVZreHJrNlBUaFRSVnhYaWRHbHcra2xPczV6V1lOV29IWVg4UytLcDFnMlZSenVlV05HRzBUbFhhRXRKVmVnOE9OT3NLVmtHMGJmRnhpK1NWYVF5U2EyTE9MOEhYTjBlOXlrVmMwRzhlWElBRlRUK2tySDlYbjU0cGl5N1VXUXlZcjJtSmFLVlIzRFZ0SmNEUXpSOUxIMzg4V3FMZHBpSlZwZ2k1V1QzeHA2WFJtMGtLUVRJaVQrL25odVpPVUM5WkxDdzBnQVd0UHNmbkdLRWc1cHFGVHVBSTJNVyt1TUF4dGJTTXhVZ3V6OTZ6RXhhZFRXODVIdmZGemhzdFFzdFlKVDd6d2tnV2lmTENoaUhGblJsZUZsMlltTnhZZjUrY1lkOW14N0owOVdVclBUQ0NyVWVBNU1hQ2JTUkhyamo4aHUyZEdGYVIwektVa29UbEthcXFVV1NXM0xOZVJmempIQ3pwdW4wWEtpd0dPazkyQW42Wm1SWWZVU2ZQQ2U3S3JaUlNGUktLYTJVR2pWT3NBYVpPOGI5T2VBNjlqcFdVY1RxVmhsZTk4SWRBQ0dxR053U1NmTzIvdGhVcVkyL1J6THRMWE5PbUhSbGMyMU9VMGh6Y1FmU1FmTzJQUnhRVXYyUnk1WFMwYy96akdybW1lb1FIWWpVZVprejgvVEhiSFNwSEJOTHNycFV6U3pJcHF4TGYwbXhOL3NZTC9vRWUwamVkamVNTnduTlU2ZVpEYUF4STA5SS9hMzF4eWVYZ1VsY1R2dzUvd0FlanJLY1FwWm5MME0xVFl2U1l3WE8wUllueXg0N2hUNlBZV1ZTaFk3NGZ4SktkSTl5Q3JOQkZpZms4OFJ5UTFSV01reTdQY096T2V5c1U2cDhhUWRDd1RQSUhsaEl1T1B0RmFYc3krWjdBcXRkbXIwQzd0Y0dtd2E0M25jLzZ4MXg4eHFrdWhQd1FtbTYvd0NUSjhhN1BabkthbllhS0srS0JCdGNTZW1PM0Y1RVp2WjUva2VIeFZyb3pGUWpKR29OV293UnEvNCtmeWZwengxUlhJNFpyZ3pGNS9OL2pNOGhxRTkyZ09tOXo5ejY3WTZZcXRuQmthbEl1N1BVZ2MyYzNXSlZrYnd3djZpWWpBbXhvcm82Sms4MFR3NUZxQm1QZUtZL3FOMjFONUczdmZIRk9EdXpzak9MVkVucVZhMmE3NXcxd2llRVNGRVc5ckMzSVlLUVA3RHN1NEdrRnhUR3EwbU4rWHp6bm1NRCtWbFYxc3Z6UWZMZDFUY2dyVXBxRElrZ0ViVDE4OEt0M1p0Vm9TWnlnb3pOS29FVlpiUTRWZkRJSjJFZGNXZ2lNZ0R2cWVvb3dPa09Rd2tEbDZlbnppbkZrcE4yRE9nR2dwZG9pNGtINy92aHhpT1pDTlVHc3ZJVUNRMFRielA3WUZpY2pNMURUV3ZtR2NOcUZVanlQaXZhTnNkQnhrNlQrSk5ROE14dkJZZXZMZS9YQ2pMUXp5QzkvVHF5RkpRQmlDQ0FSc1ZqZTgvMndyZEZFa3pSZGpzcG5hR1pxNWV0UVlLRmhLclJFYnplNTVZNWM3aTBXeDJ0SFdPSDVTclVKZXJUQ0xWaW83bjlJYmNxdlhIblRseFIxeGYyRVozTG5JNWJ2RTA2Z05RRGJtTFg2U1l2Z1JsWThuclFOdzJpL3dDR1lWWFZuZG1xdDRadmJuMEFuQ3ZicGpRZHF3VHYweWpVTTFublFjUHFVUlRyQmsxYVNwSTFldC9yaHU2SGJkYU9mZHFPRzFNdnhLcFFScWRlZzFSalRlbGRYcHdTcEo1TUlqNHg2R0dWUnBuRmx0OUdGNDVRVThSckdtdFFlSFN5a1REQ0orL1BIV20ydEhMTHJaVytXcFBtc3BtR1YrNHFhbWNVMTFFZFl2c01ia3VtQ0VHMnFOOVM3T0puK0RkL1NMUFVwR0ZxU1ZCRnB0dEUzODVPT0JaNVFuVGVqMWNmajhvT3ZvWGNJNDltT0IxL3d1YXZTTUNDVE51Y2JSYkZKWWxQNVJJck5MSDhIMGJiczkya29WOHVpT3lsWThMbTRCdnZiZWNjR2JCS0IyNE02bDB6b3VWNDhpNWNXRTZDQ2dhUnl0Nzc0NFp4bGRIYkhORnEyQlV1MEZKK0lDalRVTk10NFAxRUhZKzNQQ3ZGVzZIaG12U1ptTzNIRkV5OUpxRk5kVFBMaFFQcjZlV096eGNMY3VYMmMvbVo2anhzNDEybDRpQ0JscVJYdldGK2c5UFU0OW5GRnIvQjRlYkw2TXhTQU1hV09semNTSkE4OGRMcjBjU0hsS29QeEtVVWxZSUNpZDJpL3dCTCt4eE9TYmFLUmsralQ1ZE0xWHlqNXZKb0toVFEzZEtaTGdNUmIyQi8vbGljNWRyNkx3ZzJPa1dzOWZMdjRobDh6U0JCZ0RTMjI0OUwrdU9kTmRsYWxIVERzbU5lV1A0bXNhZmRrQm0wYWlJamtQWVlXY2tub3JGTjludWlwbWMwMU9vd3BxSlVQVVFnZ3hZUURhOFg2REFUU1RhRVZzVDFUVXJJV3FvaVAzaDFLcE1DK3hubklPTEpwVTBMSzdGVmVrOU52QWlrcTBzUExvUi9PTHhsWktTWlRxWXUwcnV4aURFY28rK3VEUnJJS3FzSjFvUnlsSndhRTRveWRaOU9icWxMcDNwR21aanhHM1AxeFU1UzNMMWdhOU53NThJdkZpTDh6Z1VNT2VFMTBUTkh2Q0ZSNFVHL2xIcnZQc1l4TExIUThmaTAwZEw0Sm5NNWtzcXRPbzFBMGxZMUpLUklheElKdU53ZmJIRk9OYU9wT3RtbzRmeEhNQUFMV293aVFvU1hLSHAwK2NjMGttK0xLeGxmWThhajM5SFU3MDNVblVBV1lsL0tSeW1OOFJja21WUzVJRlZLbEo2OVFxb3BnbFYzaDN0WUUrOFl6KzBVUzRxak04WDRoUXAxYStUZFdiTHN4VjFuZGlZQkhuaXNJMnJFbE16R2Nhbnc5Tk5MTHExR295MDVpU1gza3g1RVJNN1l1azVLeUxsYk1meEdnbGJPVnU0WWxlOFpZQThSTURhYmJBazQ3WU54V3pseUt6enNwWHBKbVdYTVUxcUtwZDRJQkVsWVB2dDdZWExIMmltQjNwblhPdzFEOEk5Zkk1aW05T25VaXRRWWdBTXVrQWdlaHZHUEl6MjRjL1o2L2lmRVVkdWV5d1lWaXRPRmFHcFZGRWFHRzRQa2JZdjRubEpLbUw1ZmpjL2tqbHRXbm5PRTVrdFMxVXlXWlE2ekRYNTQ5VlUrenlweG5Eb2RaUHRibTBwaWpYeTlSZ0IrcWxVM0hvZnNZNTh2ako3UlNQa3VLb3RvZHFuU296SlN6Q3NTQ0NycVd0TzBiL3p0Z3J4clN0RGY5elNFdkd1MFZlcTNlMVVkcTEvekhmVXdrbTQ5SSt1S1lzWDQzU0laY3ZKWFpsWGZ2cW1zcXpGbU0yMUVkZlg3T09sYVZITEtUazdaYlEwMHFncWxiU0pNa2dEZVBRd0w0VmdReHl5bjhjTE82czRKRVJLa1NRVDFBL2pBdWlsSk5NN2wyTDRFbVh5OURNWmFveVpuTFBvYW1WTXZTTFNwQTNnQ2IrUng1UGtaSGJvOVRGRzBtTU9LY0RvSlE3cENFWlpZcVZNZnEvV3NiK21JWXNsRlpZM2tmSUVUTDBjbkxaNG8xUFJERWlkWUFObzVuYTNsaTgzeWV1eVNkYVlCbXM0YzVtS3psaFJwa2dGbFVXRVc5OE80U1MyVFNTWWl6REJWV203THFhcmMxRHZOaUQ4NG9rM29FbXJGM0VUVFkxRmhZV1NDTjd3WSt2MXhhS1pHVWhXNk0xUTkyRWdMTzhuYjZYeGF3VVJjR290Tmd6TU5NQ1hOdnJnaTBZMm9TYXRZSUkxVlhqL3hPb2kvNzR0UngwVzVVcjNpRlJJTUJodno4eEVZQWJHdE9vMWF0VXBWbkpsd1NZZ2puWWVVY3NMTnRxcUhpN2FzMW5EczdtRW93UUtpaFF1dURJQW1DT3NqSEpLSjBxYVpxY25XclpsYXRSNnpEVW9CV28xMUp2dEh6aUxTVHVoNG1oeVBGQ21WVjJYUzBhU0N3MGp6dHl4elRpdVZsVTYwQWNTNDFtYXcwcVU3OUxCQTBhSnQ5Unp3eWdub2RPMDdNcFV6S0RQTU0yekpUcFUyck00YURxaUthejF1VzI2WXJ4cU5SMlJsUDdGT2ZxNUtuUm9uTDFXRmRTNmdWV0RyTUJRREVHZklqYUw0cmppNnBrMi9vc3krV0lvNWcxRkFJSjFIK3FkSkpQbVNDQi9hVGdOdTlNZmo4YlprOHMybk5WWFJpbElNc3diTUNZa2JSMXgxU1hLRmV5R04xSzBmb1dweExobmFIaVRWK0E1dkt2bkZjWmdVdkVqa2lBR0FJRmpjSHJPUENVWnRPL3M5YkhsWEZCOVZxV2Z5U09vWVU2aWhya1FEdGUzSXdNUmpCeG5hTzlQbEV3M2F2aDFDbWtPa2FxcGpVQktFbjlqKytPL0RLWjUva0tQbzVUWFI4dFdxcDNiOTBHSlh3a0FpWTM1OCtuUEhxci9KNTlMNktjNW1lNm9rcjRTZkNEUE1jaDhIKytHV3hKVjlDR3VYcU0xUjBKVGNFcklCK1BTY090TTVYMlZxb0EyTXJDaVQ5ZmY2WHdic3dRc2xGQkNFQnpPbHYzNjNJK2NCZ3ZZeXl1WVVDayttWFJsVmtKLzQzaWV2Sy9UQ1NpNWRGRzlXZHU3TThSeW5HT0NaU25sOHd0RGllV3BoYVRGOUl6RklNQ0w4bUY1VSt1OGpIbVpJY1pQbDdQUnhaRTRwTjBNc3p4YlBuTGxHV25xRW9haUFoMEEvcWlma0RFWVk0cDlsSmMwOUMzS1ZLOVdrbEI2ZFRNR21tcG5iWk9yRW42NHRKSjdFVUd1eFBtcWlxNU9vb2hzYWVvRXp0RWpsdDljVmkzSnF5VXRNVFp2TWQ1bG5XaUFxTTFneGs5YitWeDg0cWxRdllzcUdtMWJVd0ViRWxaMkEzakZZRUh1VkZjb3RVcUVZQmR2REo5RGdsU3VvWUlpb2llVGdtYjdqeXdiTlJrcXFFMW1WYWJFdFZZcEpuK28vWFk0NkRpSjBhakFCekxieDFFZlRrYllGQW9KZFN3ZGxMS0lsZkZlSTVmVEdkVlFYMW9iY0V6eFR2c3RtcXgwdW9Dc3JURFcyL3Y2WWpOVWhzZHJScitIY2FmaGI2YzVxcUlTRkQvcUQyMmIyaWZYSEhOV3JPdFBqb2UxYzNrM3lUR3U0eTdrSFNhYWdrOUJQVC9PT2VtMzBVdHZhUXY0am1LYlZTdGV0bGFlV1VRcDFTV0ZnWmpsZUkrdUdkcWxRTHZwZ2RiT3BuYVF5dVJEZDFTMDF6M29VQ29aRUZnQnZ2QjJpMjJIakdVZHNSdTlVV1piZzZudW5yMUtOMUphS2loeVMwbnc4dHhkclc1NE1zMUtxS3h4THNBN1paeW5TMUpsYUpwMG5ZaUZxQmhJRUVMMWlBUE00T0JQaTJ6WjNiU1JrNk9WWWp1MUs2cFUxRm1ZOHYzbkhiTDRwUytqbncvdFRONXdjcncvaStUem5kbzcwVURDSlVPb0pNamI3R1BPeWJpNHBIWGpncjdPaHJVeXREaUovQ3RWL0NaeE84QWFGQzFCK3NSMHVENWc0NG5HVGkydlI2T09UY2FGM2FMSzBLb3BMVllCQVoxSHhHRHpJODdmemJCeFNsRVhKeFpnKzBlV1NuUXFzQXdvZ0ZUcVh4T1pKMHhOdldMUjVYOVBGa2JmUnhab0tLT1hWbnE1bk1aaXF0UFJSRmpIVHk1Y3plMitPeGZaNWszYktxbjVqb3lrcXNhVkdtQUFPWkhNbjZ6aHU5aUVVcWFiYXY2dDIzZ2dqek54UHp5d1RFRkpCR3JVQ1lFcVlJbmw3d2I0RkFEK0hWVkxTeFdvRS9wZ25iYitQMkcyTlRXMHlxMnFOVDJkcS9oNm11UUtZWHZwQmdzVkp1QUNKNUdSZVRqbXl3VW5iMld4eDQ5N09nOE83UTBPSndqVm9xRWFxRmF0SlZuZ1dQblBMM3h4eXhVN1IwdksyTmlLK1hvTG1LYlpkcWRWUEdHRWQyM01qempsMHhPQ2NobTNWMlpEaTlLdlV6ZE5naXdWS2xWRURsSUhRWTY4VFRUUkdjYWFGQXpLR25YTlNJU21QMVg4VnZDYlgzUHppZ2taSnNwRGQ0K3FVMHNMa0pCZzN1TVBIUXZENWNqNW4zWXRJaUFaaThYLzN6d1JpaDNDbUNhYWtUWXoxNVh3YUJabE04MVR2NnlyckRseVZFZ21OVVJQM3Zqb09NcmJVS2pFQWxyY3lDZVVnYitmdmpHTDZOWlFBQWpTSEd6WE1FU0krTUNqRXN3b1RmVEtxWUlCdVBJK3ZMQ09Pd21pNEp4N1VnbzhSZHRTZ2hIMklKRUVORWVtSTVJVTdYUlNFL1ROSFM0dmxjdFJPWHFISjE2QlN6R3VWUFB6MmczdGpuNHQvcWpyNThWUXR6K2NwVmFyRGhpMEtCajlYL0VBUnpIVDN4UkpwYkl6cFA0c0REL2hxTk42ZFVaaFdJWjFKUGpKRnBKM3VEOU1IOXRTSFVxTEtYSDY3VWhsMnJpaFNWVGJMcHBhb0RiZnJHRi9GR3dTeVNmc1FjWDRuVnJpbUtkWmw3dVF1bGpwU1NKQTVrek1rNzRwaWh4MExrbHk2WnY4QS9wWDJmL0hhdUw1K21EUnB5eXhjbGdRT2U5NTN4eStWbTNTT3J4WXJpMnpZOFk0QlN5ZkVNclZxVXpYVE1QOEFoMnBWU0dOU3FSTEFkUUQ1WTVZNUd6cGNZbys3ZDUralZ6M0JSU05NMTh0bHlYTko1aFRvQ2czL0FQRnJHOEhCeE9Vb3RmWVl6M1NLOHZyNGtVUXNwRFVnNzFLcDhOTVFOUmNuWVhPTnhUZElibHEyY3o3WmNZR2N6TmZLNUppdVdSNmlzVVVLWFU4aUovcUFuMElFV0l4MzRvY2V6enMrVG1xUmc4d3dlcHBwc0FpVGUvaTgvYkhXa2NKRTZrTGtscENrd1o4VmhHM0lmdmc5R0lxNVFsU0NGQjFYTzQ1Qzk3OVBQQk1RZW1FWllFNkozaTk5dHJXeGpEWGd6cFN6V3FwU3FWZFNsUUNBRHA2ays1dUwyd3NrNjBQQTNYWjdMWld2U3E4UnoxUHVhSWI4aFdMSTVhWkVmZDR4eVNsSzZSMXdlbXhtbWFYTjhOV3ZDaXAzNDBhQUJCa0NSSE05TVN1WEp4a09xYXN2em5GWXBVS2JPcW54ZUVtd084MzNuU3AzNVlXRUhUWUZMZEVlSTUxQzFBRWhEUzhRTXhBQTJtUjBqM3hYQW5lMExsbXF2Nk1Wd1B2disxNnEwaGlkVnlUYmtEMWpyengwMGpteHRwMk1XZXFIQmJVcEM2QmN5VHZCNjQxRk9hUFJLb3l3NndnM0g2b1VpZC91Y0FQTkVIcGthUkJOdHdvUE05Y01ZeE5iUUtsZURCV294SVlkT1h3VGk1eUVIYnVTeGFFWmFqY2hHcS9Ma0JiYkJNVDc5RkRBT05MR3hWWU5wNmZQK3NZd1dsU25XMExWcStNbTFyYnlMOVlnNFZvSll5b2N5aTk0dXBqNFdtNDNIOXVYTEN0eVdqRnRKWlNsQ0s4VE1nbm1PY1d3Tm9hNzdMSHoxWDh0cVpDZ2tFaG1tZVIzbTIzbkdCVjlnNjZQcXZGNjlSVXBDcUgwaUFyS0YwQS9XSm0zbmhWQ21NOGxJV1ZjMVhjS1FUU3BmOFFURWREMDN3MUN1U2xvK29LOVp4UlEvbXVWcEtDTGFwajc5Y0IxSGJERkswZnFQc2x3cWpsTXRrTWpsUXZjUEdpRk1GS0lCQlBQOVdrbkhnNUp0eWJrZTFqU1VOSDNiRE1FOFA0am0wMWs1UnFXWHlqd1I0MnJBczg5WVUzOGhoOFNhblRIbFRWSXlQWnpzdTNFVmZPNTNNMHNoa0JMbXZWUzlRRGQxWC9qNW0yS3l5Y0hSS01WRjNJQjdaY1R5L0R1Q1BsdUhVU3VWc3V2TWtkN21qYUNZUGdRZnEwakZNRWVUdjBUejVGQlY3T09aMWhsOG1GRXJXcVNZQWtxdlVuY2Y0bkhwUmlrZWJOc0RTbUc4VHJUOFlKZzJHOXYzakQyZ0pxaW9BMUM0U1lERUVpd3NEL0J4aFh0NkxHSlZ3S2FzU1lFUmNHMjNYbGIrTVlCOEtUVTZ5aGdWU1FKSnR1SklnLzZHTllXbXV4bjJjeWRQTnZVTlNxYVRJdzhJUXNTT1EzRWJ4N1lXVW11aDRSVDdOTGtzalN6ZVpwQVpyT1BRRHl4cUtDUER1dGpBaitjU2M5ZjJkTWVNZWhybkNtWHFmbFUzWEtVUVcxTnU5VFZPcGp0WTh2TTJpK0pLMnRqU2R2NDlDVE5jVnBQbTZhVUhwZ0JqOGJuMkY1OVRpa0l1TVdjL3dDU3BVeVdleTlETlZvcVp0M0JZbDBnWFBrZDR2NmNzR0VxdUxNN2tXMUhTa0RUUmtBVlFzeC9qcEh4aHdwSkk4cUlyTXhCcUVFUnFVR0o4dXR2MnhyRUtscUNtWDFrbGlTeHZ0SXNSKzN0aGFDV29hZ1dLRkVWRkhQdlB2bEdHS0dPelJVMXFpM1ZnU0FVTVNReEZ1bTQrTWRCeUE5VUwzaWFWU0N4NTdBbUlnZTArdU1ZOHBvWEZOV2dURU42aWR2ZmZyR01ZdXAwNmpncnVBU1BFMFN4ajZ6SjlzQUlVMVBTd1pxWUIxa3owWVd1VHp0ZkFaajQwbXF6Q2h5SGdpUnlNd2NLWThyMU5QNVNGWEJVaUIvVHZBKzc0QUxvcnl0Tjh3YWpWQXVrWDFNQVJKSFA0K21NTWw5bnRUSzkybE41a2YxQVJZenpQMG5HTlFYMmRwclU0L2xhYmdsRXFoaXRwc1Ezenl4UEkvaXhvSzVJL1ZYQUtxVTZXWnFNQUZ5WERxeUZWSWxpMVdGOUNkTWUrUENtbTJ6Mm9mcWtZM3RWbkVwY0w0YnduTlBWRk90V3Faek1WRkNzNlU2YXNQQ05wMUV3TWRFSXB6VDlFOHJhZWdPbHhIUGNaV2hUWU5ReVFxSlR5MlRweHJyVkZIaDFFLzBnYjdBZEx6aXFoVXRnYitKeS90bHhKT0tkb3EzY1BWL0NVQUthdVl1VkhpWUFjaXdJSGtCanR4WTFHTkhCa3lLY3JzeUpaODFtRlpQelFTUUVVQWM5dmY4QWJGK3V5TW5mUVFxa1ZGRC9BS3BrRTdIMTh2dmZBQnhhV3dkbjBWUzZCdWdNQWlSZXc1UjAyUHRoa3pGVkZOYmdPcU0yMG1mMVJZZEQvamNZREI3RHF0UHVPNVlMVGVISklkTE1RTHlPY25sakJaNWxLdFRLVnFkU2t5czZLVkxNSkQwNGdnOHpJSitNYWt3WFF5VHRQWFducXE5MmcvU2RGS0x6eSs5d01UL0hiS2ZsY2Vpak5kcHE5VldwSlQ3MURiODhhdHVnSFBjRDJPQ3NZSG1jaEE5U3BWWVZHZ1Ewd2l3Qnp0aXRLaWJmc1paTGpWZkxxVXJKcThaWVZET28yTS94aWJodTBGWk5kbW00WnhFWm1tZTdEVkVKSGpacmd4dEhQYVp3ckdVN0RYcGtvTlhoQWphNGtXUG1lZC9UQ3RwZGpyWkNycDA2UUJjZUlCcnpiNUZ0L1BEbUtxSVhNQm1VU0F4QTBFaUJ1UFV3Y1lma2pKdlNMNXVxcUdxekxWTVdzQnFOL1BGN1J5bE9ZQ21vSlYyVWpsSk94dnZ2L2JCTVM3d2FpV1ppWjhaMjFYbUpHd2ozR0FZdFZhYVVkTHo0eE14WXhzWjg3OU1ZSkpqUlYzVlNic2RPbTBDWklCUG1NQmd0SHRiTk5XVjVaTk45UkpJNVd2MDY0QVQ3S1pFTzhPVDNsMWdqb1RmOThCbVN0aGxJYUZKcHE0QnNMbVNESG45KytGS1NTclJIdUZmTTBWUkNUTnJYbitZSDc0RDZGUjV3UmluRUt6YU5MQ2hWYzZDREhuT3dGb2tEcGhaNld3eDd0SDZKNFJtRG5LWEVOQ0dwMzlES1VTQVpEQWxxc0dMWDFBZTJQSHlxbXoyY1R0SXpIYXhFekhHc3FyTnE3dENqYm5VZGJFbmNjK1dLNGxTMkptYTZNcjJpNDNWeXptbGxhdWg2OUZzdFNHeHBVWUllcEhJdCtrZVJubmp0eHc1SzJjdVhKVWFUTUpuR2FoUktJV1ZtVUpiWlJCSDM2WXRHNk9FancrakRodEFVQ1FSekpJRzNwTytLUzJVaW8vWmRtV0JSWDBhQ1FCdGNRTGpyTWcrZUFOSnI3QktkQnFvUGlDa21YSFEzSTh2OTQxa1VyR3JaVk10bDJydlRRVkNRQW8zaWRwNWRQTytNdGxJeVVWVEZlY3FVaFhBWWFDZzhNRFlqa0ozdmJuejY0SXM1Y25hSzJRK0pURVBZelVtOERuNkUvR01LVnBTWi9DNnJxQTJHODMyUDNmQlJxc3BhaXFrNjZpbTlnazMzK1ByZ21xanhxQlNRZFNCUklMRWd6RXpibDU0MWdhSzZsQWFCVWd1U1pOenQwK21NcXNIRWxTYXZsYWdlbktNRklJaTBid2VmUDZER2xGQTJ1aC93N2pET2dvVjViV05KYVowbnBQbnQ3REVwUUtRblE5SldxVmJVQ04xTzI5eEhYR2JLZDlGQmRrTXM0R3J4RHhSZzBQOEFFenRZRDhWVUlJYXAzanFiL3dEa1krYmZHS0hJQ2dLek1lN2xSK3BZbVNUempmMS90aGdudGJTTXNpR0RES3hCdVppRC9FeE8rTVlIVWwxSUN3Qk5TUXhuWVQ3WUpneGNreWxIcUdGcWpTdWdtWkl1UG04NHhsRzJlWmtMbDh3YWY2dTd2QTJzUDFEMjVlZUZZOGxRYmxDMUtyNHpKSkV0TWd5Ym1lZGh2NTRWZ1JOWEhlSU5HbFRKTitjZjZ0eU9BWVlaSFEyZU9aWVBveTlGbmhtZ0JpQ0k5NXdrK2d4OWk3Z3RLYVdiMUV3S0FweUFUZGhhM1MwM3hwcE4weHNLdDBmb3pzSHd5bHdic3ZUem1hSU5WYUpyTXpDd01CS2UvUVFjZVBseXFjNlBYd3FrYzM0eHhMSjViS1BtTXhLaXE3RFFETGJHdzg3aS93RGZIVkNGcEk1c3M2a3pucU5YejFiTTU2cVNBRE9yYmZiMEgzZkhmeFVZbkZDWEtZQm1HT1l6TWh5U1d0dmJ3d0wvQUVQcmhpWXdTYVdVQ0lhZjVpL3AzRUcwWDVUNyttQVlxZFJxbDRZTEVTZE1SMTMreWNZd1p3K2ozdWFlV0NCQVRxTUVCZVJNZWVGa1BFaHhKaitJcEl1b0F5RkFJam1CUFcrTkRvMCt3Yk1VcVFVTUthazJBWlRNQzl1Wm1KRVgyTUhEaUFkV25YdHFoMTAzS2t4SWtuZmx0akdLQnFOSVdjc1FCTzhDZjI1VDZZS0FUcG91dGkzZUFhdHlMQUFFNHpNWDB3MVJpWEpZQWVMdzdSWTNPMXI0VWY4QWlTenRNSXRPbU5SYjlSYittSU5qN0E0SW9QbktlalVYcDZwV3pBRUNZTVJQV0Q5eGhnQXBwS3Q5VWdEZS9UN1BNNHdvMjRSeE42UkZETjZucDJLbUxnallmdmhad0RDWSthdFVwa0h1cWpoeHFuZjd2T01XTTVXMUxtcXJJUVRyZVZFQ2JuNnlEaHJJQUxpWEN3UDFlS0xUZVB2ME9HQ2ZWazd5bVFmRE55QU9sK1czcmpHQ3NqVE5PV2xkYkRhTnV2OEFGc0VDN1pldy93RDNOVmxDbndLUTB4Q3grNFAwd0NzdWdVMUNLbEJ3VkpWaEFnM0l2Y2ZHQXlhOWhGQnU3b2tCbUJjeUxtZHowdHRxdDVZVmpCV1NZdFhyTW9KVUx0emtpYmZVL1l3ck1IVkt5VWV6K2FwcW9GWE1WRlV6TWFFTi93QnlmSytKUDlnbHZaUGhoNGpuOGprNmE2bXptWlduM2N3ZEd4dDBBSlB0alo1Y1Z5S1lOSDZCN2I4UXkvRHV6OWFuckNwVnFHbnFWNWltaWliOGdGZ0R6T1BLeFE1enM5YkovcHhSK2NNL21xM0c4NzNsVW44UFRYVFRUVnRNd0k2bUJmeXg3RUZ3aWp5SlBsTnN0NHJtZncyUXBaRkthbzdqVlhPa2ZwRjFTT2tSYnp3SXJuTnNJc3BUM2ZlRUU2ZHlvdnRJdjEzK3hoeVI3VXJNcHFId3N4R2tIVUlqYTNsUDN0Z21MT0FaRWNWNGxTb2hqVHBIOHlwVUIvUlNGMm55NUR6aU5zTEtWSWVFVFlMU281ei9BTGhtOHVsUExVM3FKbHN2VFZTcXFxSnJhUjZBRDFqRUp6MGpvakRzeWVmcWxjM1JMVWd5c3NnNlRFbmYzNS9HT2hPMVp5VldpK25rdTlxcXVZY3Uxd3dNQzV2eThwOU1MS1ZPaDR4dEYzNFRMc2k2d05JTWtFeW9BdDhXd1l1eWtWR1BaT3NRdEoyVWQycXJBOE1SYzJqa05vdGErQ0xrY2RVTDNMTlIxQmRMRmRDNnJrVC9BSXRPTVNQYVZKZzhrZ1U1dXpFeUxIbDZ3ZmZCTWZQVFNrb1hNQlN0L0FCNHBsdnJZVzg4WXg3eENwV3pkRW12VFkwWFVNSDB6YUkvVVpqR014TTZta1lSalV2S2tDMXVmcDE5Y01JRGQ1WWFRdWhaVXdJa1RQdnVNWXcrNGZ4R210QW5NTFgxc3hhRXB6RTliOVorbUU0REtaVm5LSU5mTWFpQ084WXpzTnovQURiM09IL0lLQTFnR2VOS3FYQW04R2ZQNjRmK3drcWRId3hTMHVkU2dFZjFUKzJNYVBZeHA1VmFkSUdvZGRSbUpWckh3OHlQUEFLUHNINHBVSUMyQUxnMld3QWcyQjVDM3ZBeGdQb1hnTlVxalFmRzBTQmFUMTZYNmVXQXljZllZR0xxdWt4SDZBby9VSWdONnlKd1BRNkRjaUdxQUdoSXFWYWhDcklCMkFBdnovbkVuMHltUDJTNDJ4cVo1TXJHcWxRUVUvQTBpZjZpQ1BiQWgrb1BadnYraytYWE05dDhwVk1OUXlHVGJNRUFXRlI1Rmg5NzQ1dk15TlIwWDhQSGM3UHYrc1BIMTRoeHgrRVphcVd5K1VDMG5JSUFMQzdqMEpNOHRoaGZEd3BKemZaVHpNeWxVVEcwdE5ESkdxWDBxQ1JUUWdCakZ3VFBQK2I3WTdFY1F1cUsrWXI5L1ZjUFZZZ3V3M3Z1ZmpEQUJjMzRGSzA0c3hJMDdFZVVIZnI3NEkwK3kvaGZEbTR0WHFyMytYb1VLTlBYV3ExaVZDcjBBRjJOdGgwTzIrQXBjQVlvZkZqYnN0U2RPR1oyczY2Qm1YV2tCYVlRQW4yTWlQOEEyamU1eFBNN2FaWEQweDVtcW9vY0FvSlRVanZNelZEenlFZ2I3YkNRUjB3aWpic3J5cUlpelpwMXE5V21WQmtuVHFOak1ianIvWVdtK0xwVXFKTjJlVkpWbHF1NUpROG9zQ2YzNXpnZ0lWYWdWUUVrV0JHa2owMnR5eGpFTTlRL0M1UEwwVXBobXFudlNwTXd1M1htSStQZkdOeHNweWVWckVsdFRXSjhRc1lpMStjZ1lCdU5CaHk3c0ZwVU5LYW1oNTNZUnNPdk1BNE4xc0tWdWdqSThQb0pSclpuTXJPbVlGUTI5NzdDTnJ6R0pPVnVodUJLcFRxdmxBdEt1UlJxVWFsWXFpQStBS1RhZHQ0Z2RmSXl5VzBCeFNSanFGU0tMVFRJZlNTMHd0enRGc1ZPU1A3TUZOVXNBcEJPbFNibjB2aHhpNUs1cGdoVEVtU2JYKzl2YkNHWFE0empBWmpNU1E1MXVBQWhJV1dPL3dBNDFBQk1xRkZlaXBwQjExUUJBQXNPVTdqREJHYU10TnUrTklONDFlU0ltT1IrTUJoSkxZb1NDWEpNay9xQU1uL0h2Z0RJWGNWcktjMDBxb1JRcUFRWUF2dDk5TU1oV0RaZHAxYWhwSmF3SXZjR0FSRysrTUJCTHVncEVNUUlCVWdNYnNMMlBXUDR3ZlFScHc2dFR5ekxWcUlyTFJRdFlXWmlwaisvMHhIMlhpNlRBc2pUZXExU3U0dUhHdTVFc3hKOUkzeG5vbEJhYlp0K3dIYVNod0RJOXA4NEZINHNVRk5FVkU4TE9XQUFIT3hFMzh1V09UeU1UbkpGL0h5ZmppNHN5bEkxVEZNMTVxVkNhbFZqeTVuVnpNbjdBeDFLcVZlaUxmSnRubkVLcGFtS2FNQWlqd0IxVlNvSXNiZVlCOS9QQkZKVTZmYzB5V0hoQ2lZaVZuN0J4akNiTU90UnJLRlRUZTBrcjBFZEZremJZNEkwelE4VHlvNFgyWjRmUnpBMFp6T2s1aW9uZGdFYmFRYlNOSTIvemRGSlNlaWpnNElhY0YxSndiSktsTmdLbGJXZFRIbVpuMEpLKzV3ajdLNDE4V0JWY3lHTkNnYVFidXFqc3gxR0RxbHZxQ0o5TVpSZjdBajBWNTBKUmM2MWhsTnpxNSt2cHo5TVZRVlFGV3pDMWFpcXRGbGxXa08zTTdHM3FOK2NZRWljK3d2aDJWV3JUZ3hVVlBFMy9INzN3cmUwR1BUUHE1VDhmVkowVXpUaGFaRFNEQU1uMHc2RWZaZFNGRXBUQzFDbEp4NFpKaXdNRDRtL1dEZ21QS3JmK29mVFVQNVJLQ0Qrb1RZYndZTFI4N1JnVllZdW1BNWpNTlhycHcrbWZ5WFBpbFprd2YzNUQrK01vN0E1N0dPYXpDNVhoclpqdmhVb0tob1VWSUs5N0FFa2U4Yjd3T1J4UEgyek9lcU1jNmFDaXdHMTJnK1BudjhBZlh5eGM1cEZWZERFeE15UU5NYmIvd0FZd1R5bW9aZkVyRXFTUENQODR3UmxtbUJ6bFJBV0ZScXJDWjVGajhXaisrTUFqVDB0VUxHTkt5OTU1RC9JMjhzR3pCdEJscVVLWmtnZ3FTQS9PNDlMZy9HQU1nbGREazA0Qk02ZXNDOHg5OU1GR0ZHYjhWWmdFa0tUcGtFMkV4OTg4RVYzWjZpOTIwaGRMZ3lwbVRxdWQvVDU4c1lLdjJWTTBWQXFqeHlZWW5vZDlqMHdmUVFqOFEzY1ZhbFFzYjNrQUc0azNHSkx0ank2THVCMVRWek5LZ0NTS29NQlJOeEpCSFQwUG5ndEFqOUZWSE1QVDcrbFBnREJuamxwMlBsdi92ZkFxd1BzT3lOUmFXWHJWcWtxNS9VU21rZ0hmNjRIWFF5MUYwZU1EVktJMGhnMnBnUk1HOFRZeURIMXdyWmwyV2NVcnBsMFNucUlWUUp1WlVRUkJuZWV2N1kwVzMyR2FTNkFlQmNQYmpIR3Nsa0ZVczJackFIeVM1YjBHa01mYkRTa29RdGdqRnpHbmJyaVE0bDJocktyZmtVbVlVaHBpMXZJRy9LL0x5dkxEQnhqWlhOTzJraHpsNjVwcGtWbGdVcGlZNjZJSDhSaHY3SFdsU0VDbU0zUkN5V1ZkWDZmNmlOaEhJK0gwbm55WnQ4YUZUZDBYOFZyTXRjdEVJUUxYSDkvdjB4bzlHazJub2h3aW1LejBoVTBOU0lOTjlSdkIvaVRNamtmTEFtTDI5am9HbmtNbytzZ0ZRekVIb3R0NW5yMTUrMGJkbFVrTEthMHhsRjFDRkpNc2VXMjNyZjk3Yll2RVNhUkdwV0dvb2toazFGUmU5cGdlOXNNVGwwQTVyTUpSb3U1VmJrM0ZwTjdlVVh4a0piQWVHRnF1WnNuanFPRlJaaTBYTW13aTJCSnVuUUZ0akx0Ym02WnpsREw1ZUZvMEtZMHFGZ1NnZ2tlcDh0c0xqVmJOTFFnVXRVS3FxaDlJYUppYmZ6QStaeFVSa0t4VXdOSjFjOVh6YkdGazJYRDhRZjAwd3c2c3BZOWVSaUw0d3hkWGc1L013Zy9XNEpFZjhpSm4weGpFMEpDTTVNQUtJSkVhdlVEMittTVl2eXRaMG8xQzF3V1BoaVJaZnBjZlhHR1FYUnFCYzJyTFlyQklpYmIzNld4ckNrVW1pMU1WVWFDNndQT1J2OEF2aGthdm9qVEJXdFdxT0hCQ1R0QjJKbjQ1ZVdNQmk4U2RBZFd0VEt3Z0Z3UkZ1dnJnK21ZdnpkR01rN29wUlVxQlhBdllnR3crN3ppUzdaV3JUTE9CMUtDY1R5ek9Bd1dvSUdtQ0kyaHVuOXNGOWFKNDc5a21lbFV6VmJRSDdvdXhSV0dra0dZK3gwakNxL1puMldJVVZkQUJWdFFCZ21WRzBlZCt0citXTUcvUWRrbXBVMll5UVFBRmd5WjlCeTliNHpTb3k3RnZFYW9yMWtNc3hnQWtMWmdMVy9rNDBFZ3piSFhZeDA0ZmwrSzhhcUFVNmxDZzJYb2pyVnFBaGlOOWxuM09KWjZtK1Bvcmdrb1JzVzhLeS8vQUhEaTFDa0NQem0xSFhOK1p2MHZGcHVSdGlqYlNwRTRwTjJ4aG5jNEJ4UmtFSUMzaE1UWUN4OS83NFZkSWZrMDk5QWdkVzRyQU50SUpHMFdGdXZMNitXQytncDIyeXZpV2xhNkpKQjJsYkQ5SXNMZmZyZ3c2RXlOOGczZ3pMUkFSaEtQVGFtVktrQ1FRMS9ZVytjQ1JvdjJFY1dycXJLSU5RRFF0Z2ZNazNBNm0ySlJTZlkzSm9nT0paVXRvclUvSHExQXF3aFNMUVJQT1JzUU44TytYOFF1Y2FQT0pKbDh0VmZ1M0RJRjNOZ3czRWVSK2h3MXNEU2FNenhDczFhdm9xRUZUY01aaVl1YmZkc1VpclZrWmRqbnMxVEZLbm0rS0UyeXE2S0laVEd0Z1JlMjhtZk1BNFY5ME5GTHNRWmtyVXFzQ0NXUWhkUitoOTRuM3dicm9uTnNPeWRIU25lQlYxUVlNRFV2aE04L1BHdGhpcjdBYzBmL0FLTE1DUTA2Z2JUZVk2MnY5TU1KSkkrUVZRZzdxclkzT2x5QlBzY1lKZldXY3hWZ2pTOVZtQUEzOFJHTVkrQVlVb2srSVJCMmpWUExySDB4akJlVElpcXdIaTFiZzNKQTM2ZFBuR0RGM1lia2lLL2ZzM2lpWUtHODJVMjY0dzBkaFRwR1hxbndIWHFnUUxiaUJ5ai9BRGdXN29wMGhZekVQcnBoRU5TNEFBNXNRTnVsajZZbzlFbTJ4ZnJPa0VoVklCZzdnK0cwL0hwT042QVBNa3ExY3ZtS1d0Rm90Q01yV3ZOalB0aU43WjBROWl6aVdTcWNOcjB5ek85SlNXV3BwMk0zbjMyd2JKMjFwRkZOd0dEU3pEVHZJTzl5WTh6ZnJiR3V3T3F2Mkc1YXFIV3N4cUdlN0pMTGFCNmMrc1lBWXEwWFp5b2FhTXNBSFFTZEltWnVma1JqQjQreE96YTZncUY5VEVoYnB6NSt0c0ZhNkVidnNmNXAxeWZBTWhrQVNqc1RYYlNKblV2TzJ3VUFpZW5uaVVWYnNwTkpLZ2pzNHB5ZVNiaUNRMVl1eVV4Rm9JSm55TnA1bmJBbEo4cUd4UlRqWUhUN3JPTFVwR2FkZEFwQlByRXh6c1RiKytLVWpTZDZCOHRVcUx4RXFTckVTbmhITUd3SHoxNTQwdElXT25SYnhaWnpWUkgwdFRDc0JhUXM4ejhXbjY0RU9nNUY3R3ZBTWlNeFh5VkdRVmNPN3hLaGdHSWkrMWx3TWpwQmpIZGVpUEY4MHFjU3pUWmRYU2lEcFJtaVFSejM4ampRalN0bWxYU0VHV3FVOHhuZThjc3JUTERrZm5uOU1QZkZPaUNoeWtrTmVLdUtWRFNEcEFBMElaOE1IWVRhTmg4WVdDNUsyZFVvcUtwbWJoc3pXTk5RaHExU1JBbTNuNlhuRmVqanR0N0hHZnFqTDhFeTJWV3M4RmpWckt4MGdtSVdSLzRocDlXT0ZTdGxaM0ZmRUQ0ZFEvRVoybWFwcVJxWXU1SU1xTFFJK0RnTjA2SnBOOWpHcjNkUkRUOGZtU2hBSmk1aVBLTUVaYU05WGtwU2tLcXlRTk5PUDIzL0FNNE5pU1B0Q0V6VWNnOG9ZRzN4Z2hEWDFETlZ3NFdBN2hkTFh1VC9BTHhnRTJBMGdoRC9BT1Y0QWtnVDZiZ1l4ajNod1VaZHhCTnBodWtjL241akdNdEJPU1kwOHRWVFV6Qm1DL1hieXhobzZEM2Yvd0RLcWxTUVNEdUl1ZVgzNVlGYnNkeTBMTTJ4cHNxRncra1hHbTNXVDFua01QZGtrQVZXVmFBWUxwTnpFM2kxdjgrZUdTc1BRNTREVUZVUFRxYWU2WUZUdUk4UCtNUmFwblJpMnJZeXl0U2lyTnczaUxpQittb1FTWFVrK0xibGY0d3NtMHRBcW5vUThaNGMrU3FqdVdSNlRFNkhCTnJIbnlJRTRLWWtvTmJKNWVVcGZtSFRWUVRHcVlGNDljRWFGVVZaNHBWcUEweXcxV1JUdU9aRnVkNyt1TUxLVkZPVXBtcG1LRkpwQ1hKTS93QlA5dk1jc1lFWTJHY1l6RFpqT1F0THdyRlBlMGJBYjdYd3NZMFV5Tk9WSWNWSHBwbE9HNUphakJGbXE4RWZxZzJuMEoremlTMjdLUmlvcWdiTXJTcUJWVjRyaUZkZ2I2ZnNtMjJMQ1BzWDVIODNpS2hsM1loVE5nYmorTUNYUXE3RE9OSDg2a2hFZzJFbXdOcFcvVCtjYUhRY242ajNzalZHVzRMeExQdG9QZFVscFU5WDliR1Q4U2JmeGllUlhJdEdrck12bUhkYVRlQXNySFdTcDNQSURuRnRqZUo1NHFucEw2SXRWWUZ3blVLbE9wU0xhcEcwV3R2dDViWXpYb25HUEo5MVJmeFRNbXJXY0t5Z0RVZ25uem41TytOQktPalNiYjdQdUVaWU1TVFRCWnhxT3EybFFiL0lqMnd6b0tqcWl4OHNjeG1YZGhGT0NDQ1AxWDZXOXVtK0JkQW03WTN5K1dTaGx3dVdDTXhJYVFibG9JMjZqcDVZbTVleWtVcVl2ekFaWEppb3JpYlhBaWJpWmpsUCtzTW5aTjZFZWFZczJobFlCWkpCYUR2eSs5c1BST1JCbTBRRGMzbSsxemdtRG1DTG5helZGc0t6eElFbTV4aFZLeXV0S3ltNkJwRUcrbjdIMEdNTUVaU3BwUjVWdFUyYTl0dnB5SndhRjVib3ZwQnZ3RlJWUXpPb0NEOEdmbkFIdWp3VkNlSGQzSkoxekkvcTVIQm9ONm9GemJkNVhhb0ZNTUFRZFVpWTUrUi9qQldoYUswMHNDcXJaeEFKNStYd01GT2cxYW91NE16TFVxb1RDa0dEMWFMZmNZUnIyV3h5NHFoL25FZlBaYWpwQS9FVUJwVnFlNUJ1ZC9RSDVHSjh2c2VTZmFGQzEzcnFhT1pCWlFJcUFFV3VTZEo2ODR4bEgrVmsrYnZaNCtYU2lEVVUrR3pBd0xpUk1kT1gxdGhnTGNpbXF6RjFZczJwVi9UeTVmVzNLM3hqQW1YWlJWQTc0TVBFdDlGNG5mMjY0dzBEekowelh6ZVhHbGl0UnhPcmxlVDYyRzJGY3FFZ3ZtaHp4SnRRV3E5TnRUczNqYUFaUEk5T1J4R0hZL0lHb2Q1V3pZN3hnSU1Fa2t6WWtYMzYvVEYwRGtCVVNxWitDQ3R5Q0NJT2ttOWo1ZlBYQWtHTzNZWngxaUt0SXRxWkdVMm5wRWdkUVozUG4wdHNXOURaUDFDbGMvOEE0Ynk2aDRGU3N6MUFKSVBJWDlKajdPRmIrVkRlaEZ4QmpwZ2lTV2lDQ1NENzg5L1d4eFh0RXVWV1ZVcWk2VkFzc0dHZHROZ0lIdjhBMk9OUXRrRVZtY2JoaURPcStrQzN2djhBVTREall0YkhtUXBGY25VclZQQWpnS1oyQUpNQWNwTnZpY0wweXEwcko1TGg5WjJJN3hCVWd0dkFOeWJ6dGFQcGdxVmJBbHlsUTVkY3B3bklPSVhNWnBybDBhQWt4OVJmNHhLU2NtVS9WVVozT1oydFVVYXFsTU1QRnBuOVJ2c09YTW1lcDY0b2xSR1RFT2JHcHhxTTNJRU5QUUNmdnBoN0p5Wkg4TTljczFOV2NUQmx3c0hwR0NFWU1OV2NZTXNUVllLVmJxeGljWW5BbG1RU1lLNlM3RnBReGVZOXVlK01VS01zVk5WU1VCSk52RHRhM29aL2ZCVEovd0FtTVdMcGxxaWdBUTBzeTJMWGtHZDV2dmdYdWlqQkZybU5TamU0QXRZYmN6dGI1OHNOVkJBOVpGWm1MRUlwaytHNEk1K3VDWW1yRkJUWWhsQUlEQWkrM3A2ZkdNWkZqd2xlbTZJRkJpUkU4dnJnVll5ZE0xWEQ4eTBFTTRBaFVib0NObTl0NTZlbU9lY1gwZFMyckk4YjRlWFlWYWVrVmxMSHhEZSszbjE4OENNdDBKT0dyRkN2VXFLVlpBbW1WTm9pMXVmK0w3bkZMSnFOTXFxVUtqSktLU2dFQnRQVXg2K1dNQ1ViSnZVQ1VDcWxlOFd4Q2puZVIwUFE0SUl1aWZCNlR2bWpWTk1ta2lra3J2QnNQckE5OFRtR0g3V01jNHdHV0JBVWhXSkxBalVSdHZPMEUvSG5nUmcxc0JRMUVwVXk3SHZIVWdnblNSSklBanorTFJpZ0Jjb2ppQmMvbzFYSTNBSmt4N0RBa3RXTkFONDZ5OTVsYXNXS09MZ25wQWlkdjg0T0pVMlBsNlI3bDY3UGxhWWJVTzdKSUVsZ0lBUHdBVEdFNDIyd3A4bzJLYzB3TEtwVWc2aVNXTTlKOS91K0tSSXk3QjZOVFRsa1lrMjhWOTlvTWRjTUFQNGFsTnF3N3lscFFNTEw0akJJMkZwbVNOeGhKUFE4WSt6VVVQMEtLK1hwTUI0VVdxQTRwM0FKSFUrY1lnbTNJbzJtcUs2MUttYVRzZEFxNmlMTEptVC9BQ0JHS0svWWlWYkZPWE9XTGxzd3poV0lteHVQYmJuN1laVUR1U0laeXBRRk1VS0ZKaVRKZG81ZWNqZmUzbWNNR2JpSkhjcUttMzZ5R1dkeEhNZkk5OEdpRFZucVVpMHNVVjVneStxZGgwR0NFTWNNdWFxT1ZBMFZIbnpnejhZd2tZdGRsK2ZhUWJrS0ZCNldQMlBzNHc0Q2xRaW9UM3BEU05MVHBHNEgyTVltdjJZd3pEc2N0VllJZEphVkV6Y21BRHpOcllGYnNvQUkwRmpGcE40K2grbUhiTUNoQ1ZVUXNYa2FkekV6OU1hMEV0b3FWcTAwY3R1TlZyK25xUmpCTHk3TTRvazNJRjFIaEJBd1JvMTdHWERNMk85VWsvckFGanR2OU1TbEY5bEl5M1EreXhYTjVIdU5RRmFuNGl3SkdvQzg3ekkvYkVLZkl0MlUwMHk2MW1UUFVsTkZpRnF1cWpVaDVPaDNpOXhodGdhdEFMNWRzdFRyVUhBWjFnRTJJZzdFUnNEWTR5c2sxUXByeU13VUIyQkFZblRzTi9qNkgwaXBKcWhwd3NDbHc1NnlMb05Tb0ZESklrRFkvd0QyNGpPUThFeUZSTk5KdTlCTHQvU1lPcWJjdlczdmlsZzRzaGx5R1ZDRmFHdE1OSlA3ZVh4aGhSZFRCVE9rR1RCSVlDNWtnN2UwREdlMVEwWHNONHk3dlJ5RHlFbFpnbm56STVSYmI1eG9mRjdHeXY0b3B5bGNHa3lFaFVpZkNkaGFKRy9sNm5wZ0pBak5LTkFQRUt3L0VnTUdRSVJJS2lRZCtYUDk4TWhHOW5pRnFpVWxTemE1SUJCbVAydE9NeFd6UThOeWswaG1xeFNtcXozVUtUcTBrQ3dHd0F0UFV4eU9KeWFSMEtPckdsT2xWY2hSVFppU0VVQWt4TTlPWG5pU2RPemNTMThqbWFsUWVCcVkvb0pGeUkzNmpEYzBaeGRBRGNIS3N4UmF3TWk0SkhJeGIwdEhyZzgwS29QMkRIaHJkekpwc1FLazMzanBBNSttSFVyNkZualJtOHpJY3FoYzZXaHBzRDVqem5EcHA5RWloVnJySW9xWEUrS09SNmZzZmZCQ05GbE16bVZwMkxNNFBuNHJmZnJPTUFobTI3eWtncXFTdFNuTVRjYlhBNUcxL1hHTUNyS2t0MElNcXdQeDk3akdFWGJHVlJTTXRWSjBzUXNhaUlHLy93RG80dzRHb3FMbGlGWTNBRnpJTmp6MzU0eGlJVUZFa3FIQkI4TXdRVEIrN2M4WUtLeTROWmRKMDZmRDRUc052ZWNGQkxkTUdreEVLQUxIa1FJSTlQN1lJVWZOM2RQT0Y2US9MWWhtRWJpWU1kTWJYc1pkai9KMWxMMDNwTWRabVJjd3dOekczVDVPSlNYdEhRdWhvbmQxNlEwaFN4R3BkSXRJNWV2VDJHSjJybzFNb3FJdFdoUGRnVktJVlFnWWFoVHZBa2J4Y2VoR0dFbUpjMG9xMEFEcGNKQmdSQjJrQ09WL3VNT1Jsdm9LNFRXUVpkS0ROQlBpS0hlUnY2RG42NGpPTGZROFpKZGhybzFRSXdWNXFDMXdSZnIxL3NjTU00dGRnTEQ4eG1EYVNCRGFPUjVIMDJHSFJKaTNNR21PSldETXQ5Sm5ZdHlQM3l3UUxzczR3ZGRQSkt6S3I2WDhTY2dZTnZqR0RrM0ZVTGtxdVhDdkJjaHBpNUxTUVBuR29WUFJYbWRMVjlRQmlieGZZUWY1Z2NzRmE3TXdySkxUWkZOWFdzUkxHZlhibk5wd2JNbDdZZS9FKzhxRHVhSWNvTkkxVEt4NWM5eHlHSjE5anB2b0tvZjl6cXlhVGlqU2pVTkhnODk5eGNIeXdyU1l5NVBTUXk0ZncvaTJjZnUxcjFIN3NhcE5jaUFRWUpBa214dDZlWXdqY1k3Ry9ISjZaNVV5ZVZ5YjFLdVpydFUxUkxWS2hBQW05K2ZQcjBHQ25LUzBoSEdNSHRpek9jWEQxdjhBMHFNaERScmVkUk40UHlkL1NaeFNLb25LVm1kemNHb3pLVmxneW4xdk5zTkZWMkFGcWtPUVcwZ3h6Qk0rNHc5TXc4N3hWemRXRmtHcTBBOVpPL3ljQUJWVXFhOHZTcUg5UVlHUmJmR01DaGtZQlZTeXNCY3hFbmtPblBHSi93QW1OWEo3cHB2Y0tGSmtFRzkvTHl4aWdCVXFJMlhwSzQ4TE1Dd2oxQTUrWDF4akgyWXBpa1RJL01RUkc0dUFkN0huakJSRjFocWdDckV3ZlB4UkhwQUdDZ2s0WUlyVkFJSlZZREhtTnY0bjFzY0VLUGRKQ3Eyb3lLZ21CRWd5VGpNMTFzTDRYWGRLYTZpU1hVVkFaMk43K3RzTFZsWXlkRGpJVnpTelZTaXd2cDcwRUdid1A3NGs0N0dVcmRCcm9XcGgxS3E2b0RPbVpYeExmenY4WXdKOUN0MVRRcDhUSTArRTJnQXpwdHl2OFljaUJGSFNvZzFlTU5xVnhhdzZqM1ArTVl3NXk3cm5jdFJxMGgzWmNIMklrenZiL09KalJtNWRndFNXb3RtRkoxRHhPQ2RvRWtyNTN3NkErMkpjMHdYTkZrZ2xWL3FVWHZ2NjJIeWZMR0FmY1lyYStIMGRLZ2hHYnhuOVhLMkdRZlF2RnlXU2RXcGhKNm0rQ0lnbmhsRnMvWGNpTzdCVm1EbTVFZW0rK0F6UHN2VnpXVm1KQ1VhUWpTbzJYeUU3K3VBUDZDYWVmYWlDTXZScEw0cERrU3dtQUQrMk1sWUxvcVRpTmRoU0N1QWpNb0FBL1NZbXg2WUtnRlRhRDZIR2FtUlIxeVZJSlVxQUIzTHRMZUZqaVRnbXpmbFl1ek9jclY4eitjZFprRWpWWWt6ZjZqK01NbHhGYnZZTjNncVU5YXJwMGdzZXA4UkFOdWVHRktLaEQxYWFsbTFNYlFBQlk0WXdHS3FJV0RsZ1NTZkNBZjN3NFQvLzJRPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL05ld3Rvbi5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBWkFCa0FBRC8vZ0JZUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEJ6T2k4dlkyOXRiVzl1Y3k1M2FXdHBiV1ZrYVdFdWIzSm5MM2RwYTJrdlJtbHNaVHBGY25kcGJsOVRZMmh5SlVNekpVSTJaR2x1WjJWeVh5Z3hPVE16S1M1cWNHZi8yd0JEQUFZRUJRWUZCQVlHQlFZSEJ3WUlDaEFLQ2drSkNoUU9Ed3dRRnhRWUdCY1VGaFlhSFNVZkdoc2pIQllXSUN3Z0l5WW5LU29wR1I4dE1DMG9NQ1VvS1NqLzJ3QkRBUWNIQndvSUNoTUtDaE1vR2hZYUtDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2ovd0FBUkNBRTNBTndEQVJFQUFoRUJBeEVCLzhRQUhBQUFBZ01CQVFFQkFBQUFBQUFBQUFBQUJRWURCQWNDQVFBSS84UUFQaEFBQVFNREF3SUZBUVlGQkFJQkJBTUFBUUlERVFBRUlRVVNNUVpCRXlKUllYR0JCeFF5a2FHeEkwTEIwZkFWVXVIeEpET0NDQlppY2lXUzB2L0VBQlFCQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQveEFBVUVRRUFBQUFBQUFBQUFBQUFBQUFBQUFBQS85b0FEQU1CQUFJUkF4RUFQd0JRVWttU01laEZCWFduSkEzR2NmTkI4a2dxUG14NlVGMjJ5dUJ6SDBvQ0xJVW9pRUpMV1pQSi9MMG9KSFd5bVpCQ2h4M29COXduRUdlZnlvQXQwaU05cEp4aWFBVThrZ2trR0p4OFVGZm1FaUFSNzgwRmhrS0NRck9QYjlmK0tBbGJrajBKNGppZ3Z0RGp0R01tZ3NKRW9BZ3ljbVQrMUI2Uk9BWVB4UWVFOHdvK2FSSVBKOUtEeE1HREdGREJCNS82b0s3aVFVSzNBUVU5K2Y4QU9hQ3V0dFU5eUo3RCtsQkE4M0luaWU0eUtDcXRzQVRQZnQzb0lGSWdTSndPL05CeUJBd1JIdFFkSk9aUGw5ZTgwRXFmS21CejZpZzdURUVBQ09QVWlna1JBVk9jRGtmdlFTaEpJSFBGQWFTZ2dtZVQyOVJRUkxRTWtISEVIMW9Jd25qTXBudUJRV2JZSGNDSUhwUUZiY0pDVDhpZ3N1TWdnN1lqZ1FPOUJSdUcrZDQ0b0JGNndjakVUenhRQnJ0b0lCVW83WW1WSGlnREsxQ3o4UUR4MEdQU2d0Tlh0bzIwZjQ2WWlZU2MvVDJvSVd0ZVpTdmEyZ3JRQi9OeFB6UVR0ZFZOb2VRSGJkd0Evd0F3emlnbGU2dHRtc05OcVZqNGlnNFBWckRxVERiZ1VSamdqODZDemE5UjJwUjVnc0VaeU0vU2dtWjZqczNYZzJqY0QzVUtBcTA2MjhCczJ3UjY1OTZEbDBFZ1FBZHh4dG9LcnFKVEtJUHhnMEZkYU5vSTRCejZqNjBFQzA1L3NhQ0ZZUGVNOXFEeE1nQTVCbmoyb0owem5IOXFDUUFrZjE1b09rOTVHZTBVRWdCSXlpVDY4VURGdGc4WjR4UVYzUU1FeVQzL0FMVUhBVHVVVGhSaVNNWm9MTElJR1RPTWYyb0Nkb0UvekFjakV4SW9DQ1U3a0JLb3lJSkI1UHZRVXJwSVFONjhKZ3lvd1A4QU8xQWs5U2RTMnVuclUwMy9BQlhPQ2xPUURGQm4ycDYyL3FpeWwxYmdRUDVCaE5CU1d3bElUc0JVWTVKNHhRWFdHZkViVnVDdDZZSVVrNTk2Q0I5cGV3RXFLZ2V4b0lXWFZCWlNvcEtTSkJKajhxRDNVQ1VvYVcyQUZvNWp2UWNzdnR2K0pLZHNKay84VUU3ZHlHVHRjM0JCd1lQRkIwb25jQzNKVHlTUDNvSm1kUnZtQ2h4bDFhSXhCTkFjMHZxcDhPQVg1U3Bvbkt3bklQclFOamJ6YjZFdU1rT0JRM1lFaU9lS0R4eHNBS2o1b0s2bTRqY08zUEZCQ3BCZ0VIanZRUktRQ29aejM3VUVxRXhncG5PQk5CSUNBQ1R6MmlnNkNUSHNPS0QyZHVOMGZwUU14RTVIMDk2Q3E4bVZBQ0NEM245cURrSm1JTUhqRkJaYkJnRVFwTWN4UUVyWWdKU0ZqbkI3UWUyYUFYMVAxYmE2U3o0YlNmR2ZQOG9NQVk0TkJsdXFkVDZ2cWI2ejk0V2xCL2xRWUE5aFFSV2VtWEY2MHR4aEVrRFByUVRNNlg5M0NnNjNLNEdUMm9DSjBWbEZxcGVWSkEzS3hsQVBlS0QyejB4U3JRTkZLUXBVRko3a0UvNWlncDIra08zS2xrd0dHU3BNKzR6QS9LZ3BQNllXcmRiNlc1UWx6d3lUNitsQkUvcHEzOVFGdTBDcmFONUtSeDYvMW9BempIZ1hSSU81VXlKd0pQOEF4UVhHMkNvSUpRclA0b0hhZ3JPaGFOcFRKU0ZiWVNNL0ZCSXRZOEFrZWJnaVQrbEJ3SE51MUpoUnlTazl4NmZTZ3ZhUHJqMm1YQUVxVXhNRkF5STlSUVAybGFwYlh5ZHpib24wUE5CZGNTcVZUbnZBb0lGSlBwamtVRVVDWmc0N2pOQjlQa0JJajVvUFJrRE1qaWdsUW5IR2FEc05qTWljNGtUUU1vR0JHRDhVRUMwU2Y5MUJ4czRCSEg2VUZocmFDSklvQlBVK3VEVExGVzBqZWNBQXlUOENneDIrdjdqVWJ0VHptNUtDWWdLSklvR0hRbVVrQkRwYXVFeElXUVFvRDhvUDFvTHptdWZka3VNb1FsSlNaU1FPZm4zb0I3R3NPWFNFb2NXVkxra0ZCR2U5QmN1TlNOcTk0Ykx5VnQzTFlhVWs0SkVnajYwQTl6VlhVdmk0YThuZ2dEQm5hb0V4UUhiWFZWVzYrbjdVN2ovN0huaUZjcVdPSm9LbW0zWmRzcnhOMFR0SktvSXlGSlZIUFl6RkJmdjAvY0w1RGpDa2VJODIyeUV4SWxaZy9vYzBBWi9UbEt1QTYyZzdYWDFCS293UUR5UGJFVUVUek8xaGV5VnVyVkFVQVlTUFFlcG9LQzdQdzBueEVxM25tTUFmTkJSY0JMS2lzUWtRb1JrbjJvSTFwVUxkdFJUNTFicGdTWS95YUN1b0ZSL0NGRUg4Y1VFOWs4NDAyZkNWdDlGcFBCb0hQcHZxTTNFVzE0Q0haQVNyc2FCbldrVE9EUHFhQ0pTQ0R4bjhoUWNnS0JQb0tEMU9USkUwRWdQR2UvYWdsQUI1VWZ5RkEwYlpCRUhBa3h4UVZsa3pJSVBZQ0tDTGlOaDU3VUhsdzZpM3RYSDNQS2hDVHpRWkwxaHI1MVM2OE95Q29TUE91T1Q2Q2dIYVRhWG9kUzRiTXJha0JTdWFCNzFIVWJmVDdKRFNiRnJZdElram1hQkUxbTRSZHJVdGxJQ2daeHpRQzdmeEUzYUNoTzFXN2djVUJlMVN1NWRRbmFWREtodEdab0NscG9keStYUXloeFFkMm5hY3hRWDduU0wwcVozdEtTdHVVajJ5UDFvUFh0SHZFdnFSa0QvMmtBK3BtZmZ0UVhkWWFkdU5TRG9iY0xWdnNDQVU1a0k1OTh6UWN2aHkyMGREU3lwdFMyaXNyd0RDdVAwR0tDemIyS25uN1JwVFlDa29TbExSRUpRQ01KUHJQSm9PZGYwa05LV2xwb2xsTWxTMGlBcUlCajJrd0tBT3pwRFlzMm5IVnd0Wlc0bEl6NVJpWTlPZnlvQkxsaXE2ZTJza0VoUG1Qb0IySHhRVkxobExDUWtlYWNDRGtqdVlvSUhQTGs0UFlSSk5CNjByd1Z0cVFsWk05anhRYVJvbDU5KzA1dFpJS3g1ZmlndkVic2tFanVhRGhTZlhNZDZEbUVnaFU4KzFCSWlZaUlOQktGWTh4QVBlUlFNem9Pd2NHQnh4RkJYV1JneVA3MEVEa2lBU1BURkFpL2FMclNtOXRpaFFBNVhRWnR2SzNnRWdrVE1BZHFCejAxNURWaExxcnRySFBhZmc4MEFuVU5aZlU0RUp1R3JscEJJVDRyY0ZJOUovdlFDRlhMN2lsR1JITUpBQS9TZ2FlanVsYnJYTGdBSWNRM2lWcUU3UlFiUm8zUUZuYjJMYVd3bER5UVZGYWt5VjBEdG9uU1ZvMlVEd0VFRkJuR1VudFA2bVJpZ0tYM1NWdGVKY1hjSVBqSlJJVUU1QkFqTkFDWDBPVUh3d3VWTEFUdFJuY21aTWs5OGNVSEZ6MEpidDZXbFphOFM0VW5jcEdVbmVTWVRIMUg1VUFXLzZMOEJkcXEwWVM4K2xhUXBMaWNiZ084NEl4UUwrczZMZTJkdytMdHQ5YWxBNzFxUDR5cnpLTWppWi90UUFkZWF1WFcyd3duWWhLZG9TQkc0Z1JKSGFPQUI3bnZRSTE3YlhvY1dwYWxweEJVSjRpQVBpS0N1RXV0dGxsS1ZURVQ2anNQaWdwWEhpU1ZxQUNqR2QwNDlQYWdxSVhJVkNTRDY5L3JRY2xhZ3NrQXAyNGtpZ085TTZrcXp1Q2hTd0czTUVHZ2ZVS0NrQlNTbFFWa0NnOVdaVnVTWnhQTkI0RXdNeG5NK3RCSWxPNFFjZTZ1M3hRU3RKT3dRU24ySUpvR05hUUV5ckJpQm5Kb0s2d1p4QnpHVFFWSGpEbVFNZCsxQmkzV3I1ZTExOEZVZ1VGanBhMmFGeUhuWGtpSUpFWm9ER3YzU0x0T3d1SjJ4NVFtWm9GOGFXQ3lwMXhLbEo0QjNVQm5vcnBiL1hOYWJ0bUF2d3dyenJpQWZqdlFmb2ZwelNMYlRiVkRGb2dxVHYyQ0QrS09TZmJ0UU91bjI0S1A0dTlLY2Z3eWlCeHdQZWdNc3RFb093UW1Od0p6MnlQU2dsUXcrNjJYVkpjS0V3WkU5L1QwL2FnSVdxRUliS0ZUNVJPK0pLaWYzL0FPS0NLNmlVbFcwbmdnNXgzSS96dlFWTHRMYmpZM2xTNEFNbkNnUFRGQUl2ckFYRnUraGJiYVlsVzBDYysvMTcvTkFwdjlLV3p6cndXZzdqd1JBZzl5UDI5NkFkZDlDTnc2cHJMYXdrbzM1anRQeFFKMnU5REJoSG0ySlVDVEhBU2FCSjFicHNzUUV0NWlaajk2Qk8xalQzYk9WcENnZ0gwNDlqUUJXM25DNXRWazlnZTlCWXQzeUNKSlNmZjFvSExSdFhkYWFTMnRKVW1QWFB4UU5OcyszY3RoU1JCNDIraDlhQ2VQd3lEN1pvUFcwYmNRbkk1bm1nc0ZzVEhjZXhOQXhPSVVXRElPU2NlbnZRVkhSdGpnL0hGQVB1QnRqYURKbVBlZ3h6cXEzUU5hZEN5c0xKL0NrWm9MV2pXeUdHOXkwT0lITzQvdlFkcGJaZXVraGFpVVRnSHlwSHpRRzcyMmN2RzJiYXpRcFRJTUliU09UL0FMbEg5aFFhejluR2pOYVJvQzMvQURCMVhsVXRJMmxSamlhRFJOQ3RnNEV1bEd4UklBQk14NmZGQXlXOXY5NGhLUkNqbFNpU2VEenhRTU9uYUtGTXk2UXBSR1pFL3dDZlNnSkN3Mm9BQVFERUdQU2VLQ3ZlV0pWdEtWSmJDQitIakh2UUJyMXNKVXBDRHZBSlNSRW5pZTMxb0F0MWRTaDFLZ1E1dUVBSEtnWXdSL25GQkpwem84RWxRVVNvN3Q0aVRuazBIeWloRzVhMGZ6U2xJRUFqMG4wNzBGVXZxRnVvZUdGU0FkeEVnREp4N2lSUUFOV1pTNDBrS1dDNG96dENoSkg5b29NKzFlM2JMaWp1YmpkeDZlZ2lnUjlic1dYRnFHM0hlZWFET05TMDFWbmRLU010N29uMm1ncnJDQW9JV0lQcEhOQVJzTGdvYlNpUVlPSnppZ2NkTmZCdGtyeGdUam1nWUdWQnhDVkNmd3lUUVNiUkVFUlBJOXFDY1FRUC93RFVVRElFbndoRW1NVHlmeW9LZHlCbkhseG4xOTZDbW9UdUVRcklBb01jNjV0M0dkVlU1QkFLdDI0OG42MEMrTGg5ekhpT2JKQTJoV0tCcjZZdG1uSEVMdXY0aXVBay9wUWFMMDdwcmR6cWpyVDEwcTFaUW1GS1EzdU9PQW4vQVBJbkUwR3R2V2pTYkJsdGxJOE5LUWlDaU54NUpIcjZmblFIOUZiMjIwSkFJQlVGU1o3Yy9sUU5PbElTeTJnQW44T1NKelBvUDYwRFJaTFVwRXEyaEl3QU9BQlFXRnJTbE1uSW1ESGI1b0tOOHR0ZHVyWnNXRTVnQ1Q4VUNicVN4S2lRcUFQNWxBa3BQZjJqRkFCUzhwSUN0b0NYQi84QTE3VGo5L2VnbXNIZ0FzQmxlNEFJQ3lSdDVJSk5CWnVkaWk0dEVTTnNxS3U0RWZ0UVYzMEtGZ1ZKSUtZaEtRZDBBNHo4VUMxcUZ5dEtuVXZKMmdIQ0VpUUJFSDRNY1FhQk8xUlljM3BBQUtvbjFVTzJLQlExTktrcmdDQ2ZRekFvRjdVN1ZEb0lnN2dtYzBDZmZzZ0svRG50RkJVYk94Y21PY0FtUHBRTTNUN2lGSGFxU2prYlR4UU8rbXFKWjJES1p4NlVGeFNjNGlEUHRRUzdTc1RQNTBETUd3V29na0E4QVlvS053a2dGSUhNZ2tIM29LWlNaTVNEUE5BQTZpMHl5dWJSeDI4Z0pRbVpJNG9NZnUzR0UzS3ZBU2R1UW1NUlFGK25ueXkrMFZMZ3RqZW9udVJ4UWJQMEZjN2tHNWNUdldrRmJpems3ajIvek5CcGRpOHAvVEVlT2xLVUxNcFJ1RzZZNUh4NlVERnBEcFdoS2o1VW5jbFNKNWdjZTlBY3RIbFc1RGJ6aFFTajhlT0l4SGIybjJvTHJMN25pa2wwU29DUk9QeUh0UVcxWGltRzRRaFFWQkNTUUFEN2lUUVVkUXVGcW54RlFsc0RJWGsvTWQrT1BXZ0IzbHNraEo4TlNTZnhHU3BTQjJFSDIvZWdDTFpPMGhhenQzRUpiVUFjRDM3U2UxQjdhS0F0RWxMaElDUEVBV21keVNRSlRCekhwUWQzUVdoWkhpTXZvVWhPMEFLUkVESWdqSHZRREg3c0NXM1VHRkpJbE9VbU8vOEEzUUNYNzIzVUZwU0V5cVFuY04wUWNmWCt0QWwzbDJWUG5HRmM3czU5NkFMcVcrZHZtU1FKNGpIelFBM2dTNXdSMm9FL1dVcERpb1ZBNysxQUhXdmVRQ3VmOTNlZ09kUEpRdTRRamVZS3N4NlVHcFd6S1cyb1FJUkgvZEI2dEFNKzVqQm9PZ0RINGorYzBEVXdpV0FvaVNZVU00bnNaL09ncVhLTW1jcEVpTzMwb0tLd0VraVBuK2xBdWRlV3o5eG9EcWJVeFA0ejNJRkJrRExLRXRLOFFEeTQrdEJMcEtsS3VRVEVMVUJIYUo1b05rNlR1RXBhY2JaV3BlK2VNQ0JnbWcxZnAxYmFyVUtjUTB6bExmaHBUSlQyait0QTBXYTF0UHA4aWxwd25hckVIdG50OFVCU1NwS3dvK0tTa0pJQ1lBQStmMm1nbjB4MWU5S2toTFlWNkdBb2NZeFFUTGNjVWsrSUZyY09GckFLaDdBR01VRVl0blhtRXFiYXVGN1RCQ1VRRmsvUGJJb0s5NWFYTFlRMHUzZGxST1ZEZGlUQlZuOXZTZ3BPVzZ3MXVVeGNKZEtjd3lTbm5rbWN6aWdIbTNRejRvSzNXdjVWS0tTbFFqUHdjVHhISW9LdDI0aTRiV2xMNk44QklSSmxKOTU5WTRvQmQ4UWkzOFFQRnNLa2JRcmoyajU5YUJXMUlodHNxVUVGNG9rVHpNOTZCYWNSdE1wVW80SDRqTTBBcThkVzRvOG5Kd1RnNDVOQUd1eVVPaUNQaWU5QXFheENubEFwbU8xQURjQ1VIZHRBQlZ5TVJRUG5RK25Odkk4ZDNDazhHZ2V0b0FLWUdQUVJRY0tPVlJ6ek5CNmtZOG9GQXpXaFVZQlFEN1J5T2VQV2c1dVpFbEpramt4UUMzMXlza1lJN3pJb0s5MGdMc24wa1RLVEFpZ3hWU0l2cmhsOEsybFJJU252bWdyMjVVemNrZ0pTbHN3a0RpZ2Z1a3RSY2JTZ0pqZXBQaGdBeDNtVDYwR3A5T1hTZ1VJU2h6d25WYlZxakp4bjRtZzBpeFZ2YmJXaVF2WW1UNGdVU1FlL2ZraUtCaXN5NDRGYmZESVNUQkJtYzUvSThmV2c4YXRWSWVCQkRwQk1CV0FjL3BIcG1nWXJFS25BMnFncW5kajZlMUJiU3lQREJDdCtkeDI1bWdyM05rRHVlYzJLVURnUlBsL3FhQmZ1MjByS20wZ3BDTWJTdVQ4SzdVRlpwb091TmhYQ3VRcFU3VEhZVCt0QlMxT3pVN3VTNTRhOXAyZ0hnRGlCUHQ5ZmVnVnJ5d0FEUlNvbUJDejRoSmNCd2VRZmFnWGRWMDd3Q2x2YVNwUWxRVU00UHRqaU0wQ3pxVnU0Z0FLUUFDRHdjZ2ZYbUtBSHRLblNwWWlKbk9ENzBDL2ZxQldvaUFmVTV6UUtXckU3MUVSOFVGYlRMWDcxZXRzQ0J1RWozb05UMFN6UmFXYUVBa0tFejgwQklFOEdQUXg2MEhCTVRBR0R5T1BtZzVYeU55aE1memNtZ2I3VktRNHJjUzJtUUpPZmsvNTZVRWQ2aUFaTVltUVNSM29CanlVclVCdEFIci9uN1VFU2wrR3l0U2h1aFByUVlucUNYTHpYWDFOa0lVcFppVEFUL2FnaWVzM20xSFk0MjRrY3FRb0hGQWU2WWNLRmxUWkIyckVmMC9XZzM3cFd6LzhBNDFoOVFCY1VyZXRmSG1QYzl2YjYwRHJZYkxnRHdtMHdXNDNEK1ZVOEh2R2FCbTB1MEFiU1BDQ2tKVDVraitYMUhKOXFBZ3hibEFHQ2hKQlVkOGhRRVJuUHZRRjdac29VQmlDQVJJNC96MG9MWUtTREVHT1lvS2VvWExUVnM2NDZwSlFrSENSSk9LQk9XNGw5VGlWcTJncGs5OXg1N2R2N1VBKzB1aTVkdCtPb0pZaVU3aGtBUUlqOWZ5b0xPcnVsYUZRNmtKVjVpWUFnL1R1YUFEZkpQM2RDa0JlNklLRUF6OGV4aWdWOVplU2g0cGp5UUJBa3hqUDU4ZldnVkx1WFZFS1NvRWNTUVlIYjZVRlYrM0xiU2lHNGpCUGMwQ1ZxSTJyVUJHU1J4UUoycy93M3N5Y2ZuUVh1aXJmeHI3eERNSU1ITW1nMDVKRzBad2VCR0tENEZXK1FlREVjVUhpNGtlbnpGQjdDZjVvbjNGQTdNS1VYU1ZrYmlBcEo3L2wyb0k3dGtKaExZVnRIT0JpVFFDMXRBS3dsTVNUSEdCNjBGSFZWK0RZdkxRSktVayt2YWd4aGxMRnhxRGlyMThzTWxSSjJwSzFINEE3MEhONjBsdThiTGFWSjNDSVdtTWVwb0dYcFcxS243Y21OcXdZSVRHSjVvUDBiMHRZSC9TTGZ4MEFia0VnL2lIT09mZzVGQTAydHM1NDIxQ1FWNFVJQUlTZVNCMjlhQjAweTJEVElXc1pWa0VBVDdnVUV6bHpiSXdvb0t1VkFpSUh3YUQ1V29OYlQvS3VBUU5wSno2NGlnb3VkUld2NFE2Mk1rQWJza2UwVUFxKzFxMnVHWEEwdEcxcE9kc0VwUGJ2ajYwQzJ6Y0JkNmtvUWZDVUNkcVZRRVNZRVR5YzBBeTZmUXU4U0d3b1J1Qk01ajErbUtDNWUzU0Q0SmRBSk1IY3ZPUmc0K256eFFWTGg5THJUNmtyM29SSkNtekczM01jMEN2cWEyMXZQQUFMZ2dPS2pjZTNQcFFMMTU0bTlaRGEwQXFKSEg3L1hOQlNkUXRMU2t5U084bjhRb0VyV0JEeEtqSmt4TkFtOVJBSmRiSkdDSk0wRTNTZHlXcmhRU2Z4UU9PYURVTEJLbE1vVVZFejlCRkJPY2tUM1B6RkI4cE1mcm1nKzhNbi9BTDVvSGRLRWlGSlduWXJ5ekpnK3RCMWRBRURhRHhnVEVlMUFMV2dOa2xJSjNaZ0Q5UDJvQjk2QThoYmFvSUtZSUovcFFZeHJsdWJiVTMwS0JDaWNCSXdCUE5BUFhkS2dwZTg2NGdMNEk5cUIrK3pKMU56MUpZMjVWdjNKQ05vbVNBWmlnL1RtbHNPS1pLRjdVdXRFbFEyNGowT2FBZ3kraXhsWlR0am5jWVNFeEorYUN3OTFPdzFicDhPNWIyNVVBWlNjQWtuOGhOQWtkUmRUWDZMMjh0ckFYbDNxaUdRN2NOQjd3R05QU1FOaHVuZ0NVcVZNaHBIbUlHU2tHZ3hmcVd5dk5RZFUvcW5WV3RhbGRrZWNHNUxiYVNNRUlTQ1FFOXFCYVowL1VyVUtOanErcDJwSTRMeGNSK1IvcG1ndjZWMWZybWozemR0ckNBdnhjTk9BUzIrQjZUM0hwUWE3MEZyMyt0WGpTMWtLOEJKV1VCSmdSKzJjeFFGTDI2VzVjSVFIWWNVRkVyS0RMZVFld3lLQkk2bzZsY3RHa2tLUzJVYnNvOXlLQmZhNnExWFViSzl2N2R4aTAwMjJVbHR5OGZCaFRpaEtXR2tqTGp5Z0RDUndKSklHYUJYdjdQWE5VZFU5cXQzZHRxY3lodEtna3dlQVNNZmxqM29QYlBSYjVodEJZMVRVV0d3SlRzdVQ1UlArMDROQlllMWpXOUZDRmFrNm5VdE9Va0F2b1R0V2ovOEFZZHh4UWNhamZ0WG9TV0NDQ1FaUEo5SW9FN3FRZitReW5FY0UwRnZwVzJLN254WUJLVjhHZzFWcElEQ05nQUJFQ01Zb09ramFreVJudjZtZzhNd1A2ZDZEbVBjRDRGQTkyUWxwWThJYkVqYU9QM29QcndBR0FNUVBjbWFBUmRySVZKQWxPSlBiMGcwRmJUTEp6Vkw1RnMwbnpLT1ZUSHpQb0tBUjF2MGF5MjI0cHU1U0gwbU55WlAwbnZRWjVjZEYzamFRNDQ4MjR0dzRTRGswRVBUOXlPbHVxV0w5ME9pMnQxZnhrbzh4SU9QTDYwSDZpNk02cjZmNm1hYVZvL1VXblhGMHBJRGxvNHZ3WGlJRXdsY0V4N1RRTTNVSi93Qk9hY1c2MHBiYVlRR051VkdQNWZuMDcwR1c5UjNONVkyckYyMit6Wk9YVDMzT3hUY0xraHpKVzZvWi9odEpCV29RWklRbnZGQUN0dFROdWxYU1BUK25MMU5kdXBUdDVjWHl5UEVka3VGNVFRcVhTUm1WUjZSUUlkNzFJODQrdzFiTzJEUnUyeVMzWjJJYVVoVThLVXFTWjV4NjBGZmZldDI3TC8zcDBwZEJKYWRBSVVRWUlCSEE5NkMwOXA0MWUyY3NsYm13OGtMYUtwL2h1RDhLeDljR08xQTEvWVIxYnBhL3ZtbVhtblhiK3ZyYVVsbHRKYlN3c2pCa2tnaFdmd2dHYzBGWDdRdXR0UzZiMSs3MFpWanBuak1wU0ZHMnVGT0JNakFKR053NGp0UVovcW5VcU5lV3czY3JWcHJTbkVwZmVlUnVTMkp5cnkrWlVETUFTWWlnYVd0WjAxTHFYdFB0MXVhVHBqUnROSFl1bFFvcVgvN0xsd2NlSTRxVkgwR3hQQW9CdXJhaGR1cnZyaTQxSVcxNHlaZGFVbEtVbEoyN0Fqa2xSa3lEakF6UWZhWTVxZDVhdXZJVTFjRzNLU3ZHMVJTcmd6L3hRR0dIYmU0WjNOdG44QjhSdGNGSkEvZjNvRmU4dG05SjFaeXliWE51NDJsKzJLaGtJVnlqNkVFVUN6cmo0ZXZFaHRNaEE1N1VCWG85OEM4UzN1aENza2tUL3dCMEdvMjZ0N1lJSGxBd1lvSk9jWi90UVJ4UE1SeHo3VUh4T1RnSC93Q1VVRDVZVDRDZktsTURJU01UOC9sUWNYUGhrRHVvWUozUlArZjBvQWw4c3FVRXFJSjVJRkJRMVMvZDB6cGUvdWJaV3k1WC9EUXBJeUNUR0tBQnBUZXRpMlNibHh4eGxaa2xablBlZ3I5UVhSMCt6V3BDSnhnbkZBWCt5UFJtTmFTOC9mTW9mV1pDVzFDVTVHVEh0UVM5Zi9ZZGFlSWJyU25GV1FjUEJUdlFrKzZlUVBjY1R4UUp0emFmYUxwblQ3dW5XTnJxdHcwTGp4QnFGbmR2dmp3dHNCb0FLaEtRUnV5a0s0N1VCajdJMUs2bSsxNjB0TlgxRyt1Ykt5MDl4dTFSZktTbFNOaVVrdHh3a0V6N2tjNU5CK2tIMkxUU3I5ZCsvcEtIN2hSM0p2TlBZU0h6TUJRVUlnZ2dBUWNZb003NnI2VTBsM1ZYcnF3LzFTeFE2bGFnd05QYlVsc0t4RGE1OHVjZDQ3VUNocldqYVo5M1MweTNkK0doS0VwU3ZhMEk3bnVTY1ROQXpkRWFQWVBKUjRhQTR0cHdsUlc1dUtBWXhIdVpqdHpRWmg5bW5SdXE5VGZiSDFEWWRPM1NkUHRiZTR1azNONHBoTGhadHk0cE8xS1ZBamVyZ0hrUVRPS0RlOVQrd1g3T3RNMGRMZjhBcEZ5N2NCSm03WGZPQjFSLzNHRHRCK0VnVUg1ZCswenBaSFMrcEZ1eWVjdWRNZlYvRFU4UVhFSC9BR3FJNXhNSEhCb0N1bmFXMWRXalFjdUZNaHBTVlFBQ0ZEdk5BZnZlbm1Ma3V2bDRLZFVmRFVyd3Q2Q01RU0o1ajBOQVgwYlRkTXNMTzZ0WExsY093RnVJUnRMMEE3VWdIS0JCanZRRDlYc20wUEIyMGI4TmtOcVNFcEVBSmlCUUxmMmcyVENkSjZkMUMrVzZocE53cTJkKzdnRjN3aVVySlRPQ3FDcUFZRkFrM1NTTHE0RFNMbjdvcFMwc0x1R3doeFNKOHBXQmdLaU9POUFSNlNZOFhWR2tLUDBvTmRRMGx0RUpHQUtENVhmQmo5YUNOV1FUK1JvT0FEMjIvVk5BODJTQjRaMi9pSnlESTRQYWc1dVNvZVVEOFluaWVhQURmcElKVVp6SjI5dWMwSERkbC9xdHNpeXdkcm02UFFZLzVvTlQwelJMWnhiZGxjTklGb2hvUVZKbURIUHNPTTBHTi9hVHBTcjdYaG9lbEZMamk4TnRwa242MEJYN0dtMzlJZmNzTlFiVTArbHdoU1Q3RHRRYnlMZGkrWVI0aVF2YWlWVDJuMVBjL0ZBcGF2MDg5YlhxcnF5M2JTcmNTa1lUT0NreDdkNW9FejdUMnY4QTdhNmg2WSswVzNaU3A3VFh2dWV0TnRqenJ0bkpRbHhVY3dGRkU4eVVVR24zL1VLR0xFdnMzQ0ZXampLSEdIVUVGQzBrQWhTVmd3ZWFCWTFucTJ6dDdkYmxvNFgzVlNDbitRbmljKzNwUVprNnpmNi9xcXdwQUMxcUhrVFA0UmdUNndQV2cwTkZqYWRIZEozK3BYenFXclRUV2ZIdVhDWVU4NlAvQUZ0aU9DVjdRQjlLQzUvOU5IUzY5RSt6NWVzNmtpTlYxOTgzNzVWaFFiSlBoajkxZi9LZzFUcUMyVGM2ZVZLRTdlUVJPNEhFZnJRZmovN1VOT1E5cU9wYWVCQ2xTcHNrNUNod2ZiUDcwQzkwRTRMeTJRdENVbTRiRzFZS1pLRkRIMG9IQzNlWFpuK0xiQjJRZk1EejdtZ2djdldGM0NVK0VVcU1GQmdKZ3p5VFFlTjNGMXFPb0l0Mld5dnhGQktpa2hRU21jNUZCUjYzWkMrcDAyc0pVem83SXQ0S1lBdUYrWmYvQU1rZ3BFK3A5cUJPNmdRVnZzVEpJQm4xTkIxMFd3bzY3bEpQYkZCcUtna1JrRXpHUDZVRWFzOEFlblBOQndwSWdnbnNUbWdnVU16eFFPMm1IYVZUL3VNa0dTbzhrbk9LRHQrQkFNWlZ5ZVFUUUFyOVU3OGdDWTlTZlROQjcwdTZVNjdib2tBT0VwUFBwUWF3KzhXTEhVSGo1aTAzMi9jVUNqOW5HaEt2dXZHOVl1VW5hdzBwU053NVVhQW4xMVlvczliczlUWlNXbGVJcExwbktpTWd6UU5tajNZVzAyK1JHNk44S2tHZjdudlFGdkVTNGlWTFQ0WnlkcHpnY0g5ZjFvQXV0bTNldFh2NFRMMXZjdGxwMjNkU1ljYk9Gb1VPNEk5UFkwR01zNmZyM1JEZHkxb2xnOTFCMG9GclUxWUwyTzNsZ25rbEFrNzBjNGlmZ3lTRkYzckxwclVsdWVOMUExcHp3a2xtOXRYbWx0cUo0Z0FqQWs4ODBEWjByMXYwTm83SlZvYnVzZFMzWUFTNS9wbW1PcTI1UEtuUWxJR2MwRkMrdXRRKzFickhTOUR2MkUySFRsazc5N2QwOWgwUFlTTUY1d1lXdFJrUVBLa0U1VWNnUDBtMHdHbXlFSVNnL3dDMUp3QjZVSFY0bmRwejZZM3kycUFlK09LRDhmOEFYN0xuL3dCeVhEcTBrQUtLVkVtY0dnenRwRi9wT3EvZjlFSVJjakRyUlBsZCtmbWdhVyt1Ylc0S1JxeURwdDByYnVRK2c3VEE1Q2dQM29KTG5xTHAwZ2h6VkxVaUovaElVcFJKN0FBR2FBOW8vVWorbTJEaXVtZEdYcHkzQUVxMWpVa2p4ams1WXQrQjdLVVk3NUlGQXR2SlJiMjZVb0pWRWp6S2xTaVRra25ra3lTZTVOQXRheVFoOXRSNG5GQWQ2R3M5MTA2K1I5YUIxV0pKQTlhRGhRMm50L2FnalVCQmtaNCt0QkVVSko4eVRQdEZBN2FjaGFBVkVFcFVqZGhPM0VBL1dnOXVvQ0RpQVkyNXdRTzQvT0tBRnFLbEtBS3NFOGpuMW9COW83NEdvV3pzZ2JIRW5keEh2UWJRMnliN1RubWs0VTZFclRPRCtRNTdVQjNSclZ1MFpiUWhxVkpFQllUeDdVQzExZ3Y3MWJYU04wckdkcVU1U2ZRbnZRQU9tdFNMVnVoQ2x5b0xnbmdUeGtuam1nYVhMc29LMGdweklBa1I4VDZVRUxWeWwxL3duRkZhOW9TTm1UUGJiM0E5NkNyL0FLR1hGZUkyRWtoUk8zempJN21JeHorbEJ5K3hmTUljVWtOM1RzN1p1V2t2Q1lFL2lFMEFYV2hxdXFOT3MvZm4wdE9oWGtSTFRlMGovYndDQ1BUdDcwRGw5bS9UbG5wUmVOczJuN3c0MkZLZHllNDRvTkZXUzIybjM1OTZEeTJVSGJZY2tHUk04MEg1MCsydXdGcy9jT3RvU0FsUWtnUlA5NkRIbVdVdlhJM0FnS0hBOUtBd20xV3lsd0xDVnNxZ0FMQVVQeVBGQmJZVWhzNzIyV1dsOGVJMDBsRzM4aFFWdFZ1MUtJS2dQdzRnN3NmSm9BVHJ4VVR1OVRNZnBRQk5TYmN1YmhKQVZ0VDNtZ2ZPaVdkdW5TUVFWRHYvQUVvRHhPSjllOUJId1A1aDJJaWc1SWtnZHlZajFvSVZwazRKL09nY05IVXFZTVNtZWVmd2o5S0N4Y29NRUpUa3E3OXpIZjNvRis5VUVrSVZFSzRqOHY4QVBpZ0V2Q1pQNjBHbmZaOXJ0dGZzczJWKzhHYmxrUUNvNGNIYUQyTkJvaTFYbGt0U21YQXBnakc1TzRURXhRSWQzYjNMYlY1ZlhiZ2g5d2hDUWNSUE5BdjZHMkVPdXFiamR1bjBQZWNlK00wRFhkc0xWYm9VRmJRRWJnWjVKT2ZpZ3AyRjI1YjNLbExTVXgrQ0hRZU9KUDVZbjJvSGJUWEcwTm5lZ21FU0JQbW1lTTRvTGQ0eGJ2MjRDa2xPTjUyNVVENlVDcHExd3hweWdHTnpyNFVRRVFDcGFqd0RuMXpFK2xBMmRQclRwOW93MDZvZUp0RGpzaVBNcm40QTRBOXFCaWRkYlcwU2hhU09mK0tEdmMyeTF1S2dsSnpKNzBHRGZibGNXN2phU1ZsVGF3WUI3bm1SN1VHTTcyaGFXVGlRUEZTU094bFBlZ1AyYUM4eG1ET2VNSEhFSC91Zyt1YmR0aEtsSlVWSklBVW84LzRLQmN2aWplUUFRUFVpS0FZcFVOckpJQTdSNmlnNDA5UXVtZHVDdVk0b05CMGUyKzU2YWxJNU1DSjdVRXErWUhISW1nOElHMENJeEpnMEVaQkhvTzBSUVJrZGdQbm4rbEEzNlUxNFFPNGxLM0ZKV0VRVlRpQ2FDeGRiQWxSVUl6R0U0STkvVTlxQVBlb2xSNDJqOG8vcFFCbld4Smc5L3dBeFFRdFMyNGxiWktGSk1nanNhQjEwZnJ1OFpzUlo2Z3BUcVIrQndDVDlmMHpRRHRYNmp1dFVlWURjTTJyTXJTQ1B4S2ptZ3Q2VzRsVjBWcEpFOXpBQTR4K3MwRHZhUEpjYmFTb0JSSnlDWUNsZG8rT2FDc2xLSEJBU3J5S0s5cVU0SVBhUFNabWdMYWNDNEFvU3RvSzh4eUFUT1NmY250bnZRWGRUdmZ1MW1GQkNRb2pjSlRtQnpQcDlab09lZzlETis0blc5VEJ5cmZiTm5qLzlvT2ZpZ0lmYURvbW8zT2tYRjMwNHRYK3FJVElhS3BEZ0hZU1kzZWs0TkJoT2pkYy9hSm90ODROVDAyMnVOTURnQ21seWg5QW5rS21DZWNIbmlnYU9vL3RNVSt3ejkxS2l3dE9DUkJINjQ5eFFZNzExMWJkNmlwQmVRcGYreGtSTWV2eFFCcmU4RDZHL0RUaElsVkEwYVpjbERMVTd3RHhtUkgxNzBIbDgrNGxFakNZeG5Kb0FEcm04VE14MkpvS2JnVTZrdE5uYzR2eXBFVURSMG4wK2Jka1AzUXo2UnhRTmkrSUVEMEVVRmNna1lIbDdVSEl5Y25FVE1ERkJHb1pJNEk1aWdoSUpQS3ZwUU4xbkVGUVNTUW5hRW5pU1FmMzlLQzA2U2xTU21GUUl5STRQUHhRQjcweW83VUxUSGNuSit2ZWdFUGdxVU5wSkIvbUhlZ3FuQkVaOUpvT2taSWd6MkZCZGJWdFFWS0pVbjhVSHVCUUYrbjE3bTRTb2xlN2J0OVo5KzFBMjJ6Ni9DV1VKak9ITnNRZjcwRmhTb2NKUVUrY2JDdVNrZk16Nkg4NkE3WkpiUWd1RndGSVNDU1lPT0krYUQ3VDlPUFVGOEVwVDRXbHNFQjVaSi9pcUdTZ2V2YVQrVkErRjlBUWhMVzBOakNRbkVSL1NnK2RmVUNkbzNRTjFBbTljc1dUK2x2cHUwZ29jUW9KVHRoUWpPSXpRZm1TenREZmF0ZE1qZnNUUGw3VHptZ1hOVjA5Vm5lTDNGUk13REV6UVFXamNFaVlGQXg2VTU0bHVHMWVaSE1LT2FDTngxVzBOcUVrSmxLbGVtWW9BNm5JQkFNZHlEUVgrbFVGenFHM0tRWVFsU2pGQm9pUUU0M1lqbWc0ZzdENWdBY1pnVUVTaUNUK2laL3RRY0tKSWtIanNlOUJHc1FKUFBiMW9JU0FENWg4UlFNT24zRzFwS2xCZThxaE1rNWp0SHBRRTNGNElkSlNaaklNZXZIK2MwQSs3Q2w0S1R6SmsvclFCMzBFd3JkNWZUMG9LanFJR1o0NTlxRDVJa3lZSGNkNkMweUpSK0FSekhPS0M5bzZ2Q3ZRZ3BTVXFFbkhjeVAwb0gyMFpqK0x0RUtBU1VrNEhyK2Y3MEJHMHMxTXJDeENRaHdPYmdPd0lHZjhBbWdMT1d5M0VxUTJrdUtNSkVDY25tU2VPWUZBWVNwdXd0V2JkZ05JUXdQT1o0OVNSTTVOQU92ZGNUYUJROFJDVkJXQ3BYUHA5TW1na1JxRGFtUzllclEwd2hJTzkxemJJbmt6Qkk5cUJldWVyZWsvdlNiUzgxQnE1ZmQ4cVFralljZnpFWVRKaWdIZEtkQzZUWmF6ZFgxNDh5YlJ6eEZOeW9iVWdBWVB2a242VUdMZGRQNlUvMVBkalNMZ1BXNU04WS9QdlFMSmI4RmFSQ1FESk9NVDYwRmkzZEtBRllKSDBvSTdoYVZ1SldsVUtHQ1I2RWYzb0taU0M2b2dneGpjYUJnNkVaMzZoZDNDZ2ZJand4OG1nZDFFcXlKamllOUJ3Nk1nR0ovTWsrOUJFcFBtVVVqanNPYUQ1UTgwREFHQlFRdUo5WkFBbUtDQllNNFVCODBCdXdnZ0FGU1ZUSE9EMy9PZ0plS2ZMSFBJemdubUtDcmNoSUpFQnNIZ1ptZjZDZ0VYWDRRQUVnNU1VQTl4V1k3UUIvd0EwSGlWWW1mZk5BUzA1Z3ZLbUY3UitRK3RBWTE2ek9sb3RMZ2YrdDFRUnVBL0RpY2ZsUU0yajZvSExFN1lVbFkzUlBCL3pNVUJpMXVDRXFLa3BKQVNRZ1pNVE16UU1tbE9qeGlTVXJTQ1JrWkpuZ0Q0NzBDOTFyMUFyU1duSGtwVXZia0hqY0FQd0VuTThlbkZCaGJtdDlUNnBxSWQwdG9CYUNTQytUQ0FjOER2UVgwZEtmYUoxSzRoelZiY1hUTUdSNHBLVWdjU2tldngyb0RySDJiZGVzSWRYWVdPbk5vVzBRV3k4UXRVRURiQndKQjcrbEFyZFNhUjExbzRiMCs1MDU2M1pVRmhPMjVLMEVIa0NCRkFvTFoxaENDMHV5YlNsSmhXNVJISHpRVWJnWDdBM0xaUkVRQjRoODN4aWc1dHJ4OHFKZVpTQWNlUlUvdlFFV1dWS2JVcFF4Z2dBeG1hQ280b3RoWkorYUI4NlF0RldXaHQ3d1VyZi9pcTlZUEFvRCsxUVdrRXg4RDlLRG1TZ0dPVDNqTkJHaFA0Uk9aajNBbjlxRDVTQnljem4wb0s3aVJQbFQybmo5cUNGUU1qUGFLQW5iTDJvL0NkaElKS2lPTTRQYk5BVXdFSlRLZUl4ekgvRTBFRjJCdVVsS2dST1Q2L2xRQnJvU3NoV08rQmtpZ29MSTNZZ0dnaVFDdFlTa0VrNG9OTTBuUWxNZE1yZTJwQzFvSWt5T2UzNjBEcWpwZjhBMVQ3TjJXSEVKVmZJUUhFOXlWbzdFK3BFajYwR1NsMXpSbkhMUlJBdDFRNDB2MUhjZlNnZCttYnN2V3FYRXJTQ0VsQ2dyc0kvejg2QTdiM3lBeXBCL21BZ1JnZHpKOWM5cUFWMUt3TlZlS0FGcVlVcUZrSnlvQSt2YWYyb0RmVCtqV3pMRFNsTnRMSVJDd0cwakdZSHgzem1nbXZXQXl4NGpTd2xJOHlUQlRBTWNSblA1WW9GL3FicXU3c2tMY1lOMFhFRWdwZFNZamlmZjRvTTl2ZnRDNnZMQ2t0dTJiVnNod0ZJRFFsQjl2V2dTdFIxclViOUpWZXVKM3FVVlFsSUdTY3o2ZkZBdjNEYmo1bFpPMEdCbjg2RHB1MEVvU0JqdURRU1BPN1dsTkVmcG42MEhXaTJCMVRWRzJSLzZHZ0Z1NC9TZzBSS1NOMjBGSUVESGJ0UVNpVEVuSjlJL3dBbWc5S0pTU0JPWU9LRGtveitKUkJ5SXg5YUNQa0JLazlzL3dCcUNFcG5hU0lqc1FhRGd0Z2t5VW4zSTVvTE5rTnFnQi9ONXZTZ0xwS2x0bm55alBmbjFvS2R5b1JrRGJNbnZqdFFDN3MrWWtrVEV4NlVBNTFSSjlvT0tBNzBMbzY5VzFoQldGQmxCSE9SUHRRYmF1MVN6YUcyUWtsQVQ1Wi9XZ2NkSk02YmJtSWxBb016KzFIcFJvN3J0Q0lzM1ZibGJSLzZYUFgyQi9LYUROOUUxRnpTYjB0UHVSNGM3Vko3ekgwbWdkMTN4WDRkdzJseHh0U1lXSWhNOS9qMW9PV24zSHJsUGlLYTNxVEVKVEVER0o3RTl4bWdhYlc3UTB5dExYbWNJRWdZZzhHZlgzK0tDd3UxZWVXcFNqQ1FZU1ZDWlY4ZDhVQTUvcGRPcE9oTHlodG1WTzdaY0k0eDJIeHdLQWRxL3dCbk9saTNsdGJ4V2xPMUp4MitPL0h6UVpmMUIwa2kxZFNmRkprRlJCeEpqSituZWdWcm5TVkpDU0VxU2xRM2JsOFVBaDRlR2xZVmt4ZysxQU5YdWNJU2tGU3lZU1BXZ2Z1bmJCdlRyRkRhU2xUeWdGdXFQSlY3VUJkQ1Q0Y1JnNCthRHRBU3BJbFczQm1NKzFCT2xNaFNGQWhBd004Q2c4MkRmTUVudU1DTWY5VUhpV3dFTmd3U1FjUjc0b0kxdHFEbm1IbG52eFBjVUVUakM1RzFSQUlrNVBOQkRKbUFSTzM2elFYN2VRMzVwQkhZK3RCNCtyQk9lRHp6TVpvQlZ5U0ozZW1jZC83MEZORnV1NmZETFlKVXM0Q1JQK1lvTnc2QzBBYVJZSldyYUhpSkpKZzU1b0czd1F0QThYQTR6MkZBVzBjZ1d4WnhMWmlQYm1ndFhWdXpkMnp0dmN0cGRZZFNVTFFvU0ZBOGlnL1BmMms5R1hmVGR5cTZZQzM5S1VyK0hjVEttdjhBOFYvMFYzK2FCZjBuWEZFRmw4a3VBWUNqdWtmSGZIclFPVmxxYlJMWWJjS2dVaVNtQ1FQNmUvTkEzNlM0bFRPNlBDL21DU29lYVk3R2dhN1c0YlVSNHhTSkhsU1NEN1VGbHk2YkJLZ3FRRE9BUDgvNm9GZlh0VVE2OTRhVmxDVEdVT1FWQ2VRQnlSSDcwQ0oxTTZ3bFFJS1J1SVNSK0liUkdKK1l4ODBDQnJWNjB5SFdoNFpBSmhZUFBiNmlnUXRTZEMxS1ZKT2VUNlVGWHB4LzcxcXFrc3Ayb2JPMmU1b0dSV3BLdG5naGNnSlZFbWdMV1dyZ2p6S0g1MEJ4bTdZY2p6QWtlK0lvTGJha3hLVlFJZ2VzMEVnUUZwSjJuSkFFL3dDWW9KVzlwZUNaOHNTU2FEcExjS0tpZURJQk1DQWV3aWc1OEFuSVNST1Qyb0FESEFtQVIzbWFDNnlUc1FWQUpNNHhPS0QxNGhRd0FuMFByUURMaE85UWJiYktsazhEK3RCb2YyYzlMYmYvQURMb0pKZ2NxeUI5TzlCcTFvMzVlMEpHRWpqTkIzc1NHUVNvQS81aWdxaTROcnFDSFVBK0djS0FPTnZhZ1pFa0tBSXlEa1VIRnd5MWNNTFp1RzBPdE9BcFdoWWtLQjdFVUdCL2FaOWsxMVllSnFQU2pSdUxGTXJYWWcveEd1OHRudVBia1VHVzZicmpsczhrdUJTa3BWRzlKaFNUM0NoUWFIMHYxYUFoQlllOFlvUG1WQUtwazVVQ0NRTXhnZTlBem8xOUxZY0tiZ0ZLa2tEYWNjOTV6eUtEeSs2b1NXaTJoOWJnSTNLL2lSZ0NJRWM1b0Z6V09wR1VQSjhOTXVxSWtxRWxQSXdKZ1l6NjBDcDFIMU0ydG9JdDBqeUxsdnZpZS92eFFKRi9kcmVCVVZ3a0RudVBZMEFEVUxoUmJVb0h5eHpQTkJkK3o5dmU1Y0x3WkU4VUJMcVJNUzZuOEpnelBGQlZ0M25GSUMyakJBb0wxdHF6akpUSklOQVl0OWNCNVVjY1p4UUY3WFhTQW1WVEhIdFFGV2RaU2RwVXZueTVIQW9DTEdvTk9yM0tBUG1NbWMrL3pRV056UnlUazg0TkFyTUhBOXBQeWFBbXlBdHBJQTh4OXZhZzZiWlhjcThKaEpVcjJ6LzFRTlhUSFRKKzlvZnV3a2tuZ2pIK1RRYVhhc0paUzJtM0NRZ2o4TVFUSHIvYWdJTlNoWk1pU1o0L1NnOGtxV3BTb1VrOWllS0NwY3NrdFJoS1ZjK3NlczBGM3A2LzhUeExWMWU1U0Q1RkhHNFVCdWcrb012KzFIN0tyUHFkRHVvNk40ZGpyWUU3Z0lRL0haUTljYzBINXdmc2JpdzFKeXl2MlhMTFVHVDVoTzFYeWsrbEJiVnFGL2JoS1hGZmVXMEhDbFlWK1k1K29vSzd1dHVvSmxMZzloUVVIdFgzeUNWQ2ZTZ29QM200VHNKek16aWdwcmRVNWx3NDlzelFDOVhlMnRLRWtVREYwQ2hUZG5jUEVRa0pPWm9MR3ZQTXEwbVZyU0Z5UkUwQXpSbmdXb0p4K3RCY2VRRktudjM5cUNCSktENXBNZTJLQzYxY2toS1VxSTV4UVdtbjNFeVVxN3dLQzZ4cWEyMUpuQUhmKzFBV0dzcUFoSmtEdkhOQmJhSVVwSVByRkFXMHhoeTVLV200SmlKSDh2MW9ORDBEUTI3ZGtGMUIzNG5FNW9HOXRBYlFBRzFCSnhCRW1ndnRrS2JsTVR4ai9PYUN5bUk4NW1mVVRRZWNqZGpiQkluRVVGQmF5aytKdVVxUVV5Qkl4bVRRVU5RUy9iT0l1YlJza0lPOHFDdlh2OFVEUnBPb3B2V2dGalk4a2VaUDlxQWhRZlVDWjlvZjJmNlgxbllueHg5MjFGQS9nWGJZaFNENkgxRkIrYStwZW5OZDZSdURiNjdhS0xIQ2Jwb2JtM1BmSEhOQXZ2cFF0TzVzZ2c4UWNVQTliUU04ZzhVRUN3a0RhVEk1QTlhQ2pkdmJFa2lBQjdVQzVjdUt1YmhETGU0bFpqRkJvVnk0anB6cFpMVGtlTzZNZzBHZXVQT1hMaWxPTE93bWR0QVgwcTRDQ0FxUlFNelpTdEFLUUNEM29PSFVTUE1CT2VLQ290WGhxTzMyTkJkczMvRVNNQ1pQSHhRVHE3a1o5QlFkN3NDZ2RMRzNXOG9CQklTVEJJeGovTzlCcDNSK2xJc2tlSVVCUktaOHgvYjI5NkJvYVFsYnlGQ0ZOanpiUmdBL05CZld2dzNmNFlUSFlnOThVQkJzcWNTQ04zcVo1QjkvYWdsODZHU2hXMWFWVG1hRGgxS1ZJbGF3bmNKMlVFQ0lTSk8waU1LbUJNLzJvS3EybkFsMUVoUGlZQlNNYzBGUmt1MnR3SEFYRXVJTUFlcDcvUStsQTBhTHFhZFJhVUZKTGR3MlljYlA4cG9DVkI4YUNucUZuYjNkc3BxNVliZWFWZ29jRWcwR0tkYi9BR002ZGVGeTQ2ZWVPblhCbitIeWhaT2VPMUJqR3VkSTlTYUU0ZnZ0bXAxcnM2ejVnY1VDdGQzY0VoWVdoZjhBdFVtRFFBOVZ1eDRjQTgwRFg5bS9URzlCMW5Va0VNSi9CSTVOQUI2MzFSV3FhMDRsT1dHenRTRG5GQUpiYUNZQSthQ1JzRHhFamlETkEzNmRoaE9CSjdrMEZ4WTNmaG1EUVYxTUFqTWlablBGQno0U2tEeW1CNjBFeUhKNS9RMEV1RGtGUDFGQnQvVEdqQzNZRHppRkpVY1RQUGVLQjIwZ2hLZGllNGtwQUpJOS93QmFEblU3MWJhZ1dFd0NkcEt1SmlndldkMGxkdWxicVFERWtwSmo2ZldnTFdWdzB0S1lWRzd6ZkI0aWd0S0d5RUNkaDd6Z1lvSUhBSFNWTndDRGtkeDcwRWR5MHBUcmFreEJ3cWNSeGdlaG9Pbi9BQXkwMmtuZVVwd1VqdU85QldkYldKV0FvSng1VGlJNG9LVDZiaTBVcS9aY1VYRUdRMkV4djlpYUJxMG5WR2IrMkN3UWgxTUpjYkp5bFVaRkJiY08xWVdtQ0RqbWc5Y1VOa2lJUHJrR2dBNnUzNU55bHBRTXdvOTZCRjFlNzA1cDB0UDZ2YkJaSThpbkFaUGVhQlZ2T2w5UDZnZWNDQmFQTnpHOEVFeFFZMzlvL1NXaDZEMU8xYXMzSzFsS2dwMUNlMUJKMUgxMmx6U1U2VHB0cjRGc2hJVHUvd0IwRGswR2VBRlVrcVNDb1pQZWdrUW1JR2Z5b0l3WWNUN1VEWnBqaFUwa0svNm9DU0NNUUpIWWlnNkNlK0JQdm1nalVBY1l4UVJMQm50RTRvTzBxTWRnTzBtZy9TYkIyN2c0bUVwOThleC9lZ002ZUViVmJTWkVFZjUrZEFLMTVMdmdyYmhTa3JUdUJUNi85VUZ6cE5RZTAxSWtoMGZpa21JNzBCcTBLaXRCd2lEQkF6ajFvQ2J1NUMwcEFDOTU3L3ZRZkpiY1FwU1pBQlBsQTcwSGR5dFNGSVNIQ3JkaE1qL09hQ0FzcVcwK2tMQmtETVVFRGpZUWsrZllFSTNFcUdTWjRvS2lyYnhIV0dHbno0Ynl0NWJLWkJBOVBRKzlCTnFWa3F6VC9xRml2L3kwRVRPUXRQb1I4VUF2cVA3U3RBNmVaU205Y2RjdlhFQmFiUmxHNVgxUEErYURKK29QdDYxVklkWjB4bTJ0MVRDRGx4d0R0UGFneXJxSHFmcW5YajRtcDZqZW9aV1R0UVZGTS9RVUM3YzJ4VHNSNHJqajVFbmNvbUtEeTJ1TDYyV1ZXZC9kTmxPVkxTc3hRVWJ4MjllMUZMN3JpM1ZyNVU0cVNvVUUza2ZRV3pnRVlBN0dnb05ibWxrR0FrbmtpZ3RxSDh4SklvS2hWdGVTSjRvRy9RZ0N6SkVtSngzb0NjQWxXQVBpZzZSS0FRVGo5VFFmS1FEQkJIMEZCOTRjd1QySDFvQnJycVVySTNSSGFnL1Rkc2hXNXgxTzR5T0FSQkg5S0FtRWhLaWtBRktpQ0k1ajA5NkFWclQ2Mm1WbGtLVHRWNWdjelBlZzY2TXZBUEVaZEpSa0NZNDk2QmpTMUQ2MEJ4S0ZUdlFmeFFDYzUrUlFXblBHU1M2NDhkcVpnamo1b09yZDE1dGFWb1drakJVb2cvcFFYM25tM1EyWkFqZytoOS8xb09XM2o0eVlXQmdra1NSOGZGQkUrbFBqQStLU1VtUXJiL1gwb0tPOTM3NnR4Y29VMmdvUXVKQktqbWZTZ3VCN2R1YThxbEpRQ0R4S2llYUJIKzFQb0cwNnUwNTRzYnJmVkdFbHh0NUNnQzRyL2FSNkdnL045aXduU1hMaHE5WThLOVpjOE5US2hrcTlCUFkrdEI5cTkyOWN2aDE1S1RkRk1Cc1lTMFBVKzlBSlMwSFF2ekVOekxqdmRaOUJRVE9XZ1MwbGEyeWxCLzhBVTFPVmU1OXFDbGR0bHBaM1I0c1NRT0VEMG9GeDF4ZHM4clo1a3FrMEYyMlUwL2JBSlRDMG56Wm5OQmFYQVlTSklWNkVVQXAxVzI1R1FQNlVEdDAyamMyTUVlNEZBV1cyQXZBeDdVSEtXd3VjRDNJb08yMnZOdHlSUWRQSUFiV2ZiaWdXbjBxTHBnVDcwSDZuMHQrYmRlU2wxS2lOcThoUUp4Ky9OQmFaZE81Q0ZKOHlSZ0E5djZSUUNlckczZ3g0cmJwVDVTa3BBZ2lPNTlxQUwweGZQRjNhMmtwS0V3UW96NjQrS0RSR0drbGRyZEwzTFJjTTdkZ01wa0gxOWFDMjJzTFFDUkNRU2xPNHpCSElvTGZpTEt5citFVTRBak00b0piZEMzQnVVaEtrb0pDaHo3MEhONnBOdmFrSURhV2srWUVLR1NPMFVFVjFxQ0VXeVhiaEVFb0trRkpCUEhKOXFDcFpLUzlZdFBQUEZEN3lTb1RrUnprZkZCSmJ3MjZoc2h3RkEzQlp5Wi9xS0MrMkYzSkhDZ0RKS1lnLzhIMEZCajMyemRBS3ZuRjYvcFR5SE5UUWxSV2tpQXBQKzAraEhZMEdBTGNDa2tEZDRZUG5VZnhyWDZVQlcxdEFVdHFjYkNuRC93Q3EzVHduM05CYWNhS1hWb0NrTHVEL0FPeHcvaGFHTUNnWDlTYVFHeUdncndKeXRYSzFVQzFxYWZEaVpVb2pnVUZXeVE2eXNxUVNENlVCSDd6NG9BS29VTzFCU3ZQSzRoUk1VR2s5Rk5JWGFBeEppQkhOQVd2N1lCQktjamtBMEZCTXBCanlrOHgyb0xEVFc0RVRrOG51YUQ2NFFvc3E1QjRpZ0NydENYRlNrRWd4elFmb2NyVTNkTnBVcEtIVmcrSElNTEl5VXhrVEhBL0tnSXRyRWJrbHc4QlNWREJQYjRQdlFTYTQyWG1OanJRZFZzSDhRSGdjL1R2UVovcDk0cTMxNUxXOEJPNHpQSVB2UWFCcHc4UmhEcU54UTI1Q0VCV0k5djJvRFYwWEV1Rk1CRFJTVm9KSDh3N1krdEI5cGlkMXk4NjIrdFNTbmFwTXduZEU3Z1BUa1VGeTJGNGxUcUZ1aFRTWTNTSVVDVHlJOXFDWjFUS3R3VjVreEFDVWc1UGVnSDY2NzRtbklzbHQ3blgxcGFTQVloSk9lT01VSDF5bHRpMk5xMmhPMUtZUUZLaFJFeDVUNjBFenlsTklJWHRLeENRcGZZbU85QmJzMnZ1VEQ3WWNXWk1sQ284cWoyVEZCNCsyYnBRU0E0bEtVeXRhazdTbzBHRS9hNzBHdGk0ZTZpMHV3VXNOcWg1cG9BSVVZbmVFOHpGQm10cmRwU2dwWWNDbkZKQ243anNrZWdvSjFGcDIzRUh3ckVZQmp6UEdmMk5CVDFGbHd1TkZ4c2VNckRWdW5Pd2Vwb0ZYV1dnbDFMY2hhaCtJbjFvSUdtZzRpTzQ3VUVMOXVwdElXa1pIdlFVbnlwYVU5aUtEVS9zM1FwMjBDVEFIUHpRT090V0NSWkJTQ25jRG1PYzBDdzB5VWxXNEFFQWp6VUVySUlYSHhrMEU1U1ZTRHdhRDVURFlpUW5Jb05qaEpLaSsrcFRpVHVBRTRFanY2ekJvTFZ1dHo3NnloNEFKZEVLVWdubk9RTzFCTmVmZG1tVXRyUkc5Q21OOGt6SWtabVFmZWdST3JMZHhMemQ2NEcySGdRZytHSkJJNy9wUUhPZ2J4T3B0djI3d1dyY3dwWkNUQUJIL0FIMm9IQzJkSnRHWFNTUTRnZmlPZDN2N2NVSGpOMHkwVzJyWkRpYmhKSlZJVEJNeEFvQ2RrMDljT0tsU2cyRHRKTVNKNG1PZm1nNk51d1ZPSlU2dHFDVXFTa1NmZ0dncDJqQ1VQT2FneTQ0K3FQRENYY0o4VHVyMndZa1VFVHFZVXA5YWltNVpSNWdGRXBuMUhwelFXTFl1Tld4SzJtbFd1eitJQnlWY2tqL21ndG00S1hHa29DSEdNS2tnanRJTVVGOVNpdTNXMnlvTnJUQkl5U0FxWWo4alFSM2RzbFZ1aExqcFcwNEFsTXBraWNkL1dnL05YMnVkQ0w2WHV2OEFWTElKR2lQdUZUelFnRnR3bnNPNE5BcTJqaGJRMjR0S1YzYS9LeWcvZ2FCNE5CODhDRlBKUXFYQVAvSWZQS2ZaUHRRS0YyNjNjUExLRWJRbjhKN2tldEJKYnM4S0E4M2NVRnB5MjNKQ28zRTlzVUZlNjBWVFZzWFZKQUI0elFObjJSdUJUemphMHlVeVlvTlN2TktLclZTa2tBN2N5ZVpvRUM4U3BsNkQ1VDNpZ2tRSUFvSlpDbGNlWWR1MUJLM3QyK2FKK0pvUC85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL1NjaHJvZWRpbmdlci5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC8vZ0J2Um1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPazF2Ym1GZlRHbHpZU3hmWW5sZlRHVnZibUZ5Wkc5ZlpHRmZWbWx1WTJrc1gyWnliMjFmUXpKU1RVWmZjbVYwYjNWamFHVmtMbXB3Wi8vYkFFTUFCZ1FGQmdVRUJnWUZCZ2NIQmdnS0VBb0tDUWtLRkE0UERCQVhGQmdZRnhRV0Zob2RKUjhhR3lNY0ZoWWdMQ0FqSmljcEtpa1pIeTB3TFNnd0pTZ3BLUC9iQUVNQkJ3Y0hDZ2dLRXdvS0V5Z2FGaG9vS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tQL0FBQkVJQWI4QkxBTUJFUUFDRVFFREVRSC94QUFjQUFBQ0F3RUJBUUVBQUFBQUFBQUFBQUFEQkFJRkJnRUFCd2oveEFBL0VBQUNBUU1EQWdRREJ3UUJCUUFCQXdVQkFoRUFBeUVFRWpFRlFSTWlVV0Z4Z1pFR01xR3h3ZEh3RkNOQzRmRUhGVE5TWWlRbGNzSkRVNEtTb3YvRUFCb0JBQU1CQVFFQkFBQUFBQUFBQUFBQUFBRUNBd0FFQlFiL3hBQXhFUUFDQWdJQ0FRTUNCUU1FQXdFQUFBQUFBUUlSQXlFU01VRUVJbEVUWVFVeWNaSHdnYUd4STlIaDhSUXpRc0gvMmdBTUF3RUFBaEVERVFBL0FNODJsTE1WWVRKa3h3YTRlVFd6bWt1UUlhRmhQbGdsc0FFKzlENmxrMWpmUnkzb21TR1lRT0tWNWZnZFkvazcvUWI3Y3NyTE04WmcwWTVHL0lzb0pIYnZUNFNXYVY5RzRQeW91Y2wyelFpbjBpQjBOcFZMd29pRDhlS1Z6OGhVRzNSUCtra3NwdGtDWTRpYVAxS1NCd09mOXRWcmdES1VnR1lubitDa2VSTUtnMERicGZtM0ZKemdNWnhXK3BSdnAvQkM3MDRRRDRTU1FGNHpUS2I4TVhoWFo1ZEVRa2JNd1Q4NG94eUJjRUZ0YUZIdHdVRU1JZ250U3VhVjdEd3VqcVdXdHBObFlNK1ZsYUI3ejhxV055VVhZZHhiclFOdENoQThxRThzRFZIS1NzVlFRZlMyb3ZMSUhCR1BkU0lvY3QrNFpSYTZKMjdWcEZFQlNDUm1Qd3FVVjhETk5FcmEyd3ptSUpCQUVkdTlNdExZTjJEVFQybk1rSGpCaVQ4YXlpMTl3WFlYK25STjNrdGlGaVFzSDUweTEwWjJ3RjNTcHRDK0dzK3N4UjQrV0MzNEJmMHRzZzIyU1JPQUNmMHJMSGFzem03cHNLM1RVWUFoUVQzaVlwTlIwK2piZTEyQk9nUU9IOE5USEJITmJuRnE0c0ZOYVpJYVZiYXlxZ01EUEJOTGJkM1EzWFFMK2xSWGhMWkFBSUJBeHhXV2xvTnY1SWYwYStHbmtJTTU4b29OTitRbkcwSXdmRFVtZTY4MC9LU1ZXTHhWMkNPaWtMS0lQV0JGRk5velNaTmRMQytVQVpHUjJQem84MThpOEg4RVYwcEpFamNKOXAvS201SjdGY0dnbzBad3dSUVQyTXo5YVpaTmlmVGRIUDZBbEF6S0pBN0hGRDZpYWFUMkZ3a25iV2liNkMyQklVWnlZRk9vcjRFdC9KRzFvRVY1MmdxZXhFVU9tMGhsYlJLNTB5d1NRTFZzemsvRDFwN2QwakpQNUJEcGxwcDhwSGNrRWduOUtDaTIrNkdjcVhRV3owdGRnMnRxTjA5Mk1VamN2REdUcDdRSzdwTlBhZUxsNjViM1NWVlc0RTk1UE5WeHUxMmRNSmFOTGVDeUNnTVJuRmNia3F0bXJ3aU42MkF5ai9FSEU4UlN5bXFER0lKZ1BGa0tvUHFva2t4L3hTdG1QV3NiV01Ibmc4Ky82Vm95WUdsNE9NYmJBUXBKSDRIK0NqeWEzNUJRTUs3SXdDNU1jbjE0L00vU2w5MURhc05iVTRJWGRCZ1RBbitUUmIxUUZGWFpLZkRCTEdlU0NSMm44ZWZ4bzJEaVJmek9wVjVCSm1NL0dtcFVCS2lDcnRDbUFUTzR5Wi9uclNLa00xWUpCdVVIeUx1ODBkeC9QM29LS00vZ21zckVTd2dtRFJRR2p5Z00wT3BpT3hvOGt6VTBUQ29mdklBSmpJb3AyQ3FPaEI0Nll3VDhLUlN1UldLcFVRdG5hcE1lWGdWdVZXQ1Vib2svbmpFTDdDS0tuWU9OSE5nTFJEUkVUTlU1dndKeFFkRlZjRW1ZNVBla2JaaUpaUnpNSHNhZFNBMERLTElnRWJ2ZWltMTJ3VXZCM1lUZ0F4OGFuS05qSWg0V1lLR1BqU2ZvTTBlZFZCM0tXNUl4VEozb0hIeXp4VVEySWp2UWpKdDdabkZlQVpCTVJPSitIeHB0ZGhxaUFERXlKZzBMUzZOWHlFMmNibE1uTk56RjRFMlFiUXpCaDhxSEkzRWlCNVRpVC84QXQ1bzIrMGJpdWpsMlQvajVSN1ViOHRncjRKV2t0dVZDaWZpT0tMZkxTRFZiWVFJQXpZQjdmd1Z1VGliaW1kVkJKaEZQZnlpZ3NzdXJNOGNRa0lGQ2xCOFFPZmhUZlU4V0RnanFJandOb0JYa1IrVmFNM0tyZlFKUVNDTUVCak80UWM1K0ZISTIyck5DS1JuZW8yYk56VWxqZFZTZXh6M05OQjYyV2l0R2t0d2Q0RzBzTW1LNTVQWmtpSVR6YmllNElKemoxRkxGV0dSQnJRYTVrRU5Ca0dSSDgvU2kvaENvNExhaFBVRThZTTg1L0w2VWlWSVp1eUtpRlZWTUE0SnpFVC9xaXZnMVdEaTRRQ2NZMnp1bkk5UDUycHRJRldFWWxDWkttU1NKTWZoK3RDemNUbHhXWnZMa0RqRmEzWVRoc0ZCa0QxSjlUK2xGSmcwQjgzK1IyZ21BNTQ0NGlpdEdhT0JQSW1ZYjBpTWdlbEJzeVJNcDVTU0luSE1UU3ZzSklXenVWZ2ZoUm9CTXFUOTRuNENzQTdPMkNvQWFSZzF2SThTTnEyRGFVZCtUbXB0QkNHMU9md21taDFRc2lKUW51ZWUxVUZvbXRueTVCK3RCYjBaNk9HM0kzWWo0MGQ5SUZIUExPRDlLTm1vNFVNbUdqM29NTkUwWGFCNXA3bXNxVEEwMlNLanVBRFJRR2p6S1BEeklKRURGS01DTm5hSlk1TW5GQmEwZzFaNXJlMWxJN1UzZ0I0Qmp4RTl2YWtHbzZFUFpkMktLVEJvOXNZWVZSOVpySy9BYVhrajRhaHlZejNOUFFyK0ExbXo1VEhPRG1tdENVMlNlMFpKSUFqNFVza21NandWWXd2YWxxZ3ZZVGFKQUNrd0tOQU9DeU00eitkQ3cwQ3VXblRoY1JGYTlqS3FLWHFRbStOeUFFQ0RCNXlhN01kdU9oZEl2dE1BQ0o0T1JubXVIdlJSaExwV1R3VGo1WngrdFAwSjJjUlJ2RFA1Mm50bitjMEd2TEJmaEhXWXdBRnpPZlFUMi9LZzIrMlpKRUVSSHpnL0d0WnFKVzdTcU1aN2NkNlpVTHNtTEtrU1FkM3JBbWcvc01nTHB0WS9mSTlaRVV0ME5Wa1NweklZaU1kNmJsU05Wc2pidDRFQUdlM3BXMEIyUUZvTEdEZ2ZXbEdPc2dCSUJrL3oycGhTUVRCaVIrbFo2QWxZVzBnekl6K2xJdXhtUTJmM2xJeDVoRS9HamUwRkxRTzB2bGtEdHpXaUdTR1VVUURrSDByTFRBMVpQd3kwbnQ2aWpiWXRJNzRTWFBoVFY1QWN1NllJa3JrMWsyOWhxaGZ3REpZcldiM1RDRE5zazRtSzNabVRBQWtaRmFoUWlwTGdHVG5pS0tWZ0ROWnlEbjg0b1NWR2lCdUlTQlBmT1BqUVNHdllOa1ZvSUU0clhvTkV4YklrNUdNMWpIU3VEbVJ3UGpXZWpMWndXeVJKOWU5YUptZHRvSk1nUjcwNjZvVmpIRTQvMVc2Rm9pNGtTWjVyVXIyTnNnVXp5QUI4c1VaVlFFZFVoVDNNemlPOUpZelFTMlpKUG1rK3REb0J5OWJrR2VTSm9XTVp6clhrMXpLc0NBTVYyWTVWRkM4Yk5IcGJJOEtUQkVmT3VLQzJQTjZJM1FkekJGamdZL0w4YVppb0c0TE1PWURHSjl6UVlhRExiSkRidlVaRkpZYU9wYUl1WXhPYy9PdEMzdGdsUzZKZjRvSUpNRDk2dHBDRVk4eGdtU2N4U1hlaDZKcjVzUk1Ud0lFZWxaNzBaZkowVzFMU0NPT1lvOFYwYTMyQ0tlWTdUUHkvV3B2UTNad1djaVZnakh2N1ZrMFprWFRiSVBwUjVVQ2dpSU1GaGp0UWNyTlIzWmtLdkI1RmE2RFZnbnQrZFpIbGtBMHZMZXg2cEhyZG9qSjRJN1ZSUHNEWFJQdzVNa2dDbld4S29rYloyWVB5SGV0S1h3Wkk0aWdUSkpnelFXdXhudm9Ka3IzbWp5WXZFSGM3cWZ1OTZEZmcxQVN1Y0RudFFYMk15U0tDRGtBelRDaDFYYjkwRTlwbzJyb1dqcmduaVBuUWN0OWhTMEN1NGlHRWlsdXhsb0V3QU1BZ0FBQVNjMEhJWkltY2piM0k3OS9sUlRCUkFmZHhCRVR6V3UwR3FDb0o4cWpNUjdUVElET0JZa0QxeEIrSCs2eVlHR1pUQjNSSFlFNHAyMGhVUVJRRUk4MFpQOC9HbHZReld3aHRFRUFjZDU3MHJrYWdZV0c1eVJtRDc4ZTFKejJHdEJrVUVBQ0QyL3dCMDhYWUdqelcyQVp2VWRxTFZtVG95MzJpdE9lb1N0c01OZ3ljK3RYaTFTR2lqVTZXUEFNejZSUEZjc1lXcVFKT25aQjFEM0dSVklqa3gyRkdTZmtWUDRDaXlyUkFtRGp2UzFiRGRIYnl4SWt3S0xWR1RCb1kyeVlQSDRVRktnOFRoQktFckpuNWVsQk93MVJGRllDTXpOTWtZNnU0anVSSHBXNUpzM0dqeVc1WUFQejM5YTMyTUZXMGZRRHpjeFM2WnVqbDIyV0FpUVNlM3dyY1dsWmt3STNlR0JHQUtWb0tKaFdLd3gyaXNrakhtWGJ4NlJUVmJvSFIyNGhLNEpuR2Yyb1VxdnlOMjlIYnh0V2JCYSs2b25KTEhGSTJpaWcyOUdYMTMydTBnM0wweXhjMVRyamMwb3Z5N21xeFVuM292SDAzeVVPdSsxblZIY3F2ZzZlQlBsdDdpQjhTYXBISEZyNUtmUWpIc3JuKzBmVTJaU2RmZEU0TUtnL1NxckJINEE0d284djJvNnhiMkZOV3R4ZlM3YlZ2eWcwZm94K0FQSEI5RmhwUHR6cXJaL3dEeTlHaFh1YlRFZmdhVitucjhyRWVGTTBQU2Z0TjAzcVRxaTN4WnZ0a1c3dmtKUHNlRFV2cHZHdG9qUEZKYm92RkFuaklQRVV0cndSYWFDaFlUMzk2TGE4QW9Mc0FVbk1kNE5KeHBtdXdONWN5Y0tPRHgzcDNWV1pJSHQ4dUpuMW1rYUhSS3lJYklNeEJ4L0pvclFHZTJxV0pNUitmOC9TaXFadWlhV3hLNG5IcC9JL2FxTkNXZDJsaTVpRDdmblMzMmFnd1NFSmpnOXFEMmdwYkpXclU3aHp6MitGQmRCWks1Yk8vUHJQUE5aMEJDN0pEQSthQVA4YW5XeHd0dFZaY2pJcGhRckE3R2ovMXpBcWw2RThtUyswRnE2ZW9Fb2pzTm80TVZTTWxSU0pwZENGV3dKQjU1OWFXTDRvbkpXeWJqYjVWSG1QZVpwWk8rekpVZVc3LzZrRHVTeC9udFFURFJ5NWJMdmhnUlA4L252UWtGRTdWcHQ1eUo3L3ZTZlljbGN0a0tCbnYrZEJOcnMzWU1JQ3NDQm1tVDBieVNGb3lBQk1DY0g5YU5Bc0paVGE0TVpBeldvMWtnd0FpbDZSbWlLa1kyaUFEbWEzMllTU0lDek1WaFppbGswbm8xSEh0N2dNQTl3T0tWZDBId2RhMkdpSWxhcTFRcTJWL1Z1bzJlbjZWcmw0K2FDRUhxZmFwdHZwZGw4ZU55WjgrNnRxdFgxZlVBNmhpbW5VK1MwcHdCNm4xTlBxRGRkblpqaFMwZDZab0VHOXRzcW95VFVjbVZ2UjBSVkNlcTB4ZG5abG1UWFRDZEpFbXJaWFhkSEEzUkFHZmMxMFF5V1RjYUtuVTZjUmlRUjNyb2pNbEpDemFtOVpJRGVkZlExUndqTDdDcWJpY2U1WjFDUmJEV2preCsxTHhsRHZaVGxHUzBYLzJaKzJ1cDZUY1RUOVVOelU2RVkzak55MzZmRWUxUnkra1dUM1k5TWpKTHBuMXpSYW14ck5OYTFPbHVpOWF1RGNycndSWEZ5YTAxczU1UWNYVEhDb1lrQm1KeEdaclJwaVBTQkd5SmtqMk01ck9JVXdiSnRhRm43dUsxSkc3TzJsQmFCK0hhbUF3cFg3Mlo5ZmVtOGJGODZEcmJYYWR3bUIyclM2TXV3WGcvM0FSeHhGUWt2Z29nbTJBeEdkc2NHdFl5UkpSdFVpREUvd0ErVkMyOUJPM0paZzNCOVlwaENQaDdnU0JQNTBPd25Oc0lBZStNVTYyS3c3d0VNQ1lIcFFsS3RBU3NvZXFhYTIyb0RPUkpYdjhBRWlyUVZxdzJ4elJYSTA2anpUdUpKUEpwVjBGOWpkbTBIOHBIUG9KejYxcXNUb00rbUROdEJJWEdPMFVQc2tIN25UYVVFd29PUDE3MGpsc1pMUjBwNFl3Sk9RY1pyTlVaT3pqaVZ5UGptblVma0YvQnhoNVYyckxMejdDa2JYZ0tYeWVVVDc4MGJRYUNLcEx4R08rS3prQ2p3U0NTT01VTERRQXJCSHZXYU1HS3FjSEFCcEZGZHMzNkhRaGFDV3dCaW1VVVpzRnFIdGFYU1hMMTg3YmFMdVp2V21ZWVJiZEkrV2EvVzMrcjlTZTY2a2d5dHBCbmFQWVZtbEZXZWpDQ1NvdWVuL1ovcUdwZ3BweXF0ano0cm15Wm9LUmFLMFg5bjdKM3hZYTJXQzNHRXlPTytLNVhtM2RERlhyUHNwclF6Rlh0Tk1rbklGV2o2cVBWQW96M1ZPZzY3VHFiaHRCeHdkcG11ckg2bUQ4aU9ETXhxN2JJU0hRcWZjY1Yzd2FmVEl5VmRsVHFsYVNlZTgxMHdJeVFqcUZBdVlNOTVBNHF5Uk5rQ1ZkQ3J3Ry9Panhyb2E3V3pVZjlQL3RVL1F0Yi9TNnQyLzdiZkptZi93Q2sweHVIdDYvV3VmMVhwdWErcER0ZjNFL011TFB1VnQwRnBHR1MvQUdRYzgxNU1QYzJSa3FQUVdueWpkdHFuYkVBclliSlBsOWU5YW1nMmNaQUk0QTl1MUN0QnNJZ0lrRUF5YWZ3S0hVRThuRWNVcjdDRXRXeXlpVFNPcXBCWGRuYnFxQ1VYajBqdFUycTZLSWhkUUtoN0FDU1krbEhveEVvUVlJTThIMW10ZTZCWGtqYkFHNzE3R3RBelBLdVZQcWNHblhZR2hoMUFVbjBCd085R1NUc1ZGUnJUL2NVYlpoZVpqdWE2TWE5b0grcExTS1JaQkRidi9ybjNxQzB0bEhzYnM3MDJzY3hqR0pOQnZkSVYwT0s0YUZVYmRveU9hYlNGV3ppekJZQUZlNGloRlhzTDBUdUFPSVVUSGMwcmZqNENrRE5saU10Zzk2Q2t3MFIyWUF5U1QyNzBqMzBNZ2kyaHVBTVQzNzBkSXdXSUppVGoxb3VYaGdvQ3lDWUdUanZXMHduaGFCVUZwSHZRY3FOUVcyZ09DZUNZL0NndmN3ZEhidmxRUVFNU2E2WWFFZXo1LzhBOVFPck00dDlPc09KSkRYSTlmOEFFUitQMG9MM1NiZlNPejArT2x5THI3R2REYXpwcmJwYlVYWEV0Y3VESitRL2V2SzlUbTV6bzc0eFNSOUYwblRXVkZEWEpMQ1JzVUFjVnp5WXlHMjBLc1dYelpFZzdvTTQvd0IxSk1JanJlbld6dVBtK0lQd29jbUdqT2RUNlpGc3hjYVJNQTFTTWdIemJyL1NRR1k4VDJJbXZUOVBub1NVYk1OMVBURkhLNFBmSEZldmh5SjdPV2NLS0xWQUlTVE1kelhiQjJRa2dCSVlOdTRpTUFENlU0b0p3SUtuSTlhZTEySy9nK3YvQVBTUDdRM05iMCs1MG5WdnZ2YVVmMjJPU2JmcDh2eVB0WGorcXdySGs1THAvd0NUWkZ5WEkra0FCUUN2SSs5VUkydHM1MmV3cExNTWRxTDBCSFJiM0hkd1Jta2FIVEpLc25NN2djNG9jdkJxSmhBdVNjNXBtN1dnVWRMSHpBREhBcEtIUE5iSlVTTSs5YWtZNDF0b0JreUQ2VWVKckFNdTI2UUFlKzBkNnpWQlIyMkNkeE9ET0pwWWVRdEVyU2VaRkFpREhQem9YdlJtR2p5bmR4dG1tZTAyTDVLYnFBQzNFZzRLVHlQVTExZW5UNElXVldPZE04TzdIaC81TEl6eFhNN3BqTjdHL0FEUHVVd3lnQURzUGV0RytoWlYyZTFObGsxR3dLWk1HUU1ERVVJSzQyd3ZUb2xadHNzcGRlU0JBTmFPbTdOM1ExYXNqYWR4M0Q0ZC93Q0NqRmN2ME05SFZzamNSc0h0V2FveUlHMDJUejZBWWlrMnV4a2VOb3E2N3dOMmF6MEZIdHZuQWdtZmxXWHVabnBIckt5NUJnZHZXblMrUld3ZHdBb3BHRHdQcFN0SUtDV2xFaG94VklSVGRzV1RhVklydXRhb2FIUlBjQUx1ZktpVGwyOVBiNDA4cVgyR2hCeVo4WjZHOTNxZjJwTjNXWEMxN2V6SDBHWWdEMEZWejFqdyswOUdDOTFIMzM3TmpZaThBeGp0MnI1eVhaMG1tQkFIbUpCQUE0OXhTV0dpWWZkaVpJeDhhbWxTQ0N2a0VRY2tuTmI3R0tQcUhoQU9TT2VNMFVBd24yZ3Q3MkpRZnZYVGhkTXpQbmZXTkp3WVBOZXpnbVFtakphdTFOeURJRXdjY1Y2VUhvNTJ0N0t5OWJDa2hDQ0JtYTZvdHRiSXlWZEFYSCtCTVQzRlUrNVB4UlkvWnJxNzlHNjdvdGNrN0xianhWLzlsNFlmU2FobnhmVXh1SVZ2WHlmcE0zVU5seTdydGdSNkhQUDByeFhjbGFJZE1pbHpmY1VBR0RISGJNVVU5R2EyTWhrdGhwSkJVY0UwamxUR29OWVlNU0ZiYzh4aXMzNVpxOEk2em9VRVo1Qmp0Rkd1MGdKa0ZrbjA3ejZVUEd4cStCbTNES1FjbnNZOXFGMncxUkpyWjJFaUpreFROMERzWGUxdWNiU0RQNGlwdGpJRTF2bVZCL0QxcFJqdGxkejVKbU94ajYwVnRnWTIxdWJMQVFZSEZXVDBUYU05MVZpdDJ6SVVrMjVNdEgrUnErR1RVTkdjYll0OW50YmFGb0Nkb3hraUp3UDlWSngwd1MxSkl2Tk5lRjI5NGR0b1BKeG1nL2FtMEJiWjNWNmdGUTdsbUkybUZQNVVzVTJobnBpbWsxWWZYMjl2bkRtUkhOS28wcVlYM2FMbFdKWmt3U0RJelZGVldEWWUyaDJIY1NCa2VuZitmV2xrMFpJaUx0bHJndGxpV0hJNG4xaXB5a3V4bDhCTHlrdUJKejNyQm9TdUtRODdUMytmMU5HTVZXak50OWhiQVVxR0gzY1RGTjNwQ3Y3ZzFSbU5zQmVEOC84QW1wc1pCN2RvSmF5ZG9Ba2swYmFXalZzK1kvYlhyN3JkVTJUL0FITDByYkI0dDJ4MytKUDh4VklSK3E5OUk3TU9PdXpLL1lIVGYxSFZMcnFkeFFnbVl5U1pxMzRnK01FaTJMYlo5NTZMQ0xiZGw3U2E4QnJ5WExhM3VkR1VNV2t3Q0RIUC9GVHByWXhNRnJiU3N3UkU4L3ppbFd3c2pjM1EwU0lITTAzRkphRnNvdGVqczNtQklPUG1SL3V0RmEwWW85ZnBHdUFZeEFKUHBWRTBqR1g2cDBuZmtxWUhGZGVMTHhZa2tmT3Z0UHBGMDVPd0gxTmUxNldmTHM1OGlveTcyeUYzeklJNG50WG9wK0RtcnlBdUxna1RIcU9CVkNiMEJWU1dLNU82alF2aysxL1pmckY3WC9aalEzRGRiY2xvV3kyTWJNYmo5QlhrWklMSE54STVMYjBhVzNyRmExYUM3OXpLR2xpUmlPNStsY2tYVjJPNDNWRXhxeGQxQWVkemNuMEh0UmpGMXZvRTVWMFdxWGZBMDdYV2FZV1lIcldhdDBMZEt5WGplQnBiRzRBdmdIMko1b09QS1dqUmZHSTJKUEVFSGdSM2lrNVVpMURQaHN5RUU5cCtkQmZKaWRyeWlESVBGYTdBMFFieTNBVHhCSk5JMk11Z054R2lTREU5K0t5Q0R0UE4xUnhPTWQ4MVJLdHNWdndPT0I0S3dSQmJhM1lqNFVXMitoVjl6T2RWdWxMNktGM3duM2dCNm4xcnJ3VzRhUm5WbWM2VHJocWRPVzB6aTFzRzBMY2d0bjJwSng0ZTFtN2RqMnMxbmhYdnY3d0VobW5KTThZOWZTdEJXaVVsc2pvTldMMWhoZll0Y0VsZk53RDI5cVhJbXRJckZMdG5oY09tZEx0dnhDQkJnOGdldEtseWJUN0M5TFJvTlAxU1V0dU5oSU8wa25idTlmM3BHa3JTTWsvSVc5MUJyOXVMYkJZRzhUeXh6aW8wMDlsTzFvVk92OE5nVGc1WUVIM2lQcFRSaFlrM1JaNmZxMWorbXR2ZmRSZUxiUWdhU1I2L25WSXdibHBhRjVwTGZaWVdkbDhLNEtzQ0prZS9GT3FYalp1dzlxMHE0NTJuT2VLVFlTVmhSdFRhQUFUUDUxTnFtTjJJL2FCeHBlbTZoaEpsQU4zdTJQMXBJdDJPbGJQaEgydnZGdXVaWWVHYlEyRWZQOGNWNlhwb0xoL1U3SU9rV0gvU2xUL1g2cFZPVHRJSHFJelUvd0FWVnFMRGcxWjlxMHJhZTFaVXNBREVpUkZlRkp1cU9oYkg5SnFiVGY4QWphWWpFejcxTnV0RFVOMjMzTHlKam4rZlA2MHFmd1lxZXBkWjBtbUpEdnVhZUFhS2pLWFJxRUIxYXhlVWtCQU1jbW5VR2dNWDFlcnNtR0Qyd2VJbWpHTE1VUFZOZmFJWVNJcm9oRFlqWjh2KzFyaDdyc0Jpdlk5S3FJNU9qR1gwaUlqYjZWN0VlamphWUJBUzdMR0dIQTlxZHJWaVdSWklaUUJPU0tDQTBiNzdDNmdEN052YmY3cWFoa0lIb1FDQjlacmc5VkgvQUZMSlQ4R2swR28vcUxKV1drRWhmU01mN3JrbERpQzdMZlNXM3NNck1TUVptZVpqK2ZTbFZTMVlKTXNMT3NlN3FVUjRWVUltUHcvU3R4U1YvSk55dDBTMVdyWStBbmU0R1laanZBL1d0R0huNEJ5MVJvdEhxTExoVTNEeEFNajBGY3M2WFoxUmRqNGJ5bVlrMHJZMUhsVUVad3BQY1lxZk5YUWVJYndmRGJ4TGlpQUpNbVByUm4xYU11eXMxRjhoSGt6bnVlYTBWclFaRmZwcjgzMDdqMUhZQ2E2b0xWRVpNbnFlcjdOSGhJTytBRDdEOGFvc1JONURLOVYxMTY3ZlIyVUFsUDhBSSs1cnJ3eFNoUWJ0bUg2SzdtK1dtQXZtSHFSR2Fya2pwbE5XYUpidHk3WkVIYmJCNFBlVFVGRkx2c2k5amZUZk5kSU9Oc3Njd0NlMDBrMVcwUEY2Mk9XN3dOd2JWTE1aSUl3Qi9QMnFUaS8wUTlqTjI2TFFsQ3B1UnlmanhTS045aGJGYldxZWQ2bmNvSklvU1dxR1NCLzE1VzhUczRNYzQ0LzVwNHdwSW5MYkNhYlVYTDJxVm1WWmU1Z0FjQ0taMm8waktDYnNzclBVTDNUcmd1bzMvaktqYVRPUGY1VW1QSHpkQW5MakUzUkRtNDZxQmdqbjQrdFNqSGxzWnV0SEJjQXRFZ25kSkVBZHEzRFRIVXRHVisyZXNZZE5KM01WVzRoOVlFeFA0MCtPQ3JRSXU1SHgvcmh0WDdzM0dNcXhDOXpIL1A1MTI0cmowZDBJOGs3SGZzdnFuNmJyTlZlc2dGbGdFUlBlazlWRDZrVW1QRDJ0bXl0OWNiVmFkcjJ1MTEyeUY4elc5TnB6ZVpWOVdKSUMvQ3ZMbGc0dW9xLzFkRjA3N0pkRDY3YlhWZUwwN1czdFFGLzhsdTlhMk5IY2dUQitWTG13TktwcWd4ZDlIMERYYXByZWdiVkl4OE5sM0ErbzVyeklSdVhFZG55blVhalY5UTZpV0Q3VWJ6NzJ3QUNhOWhSaGpnU3R0bG5ycm5UdWxhVkcxWjZ4ZEZ5ZHR5MmdSQ1JIRzdrVkRHc21XVlI0ak9rdG1kMW5VbjI3OUJxN3dYLyszcVZBYjVFWU5ka01QaWEvWW0zOEF1bXRyOWZxTm9WbVdNc0JpbXlMSGpRRmJFdnRMbzdpVzJGdzU3NHFucHBwdlFKclJpblNRd0VyRUNkdGV6Rm5HMVlxOHF3TThjbU9LclZvaTlIcElZRW5nemtVS3NObW4reVJkOU5yZFB1QUF1SmRDbmpJSVA2Vnkrb3BOTWxrVDBhYTNmOEFDVkpPellJOGhrajFybGNMSTlkRnAwKys1dFhMZHhtT0pESEpROS9qaWxjVW5hRmIxc2Z0WEMvaWJHVjVBZzkvalJxaEh2b0MzVXhkMXRqY0Z0VzdSMitwSUEvV3Q5S291Z3BxMGFmcEY3ZHJMVzB5R3djY25hZjNyZ3l4NHhiWjFRZTBrYWkwb1ZDekxNOTY1NHV5ckNvU2w4Z2drWWdFZmpTUmpiZWhtOUJMMnBWVmhnR2s4azlxcHhmOUJiS2JWWGJiVzdoRzNjMFpIcDdVWWQwalRXcksvVVhBaE51MnBWaWd6UHFhNmNLdmJJWlhTcEEzMG5oZFBXL2NJYmQvakhxS3VwWDdVSlhrb2VwV0VlNWFaOW00Mng5NWdPNTlUWFhnMUJCYWRzK2Y5TEIzK0hJZ25KT0k0cW1Sb3F6VmFhRXVXdHM3U1Q3ajRtdWFXMVJMN2pkbEowN3RkT0dMR0ZNei9EUzd1a1p0QmRJU3hHU25sQkVIMWlweVNUMkZTdm9DNUNYR0RYSWc3Y2pqT0JTM3BKSW92a2xZVld0bUdsWUxNT08vNVVKTjloUldXTlE5OHNwVlZ0YnR3SEVmT3JxS2lydlpOdlkvb3RTcVhVdUZnQWhNamorQ29UWDJLUmREbW0xRmk1MXU2bXZoOUtscHJycXBpWVVRSitOQmNsQmNOT3hHaysvZzF1czY4bW5zK09HRGJrRExCa1JITlFWdDhZbFZIVnN6ZG43UjZyVG82WHJoYXl5YncvZFdBT0I3WkgwcnBoalRKemI2R3Z0SnJMWTZZNjJ5cHZYcllGc2RzZ1N4OWhQMWlwdzhGSUsyZkc5WThHK1NQT1dnbWVNOC9sWG9SMjBlbFNVZEcxLzZTYWRkZHFPb0ZsdDNCdFJDclo1bXZQOEF4VEp3NHI5UTRZOXMrazIranBvK2wzZEtlbWVQWnVMRGkxQTNUWGtTemM1S1Zsa3FLL28vUVVTNGJxZE10YVJVSGxMTVdJOThubXRQTTVhY3JDYUhyaXFQc3dMU2dlUk51UkZSeE9zbG1hTWw5bWRFVXZnSlpSakVnTUp5T0s2dlVUVWtLdEdrNnhwLys1MjF0NnpwamFqWWQ2bFFmTDJ4bml1U0V1RHVNcUhzcUUremx4N2hqcGFhZTFNazNCbHYxcm8rdlMzS3hhdGxyZjA5dlNhVWpiYlJ3T0ZVQ0trcFhLd3RIeWY3Y1hVVjdnRVpyMlBSS3lHVG8rYnM4TS9CbkhQRmU5RmFPSnVoZStmT1c1TUhFWTQvNXE2SXlldGtoNXdWQkV4ZzFPNllhdEYzOWxMeUpxdFVsMFphMElneEJEQ1ordFI5UjBtaWVSV2FPMWR0dXNLcEpVNXhpSzVwUFJ6K1N6MGRxVEtzNmdEN3FtczVyd2hISFFZTzF1NHhWbVZnSWtpSm9YZXpWUksyYmY4QVVzR0F4R2VKRlp0MXNDN0wzb3Q4V2I5d09WaVE2bVptWUJybXlwUzBXaTZQb1ZxNmoyZ3hJS2pPT0Q2VndLTmRuVGQ5RVd1cDk3MTlPYWJTQnNCZnVJMHJiSVkrczFuVFZJWmZjUzFFc3BWZ0ZKUFBhcHhUaTZDM2FLbDNZNnBtSk1LTUNlZlN1M0VxMHpueWIyT1huOFhwNFZTSWljOW9IZW5hcGl4Wm51cDdpOW5aZTJmMjhneG56Tm5OZC9wNDNBem5UcnN4L1J1bnZjdCtNaUVvMlFXSUF4Zy9qVThtVko4V1ZraXhMYm4ydmR0REIyaGJvWW4vQUhTTnJ1alJTcW1FTnhyYWkwMTYycEhhWkFQdkFwazlXUWNSamRDbDB2S1RnZVV6U1NWYWFCR3hTNXFkdHhrZ095bkJNNFA2ODFOeHZhNkxSdElGclRjc2dNcFkzV0RibzQyLzhWb2RoZlJIVGxTR0Z2S0NBWU9NK3RNKzlpdDZGcnJ4ZHc4S0JrZHFkSUZrcmw1enFRYmJiV1pOaHp6eC9xaHgxc1pESzY2L2Mwc0Zac3dFUW5NQWR2enFYMFZ5dTlsbEwyMFM2cHFHTm16YkdCc0FHS09GYmJGbWxwSE5ScmhjZExUM1FvUzNhUVp3TVNlUGNuNlVIR25vcGkvTFppZXFEZnE5UmNzdU5yTmdIQlArcTZzYnBKTTdPTDRtMS82TWFzNmZxT3VzaU43QlNQbFhtZmpFZVNqTDlTMkRWbys1NkoyZTJ2aWNBU1I2akZlSWl6UnpVQU1xb29ENEV4eFdqRk1EWXAxMjJxYUMyQVJCTzRnZnorVFJ4eDl3R3lvNktvVyt1MkptQ0FLcGxqWm9teHMzZ1dCQWhUQTRqNi9XdVZLbHNkb1YxdDlRTGhPMEVUeE5hbUV3L1hkY0ZERGRIc0RYWGhoWXNuUjhpKzErcGE1Y1lTVG5qMHIzZlJ4bzVjck1kdE1TQ0pPQ2ZTSzlkTTRtanB0LzNFQkprRVJQRk9wYUVjYkEyVmdnVGtrY2lPZlg1Vm1CTXVmc3hhdWFqN1EyMXRLV2E5YWZnamtDVHo4S2ptYVVOK0JacXpjanBtb1hjTGRnaUk1dUxQUHhyaGVTTFhaSGkwN1l6cHRIcjBBLy9HSUpIK0lCejlhWG5GK1RTZ3p6YVhxVGZmczNTbzdiWXhWZVVmREk4V0FPazF3dUVlRVJiUEc1U1l6UmJoWFprTjZBYWkxZDNNcmJUQklOcy90VTIxOGhUbzIvU09yVzIwNnBjUnZLQUppdUxMaWZndmpuOGxoL1dJMXNobkcyZUQrTlJVV3RGbTB3VGFteUczZUlpNS95UEUwcnQ2R1MxWUxVNnUyU1J2V0JFWmsxVlZKaVUwaE5MaUtkMEJ5M2M5cXVyRW9YMVYxVGFVRW1ET0JnY1lIenFsT2hGMklkU2EwMTYyWWNmMnhoVDhhN3NFdllKS096SjZCamE2WmRGc0NRQXU3R1NSSkU4OTRxRTE3N1owdmJvcWRRdTNVS29CQjhxdEhxQm5QMXF5MnJGTE5XQnRLekVFUms4d2ZYL21rUkxwbmJBVVh5Z0lEN2R4V2VjOXYyb04yRkpVRkRJTHpTU0EwUm45S20weGtPWERhdWgyRERZMkdCNUh5cEczVkdpdGl0eXh1c3VtMHJuN29QdFRYVHNWYkU3bHRnOFdqQlVpZnBUcC9KdWtldDJtQVc0MGhOd1hBek1WbkpQVEdTOGcyUXEwZ25IbDI4WW4xb0tXcUg4QXJ0eDkyMGVZZ0FBZ2NDUGFtaXRHOGxiZjFEUTZzTm9aaWNFSDBBOTZmajVMWS9BamV1TUE5ekRLTUF4M2dIOElvSkp1anZweGphTGIvcDVyalkrMDZ1VHROeFkrTlEvRWNkNGYwQmhsNzJqOUU5UDFZdjJFWU9WRWNUelh6VGpSMU01ZTFJYlYyclNtTjg0UGN4UWo4c0RRUDdUWDdlbnNMTjFWZ1JMR08zcFZJZTU2Rk0vd0JIMWR2L0FMcllzalVLUmRKQUMrc1RWSnhmRzZNdXpXV3liWkc0bkE1TWZ6MXJtcFdPVlhVdGJzUnh1RXhOTkNJR3o1OTEvVzdtYkk3NHIwTU9NbTJmTlB0QTdQZmYvd0JoWHNlblZITmtkbElRUE13WHlpWWsxM3I0T1o2N09zUUZCREV3UVNUVEsraGFWV0tsVDRaWUFtUklNOW9xaEt4N1F1YldyczMxWVNqaGllOEVHVFVjaXZRWHVKclU2aHFibHJaZGU0eW9RT1M0QXhIZjQxeXVFVnNoVGZrdGRMMTNVd0Z1K0dlKzRySCtxUjRrK2pOT2gyMzFpL3VJRnEyUklCa2s1bmlzc1NKTzBHdGRmdWhrbXpiMmsvZEdLTHhKaUt4L1Q5ZnR1b2xHdE1SeE1qbnNhbThERHpaYXIxTlZVTmNWc0RBeDZHb2ZTc3FwdGRrbTZ0WWJoUXpSQlV4L09LVjRmSTZ5M29RYnFyWFdjQzJsdFZrekg1SDFwM2hVS3MwY3JsWlhXdXNYQmZDdWkzRUFrbWN4Ni9qVkpZRitnWXpiTE81MWZSV0xha09HWjVNYlJQenFhOVBKdllIbFlocU90YjlJdXkwck5nYjJVUVBsM3F2MFB1YU9SK1N2dTZxOGorVnk0SW5jQ0lQYjlLN2NLU2lralhiMloyM3FVdGRPYnhIa0Y1VkFZSkhhUG5GVGxHNTFSVi9JRm1lNWZ1M0dBS3FKZ2R4bjAvT2lra2trS25ZOTBweVF5UERFemNiNHp4OUlOSkxRc2xleGdaWjdxRHNQY2ZqU2RhRlQyRnVFSXFaaGdza2ZsajlxVHNwUUs5NWR4U0lLenozckxZWktoelQzV3ZJV3VrQWxvT1I2Vm11UFJNV0RnM0x1MWNib0VEam45NktRV2dhd2JnVXRPWkFFWno3MFdORkVHRzFtRXNEUEczZDlTS0hnWVd2N25acEVpY0F5UjcwOFdrTHV5bTFMSmF2T05vYUI1UUJFd0NKL0dxVTJXeHZXeEMvSXU3UkRXb3p0UGYyK1VVeW82MUp0QmVrM0RwK3FhUzlKQVZsWDNpQUtYMUVlV05vTUhVa3o3bjBYWDNFMHRzTk9SWHpPU0NPMDFRMHVqNmxvMFc4Q3JLZDZPaGhyYmRpRCtsY2NYS01yQ3o1bjl0ZEwxZCtvWE5QZnUvMUNJQnR1V3dWeDdqc2VhOVgwc3NWV2ljck8vWkRwTjdTZFJzYXpVM1RGa3lGSm1LUHFjcW5GeFNGaXFOOXFlc1c3aDhOR0UrM2V2TyttMXRsTEtUcTk1MlJpZUk0cTBJcEN0bUw2c3UvY1pQeTlLN3NRak1IMWY3N2c4bnYrdGVuaE9mSVV6RGRNbmdaL091MU01MmlWME1RQXNnRW5neGorUlZFeEdnRjBlVTRVQVNQUVppbWk3Sk5VTWFXSWlTUjRVRDRnRVVtUWVQd2FQVDJMaHRzd1pSdlZTWjc0RmNya21RZHgwT0ZMZ1RjWS93QVRLc0k0N0RGYlRGYmFDMmhjWElkR2cvZE01aytuNFViRVowUGMzQUFoQnlSdTdSUU5ReUxxQnhsdG9NR0RCT2FENk1sc09lcE9iak1wWUtUaGVNZHFSUTBrRjkySHNheDJ1TUdVakpPNC93QStQMHJQSDVGVXFkRFN0Y1hTT2pJQVkzR1ZHUk14UGJpbGFYSk1aZFVoTFVxd1ZRQ0ZKMjRHWjVJcDR0TjJOVG9IZXR0YUt1U04vd0I0QWZtYTEyR2cxcDBYVEJXTWd3QjNFNG41MEUyRngrQnZVYVUzVXNOYnNJODJ4Slp0cEJrOXBxOEc2R1NSaXRKcHZOWlZqTGVoK3Y2ME1rK3gwaGxpaUc0c2dtNE5nRW4xTkJYb0JaNkMyTFlETk80cWM5c2dSVTI3QkxvSVFrZ0swN1pKMjVKcE5pcUp5R3VOdXVNeWlRRE5DMHVpcVRZVmtTN3VhUnRtRDZ4OGFXT2xRSlcyQk4yeGF0eHVYMXdQNTYxVGJFb2g0aXV5NVU4ZVU1LzRyYkcwU2E2OW9pRllxR2ttVEI1K1ZEc1pmSUc0NEkzYjRKN3p0UDZVTm0wQlpEYysvT09USHY4QWhUcDBKZENYVUxSdTNHTER6YkJnQ09aejZVMFhSYkY4bGNRcW8xekFBemtUSmlmMW96ZDZPN0d1S3NVdU9ySTdxUVAvQUZBN2Z5S3FsNEZtOTJmWXZzUDFHejFIcGR2Y3dMS29WaDNyNXoxZUo0OGpSMXdseWpack5KMHZxRysvcU5KMVp0UGJnZVh3ZzRQN1Z3dWNYcHhzWmRpM1dOSjFPOWFBL3I5QStKWjhxVDhRUit0SEhPRVgweDJyUm1IMHZVbXUrRi9XMmszZDFXYTdWUEhWMFNhWmY5SDZlbWp0QVhMejM3bVMxMTRCUHdBNHJubk56ZDlHMGdmVjcxdFVnSEFvd1RGWmh1cTZqRnc3aVRnVjZHS0lrbVlqcVRiM1ltWW4wN1Y2V0xSenpLc0xERmNFdHhOZGZnZ3p0eElqYVlVZCs4L3o5S1pQNUZhK0JWMkc1aUdtY2p5eC9PMVVpVGV4M1RLRWNBTVF1emdqdnVwSnUwR0pwT21BUG9odWtPQkJIcVlIOC9TdVdiMlJrdHNzVkZ1NHhGdllBSUVLdTNJSHh6eDYwaWRNV1Mxc2tMWlZaZFdtQmdZK09hZXhHOW5VdEFYRllxVkphU0JqUHpyTkdVZ2xxMEJzM1RnRWVVVXRNell6WXQyL0VHM3lxUUp4TllSOUQxczIwSEJacG5JNzFPVVcyT3BKRU5ScUZjRlM2Z25JUlNTVFdqSDVHdHZvUTFGMjVkWUtqQlJ0MndPL3BKN3o3VlNLb1Bib0dpS3ZoeGROMXVTWjk2enRvZGEwT2FhNFJhSGhvUWh4SVh6Q1RuUHVhS1FMMkUxbHE0TGlRRmNiQmtuUEZXajBCR1EwOTlsS0Y4a0dGYjBnZnRTWkkydEZZNmV4Z3B2dUxlTUEyNFlpZUIvRFUrYldqT0paaTRXRm90SkRBckxBbU1nVDhlZnBRYU1pZmgzQ0Y4T0F4TzZXWGJqZ2NaK3RKZnlFSVRmVmdkd0lqQkUvdFNxZ2dEY3VOdW1YNzdlVkI5OFVlalVRVGVYak1BVENDUDBvNjhpdGZCN3dsdUpJNWtSUEg1VTJoWFlaZEpjQlR5RmQwc01pRDZFY1ZtNjdGNVdFWFQzUXhVSVc3NTcvQUVwTFJrd2x1eGUycHRTNERJenQvazBHMXNic3IrcDZlOG1zWUVlVmdyRm9pTUgvQUhXVWxSMFlsYU0zcnZFdDNDSURBNGp0WFRHcEt6cFV0VWhPMnNoQXhoVHdTUGxtbnVtWjcwV2ZRT3JYK2phc09qLzJtSTNxRCtOUTlSZ1dlTyt3d245TjBmY2ZzaDFxMTFiUmcycmdNeEtrNUJuaXZtcytKNDVWSkhZbmF0RnhyL3NuWjFsM3hmRllFOWhNVkdPZVVOSU5XVW1vNlBhMFc5UThzSTQ3MWRaWElXaE5yb3NBa3RHT0taS3dHYTZ4MVFzU0F3enpOZFdMRUkyWmpVM3k0dUZqT01HdTNIR2ljak5hMTk3d3ZtaXUzRW4yUW14VGNWM1FPMFpNR2ZYOHE2U1RCdVdCSVVrUVp6NlV5RWU5QUdVeU1nWUhlYWFMRWFvc05PSDhZY05DbjJ5SjUrbEpMb1pMWnJPaXFMbGxpdHNtNFN1MmZubXVHYnAxWXVWVTdHcmFYQmRaWEF5dkJKTUR0eldiVkVsc2J0YWNrUUdBSWt5SmlQNFBTczhuSFluRzlITHFzZ2J3eUkzaEY5V3hrNUdLMGNqYnFqT0lGTGp5QXdFOFlpT094cW5leFhyUVRlNnlEdUI3akU4ZWtVZGcwQ3ZYTHpFS2QyUmlaeitzVUdGSkk3WlJncGt5ZUo0bjJvV21NOURlbnNzMTNiY3pnQUNSZ1RUSVVoZUFIM2lTeE1SNjB1N0thRFdyZ1d4OTNzRGpBNTlxTHNXdGd0WTk1cjJMK210YlZBSzNMbTA4ZW5wWFJpM0d4bWpITDU3ZHNIa0VuOHF6VkZiTEN6NTdLcXhsbmRWamlleE5jMHRPdzJTdDI3ekFnTjVJYjVudkI5dWFQTmFGQzlOZTdjdWkzZGhpa25lTTloSUo3OGloSktyQXkxY2s4VERrN1pHQ0o3Zk9rNk1teE1XZHJMSkJNeEpQdjNIN1ZtOURLV3lDTVE2cjVtRVRuaVI3VWFOWkpKM3dCSGNtSUlqOGhCL0dnQ3c3UGREVzlyOThid0pCN3huaW1YUXVobTFaMUgrTG9GSndkNElpZmFsYWlCc2J0NlBXbUdTN3R5WmdIMTcwamFRVXhIN1EyTHRoN0Y2NnlrTWpJY1JrY0Q4VDlLRU5sOFUrMFpLK1FWRng5dmw4eEg4K05kSytFZGNWcXhZWFYzSUhFQ052dWU1TmJpL0JUbW50aTV1cTE5akdUSjIvS3FxTFNvaE9TYnN1dnN6MXpVZEg2Z2wvVHNkc3d5OWlLNWZVZW1XZU5Qc2ZIbDRQN0gyalFmYjdTYWpSQi9GQ3ZHVlBwWHoyVDBPU0VxYU94VGpKV2lvNmw5cUxGd3NVSlpqZ0VldFZoNmFYa1Z5UmxOZjFhOWVjcVpDakFnMTJSd0tJbk95bzFONEE3cmpEMkV6TlhqSDRFY3E3S3kvcW12WVZmS0FlT2E2WVkrTzJTbE85SXJ0UlpaQ3hjZG9qK2ZLclJsZWtUZnl4UWh6Y1BhUkU4VlZOQ0hrRXFxdkl3VHVHSngzcHVoUUpnT3ZsM0Jja1I2VThSSk1ZdGtoMDI1a0huaWxrdEdUMmFYb0YyYmwrQXg4TmdRSnh3WkpybW5Fbm1rWFJ2MjFTZDZtZUZHUjMvSGlwTk52UWtSMWRZSHRCSVlaQzRNQW1QV2wraUI1ZXdHcE51NTRZa2tZd1JqNDAwWTEySTUyOUVMcFFXaTVKbTQzckJ4L0JpbVRhME5Wa2hkVzJRUEVGdmQyR2UzdzVwdWJhMFRlTjJDdjNMMXVTcFVBaVpVa2NudWExMzJNb3RCZE16c1I1ajRneURNd0k5VFF0R3BockdtdTNHdWJmdkRra2o2VTEvSnJBM2JGMUNxdHRId0JZZmxSVFRReUdMSUtXVWdFTVJKM0FMU1BvcHF5djFPbURhaTU0OStIQi93QVVrRVJYUmpsN1VaOW1hc0FDQmt3U1JQQnpUU0hMQ3hjVkdFbWRwM0VBNEFuL0FKcm1sRnNGa2RUcUhiVTJiVnU0RlJCdEVDT1ptdGp4cW01Q043ME1IVGxQRFpMb1JMZzNObm52QUh5b1haUmFSYVd3THFpQ0ZLcEFiZkU1L3dCVWlWdWdOMHJPblRuYXpQZVFjL2VZUitGUHhKOHdhZFBENVZ3UklPSjlQYXRUTTVobDBWaEVBYTZ3akE4cDcvbFFxUU9RMTRHbmE4bmgzcml1aXFyQlRFOHdZQU1Vc1l1S29MbnkyTzIrbVdoTGk3ZkxrNEhFL2hTeWNrNmZRRlRXdXhwRVd4YUNoMzVqYVdNbWthdmJDcjhGYjlwYlNhanA5enpTNkVPTWNRY3hQdE5HRnAzWlRHNmFNQnI5eVh5TGJEWVZPRDhhNm9LMWJPMVNyUWdWVUVzNnl5aUo0UE5NNzZRNmE3QlBaSklkVERDblVpYlFTenVHd3FjU0NmV2xGTExwZmkzdFRhdEswZUlRcEE1L2sxTEswb3R2d05EODJpOHZkUDF0Z2xYSk1lMmVUWEhITENSZHFTRXJ5WDFDbzJET2FxdUlsc1dPbWRtaUpNemswLzFFa0x4c1BhMHBMV3dvSkpuQStCcEhrRHhPdDAxbkFhNFNPY2NVdjFhNk54S1hxTm9XbThvNC9HdW5ITyt4SlIrQkZqc1ZvSUs5ajJKRmRLN0pQb0VCSnR5eTRPUnpuK1JUSmttZzJWRnRweHhudHgrOUR1d2x4MEUzL0VjTExLZk1RSXlmWE5Ka2FvaGtWTzJhRHc3bDBCcm5oZ0tZZ2lJajRWeThrTGRhR2JmbEkyM1dtY25ZQm4yelRNUjdKWDdJS3ExeTY3M0NCQWc0ZzgwaXliRzQxMktzbm1RTW5KUEluMHhrOFU2ZDlETDduVnVvR0Rnc3Q1WkNqbkhxVDZtYzFxOEJzQmdnQWxSN0dUdVBPZjJwZzJIdEo0VnROekRZRHVtZmV0ZGdhSDdXcEdEYVppeC8rZ3RMTFFrWVA1QzJ0WTE2NDZhaHdBQmp3d0Q4cDcwVXRlMExUUWE0SjB6UGFBZHlJQ0ZZTTBaT2xjbWFDYmRVVW12T28vcW04TzhxckFnQmZZVmJGdU4wVWxHblJSV3duaUo5NXBKRUF4Tk8zMk82UzBPbXhjV0RkVmszR0RqSnlacURhOEM5a05SWVlNbHhDektaa0FaeHpXaS9ERlllMmx6V0cwRGJBVURBKzZBT09UUzZpTVdtbjAzaG9pSmJVZ2Y1WEdWdWM0Z2UxVGJ0MkZQUTlwOUltd05jWkZQcXAvV0tMeVVTcXdsblRhYVZBVkRuSlp6SnhTdkkySGlNcmF0SmtXN2U3bmtuOCthM0ppMEh2TzYybWF5Y2dTQnRqSHhvdXFCRmJvTWx4dkVsWDNZbVFaSEZCeGNqV29rSFlIYXJOdVlOd2N4bm5pcHZROGQ3RmRWY0NxWjhwZ2pESDlSUWkyMk5TTUQxeEF1djFTMmo1RjIvQVNzeDhNZmlLNjhiOXFPekh0V3hLNFZkUUVVaUNBV1Bjbmo2WnJKZmM2SEpmQXZmRzRtRDRZLzlSMkFGTkYwVHlkaEFBR0FFUWZmNDBMSmozVGJoczZxMWNFN2xjTVBnQ1AyTlN5SzR1STBYVFBzT282YW1wMDR2cVozRGRJcndZemNkSFYyWjNxUFNDWFlRUXY4QXIvZFhqNmdIRXJCMG9xd0NoaVJ3WS9PcS9YQnhHZExvaUdBWVQyeWVLbkxLTnhEYXZwNE5vWU00aUp6U3JMc0ZHTTYzcFNsMTVFQU1GQXlKTmVoZ3lDeWpvejk0RjRSajVwNU9LN29QeWM4bHFnRWxrNSs2SU9mZXJMUkY3RDNRVjJuYmhSdUk5QlNSZGhrcUcraDZ4YmQyNWFZZmVVaFdqSUk3VnNzTHBrWjdXallhYTBsNUxaWnJZTEFUblBwTmNqa290MFNjV3kxdGFEU2kwV3Vha3BPQnNZWi9Pb1N6U2s2aWhvdzQ3WUszb1ZMckYrNkVVa2tUbVBRMVR0Qzg2WjY1MDRQYy90RjNVUUFKbkh1YVpXbFV2SXJuZlFhL29iaU1GdklCM0FKbkh5clJhbHRNTjEyamk5SVhmdURPd0F4dDc1b1BMV3JIamI4RGxyb0RQYXdnVmV4dStYK0d1ZCtxNDlzcXNUbDRGdGIweHJKSVJFUUdBRHZWaXg1OWZhcVF6Y3FiMlo0NnRBdEZwRDRvOHlwQkJMRnZ3cnArb3FKT05scHBBeG54WEJGck1qajAvZXVYTlBWSXRpalRzenV1VjN2Qnk1QmNiakpHZmV1NkRwVUNTMlVtbHRUZDNNb0p3U0QyK253cWs1Q0Z6WnNtODI5WFVOd0lCRVk5cWl4VzZETFpEQUJyb2dOSmdHUHBSNEUzT21NV0xLTU51K2ZsNzg1cGVKdWJEV05KcG1YZGV1RUJUNWlvSkg3VXMwMTBOR2Q2TzZtMU9sWTZkbXRneHNQZjRuOG9yaWVkdDBqcWhoUy9NS1g5VTlqVldrdlBDWE54and0eEVBQWZqUDRWU0UrYXNFc1NTMExXYitwZEh2MjdqaFpiY0h6azVVeDY4WW91ZkYxOGpmVFRTR05MMXV4ZjB4czZsUU5aTEw5MkEyZVFUeHlLdFRla1NXRnFWcDZHYit2UzFhOFVyYjJJdm1MT0FRUU9CaVRVZnFTdmlsc2I2QzhzSHFPcmFmOEFvemZRTzVVeXlIeTdTQUdJSm41WXA3bGRDckZzUjFQVkxkN1VXZFJwdzV0S0NwdGt4SHJPY1VyNUtXd3FHcU1ycjlUNDNVTlk0QkMzTGtaT2NEa1Yyd2g3WTMyZEVIeFhFU2E3YzNiV2s3blZ1ZTZpT2FMalhSVGxaNUNHSXdjakFpYUZVQ1RzYnNXWHViUndGSXo4alUzS2hhTkIwYm90N1Z1dmxjV3pQbWptdVBOblVTc1lIMWJveXVtaXRXTGdMRkJFOTRBeFhqWkhiYlJkSVkxZWlGeFFQTVFSa2ZDa1VnMFZiZExNcU52UEk5S2Y2aHFHTFBUZkRHNWhHWTk2VnpacUI2elEvd0Q0cGFJam5KNW44Nlhuc0tSaFB0ZG9vQmRWSXVLTjNFQTlnUHpyMFBTWk4welNXakVhaXlic2hSTHg2Zkd2WXh5bzVwTGtnYmFhTExrSVFjYy9JbW5qa3RrNVFwQmVyV3ZEczJHQk1zZ2tmcCtOTGdiY21nWkVsRk1wL3dDNWJ1YmhsZ0M4eWUyYTdHbEpVem0yaTRzYXk4MTJFZVE2ajdybU9QejUrbGN6alNBNG90N0Q2dDBYKzZCNlEweG11ZVhGYkVhOER2U2RWcVh2M2ROSkNxQ3paZ2MvblNUYWlsTWZnNVBpV1dwKzBOdXpwNDBGZ3VNckZ6RGJwaVNSMm9LRXBTdVFpVmFEZEY2blo2aGVOM1hJd2RSRUFraUo1cE04WndqeHh1aWtFdVZ5Vm10dVdyWXRrcGR1Ynp0SVdUbjlxOG5IS1hLbnM3bXZiclJWYW9CZE9MMTBYYm9KQ3FwdUNaK0hwWGJCSytLYVg5Q0VtNnRwZ05KcEZzaDcxeUpDenRuQUI0L1dueVpISnFLRmlxMkphZ3N1OGtGRUoyaFIzN1RYWmpWb1JrZFBldUpwM3MycmF0TXFaL3hHUmo4YU00SnRObWk2MGlPck1hcTc0WkpTZktWWWpFZTFWeHA4UVNxeXJJdDIxVjV5VkFJbnZTS2NuS21XbmlYRzEyT2FXOEhWZHBTQnpPT2Z6cXV6aWtxWWU1L2FYYzZXOE5BejdVeWtrbXliaTI2UkhTYXEwbmkrSlpYWUloaC92NDBrc2tib2I2TXFzYlZSYzhwT3kyU1NFaVNRT0o5dTllZm56U2JhWFIyWWNDaWszMkExK3JpUURoVmhRREIrTlJnam9VYTdGTklQRnZzeGdYYm1Od0luai9kVWs2VmVFQ2lXbnV6cHJsbDRHOHRuanR6OWFNbzdzVXpsMXJmL0FIVzhYQWFVMmdFOGZDdTFYOU5VTDVZSzFxd3RtMk5RYmwzYkpJTGtGU1A1eFRTaTI3aUl1dGpkc2VMcHI2S3piUTN6ekkvWTFOKzJTYk0xWWo0ejZhODVZYmxBODAvL0FMZjUrTlZjT2FvMTdLM2UxeVM1a3NvZkhxZWYxcm9rcVE4RmJKV2szc3JyZ0JZazRKTThmUVVrbldpcXA3TERwMmplNHdWRkxGc0FBU2NuaW9aY3FqMnhsRytqZTlCK3liSUZ1NjJ5NUxDVnRDSTVITmVSbTlkeTlzR1ZXT3V6Nk4wVHBWblRJclhFVlk1cnpwWkhKbEtMaDlBTFRuWXZsSTdqdlBGU2xNS1FHN3BIMytVQmhHRHgzb1Jtek5JNnVoTGtFcmp0bWp6QUcvb2tCQktnbm1TRG4rZXRac3dsZjBxaTJ3Y291Wmx2eEovR2xidGpHSisyR2lUK21VZ2hBRktxSjVtTTVPY1YxZW5uN3JDZkx0VmFWZFlndHVOZ2x3KzJNaXZlaEwyV3lEWHVwRXZCL3dEMFpycm56bG9Ja0R2SDZVVkwvVnBmQWt2eU94SHJOc1Nsc0hJSW5NOXY5MWZCTHRrY25TUldza1hWM2Y4QXEzTTV4L3V1cmxvalFicHUwWENyc0JiYjdyRXdBUjJwTW4yQngwWHRucHQyOXQ4QzlhY0dKL3VBWkI0aVovQ3VaeVMvTWhXbjBpMzBYUUw5OUhSM0t0NmdqUHJ6eFVubFM2RmNma3NyZjJUL0FMUVgrOFdBZ0dRQlNQTyt4ZFdQOVA4QXNwY3NCZDIwcW95VGNpUjcxejVmVlg1TDQ4YmZnME9zRnJUYWUydXF2c1VpRlcwMjdIRmNlT0xjcmlYaytLcDZNM3ZkOVZldkZDTFFWdGttVEEvZXV5a29wSWkrdytsdkJiQmU0ZDl5NUxFRVN2cCtGRnd1V3VqWG9xOWMvaVhKdHl5YmdBSjVBQXJ0d3JpdGtwTzloZWxvbHRBMTBnYm5JTWp0Mi9XbHp5YmVoNEw1SzNYM3lid0NGU0F2Y0ErLzYxMVlvSngyVG5KcDZCSW91SWpGVkkyclB1UkFya202ay82bnA0NjRwTW05bE56dW1HSkFCSEZCWlpLalR3d2xZSzdyTGpvZkdSRzJsUjNCOWZXcUtYY2ZrNUplblNha24wUzZZR2ZUN2Jsc051TVFCMjUvTWlrek5SZHBnaEN5MGNnQkZBSk1HZjU2NHJoVzlzNitLaURmUitKZDhNdExPUkVrQUQzOWgzbzg2VjBMWHlGMG5UMDA2M1dzbGVSNStGRThRT1R4U3p5T1RTa0N2Z1IxN1drMGplQ3UzYUNUM3dJL2NFMWJIYmxzVnFrWndXcDFRNUtRR01leHJ1Y3FpU29GMXhUYjFPN2FNaUg5enlUL0FEMG8rbmR4b1dmeU02WWtkT3VKTUJua3dlMjJNL1dsbitleGtyUlVkUlZyWUFiSVlzM01UbXVuQzFKdG9WeGFXeGUzSTJnY3FvbVRqdlZKalErdzlvN1R2NUJrS1RNZHE1OHJVTm5SQk42UHAzL1Qzb2x1K2h2bUZZbUZCSGFhK2Y4QVhaMjVjVWRVWXFLUHF1ZzZhcWhkd0I3bVJKcnp3UFpicHBSdEJBOHdNZytuMXBFL0pxQ2YwNGUwckFFQlJnS1lIeUZKZGpkQWJ1bjIzSllBQ3QwWW5idGJTcFZXai8yakJ6aW1UQlJHL2JoZ0F1Um4rR2czc3lSVDY0QlZZS09aNEdmNXpRWWFQbm4yOFZyZWs4UW1OMXNJREgzU1RrZlNNMTNla2FlUklMWHRaODQxZW5GdTR2amhtQ2tqYUI4TWY4VjdNSjJxaVRjYTJ3MnN1cC8yelRiVmdrOER0NWpFL1doamkrYkV5UFJudXAzaTJySWtHV01ZOUlINlY2R0dOUk9YSS9kUUpvUG1QQVVLTWR5S2RNRmFCdmJPeFNWMnE1a0NPS2RTVm1hMFd2VGRjQU5wbTJ3QW5NU2ZYK2V0YytURyt5YmpScE9sZFcxTmgyUkxsenpLeW5jeHpOY09UR3BLd1hUcEgwalQ2eTFjMHRwcktTNVVCblZTUXhqMXJ6bkZzcmFpd1hVTE9zYUxpVzlzQ1FDSVZ2alJpbzY1RHVWOUZkZFM0Ykk4TkEyekpKRXdmalRxVWVWdGlPTHFxRmIwN1NoUlZVQWZlV054bnNhb25XMExYeUFUUzNyNjNFdGdNQ0dVQUNJejJybytwR0ZOaWNXK2ppZE9LTnROdG5iY0lFYy9EOGFyOWRQYVlGQmlRVlh2V0ZZSXFXd3puRThrWXAvRGE4aFN2VEZOUmJOMHBkSUE4UUZ2TDZGakUxMXcxRkpFcGJkc2haYlowM1RFNUlTWkdDQVNmMkZjTTAzbGwrcDZFZWt6d1p6WkRRQW03UGZqdFNTU1VxOGxVOWJPMmRPajZlN3UrNHFydFVSeVFLU1UzR1d2di9rV0t1N085SmRSY1MyWUNNd1VIMHgzbzVrMmdKVTdSY0xvbzFMQndRRldZNDM1NHJsK3ByUm1EdGFOQnFiY014TEFTTTRFNSt0YVdSOFdtS2xiUFhVZlRtL2JGemNBMjZDSWdSRWZLbFRVcVk5R2Z1MlFVdUxlYmhpdVQ5NEdEK2xkY1o5TklXVWZrVkZsSHZJaUJrMm5hemdUam1QalZlVFVXM3NuS3ZCSHFGazNiZTI1L3dDUnBhU2VQZWpqbnhkZ2NMVkF4YnQ2ZlQzRkRlVUFOdllSM0g0VTF5bkswR01GRkdkMTE5Yjk0bTJaUlR0Qm5tZS81MTZHR0RoSGZaR2NsSjY2SjZlMDd1b0VTUUJqdG1oT2FpcktZNDNvMUhSOUN6WFBEVENrUTd4UFByWGxlcHphdG5mamhXa2ZjUHNiMDVMR2lVTDkwcU5vSDcrdGZQWko4cFd4NTkwYkN6WWhnd1lURVQzR2FuWWc2cW9CRWowclBSZ0xzN0Vxb3hua2NVdHZ3RUU2ZjNnV0dDSUJOSyt3b090dmJPSkh4cWlGRk5SekU4ZG9FRTBIMkVwK3FLTm9qYUlNbi9pc2pIenY3WmFsYmR0MHVnTmJLN2VCSkpFOS9ZVjErbWczSzBPdnVmTnI5OTdta3Q1TFhBVEF6SzQ5YTl1TUVwUDRKTjZJNm9pMzBxeUMyNDJvQmlCM0IvYW5ncm0yUm4wWmU0Mzk0a1NTcGc1NTVOZWtvKzA0Nzl3N3BkTzk1dGdNSUpNazRKaXBUbW9sWUswV2VyNlZlOGdWZkx0QUVzZnd4N1ZDSHFFVWxEd1Z1cTAxelNYaGRZTEU4QXpqMHJwaE5UVklsT0xUdGx0MGJXSmN2aTNHOEdCQmFQejRybTlSamFWaVJqNDdOaDAvVzMySzZXeUVsSk0zTGhLTEhlZUQ2VjU4bzByc1B0YjkyeTMwR3ExZDRYWHREU2xRUUZVV3g1dlhPYW0yNld6T01MNkhqcXRTbWx1YXMzdE1wQytTMGJYbU9lSmo1MUJwU2FUS0pLUFFwcHRacXRkWkx0NFNudVJhSFBhVDZWUndoamRJQ2NwTFlWOVhhc0ZsdGx5cUR6M3lkcWcrMVZqamxPbjgrQmVTdWhPKzJwZlUzV1JycGxTRUVuQStId211aUNnbzdFbGZncjlXbHNEd1NWUzJwMmt6bTVNZnQrRldpM2RnUzBWK3UvcEExcmZjRWxBWUNrZ1pPQlZNZjFHdElFdUtmWURSb1UwdG8zQkFhM2h2WCtDcFpIYzNYeWQwVlVFRGUvY1cwNld3VkVCUmdaT2NSUmFUZHNFazZwSFV2SmEwenFUSjVBanNCVXBSYmtaTVQwMTROWmNFemxXNC9BVmVVYUZValgydXRMcU5acExOOUVGbTRxMjNMRWdxMFphZmMvblhsejlNNHFVbzlvcHBLaTRheGJ1RnJ0a0FFd0pMQ09jNS93Q2VLNUl0clRCYUVMMm1WWGZkY1RheEFKM2M5b3FpYmFBNVVVZlU5T0JkOFFNMTFGWU1CSGNuRUQycm94UzFRSk94Q3l5dThzR3pQbGJnZXNlOWRFdmFoWXB0aW5XYjZXdHJFaFZVZ3o2MVRCQ1UzU0hsVU5zeVd2MVYzVzZoNFpoYWFQTDZraml2WHhZbzRvbzQ1emMzU0JXa0NGaHRsdUI2QXppaTNlekpVYWo3TWRPT3B1QWxkelBnQ2ZsL3Y1VjVucmMzSFIzNEk2cytnNkRvbHpVUGFYVEtibDEyQmR6Z01QTDM0SDZWNFdUTnVtZGthU3RuMXpwV2pOcTFJQU9TeElKak9mNTg2ODYvQk43TGF5Qk1HUm5zZWU5TW1LR0lHN2JsdmVmclRVQUU2czhRQmpuMW9VYXdadGxYQWdmSGs0clNXa0ZCWEkya01JUEUxck1JYWxXVUVnOGR6V2Zaa1V2VUZZYWQ5d0pCNEhPS3hqNW45c1FEclZKVldZVzhaa0tjK3VPSzdQUzlGREVhc3FDTFZ0RzJNNGJ6alBxYTlURmIyMkprMGhYVkxkMVdtL3A3SzgzQ1N4TUFjU1NlM0ZkRUdvUzVTWnlTdVNwRXVuZlphNlZadkN1M1MvbUFUeWlKL3dEYy9wUnkrdWowblg4K0JZNEdpKzAzU2RacGdXczJkQm9VVXhtNEN3ajNyam5uaE43YmtXVUd1dEMzVU9uSXFlTHF1cEIzTUR5V2kwVDdrOGZLcXd6UDhzWWdjZkxabnRmcGRHZHpMMUo4Wjgxb2ZwWGZpeVpFL3dBbjl5RTBtdXlrRnE1YnVId1dGd3FJbERCeDdWMldtdmRvaXJ2UmQ5SzYrOWhndDZiYi9kOFVZeDZNRFhKbTlGZnVoKzMrdzhjcWVwbXUwbjJndklRb3Q2RmdDQkcxYlpJSXdNQ1B3cnozanJXeWtzY1h0bWk2VDE3VDZseXI2Q3hZSW5hRmRXbjhzL1dweXhwYmYrQkhpZmdzRHJ0R3FsWHNsaEpZS0UyeVBYbWtVTGR4QWsydHNkMHV0NmJlMDRld1ZaR3d5c2tnZkwyb1N4eVg1dE0yNDliUWQvNk5MYnVqVzlwTzRFWWtlM3dxWENYVmxPYTdhS1BxZlRmNmsrSWlwY3dHVW9abkhNL1BGZEdQSThXbm96cWEwWnZXOUkxL2paUkZ3TU5HSzlQQm54OERtbmlsZlJTYUdiaVdrWUtUczVQSUUxc3lxVFoyNDNjVVdGMjNiQ3Fxa3VBTWsxeWNuMnluRWcrakY2eVRrRkZJOG9nZlA4cVg2aml4VkZQb0N0bXpZWmt0K0g0aGoza1l4QXArY3BiOEFVQUd0Vm5PeEFvSUlFanVSTlVoS3RzempmUTMwdTVmME8xclYwMm1BejNYbk1qdnhTNVl4eU9talZvMG45WmJ2VzAxRjBDYmlBaGRwSldlNWo1MTVqeHlqSnhYajlCcTFZdGEwNDFLa2FhNWIya0hheW5qT1I3YzBITndmdUdjVXl0Nm5ZL285Tzl5OE5pcWhtVG5qSjl2alhSaWw5U1NVUVVvN1o4KzZocTd1czFQaUZ2SndtZTNyOFRYME9EREhIR2tjR1hLNU1qYlVBbmFWRzBjamo0RDZVWk1XS09CRGN2TGJReko0OTZWdWx5WTZWdWtmV2ZzRDAxSHRod3dBSTJTSWsrM3RYelhyOHJibzlQR3FSOVk2VDA1VnVONFZud2JZVVNlek42NTc4VFhqeWxzZHZXelJXN1FWaW9CamNkc3dPL3JTTDRFWk5vREFnbm43MU1BbHVrUmoxcHpCa0NrZ2tTd0JJSHJUQU9QYWdubjVtZzRtVElsVkxER0Q2bjMvd0NLTkl3cnFMZmx3UURubjJxYlFVWnZxbDFpcDhRbmFBWWtpYUNib1pJK1lmYUh4TlRxaGRMU2p5NjJsZmJ3WUUvS0s5RDA5UlZEdlJtcnZURXRrWE5SY1pHTUJ5QklBSFlIdHo4YTlHT1Y5Uk9lZFBzdHVtYWQyYzJ1bmROWjNVU0hOdVFvN1NUZ1Q4S2hrbDVuSTJsMFg3YUprdGVKMWpxQ1dTNE1vR0R1TzhDT0s1dVN1b0lPeXYxL1Z1aGFTOTRkbTJMakx5eGdzMmMrcHE4TU9XYXNXMGlnNmg5cmR5a2FQcCtuUUhBZDRaaGo1bXUySG9yL0FEU0p1YVhSbk9vOWUxbDIyWXZXaHVQWlRHUjhLN2NYcFlKN1JHZVIrRE8zcmx3c1E1UjhUSXdTYy9EMXIwSXhSenRzZ2dHb1NBU0dudjNNVlIrM2FGL05wanZUdFRzZGJPcEtxc2dCaVQ1UjZIOEtobXgydWNTdU9kZTFtalIwTmtEVHFBMHlXam1jZlN1S3QrNDZsSFdoa2RWdkloVzRVYzd1WEJQcC9Jb3d4cFBSS2NXeTY2YTJxMTZHMzA0cDRZUDl4YlJBYVBoVWNuR0x2SjJUa3BWOWpRLzBHcllpM2RlM2JJWFl6RXpBamo4cTVyUzJrQ1RUMGh6K2tTeGk1ZFowWGFCeEFVZk9wKzk5SWZsQjlpbXZXeXVvS3hlTURzWi9XdXIwL0p3OTFFOG4wNzhtQTZZcWhsSnlTcHdUQTVpdTMxRGQwZFdDdU5scGRBdFNReEI1Si9DQjlhNEcrUmNIL1ZzRklYelB6eHhpaDlOZVFPVFIyMVpsd2J1SEhtM09JZzhRS0RsNFJsRjFiR2J0a3RaTFdjd0JKWmVPMCszSGFrNVc2WVhvaFowUkpYeUVqYklCOHEvem1tbGxTOGkvY2JUU2FuVUVqWmRhUUpXMnBBajA5QlhPOGtJdE5OZjFEZnloelNkTWZSM2hjdXhwcllHMVUveVk5eWYycU1zeW11Szl6RFRaa3Z0NzFsTlV3ME9tWXN0dU41SEh3bnZYcmZodnBKWTE5U2FPZlBrWDVVWXBpWDg1WVN4NDRpdllPTDdqTEFpMHpMaFJnR01WRzdkRkV0V0c2WlpKdlcyWTdSRzc0Q2FsbWxwcEZjU3AyejZSOWp1cG5wMnNzalVTMWdnN2gvNmYvVVY0UHJNUDFGeWoyZDBIWHRQdVhTK29hYlZhVlhSMElmOEF5VTQvS3ZCbEZ4ZEQyWEU3clJadG96RGZ3VVg4b1VSYTRWT3dTV0xUSHQ2VlNPMGdOam1rUm5JRXdUNW85dmI4S0Q3TVByOTFHV0RpZWYzL0FIcW5leFNiSU1qQTVHSnhUTkFUQU1pcVFEdERFY2UxTFFiRnRUczJRdmZqaWxhMk1qS2RkZTNha0V6NWNlYmowbWtVSEowTmRIenZyT29RWGR1bEZ1NWVJemRKQUFIeG5BbnQ5YTlIRGpwYkVsT3lqUzlvTklUZTFGdzNuN0tGaFo3a2ZsZ1YxT09TUzR4RXZkc1I2cjl1YjhQYjAwQllBVUFrS0I4S3RoL0RrOXlFbGxTTXhyZW9hL1czRGN2M0g4RWd3ekVJbyt2TmQ4Y0dQSHBMZjdrL3FTa1ZqWEhCMnJxa1U3cDhpU1BxZjJycGpGZDhTVGsva3JybDJUTjY4N3poUnZ6K0ZkQ2o4SWk1ZkxBTTZtU0h1RGlPVE9DYXBURTVMNUpJOHNwOFZ6SkFFbkJGR3ZzTHkrNU8wT0N3TURCOU9NVVE4cjdERXN5QU41c1FETWtleCt2NFVxVkZMOGx6MGpWdGVzaTNjQVpsSGxhWUpBN2ZLdVRMaDR2bXVqc3g1dWZ0ZlpaRHhOb0RMdVNlL05SdEZPTWwyU3RwWkRZZHJUaHZLVkdmbFROeXI1UW5HTGZ3YTdvLzJoMVdodWh1bytMcTdFUnZTNGR3eEdSM3J6ODNwWVpGN1BheC9mSHhab0wzMmkwK3BFYWRFYTJSeXdRVDhRZmpYUEgwU3h2M04vM0l1V1dXMUVGcHRTdmhrbFh5VDkwcEZkZU9VWXhxL3dESno1UFQ1bTdVVDVaWnV0YTFnZENZSUsrbTdQTWRxOVhMQk9OTXBpazA3TkNMbHQ5enUzaWxwbUQ3aXZIa211dEhweGltTzZHd2xwQ1grNjVCS2pKK3RRbk55ZkZlQ24wMGxiSDdOdTNwbjhTN2FSaTNtQUltTThrL3ppb3R1VHBNeWdtam1xMXR4dkR0MjJYYXh5RlFINFZvWVk3YkJ3Z3RCMTFkL1RPUTkxdTh3QlB1UFdpOE1acTBpVXFpK2dXbzYxcVNIVVhXQ3NOdTBrZk01cEY2V0tkZzVmWXhQMmw2OWZhNDJtdDNyaGNBbTY1SkpIL3ovUDByMnZSZWpqRmMydjAvM09iMUdYZkZNelRTbHRtZGp1eWNpWS9oelhvdmJvNU9nR2xzbTdldEtjSUJ5ZTFOTjBteEk3WTVlWHhXRnUwcGduRWZpYTUxN1Z5Wlh2UmI2SFRFWDBCamFCQW4xSEordVBsWEpPV2lzVFFoeGFTM0NEZkVOSXhHSWsvR1I4alhFNDJYVXZETFhTOVZ2YVYxZlFYMjA5eWZNTjBqMXlQZ1B4cm1uZ2pMOHlzckdUOG10MFAyKzFla3R4MUt3TGdIK1Zwb3pQY0d1T1hvMUoreGoxcXk2Nk45cnRCcXRRejN0UUxidTBnWEJFRHRtcHo5UE9LcWhUYzZIcW1ndldBYldvc21NWWVjMXpTaTEyWWNYVTJwSGhYVVArT0d5Ukh2L09mV21pd05FMXZDVloyUVozQ0RnQTBiOEFvWDFHcGhJQkdPd0hNWjQ1OWFEYnVncEl6blhPdjJORWpLTGllS0FSQ2dUeHdJTmFFSlNZZWo1bDFicjk3V2Fud2lqT2ZORnRUOTMzWThWMzQ4Q2lySnVSaS90QjFka0FSci9tQXdFaVQ3ZS80Q3ZTOVBndmRFcFRwR1p1WExqc1h2T1ZCSS93QWlXUHhyMEl3UzZJeW1LdmRGaXlXUlphUkRPTUFuaUJWdUhMc2s1VUphZzN0UnF0emwzTzQ1WXlCMi9XclJqR0sxb25KdDluVDAvd0FJbGJnRXdHQWlmU1BoSXpSK3JmUU9IeUMxT2tSSHViVmlIQUdQZWpHZHBXQngyTEdSSURFTUNWa1lqbjk2b2hhSldWbFJ0WGp6UkhidEZGc0ZEVm43ckt3KzhaSTljVUdOSDRDMlNCa0E3R21RZStSL3FsYXNlUHRZM29CNFY2UXpKdUU3Z0pnL0NnL2NxSGkrTHMxU0tIRnA3SzdiYmM3UVRCNHg4NjhtZnR1TDIwZXhCS2FVbzZzTmMwaWhXaFEwRHNNODBJNU4vQUpZdGRIYkhPd015c3A0T1IvcXF0V3JJclRyb21kMmx1aThBRllqelNKVnZhbVNqazlyRmR3MnYrUDZscnA5WmF1NmUzY3VYcmxvc01KNGN4bjErTTBpdzhOZGdubjV1MW93MTIvdDFOdTRRU0ZCNzhINC9DdlJsQzFSeHduVHZzdU9pMzlQZlEya0RDZWJjUVY5RFhrZXBoS0x0bnI0TWtKUjl1aStMTUFxK2VmOFdqaXVMaXJaVzFTUTI1R3BzcW1yUW82aU42bVFma2FsL3dDdDNEZjZnNHRDNjZRazI3aVhFSkM4dDVTYzk2ZVdhOU5DMVRHMzBsMjR5c3dCYzU4aG1mbFUxbVMwaFpLK3hIcXVoMTJsc1BxWDBPcUcwZmUyK1daK0h3cStMSmpuSlJVa1NhYVRhUG05cE4ycnYzV1U0SlBtSDFyNlBYRlJSNXYvQU5XeVpVZUhjSk9XT0dtZVFhSzdFZGc3S3FpQmxuY3hnU1o1K1h0V2xzQ2REbWt0RnRZcFdKbkJQRSt0YzJXUzRsb0xaZjZlNnRzTnNXQWgycUlpWUdDZlhuLy9BS05jRWsyOWxFUjFPckZ0YlY2NHdrSGNZTXgyQStNVDh6N1ZvNCtUYVEzSkpXVDBkeThMSzNycWhUY081M09TTzhBODhRZm44YVhJbzN4WGdhTGZZOXBicmFpN2NkV0d4SDJMUG1CTVQ4czQ3MUdjVkZKRk9kc3NrS2xRTGxzUUZER1lsZmllMEVnUjcxTnI0Q21neVhiVXExcTQ5b2tnQXF4QUprZjdwSlF2dERLVDhEZG5xMnJzTk5yVzMxSEJoZzNOUmVHTDhEMk9KOXF1cDJ5Ui9XU3BVQWIwbmdkcUw5TkI5SVcva0pxUHRiMU0yUzEyNmtON0JjZTVuajg2SC9peGJFZVJMU1JRZFM2aWJWa1h0WHE3aXM0bFVLdzdqLzhBaVB4cThNTnVvb204aG03dXN1YWhXdWFtOS9TYUtTUXFna3Q4Qi9rZmMxMXh4S09vcTJJNXY5RE05UjZwWVM4dzBXblpBVDk5anZ1Tjg2OURGNmVUWHZmK3h6enlKZEZlMTE3enM0d1RtRDN4a211dFFVU0xrMkYwdHJkZUpjSGF1U1JuNGZyVThrNlZCaXRsOXBOSGIzQy9kQUkzYjJiL0FPUmdBZTVya3laUC9sRlZIeUozbThRWGJyWkx2aUIvUFdxcGNhaUI3RWRhKzY1cUJQOEFrQ0RIdWFyQmFURWFLd2p6ekxRUkJnODEwSmlOSHJERUw2OGtmejVVV0tFdFFiZ0VESStNeFdmUVk5akZva2RvTVpqdjcwS0d1dE1aU1VhRlV0MjVvSmJzTGVxTHJSNnU0TlBEVDJCRTR4M3JsejQwNUtSMitueXRSY2Znc0gxeHU2VWg3ZTNjQ2R5WmsvRDVWelJ3cFMwenFsbGJqdEhkSGQ4VzRaZENld1ByOE8xVW5IaXJvU0VsTFZsdDFHdzEvU1duVllCQUhPUWZTS2hneUpaS2JLWm9YRFNGTEt1TFNrM3Jhek1EeEFPOGNIaml2UlMrRHlweVNkTXo5MVpZRmxBQkU3ZlVlbE9ic1EwV3BkTmZiY1A0Y2tna2VoSEZUeTQwNE5VZE9ISnhtbWFyUzYyNHpnaTZRU0prRTUrRmVWa3hKYWFQVmpKTldXMm42aGVJY0VIZ2ViL21acmt5WW9qcEo5b0wvWHFWQjI4K2x1RCtGUitrMS8yTnhpUS83cjkwS20rREVFK24rNmRZUExaS1VWNEUrdWRZWTZGclhnSXBKekU1K05kUHBmVHgrcGRuUG1Uakd6Rm00QU1GWklqazh4WHVwSGt5YklsbENmNUZRTVk1RVVVS3lJandsTGJva1VKTXlHdWxCdDdrUUFWeFB1U1BsWFBucm9yRHF4Ni9xZyt1VUtHQ0tJSkk0RmNxalViSEY5WHFCcU5aYlJWbXpieWN3RDYvVTQrZFVoSGpCdDlzRGR1aWR6Vk1GTmhYYmNUREVpUnRuY1krTkJRVjhndVhndXVuM0ZSSEpMTmRuZk1RQ3h3UHhtdWJJclk2Wlp0Y1VxTGFqeXlRRzV3SVZTZlE1ZHZpYWhGUHQveithUTdmZ2lMaWhRcGtiMVdmYVd3RFBzSitRck83c0syQWZVSWJzN2wrNnhWaVlFREUvd0F6UlVkQnZZRCtxWnJxVzFaaTQyN2dnSUxHRGo0bkdmMHFpZ2xzU1VuMVliK3F1Qjl3VkxsN0JkaWZKYVhqay9uejZEdlMwdjZmNUVLTHFXdXNHOEhlNjErNGNUOTBUN2R5ZmV1ckhqazFWVUk1SkdlMStzYTZkeDNFUnR5ZTM2VjI0OGFpUWxKc3JzczhLcEJKN2Q2Nk5KYkpiTERRV1F6QVBqa251ZVA5VkxKT2xvcEdJOWFYKzBzaGxMbVluZ1IrMzUxenQ3c3BROXI5Uk50ZExZSkJMQm5rY0VUZ2ZBZmlhbmpqdm13eWZnV3ZJRXRXYmFydWN5U0FQa0tkTzIyd1BvTVBzOWVOdTllMTkxZElnSytRa05jYm5BQTQ3YzFOK3NqcU1GZitCL3BQdVdoUzcwdlJyZk51eUx6VzErL2RkL04yekF4RTA4ZlVUcTI5L0FQb3F4ZTlvclFzMjdOdllIOEtkL0V2TW1UM0dZSHdxMGN6dmsvbit3cnhlRUs2ZXdVdUc1ZGRnZ0pXQXVmNUg2VmR6dGFFVWFsc2l4bTVsWU1iZk42ZGpQZW5zV3JHVUpjbFc0NysxYXpKRmwwb2h0WmFSOEplQlVBK3A0L0t1ZlAvQU90dGVEcXdOTEp2eWk1ZlRGYlRPQXlxaEFIZm11S0dSTjBkc2trcnNJYkFGeHR3QndaRVFURkdHUjFvMDFIdG5IdUJyQ0JXdUZsWGNmTVNCbmdDdWlDcG5MT1YrU2VtYUxRTjNSM2JqTm1WY0FEOERUdmo4a3ZkOEZQNG9KZFNqTVFTc1RFWjlhczB4RktLUlhHMlRxR2JiNThnQThDZTladlZHVGQyYVd6WnVycHJKRGVYd3hFR1NjQ3ZLeVNUazZQWWh5NHIrZy9aMDExeWwxRVoxVVNRVEUvT3BTYTZZZVRRRXJkTFJkVXF2WlZQR2UvNDBxcGREdHRyWVJwdElJQlVuQUlPZVpwTnlEcEZSMWJVMlhzc2lxN2tITEU0K0h2WGJneFRVdVQ2T1hObWpUajVLSXFONnFTQW95Y1Y2UzZQS2s3WUI3ckxkWXdjSG4wL2FuUzFRbms1YXVzUVVZbVNZbUtTWHlNaXg2ZGQyRzQyNC9lVWViZzRKL2F1ZktyS1JlanJNQ2RSY0lNd0ZXVHllZjhBK0pxYmpwSUtaRHB6N3RRWFlBQUVzZmdCKzhVY2k5dEdYWVFYRlY1STNNVFBmMS9haHhkR3N0OU5xRFkwKy9hb2FkMHhQQWdmaVNhNTVSNVNvWk1hVFZrV0VRWmJjcWt6Zzl6OVNhazRic2RQNUkzZFU3QnlHLzhBTGRPUjJBa1krbFpRMytnZVdoSzNjZTVjUEc0Q0VROWdEeWFxMXhRdDJNdmNGblRDemJZQm1FUGNNeUIvT2ZwU0pjbmJBMlZ1dWE3Y3RCVjNwWVVuekhFbVlrK3Avd0NLdENLVDMySTNvb3I5eklVY2ovS1BsK2xka1kvSkZzU3VYWFlsUkl4MkdQaFZrcUVleWVrVVpZd095KzNxYVdiOERKRDFpNEZUY2NReFpoSElIYjhoVVpXM29lTkhWMUo4OXdueXJ1UHI1ai9CUTRWcEd1OWg5RURlOFc0OHN4OHFEdVdKT1BwUzVKY2FTR2lyWmM5S1pudXA0ZHJmZnlBZWRvaitFbjNya3pkTzNvckJmSFkzcUx2blVGV3ZYbUlKNDJqNG52OEFsVVlyVDhJclZmY3Ixc2F4OVZlRzVnTnhCMm5FZTUvV3F1Y0ZGQXFUZGlEM0Q1aDVIS21RNGVlZXhOZFVJdGlTZGRsVmYxWmE0eXFRUVFRU0JHRGpGZHNJMGprbksyZXNMUGxNZ0RQcmdmdFJrTEhiQzJ0L2lJSEFuZ0R0V1ZEdHRNWXQzVGJWVDNVaGgzelFjRTlES2RHcjBuV2JEMkR2c3FHSzduRUVaSCs1cnk1K2p5S1duK2g2Y00yS1VWWlBYNjZ6ZThCckxLQUdZbkdhYjArQ2NiNUM1cFk2MHhYUzNRSHRTUnRLNGFZNzhmalhaR05uTExROGw3dzdWdnpKQkVpV2crbjZWejVJeWI5cGVIQ3ZjVlNXeW9RRThjU01WVnV6blNPOU82ZWRUMVJyTEJ3cXl6TkFrQ1B6N2ZHa3k1ZUdQa0dLdVZHNFhTbWJSdG1kZzJxcHdCMml2R2s0MVRSMnJMUHd4bzZkbERKQ0V5ZnZBZmhGVFRpWjVNajhrQnBGWjFSN05vd2VJaUtMa3UwekxKa1hrRnJkSnBRanBkMDlzY0JEbVFQU3RDVHUwd3ZKa2ZiTUgxWWFXMHEycmFKS2tGb016amo1R2E5ekM1djNTT0RJL0NLWm0veElETTNwaUIvUHlycVd5TEZ3aE4wOEdRTUdJOUtkc1ZBN1BtY2hvbVk1aWFFa0ZNYXRzUVgya2ticG4zaXB5aUZNOHgzV1h5QnZidjhBQTBsYkNFdEVKWnZrRElnWi9udFNTMjBoZ1JjK01vVEFLaVBqeFQxcllCKzVjOFM1dGJDS1pNOWdLZ2xTc2F5YVhEYjVqSjMvQUVHQUtEVmhQQzZYWlZVaVFDMkIzeWYxb2NhMkd4dEFOTmFLbk53NXVFSEhPRnFidVRDZGFMZGpmZkg5MXZONFBCajM5S0s5ejl2UXJLUFg2dTlldWpleDJyRUVjWjlLNjRRVWVpYlloY1lXMENuYnZJbmlxUjJJOUFGV09CaytVVlFVS1NDUUFCQUczNSt2enBOOWpCTHJiZE9FQkpaanZnRHQySDYvT2xTdDJHOUM5bEM5eUJoUkRjYzhVWmFWZ2lYMXUwYkdrdDJ6a3NOekhqazVIeHdNMXhOOHBOblJGVm91dW5nSXNxQjVnd01ETWtBOFZ6WmR2WmVPajNqcGg5aGNoc0JldzdFK3VhSEY5RzEyVW11Nm1MTngvR3V2ZFkvNHR3dnRpdXpGNmZtbFNwRTU1VkQ3c3oxeS9jMUQzUTF6YkpEYlJBL25OZWpHQ2lxUnh5bTVPenlJZ1lCUFVpZnhwaEExdHl0MVg4dUdINDhpZzFhb0tkTXRUWU1Fd0p0UmpHQnlEVVZOSi9xV2NiWDZIQmJCZGdHQkFFZy9qVHFURmFUMFd2UzlHbXBzM2lWaHdSSUo3SC9jMXo1OHJoSmIwZE9GSnhxaXp1YUJmQnQrSGFVdGF5MGlaOVJOUmhuZksyK3lrOXhxaFhUU1dBZ3JJSkpJZ1RKNXJxVzluTkp2cEVibHU1NWRxRGFKamJieHlhRHI1RHlrT1h1bTZ0N29rd3crOHNBaitZcm5sbXh4U1pSWTV0bDcwalJEUTZlNHp1RGRmN3pESUlIQXJ6YytiNmpyd1hqRGlXcVB2dEQ3MFNHTUd1ZG9lbUZON1lVSUFMSGdjMG5FSVY3aXJhYnhXdWQxZ05BR1A1eFU5dDBoaW4rMEhVMTB2U2Ixd0ZXdXVRbHNBeVJQZjJnVjArbXdmVXlKUG9YSkxoRnRIelY5N3NXSkpZYzQ1Sk0xOURwYVBOdDlnemJtNXZCRzBEa0R2VHI0RWZ5ZUlJTGdKT0l5dk5GdEJTT0JiYTd5Wkc3Z0N0OWdOZVNTa01yaEk1QndLV1dneEJCZ3RoZ2NBSDRacEd0aENxU2RPUmlXUFlmQVZOL21HOEFiUUIxcWlJZzhSMkZQTDhnUEk3YWNtNjJKbnlrZmlhbEphR0IzM0x1V0lCWTVJamlqRlVZYzBBSXVOY2FJa2dlcHFXU3Vnb1o4VHdiUXVITjFzaVI5MzM5ejJxVmNuUTNSWHZjTjZaWWllZThtcnhYSG9SaWw4aE1qRWZjQjcrOVZpcjBLeXJlV3VidnA3MTBKVXFKdlpNUEIzNGdmZHgzTksxNE1SdGdGb0p3bzNOVE1CSXZ1ZTZTT2UzcDNvSlVCc3ROR214RnV2QVJFSmdESk1ZL0hOYytTVisxRllLdGxnQjRTQXNHRDdCSHRpdWErVG82RXVLR3RMcVA2ZlNqY1FHYmxvNEo5YWxPSE9XaDA2V3lsNnAxRTJOOXJUY2s4em5JK2xkZUxEeVZ5SlR5VTZSUk5KRGxvSjlPZTlkcWRhT2RxOW5oQ3Vaa1lneGlNY2ZXaW1ab01GRTh3Si9XbUVZVUdabVBjRWU5WVV1ZE9WZTFiYnpOdUFRelhOTlUyZE1YYVJFcHNlVklnQ1lHTVZSTVI2TFBvajdkY3RvbGo0aTdRWWtiaGtWeitxWHNiK0MySDgxZkpwZElvdGxNdGtNRzc1OVlyelpPenNvaGM2YXhaSDB5aGJlMWlBUkVFK3Z0VmNYcWt0U0p6d3Q5QWswVGJBdTIrUXZHMENBRG52OGFhV2RQZG9LaFF0MVBYWEJxTGZuYnQvaUIyOUovQ3VwNFkxMGNzY3NoRk5mcUpNM21QY3dPUHBVNVlZZkJUNmtoclNhdlVDRThhOVB1dis2bkxIRHVrYm5JWi9xcnR0QXBhNjBBQ05oa2ZLcDhJdndOeWtEdjlaZGRQZFBpM0NGTVNWNHhqdldqNmRPWFJ2cU5Mc3ozVXRiZDFSVTNXa1RHMDVQRmQrTEVvZmxJVG01ZGlUT3kzVkNIdjIvR3JKZVNiR1VLeGJVckNrZHlUSnFjbkpXTWtpZW90K2FRNGFSUEhOTEdZN1FqZlFrT3hJSW5nRE5XakpXVGxFamJiWUhJUEprajUvd0M2TWxZc1FkMWdWWmlCRTV6M3BVdGhEMmlDYlN2bmcvaE5TbDVvWkFMYk1MeFplZTg0cWpXdGc4alNQNW41aFFlY2RvNXFUWFFUMW4rNndnbmNyY0FkcXowRWVRa3VxVzVoQmx1Y2Z6ODZnK3JZeUl1d0lHOGtETUQyL2swVnJvekE4amdCUWNudWZZZnJUb1ZsYnI3bmlYWUJ5T3c5SzZNY2FWazVNVWFRcWtIa0hrVlR5QUd4OGdXY2NINDBBTW1XQ0FqRWdFdFBmTkdyMkM2UFd6dUFHRExaZ1JtaXdGcmFod3QyTndYYXFqMU9ja2UxY2t0ZTB0SDVKYW5WM0wxMTdyc0NJZ1k3VWtjYVNwRlhOdDJ4RzlxNUNnNDJrQUthNkk0L2dtNS9JamZ1RzQyVGtraVBUL21xcEpDVzJFVlNOT0NGZzhRUGdmMXBidVZGS3FKQUx1VXMyQ2ZiMnBtNkZTc05NNEJQSSs5NlU2SnlDSzUzekFJMi93RHJpaUlQMjd4UUViaElDOGR1YWxKV1VqS2ozOVFkeFVFai93Q280RkZSQTVXRnRYblcrTGdKVndRd2tjNW91S2FwaFVtbmFMTnRmZE8xRlpUdWlZOXY0S2g5R04yVyt0S2d1bTFkOW1FM1NSRUNmalMvU2l1a0g2a21UVzlxV253cmo3UVl3U0tIMDQvQm5rbDhqWFVnb3ZyS1RubVk3VUcyMENNVUxyYlVGUXdHZUI2Vk50c2RJSlpJTEl1NWVZM0NQMnFjckRvanE3eVdWV2I4Z0Q3d2drK21POWFFWEo2UUc2S2ZWM3ZHdUx0WHcwM2NNWllrL0RBcnFoSGlxRWJzV1MweHR5emlKOWVLcGR2U0ZlanFXSU80eVEyWjQrbE0yeFVOMlVKdGhkN3gvd0RBSE5jMG52b3NrSGF5TUJudWJTSW1aSDVVbkovWU5GZnFFQ3N4TGo1bWF2R1ZpTkN4WUM4b1k4amdVOTJoZU94TTN2N2x4Tmd6bVo5S2RMeUsrNkpXN2hONGJCd0NRSjlhRGpvMWhOT0NTV0gzdHVlOUNSdklSQ2ZEbGpuOU0walZzWVowVnorMGJoamppcHpXNkNoaXpJdHNXQWdtZHAveVA3Vk45akhsbHB1WENSSnlSMytIOHhRNjBnc3I5VGYzRXFrQkZ6ZzEwUWpXMlNiRTU4eFBmQUdlM0ZXRUk3ZHpJRHd2OC9Tc3pBYmhnS1o1SUovbnpORkNzZys0c3BHQUJBSDQvV21XaFFscnlxcnQzNEh6elN2NENpeTAyTk9ITCtUQkN4ekEvZXVXZjVxTFJLNjVxanUyMnB6L0FKVEdLNkk0OWU0Vno4SUdpZzNZTENUSms5K2NVLzZDL3FldG9YZVNRVzk2RGRGSXhKK1pEQk1nS0RIdmswaTJPMVJBenlTWVBhS2NWaFBLRlgwRFFJK1ZNbUpKQlZPNFNEamcrOHhURWgxVkxrZ0VSQS9EOU9hazNUS0pXanRzR2VWOWg2MHd0RTBYYmNYeElJRWUyUGFzRWV0aG10Z0NPTXhVNXRMc3JDTFk5cGJOMVJueWt6SkltQURVdVVTdkZqZW5EQlczWHhsai9qL3VrNXBlRE9EZms3MUs0MXkra1pBNTd3YURwQWpZb1haTUtJRS9TbG9MSTZ6VVBwN0NsRTNYQ2NLMkFQYy96dlJ4dzV2ZlFzblNLbTQzM1d1dnZ1a1o5aCttZTFkSytGMEkva0txWEUweTNudGtxN2xWOHZNUnhXZjJBaVY1V2U0b0Myd3UwQWhSdEU4U1IrdEs1VnRoVUcrZ2xwZklwUGxGdjdvRW1rZVJ2UTZ4cEJyYTJBemdTdklCTWorYzFLVXBhS0tJVnZBY3NMV3Bja0NHWUdBUGhTWEpWYU5SVjNUZnZLNU5vWFFSQWN4Mi9QRldYR0w3b1dyRTdtNWJtNGc3U0lZQVpYK1JWRTdRclZDZHdFWHBJTUhPZmFyTG9rK3pvREFvNjRCZ3ozclA0TlhrTFllTGJLQUY1QUIvQ2cxNU1Ta3RkWVJDakFBL0tsNlFSeXdvZGxRenNFRnYycVVyV3hrUDNWMjJpN2lGN0gxK0ZSVHQ2R0szVTMyY1J3dVFCN2QvMXEwWVVLMlY5M2lCSVhqNTFlS0pzNEFTWUF3ZnpvZ1BYU1FvT0luQUZaR0EzRmIwa2orQ21RcklFZ2JTSkE1bVBhc0FrRllNaUFlWlNJSGNkNkY2c3hMVTNoNFJDVHRQbEVlbEpHRzlqY3RDTE0wdEJHMzI5SzZLSjJGdGpjVkJFSDRValpXS0dtV0xoQTVKbkE5ZitmeHFkdGx1S1hRQnlRVkl5Q3FnbVBhbWloSldqbTZjd3dKZ1pQTk5URnNtdVVnNVdUUzNRYUdMQmh3REdTT2UxVWZSS3QwV0cwN2lQWDF6M3FTMk8zVmtWOHR5QjZ4NjhVNHJDcjJZUUQzN2o2VUFsaHA3ZTRnYnpqRUFtV3FjMzVLWTcrUi9USTY3UUdPN3paWmo1UlVaVVdWMEVXNWNFbmFTU1pNQTFQZ0hrTWFsQ3J1Ujk2a2xMWm9SZEZacUNXSG44cUlTekdZeDNOTkh1bDJ6TlBzci9FYThMbW92bUFUOTBuQUF3QVBoNjEwMXhxTVNQZTJSdEtHTzUwWUU4REVRRGlpM3hWQXB5WVB4Z2hjcGc0bTRXT0kvMk9LSEMreDQwZ21udm0ydm5STm95SHZTQ1JrNEE1bWtsajVkUDl2NW9vcFZ2L0l2ZDF5S0dEc1BObmJiYU1WU09GNkVsa1J5M2QwOXlVL3VUamtrVFFhbXQ2RjVSUFBmc295N1duSjh1NlRRK25Ocll5bkZkSGpxQzk0a1pYa0tCR1pvUEdraktUYkIzSGxTem5KT0k3R3NvN3BCdGRzUUJhQW96blAxL3dCMTBKRVdNYmg0SVRnZ1krZElsdXhtOVVDYmJCeVByUGVtb1VOcFVaZ1lJT0NTVGdIRkpKcEJSYld0bGdNMkxsemRKYnNQbFhOSzVNZlNBYXE0YnBjdTV3T0RUUmp4NkEySkViako0ekE5S3VBV0lKQkpiRW1KOWY0S2I3Q0hrTzFRZVNvNG9nT1hENXg2eitsQklET1RCTTl4Z25pbW9EQW5tSjQ1ajhLWVVQYXVTYjF3akpPMVpQTWpOVGE2UWZ1S1h6S2hmWUg0MDhVQnNIRUg0VXdVTVdnQUN6OGRxbkl0SFF5aFl0QTJ3WUpCcVRSWkhyS2szRWt6amlNTDZZb1MwakpmY2k2QVd5cklwRTRnZnRUcDdFbEZDNm5hQ0NEa25kN1NLbzFaSlBpSHRreEN3dUlQdC9xbVFrbFE4YnpHRnVmUDZjMHZFUEx3eU03aVRuZEp4SHpyVUN4bENONjhFQXpnVnFDV0dqY2VOYkJVc0pJL0dwWkZwbGNlbVd2aGp4a0lDZjVmNUg2MUJQVExOZEZwb2JIaTJTekZRd1lnaUNZcE5BZGlQV1MzOVRjZnVmTkNqdVRTcjRZNjZzek92dW5aRGt3ekNmZU1reDlLNjhjVmRrWnQxUjYwM2lNaVBBMmtuYUQ3NG4wcDZyb1Z1K3llcDFEWkloUklqdnR6K05KR0NzYVRkVUsyN1cyMDEwN1o0UUVFamZPVEhjZ0hIdldsSzVLSy9pSGpHbzJXT202U0hMTHFsdjM5WWNycHdOemtlckFHRkh4TlF5ZXJhL0pTajgrUDZmUDlCNDRJdmM3YitQNS8raGowTzlwdDdYbTBtaFErYllDTHIvaGdWenYxa1oxU2N2N0lzc0RXOUwrNXhiR2lWQ3E2dTljdVlQbWhVL0kxbmt5dDN4U1g3c0R4dzZiRjlSMDIvZXQrSXVtRnhCSjNwZEJQZjJGVmo2aFJkY3FmNkN2RHk4WC9BRktwNTAxNGp6RlR5dHdRUjY1Nzk2N0Uxa1YvNE9XVVhqWjIrMjZiaVFCdGtsdVRqMHBVcTlyRGQ3UWxFbG9FUm1yTG9tK3lVa0FFd1p5UDU4Nk5HSXFDTWtRSTc5cVZzMURsaTRMYUFIN2tZQXhtYW0xYkNHOFF1MllJNXpTVlFiQmxrakxZbzB6QWJ0eVFPUGlUVkVnQUdMRThESmswd3BDNnhBRUQwajQwVWdNZ2tsVkJnenpQYitSUkZKWEdLaUNNUmdVRnNERnkwd09UM3B4U2IzQ3JLZ2lCekhxYVZLOWg2Qk1aTWU4VE9ZcGtLem9ZbkFVZXRacnlNZ3R0V1l3VmxzakhKeFU1T3RsNEszUVM0bXdqZEE5Z1o3OGZuU3AyTzRrN053V2p3aFljK0lKbjVEdFN5aTJNdXV6MTdVYnl2bU9Na2NBWjdDakdGQ3lsZWhhNFczdURtVGtSbXFwYUl0aDlPd0pFd3lnNXJQUUU3ME15SHZGSlRCTVMzYWF5dnNEK0FnREs3U016RXhFMWpCUmNLcFBQeE9UaWlZYjBXb0F2V256S3NEQnhVNVF0TkZJU3BwbWh0WGtabHlGTXNEakV4eFhKVDNaMWE4RmowM3hmNmNtM2NkUVdNN1JJSkdQMG82UkdWdGxWMW05L2RZOXkwZy9MUDUwdU9ObEpPa1ozVjdsMW0xemhRRGp0L01WMlk5eHRFSmFsVE9FZ0xBSUFBUG1OR2pXQzFMa01OZ2xuR0I2NTUvS3NsWVc2TG5UQlVkYmhWamFzZjJyY0VBbTV5elQ3RTgrOWVmTzlyekxiL1R3djZuWkN2Mi95V1hUZFJzZTRyTHMwZ0hpWExZUDN5T005NTkvZkZjMmFGcE8vZDBpMFhRR3pvZGQxelYrSXF2YnNNY1krOFQ2ZXNlcHdCV2xseGVsaFhiL244KzRIeXlQNFF6ZDBTZFB1TGIwZG16cVcyeTErNWZTMmdQOEErNDVQeUFxY2Nyekp1YmEreVRiL0FHLzdDNGNPbFlEV0xxN1hUeWIrdHM2ZlRTRlZiTnNsV1BvQzBFL1NxUWVPVS9iQnQvZC83ZjdnYWxXM1JXMytpOVN1RllEZ3V1NUV2cnRjaU9Rb2tnZkdLNkkrc3dSLzQ2L2NtOE01ZWYzS083YmJUdXlGME83eXRIQXIwSXRaRW5SeHlqd2JWZzB0YmMzU1ZQYWZyUDUwYitCRXZrNGhWQUdsSnhBSjcxcFgwRkJiS0MxYzNPZS9JN1VrbmVrWWhldGpkQ25nK1hhZUJSaTliQTFzazF6L0FCTWoxLzFXVVRBaTcrWG1lWkh0VFVheU80Um4wOUtOR3NpSkJFZWxHaGJPUk00eHptc0E0REFpZVJFVG4xL1doMkFCZHVlZ25NbW5TRlp5MDBFdEVBVVdnSG1saTB6V0FRdUFiU1NZMjUrT1A5VmpCMHNpVjhUeUNPM0p5YVJ5K0NrWS9KSnk5dWZER3dFUnpQMXBhdnNxbTEwU0EzcUZMZ0QvQU9WNXJkYm9iYjFaNDJFVW1YdS9IYi91aHliOElQRkx5RFFCc0ZzY1lGTmJYZ1YweVd5QTRoakRUSW9xUWppY3ROdEltWUVEaW5xeVFkQk54UU9DQUJJNE5BSVlxVUxXMTNBZ0VFTmovaWhZYUMyMk54ZHJNQnNrcjZaeVlvb0RESVFyTUZDNDR4eDcvbFFNaTEwbDR1eXlRQ1RNQWM0NC93QlZGeExjcW8wdlJiMGFRcUZSaXJrRWtmQ3VmSkNUWTZta2lsNjJ5MmI1UDNvOHhEQ09lQld3cHpLU2Fqc29IbHRSSis5aVRYYWxTT1o3WkpvbUpqYVpJSTU5cURNaFVBdHJwY2xra25KOUJOR1dvYURIY3RsN3BWdHZjczJ2RVZGVlFUT2R6TXdNRDVuNkN2UG0yazVWL0Vka2ZDTkw0R25QaHBmdGk1NVd2TlAzUXNISkF3QUJKajNOZVZ6bTdjWDlqcGRJajFMcnB1ZE9zNlhwU1hyYmFwRjhWMmczTGdJd2dBKzRvN0tQWEpwc1hwRXB1ZVozeDYrUDErNys1dVd0Q2VsNmZiNlRwUnJ0WnRGMXYvRHZNK0llQ1YvK1IvN0RuZ0h2Vlo1bm5sOU9IWG43ZjgvYngyL2dDWEZXSHRYYmpOcHRaYVc1cU5icWpzMHB2QUs5MXBpVUF4YnRMeWVKTXlTQWFXY1lwT0QxR081VjB2MStaUDhBdDhHVGZmOEFQK2d0eTF1dUwwZnBtb2EvcnRUUDlkcmdaTEhsb1BwK2VLU0drL1U1bFVZL2xqL2cwbS95UmUzNU5GOWx2c1RvOVFQdUZkTWcyWEw0VCs1ZVljcWpmNHFERWtjMXplcC9FTWwyKy9qd3YxWHlhR0tLNlBvR2grelhTTkZiQjBuVHRJaENmZThNTVQ4V01rMTVrL1VaWi9tay93QnlxaEZlQlBxZlE5THFGWVh0THAyQm1RYktuOUtPUE5LTzAzKzR6U2Zndy9XUCtuL1R0U1dPbXRmMFYwLzVXUmlmZGVLOVREK0taWWZtZkpmZi9jaFAwMEpkYU1SMXI3RDlVMEpZNllXOVRiSGRQSzMwUDcxNnZwL3hQRGtwVDB6bHlla25IOHV6SjZpemN0TVV1MjJ0M0JNS3lrR2E5T01veTNFNVdtdE1Dd1lIRWd4Sm4wcHRHYUFrc0pPUVRUVWhXU0xlV1lKakIrdGFoUWtnQUU1UHJGTFJtd0xIaDUrby9ucFRKQ3RpemtyQUUrbUQ4YVpJVmtyWXlvNUJQSE5aaFJLWW5lUU9PMmFCanNCNWlRQmtidlh2VzZNY0JEdHU5OCsxYXRESjdDS2hZQUVnSG1sYktwV0d0V3hBSlZ5Y0g0Vk5zckZKSGJxbFdPMVNRZS9yUVRUQzlDLzNmdWc4UVpFVlZVeVVyN1JIZXl0SUxLUjNGTlNKV0V0MjNqZUZZSUNKWXIzN0NheUF4aFZtNE51NCsvOEFxZ3dwV0hlV3VPWFptL3k1OXFBVm84N3oya3h4eFJvd2NBWkFrR0o0L253b2lqbW10TVZ1bVNySUZnRVpNbURId3BBeThGLzB5R3NFb0lCUCtSZ3pBcVV0TVpKVVYvMmczSFZxR1hhUWRyRDRWUDAvVG82TW5ncDNQbUxjQ0pycXJSQzluZ0ZrK2k1TTl5UDUrRkg3QXJ5TGJnMTBYQVRFd0luR0lvdGFveWU3TGZSc0E3M1FCTnVTQ1I2RC9kY0dXT3ErVHJoSXVlcjZyK24wV28wOWdLYitxbmU4L2R0Q0lYLy9BQ2dINGZHdUgwMkxuTlRsMUgvUC9CMFpKTktsMkZVVzlDdC9YM2t0M3RwVFMybFl4dk1DWjlobjh1OUk3eTFpV3UyLzNIYTQyLzZDT3ExUTZ6MUo3M1ZicmVBalpDRGFkZ3hzUWRwaVBZU2F2REgvQU9QalVjSzIvd0RQeS8wL3VUY3VVdDlJbnFkWmMxUS9xcnlMYnVYM1hUMlVRQUxac29SNUY5QVNWWDRCdldsamlVUFl1a20zOTIvTC93QS9zTTNlL3dDaGEvWnEwZFBaNmxxU1FMeFVXbGJneTduajZSVVBWUGs0UThkL3NqUjAyejdCMGZacGRGcDdDWVZMWUFFL2o5YThMSmNwT1Q4bGtxVkZvdW9WYlN5UndNVkhpTUJhN3YzRSsrUHBXb3dxOXBjNUpreUo3VTBRc3J0UnBnemNZcWlrRVUxUFNkRnJyUlRXYVN4ZlR1TGlCcXBETlBHN2cyZ09LbHFTUG52MnQrd1dsMnZlNlJOaTRNK0VUS043Q2Npdlk5SCtLelQ0NXRyNThuTmw5SkdTdUdqNWxxTlBjMGw4MmRSYmUwNC94Y1FTUGIxcjZHRW81RnlpN1I1c291THFSQWtRZVpqMHBpZG5qTFRPU0RuRmFnTWpjQ3FxNXprRVVGWm1LWEFDRFBNMVJDTThKQTdxQVlrYzFxTWRYSWhUQk9KSW1oWHlZNkNOMHNjQVFaR0RuOXFGQk9EYUNoaVNJSkJyQlFhMWRNQ0luNFpOQnhSUlNiMEZSbmo3elJNWlBGSTBpaWJPM2R4UUVtVDhmZWdxc0xzQXk0UDNoQnFpb203RGFleTF3R0dBSUV5eGovaysxRmlmcWQyTlp1UVI1MEVrQVRFZkgrUldBTmFTM3YzRVBiVGFTM0Fnak9SUDBvU01qcWJXRndCV0NuQVljVEhINTByUlJOSG1VN0ZiZG5pVG5HUDkwM1FFckdVVm10Z0w5MERiR0J6eFM5YkNuZWhsQVN5ZVlpUkU4RVlNVUYyQ1NORDB3enB0M2lxb0prQnZnS2hOMHlpVm9yUHRJeEd0eEdXTGZVQTgvV3ArbDZLNVBCVFhCTEE0TytLN0xwSE4yenp3aTNTRGdFZ0NlUUJTSnQwTzBsYkVOUksyMlVkeUQ4dlQ4YXNuYkpTMGgvU2FsdkJLNURNQ01pSjRybnlSVjJYeHNML1VGWDNiZHlLTnpBOTZseDFSVzkyV25XTmVtb3VXUmFKYXhaWU9aRUJtWmdUK0VENVZ5NE1MZ25mYk9qTGt1a2dOcGt0cXozQUl1YWhsZytnSDVTMzUxbmN0THdsL1A3QVRTZHY1R05YY1VXZFBiVmxaZE9Ob0ttUVdCTE1mY1NjZkN0aWk3Y241L3dDbC9ZRTVkSkZwcGRVYkxGVlliR3UyYmhIdEpNaXVhVU9WUDRUS2ZKOU0wWFVrWkVoaHRDLzgxNHM4YlIwYUdrNm1oVlZrRGlrK216RE9uMVVrd1orZEpLSVJ3WGdSamlwMEZuR0c0U0RuZzRvV3pDN0lZbnQrZE55TUthalNDNENDckhQYW1qa29haXE2bjltOU5lMGhTL3ByV3B0bkp0WFYvRlR5cCtGWHhlcm5DVnhsVC9uN2l5eHhtcWtyUG5uWHZzQWdXNWM2SGZ1QnhKT212aVNCOGVmbm12YjlOK01TNnpyWHlqZ3llaFhlTi91WVhXZE42aHBickxxZEhmUWd3WVFrSDRFVjdNUFVZcHIyeVJ3enc1SXZhSzUyTzBiakhhUFNyRVdDTFRCZzRrQ00wYkFlWWVVa1lQTVZyTVRRL2UrRUNSTTBHd29nN2dRZHdFWWlhSURpa243a0gyR2FGMTJGSnZvbXU1Q3dkR1V4M1UvR2hhZlRHcVM3Uk8zY2JCNXpQRkJvZFNHSGNPaDhnaU1RYVZXbVV0TkFjaVNGbk5OK29qdndGdDNyaXFOcDJETXdQMG84VWhISnNidDJiNVh4YmpNd3ZEeTNEa01SSEptWkdCOEtEK0FXZFNBSnQ3QTBiR0FJRW5Fd08wL3ZRdGowcVBGNWJEZ0dBV0V5dU1qUHIyb3JvRDJ3K3FWN0Yrd3R4Q2hkUTBjNFBIRmJzQ2ZFS3FrVzMyZ0JsYUk5QnhRVEdmZGhMVjBMZmdrcUJFWjdUbWFWSTBub3VOSmYyYWRCRUNCR0pxTWxic29uU1NZcjEwbHp2QlRCNEVDZTNGREMwblJTY1cxWlJYTG0xcEJPRE9QblhXMW81bzlrVnZMREJtN2s4eDhhRkRPd0dvWVpneU9lYWVJa2tkMDF6YThkcEVBbWx5UnREWTVVT0xjWnJieVFQSVk5eFVIR21WNVdTYStYQ2s0QUFrVC9BRDBwRkNuUlJ5dFdGdDN0OW9CeW5CTUQxSm1nNEtMdEFjM0lKZXZNTlB0eHVtZlg2L1NoR096TjJoelRheitvMFBoc1BNcGt3YzRHUDBxRThYQ2ZKRlk1TGpSb2VuOWFhMVpDYWdzcnhBSGI0elhIazlNbTdpWGhsc3RkQjFaYmx3TDRpeVlqUFB3cm1uZ2FWbEZOTTAyaHZNVW5uRmNFNGxVV3RtL0RjNVBhdWRqVU9MZWlXSm41ME96TkVCcUFXOVJQMG9PSmtTdjZoVnRsbDRGTEdPNkdZbHBPcldMdDd3MllFZzhHcVR3U2lyTW1tV091MEdsNmpwWWFBNEdHVXd3K0JxVU1rc2J0R3I1UGxuMm82THJyR3Q4SWF3Sll1RCszZGNHTjNZTitocjIvUytxeHVOdU50ZUNXV01xOXBqNy9BTmgrcitQdHN2bzdybHZ1ZUxEbWUrMW85K0s5U1A0eDZlcmRyK2ZZOHQraXlkb2I2VDlockdvUjAxbXZ1alZwOTdUV2tDc0ZFNUJibVBoVVBVZmpFb084Y1BiOHQvN0ZZZWhYL3dCeUk2ejdHYUcycFd6MUcvcDdqRUJEcXJZS0hQOEE3TDNyWS94Zkk5eWdtdnM5L3N4bjZDUGlURVgremx6cFpEYTNUbSttWWRTZGhFKzJSMnFxL0VWbjFqZGY1L3VHUHBGRHRXYUhwZDdTMjlQYmJUalMybGpHNUZLejZiby9FMTV1ZFpKTnFUYi9BSi9PanFoRkphUUxxZGxmSFpkZjByUXVHQ25kNGZnc3hIbzZHUFQwcDhHUjhmOEFUeVA5Ny9zelN4eGIya1Y0MDNUZzVOdlU2alEzUkpGblUyL0d0bVJIM2huODY2UHE1dk1WSmZLZFA5dWhPS1hUcjlTdTZqMGkyMW00NGJTK0lzRVBZZVEveEZkV0gxVFRTM1gzSTVQVHFTdno5aWd1bzFvYldNZDhHdlNqTlNQUGxCeEoyYnFsVHVBOFFFWjRuNTBYSDRNcC9JVVhBcER3UEtZVUw3ZC9sam4xckFkZURXNmRMRjdwT21ONGk1WlEzTGtBaFludEE3RWdDS1h5TFZHY3UyMXM2Z3VWQTJ3U3B5UjIyMGJDdGdpenBmTjZGWGZNQTRqa1JUSktxQSt5VnhBd1Ywd0ZhQ1NSK2xZdzRzZ2x0c3lKSDg5Y1VHRmJPMmxMWGgzWDM3VWpkRHFOb2Z1M2Ixc3FMZHhnc1NBYVQydnRCcVh5TmRhdjZZT3FXenZ1a2lkb0VyQjcxellJVGJ0OUhabWxDS3J5Wk84Q1dJRXNWUEhyelhvbm5vaWJVcHY0alB4eFFzWUE4QkNTYWRFNUhtVWdBcUpXc0NneTNMdG9JWkJCNEk3VWpnbU1wTkVQRjNZYmNENzlxWGpRNmtNNlhWRlNlT0J5T0tXVUxDcEJHMUFlMDg3WndXQjlaNW9jYUdURDZJYWk5ckxhYUpIdWFnL2R0SU56TUtTZkdNYm4xOGhqYmVqWmFEN0k5VzFLcC8zSjdPaVhqYTNtYy9JWS9Hdkt5ZXZ3eGRZN2tkVU1FMzNvMWVnK3l1azBla1UyN1J1UEgva3VDZm9PQlhuejliT2N0dWk4Y1NpZ3VsMUJ0SzlweVFiZUo5YWxPTjdYa3ZFc0xHcXpuaWE1M0FheHRkVkNrSE1udFNjQTJjTjFBQmNraUt5VDZNSFRWMmRRb1NmTjhZbWxjWlIyRXpIMnM2QnF4Wi9ydWtzVnVKa3FPU1BiMU5kL3BQVXd2aGw2SlRqSmJpVlBSdnRscU5JRnQ5UUJDOEM0T0o5RDZWYkwrSHhudkdDT2J4TTBPcjZwcCtvYUVnN2JxdUlpSkJyaFdHV09YeFIwcEptVnZXZHR0RXVFdlpYN29jazdSNlYzSnFtMHRzbE9EVFRYUjI3ck5kcEZDRzROVGFBOFFXYjY3dm1yY3hudFVsaXg1TjFUK1YvK2lOdGI3QTZucVQ5VE54a1JCYzJnM2JUZmN1eDYrK09lYWFPQllLVGY2UDRDbW10Q21qdnZic2xMVjY4bGc0WHhIazJXbWRwOXZSb3A4a0ZLVnRiKzNuK2ZBVTZGdFJxRGExUk9zMHdCQTJ1OXJ5dXVlVDJZZTlVaGo1US8wNWZ2MS93QnlwN0xIU3Zhdkpjcy93QlFselR0RUt4OHBCanR5cDl4aXVlYWxGcVZVLzUrL3dEVWJUUlRkVHR2cEhhMjBYTEx4RW1TdndydHdTV1RmVEp6VmE4Q0tKYlYyWkM1RS9jTVNEWFMyMnFaQnF1aXMxdGxYODJRd01iVzc4OFYxNHBOYU9mTEZQWlRrYkhaZ3hnZXZJcnRXOUhESlZ0QlE3SmVZaFl1TkhlQ0ovZWpXZ1hzZHQ2dThlbm13dHk0YmJ2NWtCOHNqSUh4eFNWVXJIMDBSM2YyVVdRUVpFRGxjOXhIUDZVWDJCYUplSVJ0QUU3WU14UDFwa0t3ak1BRVdENVQyNUZCaFJLUysvelJKd0o3Ui9xZ0ZmQXpvZ3d3R0lIQkhvY1ZLYjNzdEJPdE1ldjNDbXdGK1ZuSHhOSlNZZG9yOVNadjNDOGxpL2M5NnVra1NiYkVDVlZuVW56WUkvYW1CcGFJM25JUmdBUkpOWkFZQjRNRnpPWmcweUZEeXJUSWFUM21SU3RqVWMycU5wQklIWUtjZzBPVER4WFlFbFJJWUV0Z1RSN05mRWl3V1NXVTRFeUpFMXRndE1lNk5vdis1OVQwMmp0M0RhOFZvYTR4bmFveVQ5QlVzK1Q2T056YXVpbUtQMUpLS1BybWd0ZEs2SFlYVGRQdEtESG5jNWR6L3dEVGNuOEI3Vjh2bGxsOVMrVTMvc3YwUFZoQ09OVkZEL1QydjYzVm9xUVlJWjM3S3Y2VktjWXdpMlBacXkyKzM0VnJBR1BXdU5MeUV6Zld0RmNVbS9heGNUa2RtRmRXSEtuN1pHcnlpbjB1dk82Q0NDTUVIa1ZlZUtrRk95MHRhcmRCQjQ3Vnp1QXhaNlo3V3BXQWUwUjYxQ1NsRmgwVTNXTEdzNlBxUDZ6VHFiK2tNU295eWZ2WFRobERPdUV0U0VsY04rQ3o2VjE2MXJOT0l1QnBxT2IwOG9QWThaS1N0RlA5cWVoMk5XcmFyVEtxMzRsbEhEaXJlbTlTNGV5WFFzOGZMYU1SYmE3b0duVFhHRzQrYXc1NGowOUs5UzFrMU5mMUpSazRkZnNXMmo2bFoxUWUyemJYQjh5Tjk3K2U5YytUQzRlNWRIVERLcGFJYW03NFRKYkwvd0RrL3dERS91TXhTOGJ1UzhkaVRYRmxMZnZHenFQRkhsM1NDQWNUWFRHSE9QRTUzTGl4bTlldHZxZHlPRXVFRVEzM1hHTUdveGcxR210Rk9TYkRYTFMzN0NDMkdES1NBWjh5L3dEeWZVZWxUakxoTDNmejdqdFd0RkRkREJ6YzA3bExpNUtMd2ZoWG94YXFwSzBjemRQWFpKTllMcVJlQjNyelBIMHBIaTRQMmovVTVhWXYvVVdpWDhyQWowcTNDU0VVMDlFWEl2V1d5QVFPZUtLdURCS0tsc29OU05sMGtEQkVHT0s5REc3UjUrVmNaQTFZQzJ3RzRNVHpPSS9lcldjNUszY0IyeWNTTjA4UlE4aHZRMDl3N0JKa0U1NXdheTBGdXlWaUdhSkFQck5HaFc3QzM1M0dTVEJpU2UvZWdGV0d0Vzk2cU41eDk3SDQwalpTS0xIcDQzMldCamt4OGNWelpYVWpxeFJ1TmpHc3Rxeld6ejVPUVBjMWxNMzB5cTFMbDdydHVNa2s0cnJPTXJnUVNTb2p2eno4cVl3UURlbnFRSWoxb1hScXM4U3ZBeVo4eGpranQ4S1hZeW84UUhnaGdJd0FUV3VnMVo2UFdUbWFGbW9HNnp3VEI5NktrSzQyRGROb0prNDV6VFdEaWFMN0RXZDNXeGNZUjRkbDJrZStLNFB4S2RZYVhsbzdQUndxZG00MHRpN3I5YWJGZ0FNY3RjSWtXMW5KL3dCZHpYaXluR0ViZi9aNk5HcC9xOVAwL1NycHRJQ0xZN2t5ekgxYjNyajR2SStVZ0pVeTI2VGRDMkJkdTVkMWtMN2RxNThuZElZRDFBbTRMak9SRWQ2TUY4QjZNWjFtekY3eGJRZ3o5YTlIRE8xeFlrbDVJNkxWVzd4MjUzRHNUa2ZHamtnNGhUc2xjMStwNmJxRXVEYzlrNXhrajk2Q3h4eXF2SUxjZXpWOUg2dFoxdGdCaXJxMmVacno4dUY0MlZUdGFNdjlwT2ozT21hZzlRNlFRTFI4ejJkMlBpUFN1NzAzcUZsWDBzdjdrcHdjZmRFaDAzckkxaUtDOEdJS25rZkkxc3ZwdnBzYUdSVEFmYVBwaWExVGUwWUF2cVB1eWZOaXQ2Yk04YjR6Nkh5NCtTdGRtT3ZpZFRidHZ2dFhWSGxaVEJVMTZrWFVXKzBjZCs3N25GdVhqZFE2bTZ6K0VTd2srbGFTalQ0cnNMbko2bDRGMDFUdmFZWEFjNUEzVEZPOGFUVkUxTnRIT29YUUV0a014SkFPRzd4V3d4MndaWFZVT2FEcVQyMFFseWR1SjNaUHRVTXZwMUp1a1ZobHBiRXRUZEJ2bTRqYlc1eDYxYUVQYnhaT2NybGFJTTV1dDRsc2dOd1ZwdUtqN1dEbGUwS1gyVVhDd0JpQkI5NDRxMEZxaEpQZGd2RW0zNUdpbjQ3MmJsclRLNjR4RE51ejdUWFRGSEpOMjlnazJ5SkVqalB3cHZCSkJWZmN4bms5b2dmR2lqV01FcWJlMXhBQm1SOEsza3hPdzV0NnZleWhpUVl6eVNNZnoyb1BvS1JNQWtrS0dZQSsvTkN4a2l5czI5b0Z3UUJCbU15SS9uMHBXTXRqWFM0YTF1SUF6a0R1QngvUGF1WFArWkk2OEQ5ckc5Y3dOeE5xSjl3VHVhaERyWVpiWm5OVmVobWdFWkltdlFQUEVnd0xRY2NaRk51Z2F2WVZMeXJJampIRkkwMk9uUVFIeE1BcUNUeE1VTm9OMlRBVUdDUVlIRUUwamJZeUlyY0dkd0p3UUFSQUgwck5NMWtkN0VnU1JBMit0R3RHWFoxbElRTGxuSDBGQk8yRjZOTDlqN2lhZTllM0E3cmx2YU1mT0I5Szg3MTZja3E4TTdQU1BiL1EySFN0YjRPaFpGd1dZbDJBelBwWGw1TWJjNzhIWHk4QituZzZ6V3FyU2JTbVhQcUo0cGNuK25IN21XelY2Uy80clhMamlMVnZHT0NmVDVDdk9rcXBEbFgxdnFxbFNxOWo5SzZNV0ptKzVsdFoxTHhKRFNUT0FLN3NlS2ljcGVDajFHck5waGN0eUxnNHJyakRscDlFbS9LSDlKMXUzcXJaVzhDcnhNR296OU00TzBNc25JSHA5VGMwTjQzZEl4S0hMTDJQN0d0S0t5TGpNWlhGM0V0SCswYTZ0RGJaOGpHMDF6LytJOGJzb3Npa1Urc3RmM3ZIczNUYnUrcW1aOXE2OGM5Y1pLMFNsRC82am9aNlQxMWY2cnd0U0NsNWVNNFllMVR6K2w5dHgyaDhlYTN4bHBnZnRSWXM2dXlkZHBsL3ZJREpVNFlVZlN6bEIvVGwwSFBqVWx6WGFNdytzMzJIWTVZZ2dUNzEzTEhVa2ppYzFRdFl1UWl3VEE1cWsxc1NEMFExRjNkZW5hU0VHTThVMEZVZjFCTjdPMnI0RnZPNHdaNW9PRGJGVWlKMUxFRWd3QjJwdnBvSE04TDVDeU1IbitmV3M0K0E4aUYrOEdERW5takdMUm05Q1l1NE1kenhWYUpLUUIyM0VuTlVXaVRka1ZuMDVtallvUk4wc2NreFJzMURDUVNXODBFWXpRY2hsRU9ObmxFUTJaejNqMCt0S3RobG9rbDBydkZ0WWdaM0gzL0Npd3hIN2JiMW1HYkI1QStmNlVsbEtwME1kT3VLaWpjSEZ1VHVpQ1pqdjhURlJ5SzVXV3hPbzBoblZiV2RTelFkZzlEMnBZMnZBWkdkNm1mN2prZ3dTZnhydVJ4TUc3UGV1QzVkTE1BRlVHT3c0RkhwVWdKRXJka2hmOGM4aUtSeUhvamN0c09WRWV4a2lzcEFhSWJ0dURJajFQRkVCd0UrcE9LeGdpRnlwN0hrMHJIaUh0M3NMTWVrbWxhcXc5MFAyTHpnb3locFZwbm40aXBUZ21pa0p1THRHazZYMURhYjNpRlRJL3g1N1ROZVpseFZSNkVaYzFvMVBRR1cvYlJMWmplZDl4eC9pdGViNmg4WGJMUWpvZDY1MWhMVm53TkxDV2t3dWZ6cVdIQTVQa3pOMFlUVTlUMUY0dVV1THRraVRtdlhoaGpIczU1VGN1aE1CM2ZjMTl4N0xFVmEwdkJOOHZrRTJudHMyYnJNUC9wcG9ySTE0Tnd2dGsyMDF0QkoyZzBQcU5tNG9uYXRNVHRTOThBVFBhbGNsNVFkcnBrTlZwSFBMZ2R3VmlhYU9STHdDVnRBVnY2bXlBcHVMY0gvQU5jMFhHRXQxUmxPVWRQWW5yVGMxQUJYYWpMa0h2OEFXcTQ2aUprZkxvRmMxbXVHbWF5YmhaRGcvd0M2ZFk4ZkxsUXJ6WkZIalpWYjdpamF3UEJnUlhUU2UwY3JiV21UWFVGRjRnMGpoYkc1OFVCRjRuY1NjKzlQd0U1blJlTzJEVzRHNTZPK0tOa0NNMXFNcEVXdVlNQTQvS3RSdVJ3dVNWams4MXFNNUFpWVVDaWhHemdZNWpqM29tc2x1OTVZOStJckJDS1BLWUlnY2dVTFkzRkRBYmFxaUVCSEJqUHcrRllOMGRCQnppU0RPZmIrZld0c0ZES2diV0JZS0NDUkE3OHhTWGJLcFVnMWw0M0E0Z2NlazBRSW5ZdUh3MUVEeWdueWlDWi80cFpyWStOMGcyb00zVGhlQnlLMFZvRGRDZDlBYmo3anVKeElOVklnQUF3T1lBYjZtaUh3ZUtuYUZMZ21mbFFNeWJLaXFXTGUzOCtsQy9BR2dFVy9NTWdjeDNvMndxS1pKZkQyN1FpN2dabUsxUHNDcGFSNER5SGMzSjRvTi9BVnNsWjJyY0FVbkFNbjFwWlcwTXFRVHhkb3dST0JrVnVJYkRhVy9jdFhCY1JzNUJCeklQSXFlU0NrcVpUSE54ZG16K3pXdnVqcHVwRzRTWENneDdHdkc5VmdYMUVlaGp5WEd5cTZ4cTJOcDAzQmlDUE1PZmV1cjArTldtUnpOMFZHbmR4Y1pDQ3diSUlOZFVvcXJJcHZvbmV2TXBoWEpFUjkyZ29KaXVURjNkcEJSM0lQSTI5NmZpdklya3cvbnVONVhaaEhKQXBLU0NwTVBabERETzgreDVvTkptdGdkVXhCSDl5NFl4OTdpakZJRnNTZG9QTStuRTFSSURzRVhHWldTTTgweWlDMmNaczVFL0dpa1pzRGNNNGhhWklWZ0dDZ3pOTUxTSU12TXVLS0ZhKzRNN1lpbVFqb2x1eDcxcU55T2JwV00xcVJuSThNUVNmU2hRTFBic0VCUm10UWVSQUdUZ3gzclVDemdFbjQrdEVBYTFMRWpNSEVDdFNHVFk1cFVTNDBFemljNHFlUjEwVnhKU2V6dGdBc05za2JTRElFaW1mVkFqM1lSVHRHMVprSDBnYy84VUV2SXpmZ0pieXpFSEh2UVpsMFQwczhjQ2EwNkRpOGpGOVExd3kyM3RCRTFvNlFaZGxmZkpVdE1raWVQalZTSUZHV1BQbU14TVVXbjRNcThuZ3pBQXQzaUo5S3pRTCtTTnhtdUNDUlBZQVVFcUMzeVBJb0Vrc0NlSTlLRHN5MEVIK1ViWjdtS0ZNMWt3R3pKTUE4elNqcnNpR1ZRWUpMWml0eGJOYVJGU1dKOWUyS0xWR2pzWXRMRWJ6dEIrZFRsdm9ySFQyVy9UTmNiS0cyY29TZTNOY2ViRHlkblRpeVVxRmRacVNiMXd5R0RjZTFVeDQ5SVdXU21LK0p0S2tZOVpxM0creWZPaVZ0NFA4QTVJRXh4dXBHbUYwR1YxSVdYQkFHZkp6N2UxQ21LNkNKZVJUdEJ3RC9BT3NVSEZtczVjdXFXSkRPSkVnaGZhaHhhRGFGYmpnN3BlNS8vci91cUpNVnRBWHVEaGl3SHdBcGxGaThrRDhTMy83UFB2QXpUY1dCeVNPRzhtSTNTZlZxS2l4WE5DOTFobGRnbnZKTk1rL2tTVWw4RWJqQnVFQTc4VVVnTi9ZaTB4T1YrVVpyVUJzRVQ3bjBvcENXYzdtWm9nTytnelJDZEVSMm9VRWlTYUFEMmVKeG40VWFNY1h0NnpXb0FTMjBTUjhjMXFDT2FaaVh3WVBxS1RKMFh3OWtubTNkQTlSdSt1S1dMdGFET1BHVkVaWUF3RE01elRKQ2gwTUJqT1RpajVHVlVNZE9JZTRCQkFEQUFEMW5OQ2FOQjlucnpzWEpKSDAvYXRGYU5KN0ZkVkl1RlpCTStrVFZCQU1Sa1JCR1lISHRXQjBlZGdWSGw4d05hZ05vQ0prVEVHallxVENJQklKUEhxdEszWFEvSDVKN1FNQW5ieWZldGJvRmJPTzVJNUdlS0MwTVJBYi9BTnBBN0ROWnN5UWRJMmdESGZpa1pTS0NsUEtHa21QV2x2d045eVJKZFFFbmZFeEhGSjA5bEt0YUFlSlBxVEZPMFNUQk81YnRFZTFNbFFKTnM4THI3QUFXQjdSV2NVWlRmUWZ4RzhJWmRyZ2lHM21JNzBsSVlqdmNBa3V4TVQ4YTFJMndkeTZ6RXlUanZUS0tFY2dMZ2QybkZPVFlJNUEvV2loR1J4eWZyUkFkQnpnL09zYXlJYlB0V05aTGNjUlBwUzBNbWNadkxCSnJVWnNIT0tJaDBlL0ZFeEpzQ0NDRDNCRVVBa1o0ckdQZWc5VFdNZUVZSGFheGpreUNUTW5pYUlDUW1ULzdjMEFvUHBYS2xST0o1NHBacTBVeFNwamVyWWsybWZiTUZTUUtsajgwWHpQYUZ5Zk9ZNzhkcW9pYnF3b3VLcFVoZ1FSSFlVeU0zUXhvYnUxakdRSUpnVUo3REFHZGpFbDVEZWdBb29EVmtyNVgrcHVZTzNjZnBOT3hGb1ZkZ0NWbnkrM2FqUUxPc3dKOVFUbWdibzRwMjlnVllZSkVWbWd4ZEJaQzJvQmtqMTdVdmJHdWtCWWQ1SEZNVE9MbkFKSXo4cUF5RExhZmJ4ajNOSTVJb29zNjVDcDZHSndhSFkya2MzUDRiTEhPYTFLN0EyK2lDWEltZlh0VE9OOUN4bFMyZXQzUVhQQW9PSmxPenNoaitzMXVodXpwSUNnY3dhM1pub05DUFlZc05yREErTlR0cHFpcVNhZGk3WFY4RWdneVRFejZVNmk3Sk9TVVFlOE1jZ0tmYzAxRTdSMWhLeXMxbDl6TlgwQm5NUjhnYVltUVltUk9Ld0dlM0RkMmozckFPRTQ3UU1VYTBZbUNKN2ZPbEdSNThEdFdSbURrRGdnSGlpS2VCQmlmM3JHT21lL1BQcldNYzdqaWdFNkJXTWM0a2lzWTRlQjZmR3NZa0RqSXdhd1VGc2tLTzMxL1NneG8wZ2p2dWNBam1CRkJKSkRTYmt5TFlNZzRpc0JxbUVjbTJkc3J6bnZNUWVlOFVVRVkwWUJkdDNNSDYrbENROEVFVlh1QWxXUUNZaHVhSm1MWEcvdXVNRUVraWFvSURJazQ1OUk0ckFxamd5ZUJIcFFadjFPem1DTnhBd0lvZzBSM3pBVWNjOTZGR3NrVEp6ajFvQkdMUUpRNDJpUHZSbWtrVWpvbVpJRVN4ajFwUTdaeTV0VlpPMlNLS1RZYlNCRXFjNGtlbEZKaXRvZ3pLY3dJNU05NlpJV3diQUJ5ZVBZODBSYTJGWEFPS1JsVVRWVW1XTzVva2pzS1Z0K0IxRlhzSmJFV25MS1BOeDdVcjcwUEhwdGlqc0ZWL3dEMTdWVksyYzhueFRSeFZ0bFpESGNjd2NSVzJCS0o0d0JBa2o4cUlHeUpQYU0rdGFoR3dWd0FFWXhSQXlXd01Na0FtVFFzM0U0NmtEa0dpbUswRVJDd2tSRksyaWtZdG5yeUFKSStCckpobkhWb0JtSUhlbUpISTljQ2lZOXg5ZTFBeDRmakdLd1FtM3lUSGVsdlkvSFZrSTlobWlJY3dheGpvSHR6NjBhc3lDS1FvWW5MVEFpbGZaU05KTmhOeDNBekdRT2VLV2g3dGs3MGIxT0dQSkU0azFvaHlWYUlCdHdVUU1kcWFoTHNQWmJhY2djalB6ck5ESmh3akdTSnlaeFRwQWJDOWIwVnpTOVExS2JGQURUajBKZ0duanRFbkxZa3FnZ3c4aUpKSTRQcFdjUXFSQm8zR1NmbUtDaUZ5UksydVc4TWtuakJpYXpRRTBUYlRzcUJ5dTRNWUdlK0tIZWh1amhUYUFTQVNXMmxRY2c4ZkR0VzRzWGtpUnVReFFCaVoveWpzYUhBYjZpT3M1TVNUNXBnL01pdHdZZnFJTG85SzJzdVBhdDNMYXVpRmdIbnpFZGhqODRyTlVMeUJHMEhPQ0Rqc0szUmdUS0ZCa1NNODlqRkdqV2lUS0VhR1Vob0I3Y0doUXlhUEtaSEhIZUtYaVB5SjdVWkJCT1BhaFRCYVl4NFlDQXMzbEErbEtvc3J6U1JCZE16SVhTQ0psZXhFSG1qZE9oR2t3WDlKY2NtWUI3OFpvOGtoT0pGdEl3TWQ0bzhrSzBRYlRzV0N6azBVMExYZ2g0YzdRVDhLSUQxdTJTNm8zSndCNzBHZ284OXNraUlVakJFem1hSUhzSVZiYXBKRVlnQVVsSXJ5ZEE3bHR4dVFrQXptbVNFYjFSTVdFMkdQRWNnUjJBK1hlalRFdEM3b1YrL0lZaWpRQ0tLRE1zZHZyRmFqSFZWWkFaakk5dUszRUowU0ZnUkVUSitGTHdHVTZWRUJKM0dUZ1FacHVJdG5BdURJTmFnSHRwQzdwRUF3Zld0UnJQSEUrL0ZMUWVWRW11SHVBREZiZ004bDdKU1dKeWNjVVZBem5ic21paVRNNDVQcFI0aFVpWmxwS2tuT1Qzb3FJSEkxUFEraWFYVTlQUzlyZy9pdjVnRlArSnlQenBKU2FkSTBkclovOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9kYVZpbmNpLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDMwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFGSENBWUFBQURreVFNbkFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5ZDdTbDJYbmVCLzdldmI5dzhzMzNWczVkMVFFZDBOMW9aQkFnUVpBRUtRSU1Ja1ZSb21SWmx1M2xzVWNhcldWckxNOHN6eCtXeDdhVzE0dzk5dGdlUndYU0lpbFJKQ1dURkVHVG9KQ0lSdWdjcXFzcmg1dnZ5Vi9hZTcvengzZHVWUUdpYU1zU3lXYjFmZGY2VmwwVXV1Njk1NXo5N0RjL2ozQmdEN0xKNy9KM2V2QzIvUE85Z1FmMlIvdXpsTi9sdVI4YzMvNGNnT2Izc09qZ0xYaGd3TEgvMlBzZUkyQkFSRUZCQXhBQWY5OXpBSklERC9MQW01azlGa2lBK0w3SDNIZjRBK0NBQ2lobmYvclozNGVEdC9HZk5IdndGandRbDV5OUR4d3AwRHpkVzF3VXBQZm8vT3J4eCtiWEhvMlR0Qk1abzQwb1NqSlg2WDMvTmh4NGo0TVE2OTBBa2doSW4xazd0clpxbSs5OVpINzUweS92YkhVVzR1YmE2VTd2MUZJMnZXem51TEkxbWt4dlJ0bHYzUEg5ci9lbm83MzdBS0lIUURud0lBOXFlSFhYZS93clQzN2doMVlrL3FzZGlUNlFTUFR3ZHBZZE5VSGJSZUdPZGFQNDhTTDNUemVpMXJOTFM4dlhiNHkzcmhKVTd3dXpEZ0R5dTd5NUIvWmdlQkFEUkF1dGRyY1RKNnVqSXJmemFhcXBqZFFCNDdMVVlaRVRXOUZZT1RuZjZEdzUxNXR2ei9JVWU1Q1BIZ0RrM2ZCWnlzVisvMnJoL2ZiVVZSZ1JhVVdSeE5iUWlDSVpaRG14QWU4Y3NiRVhsdHZ6Y3pQUEUrMy8rNE8zOFFBZ0Q1cnB6SVVvd0pmV3I5MmE3M1J1TjZJSUF4enZkSW1OWWI2UklBaHBaSkhndFpya3Axc21XWjU1a0FPQUhBRGt3UWFKenNxMEYzZldkNTF3ZmJIVllscFZwTllTaTBVQlk0UktsY2hDcU1KeU4ybWR3b2dWa1FPQUhBRGtnYmE3emI4c20wNjNRdm5HUXFNNTl1cnhHb2lqdWhhVGlFVkVKSTRqWEo1M05DOVBSY1phOUZ2eWtBT1FIQURrZ1F1eDlpdFJEaWpmSGc4dkpaRWRvWUdzcW1nWVF6T09pS3pCV0VzamloaVBKN0xRN0oxc3BjMldvbmM3N3djQU9RRElnd3FTSURNdjhzS2RHemVyTkZrM29KdVRpYmJpQkFJa1ZtZ25LUnFDbEdWcEVxTEhsdWVXbDJmZ2lBN093d0ZBSG1pQUtGUWlFbTRNZHRaZm40NiswRW9hMVNEUEdWVVZqVGltQ2xCVUpUNEVyRUEybXB3NGUrakVrNEE1eUVNT0FQSnV5VU1xNTZyeTR0N1dTd3Z0OXFRZHhUSXFDbEpyRVlGcFdlSkN3RnFqNVRSTG1CU254SmhJVmFPRE1Pc0FJQTk4SHFLcUZlQ3Y5TGV1K0daNlk2M1QxSUJYRVpoTEUySWpKRllRRVlvOGk5SVFuVnBhV0pvRHJOUmgxa0dpZmdDUUJ6Zk1taVhxYnFmSTl2WjgrVVkzampVMWhxbDNOS0tZeEZwYXNjV2dJcXBHQzNkMlB1MnVBVVlQOHBBRGdMd2J3aXdSY1R2RDRYUmpPbjUxdnRjcmhrVU9RR1FNSW9JeGdxb1NncEpQcHQzVjd1TGhXWksrWDgwNjhDQUhBSGxnUFlnSFNqUzRYVmUrNWEzc2lDZ2lxRWNSQkJXaG1VUlUzaE1xdjd6VW1IKzIyKzAxNzh0QkR2S1FBNEE4dUY1RVZUM2dMdS91M0ptcTNGNXVkYVNvS2dLS0FabzJvaFZIQkJSZmxiRWZUeDllVzF4ZDVGdkx2UWNBT1FESWc1MkhYT3h2N3UzNThvWDVWak5ZRVVtTkpiYUdYcU5CcTVHUVJJSnpqbkk4WFcxb3RIUmZtSFVBamdPQVBQQmhsc3Vuayt6V1pQUUtOdG81MU8zUmppSVVKWE1Wa1RHa2thWHlqZ2l6ZkxpM2ZCb2o4YmVCUkE0QWNtQVBJa2oyeDA3YzIrUCtGWXk1RlJzaEtDUW1vblNlb0lIWVdwd0d5cktjODVQaWpJbnMvYVB2QjJmajRFMTQ0TU9zNnVMT3htWXBlclZoakhvTkdCRmNVSXdJU1dRd0lqcWRac1lHT1h0czhjajhmWG5JUVpoMUFKQUhIaUIrUEIwTmQxMTVLWTV0a1ZwTFpBeUpOZlRTbUlWbVNqT3lWR1dGT0QzYk52RWkzMXJ1TlFjQU9iQUh5cVMrK1JYd0FnN1Y2czNwK0JVblpqc3lBaUpZSXlRMklyS1dKRElTMU9PeWJMbGxHMGVNdGZmVEJSMTRrSU8zNEFFRGlCZ1ZKRkFQTHpyQS8vYmwxeTd0ZW5kTlJOU0lrTm9JUlRBQ3JTU2l3cXR6dm50b2J2bTV1ZDVjSXNqK2ZvZ1JFVkY5OTNJNUhMQ2FQSEFBRWNTSW9DcFNmNzZ4Qzk2Y1hUNTg4a1NTUHVsQ01JQmtya0lRZ2lxajBwRlhwU3dzTEZZamlpL3NEdmRHSWxJQnJ0UHFoR0szMU05LytmTUhIdVRBL3VoYjBNQml1NGVJcUlJWHhHc0krZVhoeml2ZTJpd3hWaUpqaUswaHNvWmVJNkdYeHVLOGszdzBQZE15NlRHa3BoSVNFVk81U2w1NDVZVjNiY0orQUpBSDBDSWJxWWdFRWZIVTlLSmh0OHl1bDdEWnNvYllSTnFLWWxSQkVDSXhCQldkRGtidGxjN2lXVUVpWnVQdnpqdDUrYldYRG5LUUEzdHdiTDIvalE5aHRrU2xGZUN1NzIzZjNxaktONTFxbVBxSzNIdWNLbFBucURSZ1JjaUxJbzZjbm91aUtGV0lWZFdHRU9US3pTc0hBRG13Qjh1T0h6bUJpS2lJZUJHcGhrVStYYS95RnlXS1Ftb05Ga0VFSW10cHhSRUk1S0d5VVRCbmo2d2VXWmlGV0ZZUUEzRGswSkVEZ0J6WWcySC81ay85UlE2dkhNYUl1WC9Mc0xveUdidzhzZVptMHhqSk5XamhIVTREN1NRbXNVYUNlbkhUNHRoYzJqbk1qTzlYVVdPTk5TSnlBSkFEZXpCc3FkSGsvSkZUV0dOVlZZT3FPc0JmM3JwOWJXTXl2S2pHWUVVd1lpaTlSMVhwSkFrbWlFN0hrOTV5czNjYTRlNGFycUpNcDFNNUFNaUJQUkRXaUdLKy92bzNGWFMvSitLQmFsd1ZXU2J5ZG9tRVRoeExLNDRSaEZZU0UxdkJJT0pjMVd0cjh0NG9TZHFBUWV0K3lONWc3MTM1WGg3MFFSNUErOXp6bjhlS1lUQVpZY1RzNjRkRXBhdWlrM1BMM2FVay9aQU5ORXNmcUlLbkdVVzRvT3dWQmVKVWd1bzRXbWg5YVhldzJ4ZWtNbUxjYk1ma3dJTWMySU5oRzN0Ym5GdzlRaHhGaXR5ZDdxMDJmSG05TXR4SWpOQ0lMRllFSHp5ZDJOS0tMSGx3R0dOWDFuckxoMmZobFEwYWpFaWRyUDk3Zi9IZk93RElnVDBZOXR6RFR6SGY2YW5jSTVWemIyM2QyaHhXNVhVMXdseVNNcGNtcU1Lb3FFakVVT0twaW1JMUxqbTFQLzZ1cWxZUVdWdFpvOWxvSGdEa3dCNE1LNm9TYXd6VWMxa2VjTnZqNFRoTkc1Y2RVa1RHMEl4aVBCQkZsalF5cE1aUStxcVZxajNiNjgwMWdVaEVyS0tTeElsY3VYN2xBQ0FIOXFDWXNqUFlVNzEvaVNxRS9IWXhlV1ZLMkI1VkpZaWhFVWMwbzNvZE44Wm9rWmZHNWVYcGxjN0MzTDRIQVV4LzJPZlZpNjhlQU9UQUhnejdwUy8vQmsrZGVaaEduS2pjMnhFSnYzSDF6ZGZIVlhXeERJRTBpbWpZcUZaaUU0aU5rYW9xUVhsNHRibHdtdnVJSExJc2s2Ky85QTMrNnIvK1Z3NEFjbUFQaGgxWlhLWHlYbWROdzVwVWJyZzNxQ0o3VFlYS2lpTEd6TWJmaFdaa2lEQk1SOU5seW5BMFRwTm9CaENycXRKcU5PbTBPZ2NBT2JBSHc3SXlaMmx1RVFSLzMvQmljVHNidlRMeGZscDVUMEJCOU82U2JXSkU4eXkzYVp3K010ZnFObWRobHBsVnMrUzFTNjhkQU9UQUhnejcxVzk4a2VXNUJheU42aTNER1VpdURMYmVEbkhjVjFXYTF0YjZJYWFXYUV1c3dWVVZVb1lMdldhM3V4OW1xYXJaRyt3eEtySURnQnpZZzJQT09YWGVvYlZWUU5qT3ArdEpFcjB1Um9LQU5xT1lKSXBJWWt0a0RUNlVHR1I1dmp1L0tpSjI5cGpJUm5MOTF2VURnQnpZZzJNaXNpL3llWmU3ZDNzMEdMNmRqYjdneFZReENGclRrdFprV0NvQTArRjR4WGpPR1dNc3FqRjE0MUNLTXBjRGdCellBMk52WEwvRTZ2d1M1cjRscWhCOGRYVnY2K3JBdTRrVkliRVdwQmI2akswaEZxT1Q0U1R1cGQzak5vcVNmZVozVlRVMzEyOGRlSkFEZTdCc2E3QTd5OFR4KzlPOWczeHlXNjI4Z2FDTktOSkdGR0Zuakl1Uk1STFVSZVQrdll2ZHhVWHFLbFlraUJrT0I2d3VyaDRBNU1BZUhQdmhwei9NUXJ1OXIyWG9BTGN4SGU4TWczc2ppbU1zU3NOYTdJeUJVUVJSOWVJTGQrN1k4dEh6ZGFRbTBYNGxTOUVEZ0J6WWcyUG5qNTNpMFdPbmtmdWsyb3F5S0hmTC9QVVNob20xRWtjV2tUckVTb3dCUmF2SnRGRmx4U0VFZzJxa3FsYURtdjZvTDMvc2UzL3dBQ0FIOW1EWVFuZU9uZkZRRlZScmtGUm9xSGF5OFNVbllUT3hscWFONkNZSmFXeHB4QllENU5ta3NkU2FPek0zTjkvV0dWZVd6cEo0NzhNQlFBN3N3YkNpS25udDVsVUFuU1hxSHFnMnZldExGSzhuMXBKYVN6d0xzNXB4Ukd4RWhCQTNnam5mVHB2emdCSEVHbU5NcDkyUmJyZjl3TDl2Qnd0VDd4TDdqVmUrdnYrbEdITjNpU3JwNTFQT3J4NWRuUmZ6bEFzaExyeW45SjRxQk1yS1V6a0lJbFBwSkYvWjNOdmFBSndnbGFJK2ppSzl2WDdud0lNYzJJTmpZczJzWDFpclVHbFZacGNtL1ZjQ2JEZU1wUkZGSk1hUTJIcWhLdmlBZCtISTBjN0tJOVNjdlZaUlU1YWxmTzJiWDJkeGZ2RUFJQWYyNE5oN0huNkNKRWxxWXJsWk5ldmFZT2VXSk5GR0xSRWRhU2ROYU1ReHNUVUVVWW9pYnhYRHlVclVUTDlGUCtUZHdOdDdBSkIzbVQxMitpRTZyZmEzU0NUYzZPOXNUUWx2cVdqWTF4Q0pUTDBuRWhtMHJFcWJpRDEvK3ZESitSbEFJbFUxa1kzRVJ2WUFJTzgyKzRrUC9NdWNQL1RvUHoxTUVhSFhuT09wMDgvd3lTZStsMGVPdlljLytkRS85MGNqeEJKaFoyOFhFYm5ML2w1bDArbG1rVjlQak1rTktzYVlXcUl0cmhOM2NZNUk1WkhqYzZzbm1UVU1WZFg0NEpsa0UvN2F2L3YvUEFESXU4bDhjS2dHb2U2WDdXdjFHVUgySHdrYXhIa25XWmx4ZlBrVXAxZlBjV2poR0tmV0xyeWpYOXZQL1BMUDBtbzBWVlZESFdhSkE2cFhocnN2MkNUZWkyM05tUlZaZ3hpaG0wWmlRaUNmVHRlcVVYNUtyRVRVYTdnR01LZVBuWkVIbVZUdW9JcjF1OWdrSDdNOTJwUXFWQ0lpeG9peFJveEZ4TWdzL2k1OUpUdmpiYm01YzRPeUtpU3lFYU5peE50M1htZStzOHlKNVVkd3JrSGgrdSs0MS9mOUgvNFV0N2J1U09XY21hM1RKZzZObjFvNStpRXBxOE1Cd1FlVjBqczBLS1BDcVhyaXROTzZQdFQ4NjFtZUZTSlNDZUt5SWc5cksydTg4TW8zRHdEeWJyRit0a2ZwUzFGVk0zdEVWUTB3WS9tb0pjb1VGVlROS0J2SXBmVTNtUlpUakJocE4zcjBtc3RNODVLaksvTThjdndSYm16ZGVNZTh2bWNmZVpKYm03Y1paeE1CckVDYVZXVTROciswZURScFBKTTdiMVZWZ2dhcW9HU2xvM1JCT3ZOenc3NGJmMkU0SFUyQUVzR1ZWZW0vK1lDQzR5REUrdDhJMTJjaGxqbC8rT0dsczJ2bjFtWkFTVURiSXJSUmJTbmFDQnBTRjF3eUtVWlI0UXF6Tjk0eU4zZmVrbEYrVTZ5eGZOZVQzL1V0MzFaRW1Hc3Q4dkN4cDNqZnVlLzRROGhESURJR0Vka2ZmNis4OStYdDZmaTFOSTZtVFdPa0VSbkVHQUtCWmh3aHdlT3k0a1MzMFZsQ0pCS1JmUTNEQjNyMC9jQ0QvTk51RGpHaXFBR1JIM3ZmbjNuaWV4Ny93Yi84ek5rUG5oWmpSbGsxOFZrNU5hcmFvTzROM0pVc0F6VWhCQ2xjaGc4RjQyd3N2L1hTYnpFYno1QjY1azhraVJ2U2FmVEVHTXZtK0FheGJlQ0Qrd041YlM5ZGVvM2pLNGZaR2U0SjlRaTdCZEptRkp1SDU1WSswb0JseERCMWxVeXJDdTlWQ3VlMDIrNDBvcm4yRzdmNjYyOW9VS2VxbFlpNHBjVWxQdlRlRDNIbHhwVURnTHlML0lmTWJzam81TktaL2tyMzZQSGwxcUYvN2FIVnh6Lzl6Tm5uSGoyMmRNd2lZWnBYbVJSVllXY2cyVmVJRldhQThNSFhpREN6QkwvT1k2VHlCY05zajYzQmJRSERmR3VKTkdxUVY5TS9rSmVYVndXUmphUnk3bTVYUFlqdzZNcWhzeDNsUFpsemxDRkk2UU5CQTg2ckZxV3pVYXU1dFZVTWY2Y284Z3FoRk1TaEdvNGZQbjRBa0hlTEpWRUtxS2lxQU9iMU95L0xhN2RmZlBQSTNJbGh3L2Erb3huTmZmam8zSW1QbkZsNStKbUhqenh4K3NMUjh6ME1icU4vSjl6M3Z0NE5QWlJaSG9OYUJMdWYxd1QxRXRRallsQU5QSG42L1Z6ZmV2c1A1RFgrcFIvOENRYVRNWnY5dlgyQXhMbDM5cEdGNVNPbm11MFBaV1ZwQUNtRHd3ZVlsQldWY3pLL3ZGTHN1TkVYUnBQUlFKQlNqRGdSRTA0ZE82V1hyMTgrQU1pN3daNDY4VDRteFlUQzVYZnprRWt4a3BkdWZlUFNmR2RsYTZtNy9KRFI2SmdKaldQTDdiVm5qeStkK01qcDVZY2VmKzZoRDU4OHRIRE1YbHAvYXk4RTUrK0cvSFVkTkdHL1hDeVMzQWNnQlNXTm15elBIZUxtOWgvTUxmeWVFeWZaSHV4eGUzZEhWTlZJM2Z5TGo2MnNwcWZhdmZlNXNsb1FFYTFtWHFSd1FUU29KSEhDUUtyZjNoM3RiUXBTQVpVUFB0eloydGJLRlFjQWVUZlkrMDU5a0p0NzF5V3ZNbWFMUVNLSXFYeGgzN2p6eld1OVR1L3k2dHpxMFdhY0hzN0xTZ2pTYU1XOTQwdXR4YWVQTDU5NDMvdlBmM0JwZDlxL3VkRy9OVElpZ3FMLzRaLytqNS8razUvNGt6L1k2WFQyWHJ2NjZuaW12YkdQSUZWVlBicDRraHZiZnpDMzhMUG5MdkNMWC8wQ1JrVENEQ0JBakxFODNGdDR2R1BzbVgzVm5OSjVuUGRrem1NUTAxM29Ycm15YytjMWFncWhTa1NjYXREZi92dC9uTG41RkN0ZGpxMGVZM05uRHgvOEFVQWVORHUzK2pBN2t4MEtsK09ELzVZcVRkQmdYci8xNHAzQ1YyK2RXRG0yMG0zMmptdFFFOVRqblVvaThkeEtiL0h4VTJ1bmt5KysrY1huSzErVUFDZFhUc2JuRGoveTU5NTc5cGsvY1dUNTJQak5tMjljejhxcEFpcGlRZ2hlYjI1Zm03R0UvdjdiMTk5K2t6T3JSNmljbzNKT1pyc2V5YkRNemJPclI0OHZtdWpaeWdYamc1S0pNcmZVbzdNMHAwdEx2WGloMWFpdURiYS9rcFhsV01EVkhmbWdQL3RMRi9uNml4dXl1VFdTbmY1UThxTDhJeityZFFDUTM4WGUybmlkRTR1bkdlWjlndnA5TDdJL3Z4UUF1Yjd6OXVEbTN0VVhqeTRmVFZmblZrNjE0cmdSVVBGZWlheXhqbkx2aTI5Ky9qZnlLc3NCK2VhVmJ3eWZQUHJjb1VRNlAzcDY1ZlIzTEhRWGIvL094UysvSVFnSUFaSFFiblFwL3dERGxKWGVQSnZEUFpoMXhZRTRoQkE5L2RDWkk2ZU9yWDJ3dWR4TFd5dnpMSjg2d3NyUlZYd0lNczBLaVl6NHpjbm9kN1lub3kzcXZaS2dpbFNWTjFVVmJGazVVNVNWaE5rMHd0Mnl4d0ZBSGh5YmF5MHd5b2VvQnJUbXJWV3BTUThDRUFSaFo3eWR2N1grK3F1SEZnOFZhNHRycDl0cDBvbU00RUxncGR1WFgvelNHNy82T2FDYy9UdW0xV1RyNU9LRjh5RTNqemJTdHYvS3BTOSt2cWl5Y2w4RnFuVDVIK2gxdTlEcDBXNm5aSGtoUGdTelg0bjc2SE9Qclg3NFErLzk0T0xoMVo1cE40bmpoTEowVk02UlpRVkpISXRFNW8yTG0zZXUzZ3NUaVVCbUpXL1pyK2JkMzJmVFA0b2dPV2dVL2g1ZVpGS01VSlNnUVlWN2lyRkFydWhZa05IbVlIM3J2LzdjZi9Zelg3LysvSDhieEc5MVdqR2phbHE5ZFB2eUJ2VXdJSXFxZ1AzcVcxL2FlUEhtODM5cldycmQzVUc1bU1UdHp1d3orRU5wdUYxYXY4a2YvKzZQME91MGRFWUo1QUQzdFV0WGJsUysyb2lzd1lyQlJoR05aa3FyMmNBWWlFVG1sNXF0SjRCNUVYb2l6S3ZTVmRYTzdNK3VxbmFBSnBEeUxlWHZQMW9XSFVEaDk3YktWZlZOWW96NkVOU0kxVUF0ZktuVUFYWmVadVovL3NMZitPVllySHp3M0FmK3RSdkQzZmptN3RXM2dXSjJjNnJXMWF6MEgzenQ3M3hqc1gzazE3enBQbHA2YlZKejhSZ1I1TnZUajUvNGw1N2p5bHRiN0d4UHNjYmd2Y2VIQUJwUTlYZS9zWGRLMm9pSllzT2JyMjc5TTcyK3lYaE1NNG5ybHpPVFNIamg3V3U3bFlhYm5VaWVydGxONmwvTVJvWktBNzRxVFNUbTVGSzdlMmhuTXBMRitiUnorRkJycnBGR2FaN1pxV2h6TkpsV2d5dTNiZzZCZlBhVXN3dEQ3L01vQndCNVVFeFZDY0Z6L3ZCVDNOaDlNeFJWVVdsOWNnd1E3WTYyNVc5OTRYLzRoVzVuK2FGWDd0ejZ5R2g4NTJaOUlFUkFEVE9kalJPckp4YzNzdUhpMW1UVWJrU043b2k3RFVrQXZ2T1p2OFR1OEJvdnZQWDMrUDRmZXB5Lys3ZS9SaFJabHBhNm5ENjN4Q3N2MzJUWUgzUDJYQmVQMHQ4cjJiZzlSWXpoaGVkdi94K0tzYmY3SXhRTnN5M0RNQmhOUjVjM3RsNzcwSVhGVDZLaFZaYTVWSzdDR0tIYmJyS3pOOEJFOXNpanA1Y3ZIRHE3ZFA3TWlibG4xNWJtbjU1dm4yaXN6cC9QTzYyMTNaMmQ0bzMvK3FkLzduLzZSMS81N1l2M2V3K1JPa3c5dEx6RzhiVWpmUFdWYnh3QTVFRXdIengvNnFQL1Z4NDdjMEZYbDdxOGZPVWxIVTFIWHRGcWRrTmFIeXB6ZFdmRDdVMkhZeU5oYzNZb1pCYmJwNmRXVHMrZlAvYlJQejNJbysvTWZISEx4cTMwdnZCS0FKcnBIR2VPZm9nWDN2cDcvTi8vOGk5Sk5pMlpUa3JSb1B6NnJ3VEVpQmdETDcrd1BydUZhOW1DcEdFMVNTTXRpM3BjSlVram9xakczWFJTL3RPQkQyUmxxYXA2bDVaVVZhdS8vNFhudjM1bWRlMU81djI1WVpaUjVFV2R5MXRoV3BZa2F0YSsreE9ILyt6SkMvR0sxZVhPeWNOUG1lT3JqOUxwTEpNMjI4ZkhrK3F4d1c2eHVMM1QvMCsvOGRaTGI5KzdaelFZWTFBTklhb0p0UStTOUFmRlhyNytCWjQ2OTE0T3p5OVQrWW83dSt1SWlCWEVBdnJJc1llWFR4MTYraTljM3JxOXN6dTQ5SE5WTlhIVS8xK3kxRjNxUG5QK2UvL0VxR3I4NUtESTI5WkcvZEZrL1hPajhhMDdzOUNqRkRGaFd1enh3bHUvSUNGVXByODdOZU5SWVl2QzJiTDBrWE1ocmlvZjFWOXI1SnhhNTBKVVZjSGttWlBndzR5R0YyeGt4RnBoT2ltNThOZ2htczJJRXljWDJOd1lmOHRyZXY2TnQ5bmY1N0RHbURDYnk3cDhlOE45OU1MNXg3TnBlZmI2K2hiOThWaTJCMk51N2V4eFoyc1hweTQrZGFheDJHNHZwTTg5OFFPY1dIdVVLTzFKMU9oaWtqWTJiWm5CeHZCVVErUGVqYTNici9iSHc1eDduRnlockVvdHE0cjNuSHVVbXh1M0RnRHlvTmdyVjEvaVBTY2ZveHZQYzJuamtna2g3TTloOFYzditlN1RRUlkrZTMzM3hsdWJPNi8rTDZvK0JxSkcwbWcrYys2N1ArWE40bDhZbFc0SkFURlJmM2YzalYrYlpGdTNtUzB0QVdFMDNaU2c1ZDA5RFJFU1ZWS0JWS0V4UzNvYjFKMzVCQ0ZHN3liQmx2MWQ4YUM0S2toM3JrbWpHZE5wcDd6NjhoMCsvQjFudVhIdFd6WFBIejk1akt3c3BmSmUyUCs1RUgzNDBZZU9uMTVhZkNiNFlBMEl3ZU9xa2p5ZjRpcEhvOVhtdWZkL2xKczNKL0xhNVl0eVkvc0tWMjVmNVByR20zTDE2dXV5ZnJzdmFVaFByUzBzeThWYlYxN0ppdHp0QXlUTWtyamwrVVZ1YmQ0NUFNaURaQzlkZVptenF3OXhlZk50NDRPM3M4TXFQL0RzOXovcnBQV3BHenMzLzlldDNUZGVGS0ZoallrKytQQ25QOVpxbi82L2JFOG5oeFJWRVJGcm90MmQzZGQrWlpydjNXRTJza0U5NFdpMVpsSlBSYVNwU25NR2lPYTNQZnRnU2JnM1VmeFBsRmVyMGpQb1o0U2djdlQ0UE11ckhTNWYydjZXMS9Qd3NjUGtsWlBoTkJQQUdwRlVWZU5lTTUxNzM3blRIOHRLMzZ5Y1E0TW4rTUJvbWpHWTVNUzJ3NldOTGI1KzhXdFU2UTZ0SlUrSVJvd250N2g2OVJXZS8rWWIwbXdzeEV1dGhWTnJpeXM3Mzd6MDZrWDJTZXNnK09CMW5FMDFML0tESE9SQnM5ZHV2eW91K05sSWZGMnFYZWoxamxFMnFyTFllZ0VORFVXU0kwdW5sK1o3Wi83NCtqZy9YSmVMdGI3d05ReTlMMGJmMWlPSUZZMUVTRlZwek1aUjJwLyt6Sk1uTHp5NmNrb0Q3VGkxblNqU3RDeW1WYjgvNm05dlpOdFhMdy91WEh4amR5ZWJWc002VktOU0pRY0tWWFdpK0oyZFNSQVJQdmZHRzNyaVRKdnJseWM4Kzc3bitOcnpYK1hTblUzcFQ2YlVBNVgxSkxKQzlNYXQ5VnVqdkxqUmFVUnp1MzJIQ3lvVmhuWjNIa3hDSkpaako4N3lFOS85NXpoNitqUzk5Z0lTWURyWTR1MDNYMkg5eXEvdzZwV3Y4K2p4OXk2ZVhqdjV4ei80MkRNdmZPbVZyNzAwQTNVVlFwQXNtL0taajMwUHYvamJ2M1lBa0FmSjNsNS9xOTRacVRjTkxXQ2Jwclc2T0Qrdjg0bE9nQmFvbmVzZWUyVGk0OGM4ZVMzUm9hcldTSlZOTjc0eG5tNXZNUHZML2R1LzlocmFhRFRqN2svKzJmYy85WUVQbjNsdWRhMzN3VWJMbnZGZVcwRTE5dDZUVGZ0K010M0w4NG5yRC9hcTlhM2Q4dWFOcStPdi9lUGZ1UExGalR1ajIwQXNRcVJLcnFxVkJxcXR6VkZvdGlORVJGZFdsakRHRU1leHJPLzFSY0hvL2p6V2pMa2s3V1l0YWUrbVlXK09ZQXh4Mm1BeGJyQ3lzTURGeTFkNDhpTWY1cy8vMjMrWjNzSUNSREZVRG55QWhhTWNYbjZJOGEySW4vOWYvaWRldmZFVlBiZjZ2dlB2di9EMEg3dStlZlBLemMzMWZQWXozTkxDb3ZBT1pzSStBTWcvajBtOUg2aXFySFJYNTZMUU9MelNYano2c1VjLzlwMHZYZjNHcjFhK0pJazdoOG9RRWxCRkRDRTRJVlMzTjdkZi9VZVZ6d3VRTUNzRFd4RnBBSzN2L09RakovL1ZmK3M3ZnZMUWtkWjN4bWx5V0tVUlY1VlNWWTZ5TEhEVkJJZEVjZExvR0ZOMmtrWjhyRG5YZkxZMzEvNzQvRUxuVTYrL3ZQbXJyNzEwKzdmMmRxZGJzODk0V3M4TVUxVkZDRnNiT2ExbXFtOWRmRk9DOXliVUlJL3VoblhRYWFSMGYvelRLNSthWHg2ZnVyUFhrNlc1ZVVJUWh0TXBnOUdJczQ5YzRIdCsvRWVKcldVNkhPRExFcU9nSmtKQ1FFS2cwK3p5eUpIMzhjcXRMOG1iTjcrZUhsdDg5SDBYamoxMCtPYm0rdTQrK1lVQXZmWTdWeFQwQUNEL1FtQ0NIbDQ0UEM5cWp3ZW55ZE9ubnY2eDk1Mzd5UHFYM3Z4ZjN4QU56Y1ZXVDZiNUNDTkdCT252N2I3MTB4dTdyMSthUlZkMUdWaElWYlg1cC82bER6MzlVLy9LUi8rMWxiWGVCM3psa3FKVTlTNmlLSEs4OStTbEo2dkFtRG1jZVBKUVVualJ6Q3NhbWZtRjVlYkhIbnY4MEpQTHkrMlB2UHJ5bmYvbTBwdWJyOTFYU3NhNVVMbXgraUxyaTZyZUxUSkluWGUwVkxYVGFLU05QL1ZqSDNqOG94OCs5MTJIVnQ2ZkhEcTd6QmUvK0pzTXRqWnh3VE8zTU1lSFAvdERuTHZ3RUZWZW9BRjhQc1dtRGJUTUthWVp3LzZZMjNmdTBJeWFQSFBtbzN6dDBtOXlZK3VOem5SYXRldHpWMnV2VDR0TUZoY1c5ZHl4dzF5NmVlY0FJQStjellLREV5c251b2p0VGljbHpuSHNqejM5MlovcVovMy9ibjN2bG52a1ZGdVB6YTl3YStmNjlaMyt4Yjk3YSt1RjN3enE5NXVNZFVpanBKLzkwYWNmL25QLytpZit6ZTVpNXdOVkpZakdDRUhxa1hGTFRjMWVZQ1doZEJtbEwzQkFvU0taRjZvQUVodWEzYWkzVkxVLzlmampSeFphcmZnL2YrbWJ0NzdCdldGTEJkVVFBbnFmNTFEVkZ0RCtzUi8vMFlkKzVFZCs5SHNlTzNmMGt3MHpQYnErOVFwNzJaZFpmblNiSlRIa0U0WFNZZWQzdUhiOUJmTHBGbG14aDBpVGJuT1ZoYzRLcmVZODZUUm1OQnd3R0EwNXZIYUk5NXg2SDE5NDdRdlhYcnR4YVZqblduWHpzRDhhOGovOWc1L2g1LzgvL3dtZi9EUC8rZ0ZBSGtBTGdFN2RkQ3BHSmxuaHFMem5jUGZ3WTMvNlkzLzJKMy8rcTc5MDdjM2JiOHBEaDg1emJqbS9zcnY3eFJkTGx3Y1JTVlMxTWJ1NTdmZDg1c0xwZi9VdmZmemZYRnp0dlU5OXJZVldPcVVLbHRJcmtLQmFvQ0ZBOEdUbGdNcVZWQjZxTWhDY29xRU81azFrSkc1R3R0bU1QM0R1M0dyYldQTWZ2dkMxRzgvdmwxaUJNR3NNN2dNMCtjaEhQbno0ci95VmYrZDd6NTA5Ky8zekxmZjA3YXRmaU83c2ZsNGsyU1J1eFVTdEZvR1VwQXVsRzNQeHpxOHhlVE13R2c5eDNqSFhiWk9hQ0xSRkl6bE9XMDhnSXFncTIzdDdMQzBlNXNtejc4KysvUEpWdU1zT1Uzc1JWZFcvK1F1Ly9JN01RdzdLdlA5OG9kVitGU3ZhNkc5V2p4MS9UM2VwdmZLVU1kS29uR2UrUFgvbzFOcXBZNWMzTGpjM1JtTjdjdVhDOGxPbm5qaFV1T0hWamY3dG9hckdJdEo4L054alIvNlZIL21wdjNCNjhaSHZyTWFKSlFvaUtWVGVVRG9JQ3NFN3B2bUVySmhRbERtVm05YUxUSVhpaTRCV2lxOFU1eFQxaWlwUzVvNHE5NnVkYnFPYkY5WExnMzQybVlIRTMzZEJ4cC82MUNlUC9NZi84Vi8vUHovM3pETi9icnIxMWJPM3IvMTNwdElYc2VsVVRKd1NtTU9GUUZWbGxLWEhCME5SZVhKWE1wNTYrcnVPNmJpaWNCWERVWjhyMXkvempSZGVJcDhJQzYwRlhPVW9Tc2VSNVVPOWRxZDE2YVZMcjErakhveXNSTVFIVlYzc0xaRTJtbXp2N2h3QTVFR3d5RVQ3QUJIQVZyNlNhenZYcnkzUHIxYnpuWldIcWtvYVJWN1pYdHB1UEhieXRIRWg0L3B3bkNSMjVkaHpENzN2L05IbE5iL2V2OVYvLzhQUG5mbUxuLzFMLzhZeXB6K2EzV3hIK2EydWpHKzB5QXFnVnhFaVQxbFZaTVdVU1RFaHI2WjRMY21MbktJSWFBVmFCbkJLY0tCQkNUTS80WjFLTnFuRUdqbWFOcVAxMjdjR0Y0UFhhZ1lRRmFsWkV2L2tUL3pJbzkvOXllLytDL2xnNi9EMXQvOUxiYzczUld4RDNBeWNMdFRleVR0UFZubktNdUM5WVRqMWxDNWdGSW84TUo0NGlxbVNqenhiNjMxdWJkeWkwMXRnc2JWSU5zM1VtcWk3dXJ6Y3VyNTErMnZiZXp0alp0U25xb1FiRyt0NlpHMk45YTNOQTRBOENQYmtxV2NZWmdOeHZycnJVUWJUdmVxVm15KzlQc29ucnlkUkdocHh1MTE1bWpiRTBZbVZ3OFJSNFBwZ0tIa1dyNXcvZk9HcEo4ODhldVRqajM3NDQ2dWQxV2NHL1R3YTlITXBwcDVpVHlodXROaTlIWEROQ2JSTE1sZFJ1Z0x2QXVyQk80ZXJmTzB4WnFGVkNIV1YxUWNsVXZCZXFhcWdaZTdpdWNYMkNlLzFoZTNOMFlaSUhXck42RVBqelRzM21qL3d5ZmQvcEJIcjhjM05MMkJqTDBHYU9OTWtCSU56QlVWVlVVNFU1d3o5Z1NmTFBTSkNjRkM1Z0hNUWlrQXhMcG1PS3ZMTU1Ca05XTis2VHFlM1REZnV5bVF5WWFIYlc0c2J5Y1ZYTHI5NU9YanZnVXBSTHlLYXhESDk0ZkFBSUErQ25UNzBFTHVqSFlvcXZ6OWQxN0lxd3VXTk4yKytmUE1idjdNNTJYelpXTHRlZVh4WlN1dFFaNkYxcU5PUnFTL0R4dDVlL3A1anA4OHNOcnRIeHNOY3lqS1E1NDdSSktjc3F6cCtHN2JZdXdNdTNZTEdnQkFDUlpVVG5FT2R3NVVPWDlWRDkvdGV3ODBlN3dMZUtWWGhaVG91Tlk1c1I2emN1blY5NytVUTFNMXViNEJrZTNmSTA0OHRuamwrNHNJVHUzc3ZHT2Y3SWdKaUY4QXUxZDhubXpJZGVLb00wbTVLR1J6QkM5NkRxd0xCeC9nU3BxT01iRmhTRmg0Tkh1OEx0dnBiTkpKNUdsRkRzeXlManF3Y1d0NGE3THh3ZTN0ajk1N2FsZnE5NGVBZGw0Y2NBT1Qvb0IxZlBzVzFyY3NFRGN3MkJ1OXRHNHFFeWhmVnJkMnJ0NzU1OVVzdlh0cDY4MnRXek9Xc21HNjZxaHd1dHh0UnAxbGxLOTFPVTlRbVJlSEluR2VjT09ZdkxMSjZZcFhkOVF4ZlZZUkpnOG10RmpCQlc5dFVMcWNvU3NxeXdsY0JEYlhpb0hyRkJ5VW9sRTV4dmc2M3l0d3puWlQ0eXBsMko1V05qZEZ2WjlOcXltemNvOTRFeEpUNWxqMTM0dWlIMUpSZFk3ZnEzcVU2Z2pZSU9vZlhDQk43S2p4QkExclhDaWhkSUhqRlY0NGlyNmdLVDFXQU9rdkFZYXhRRkZQMnhuMWE2YnlrSmlYNHNMaTRzTER6OVlzdnZ4eENxQUJualBHendzRUJRQjRFdTdsOWpSQTh6NTc3b0d3UE4yWmJnek1kY3ZadmFBbUFtK1Q5OFp0M1hyajJ6ZXRmZnYzUzV1dXZMQzYweHQvNTFBZWZ3OWxPNWJ4b2dJbUZwMy8wQ1Q3eG1hYzRjYmJEN2EvOU5wdnJKVFpwWWNzVXY3MkN4NkdOUFNxWFFhVklBTy9yaFNudmxjcERIcUFNNExVT3RmTGNNeDdtVXVhVmROb3BvMUgrbGQyZDZZWUk3cjVrUFY3ZjdHZEhsL1g4OHVyYVdaUHVpTVdJRWZDdVFNMDhVZU1RS2lWT3B3U3Z1RXJyWE1RcDNvSDNuaXAzVkVVZ0x4ek8xZmVGTmJVWWFGYU9HRTRuTExaWEpZbmlxTk5xSjd1VC91K3M3Mnp0Q3VLb3grd0Q3N0JGcWdPQS9IUFl2L1g5L3c1S0lDOXpta21UY1Q3U0dWRDJLMFgzSDBJTEdrK0tVZmpzZDMzZnMwK2RmZkxaUEM5c1ZRVUpDbG9FdW5NdGpwNWU1TVcvOVYveGkvL3c3L0NsMjVkWlNsWnBON29vQnIrOWloOHM0R1dJMmlHSk5SU3VCb1lHQ0VGd0toUU9xaXFRWnhYVGNjbDBsRk1WcGJiYmlUV1JYTHArYmUvVm1iY3JaMTdFbGhXYVdPOU9IdTk5dUxGSTAyV0ZHQlc4T295a1dOdERhQUNDOTQ2OHFBaE9jV1ZkRkFoQjhRR0MxOXFUbENVU3RKNGlFVVdBYVRGaU9uV3N6UjhpalpQZTh1THkrdk52dnZoSzBGQ3BxcHVGVys4b2dCenNwUDl6V0greXl5UWY4MWQvK0QrZzIreHAwRER6SVBqN0puUkxvQlJ3cWxvZFB6N2ZldWk1OVhOaC9qVWJwNHBnNi9GRmdXdGZ1czQvK3M4K3oxZC84d3FmZTN1VDE2OStCUzIvam9nanl4ekRVY253eWpMVkt4K0YyKytqekZvRThSampzT0xSNE5DeWhDd2pUSE9xU1VreENMaHhoSEh6dUdtbnNkQmRmY2dhczc4TEw5VExraVhnWDN4OTgrWExsMi85VGlpRGFDeGFCWTlXRGpmZVJzS0lKTzdRVEhxa1NWUnZ1WmpaZUZuUW1TcVY3TmUrNngxaVUzL3pmY0x1SkRic1RLNXpkZjBhVnFTZDJ1aENzOUZvY204di82QVA4aURaaTFlL3dlV050L2pGci8wYzI2Tjd1K0RmKzRuSG1VeHpwbGtwcWhqcS9ZcEdveEYzL20vLzd2dC85SWtuaSs4UGpUZGphWTdGVCthUnNvVXhRaFJCUG5MRXJkTWNYbnFJUmR2ZzA1LzVDTWVmZlpiTHIyN1dpWGZ3aUUrUXlXRjh0bENmTEkwUTM4RG5NZVU0Smt5YVJOTWxtdGs1eXQxbHNrR2J5QitXZkRSbkpzT3VOYlJlNm85djMvbzJEeGROY3llZEx2ckllN3JQOWhiaWxnVzBVSHhXRW56QW1pYSt5aEFLQ2xkUVZZcjNndTZIZUxPd3E1aFVWSlZIWnVRbXp0ZmV4aGlEOXdWN2c1RWVXVG9oWXVYeUYxLzkybTg3Nzhlem5vaWJlYlozVGpuLzRKai9pN2ZWdFNiVHI1ZFFLNTVGcXNUR1N2SnYvOFVuUC9iTWUrSWZRc3VHeGg2ejloTGRkSVBvNWhueTlUUFlhb0VRaE1vNW5tby95cW41RTJ4c3RERXJIa2xpcWl6RFdzRlhqckp5aE9rS1puTVJhUlI0cVhDVngxWWVrL3ZaenNhSW5mNkF2QWc0TndBYmt6UzZoeHFOeFNQYzI0Vy9YNjh3dkg1NTk4MjkzZXlWdyszb08vd280SXM2UEtxeUxiTE5BYzRIS3U4eGxTT01QVVVBaWN5TXZrS0pESGQxdUl3bVlCU1JnamlKQ0tFaWlpSW14WUE3dStzY1dqbDhmMGoxanV5a0h3RGs5OEgreHYvOFZXYXJyMGJyYmIvNHV6OXg5TWd6ai9kK09JbnRJVzhNWGdOaWxLaTdRWHA2QXhaZnBkbzVpZDE5THpLWnA2dzhhYXRCZjMzTW5hdXZVWGxvSkJaUWlpb3dyVHk1T2lKcnNPT0V5a2VVd1lGNFJ2bVF6ZkVlMDJ5VDZXUVhyNTRvaVNsY2hVSFYzUnZSbC9zZUFPMGxjZEtZYU5OTzZzNjhlc1dGL1R3akoxUUJWd1h3TU56TXVMaytKZW1sZEZaYmdLQmU2KzZpUXRDeWRnZXo3eTdHSU5ZUXB5SzNkNjRGVExSbmpGVHZaSkFjQU9UM3lRU3AyZHdoamlNVGYrQjlKNTliV0QzNWVDRU9yWWEwa2dVd0NTNGFZTXdBc1gxTWU0K3NkeE8zZlk1eSt3amlsbWkzbTlqSWtlVWx6Z2VVV2pYUklBVG5HYnVBaWxCb1JSWnlLcDlUNlpDNGxUSFl2TTZSbnVYSC92eFBrWGNXK1AvOTlmOEdWNVdSR0pQYzUwRm1CTjNZT0RibWsrOWZlKyt4cGRiak4yK1gzTHhUa0JlK3ppZEVhRFFNM1haRXQxMUg1bFlNRVFiWEw5bkpIUEZjZ3lMek9PY0psVWNNaUZGRVFGQUNOWFZRb2lsNWxWWFhOMjZ0T3gvMmQ5WERnUWQ1bHlHRU92K3dLOHVONXNwUzQ1bkVoazUvTWxCakNsRm5zRkVITVIyTWRhUnBob2tDSnRtaFd0akJIbTVTYkIxbWV2MGtabkNjaGFSTlVUa21SVUdDb1FwZ2crSzhVbW1nVUU4VlBNRWFUaDVib1NOdzhjb1lIeXpMeTNPOE5WQ2dpYlUycWx5NEh5QXpPVG5pUTh2TjlxbWozUTlOTTIxTXA2b2lrVmdqVkZYQUJXV1NlVGEzSzVvTmc3WENaRnJUc3ZvUXFBWVY0MzZPcGhGRjZmRGVFeGxiOTJoVUNTSFVGT0RXRUluMVJWbTlmSHY5MW90bFdUckFDeEwwSFVqa2V3Q1EzeS9UZXdldzI0bFNhN0oyV1d5ZzNsTjZ3Ym1NeUFaUU1DWWlUZzZSeERtcXUwUlc2TFF6N0pGTHRJL2VZUHZtQXV0dkh5SjE1K2swRnhtYmdKTUtaNFNxY0FRZjZsaE93S3V3dWU2NGtRdUxjNCt4T2Q3aXIvMUgvek11V0VLbFJJMUkxWmw3TUFZclFxeEtkT3BvYiszWWtkNzU1Y1ZJVmxjYm11ZWV5YlJrZlRQbnptYUJxaENzTUJ3N05uZW1aRmxKcjVXUVJMYk9PWXBBbWVjZ001Y1FQRUhyY0VzOWlBRWJXVFdSblY0Zjd2M1N4WTJ0VjJjRHYwNkVnS0ovODcvNFNmN1V2L0czRHdEeXJ2RWpJTmFZS0tDMmNFcmxJSWdoc2hiMUFlOXpqSUl2YytLa1Eyem1VRElxcHpodmFmYzhjbjRidjdUSjVUZmZ3bTBlbzVxdW9PVUMrQTZSTWJTeG1PQVlhU0NvSTJRZVgzbFNFK0VrSmg5T3dVWVlXN2YvSXB0RTk0VlhFVWdheDVKKzRvUEhQbmhrcmJ2aVE2VWhJTVlxclZiRXNhTXBuWGJNdFZ0VHB0T0FvR1JaeFdDVU01NFVyQzEyU0dLTGpRTFdneXNjUmdTWENOWUkxcHE2VVNOZ28wZ2ltMVJGOEp1Z1JWME9yek9YdWJrbWYvMy8rMXNISHVUZDRVRHUvVEhObkovbW9haTg0QldzVlpJNFJkVGdmRUhoUEJFRlV1WFl1SVdONXpHYWs3c001enplUTY4WmNlcThZM1AxTGJhMjNtRDdqdUFIeTBURk1sSTF5SVBncTdwWjZIM0F1UW0rbUlLcmlFVFFBQ1pLTUlJM3ZxanVnUU9qcXZHNWt3dHJ6ejF4K0R1enZHaDZMeGhUb1ZwdkE0dGF1aDNoN0lrR2IxK2RjdlZtQmtBY1daenpyTytNNmJaUzJvMTROaGNXY001QjViRHRGSXhncllDbzJpZ1dNZW5BT2JkVjV4MWExY09UR3B6ekJ5SFd1OFoxQ1B0OHQ3cXpWNVNqc1J2N01DTm9ReEVjVlZDaXhzTmtic3pPNERKenpZUkd5Q0N2Y0hRSUppVzRqT0E5d1lPVTBDQmlZYzdRYkRpeXlSMnk2VTJ5a2FLVFFOR3ZHTzBWakVjVlZhNzRRZ21WWUxDSU5iU1NOcDF1ZTJOaisvS2wyV2NmNmxZaDZmc2ZYM2x5ZDNkeU5nU0hOVUlVV2VMWWtzYlFUQTFscFV3blFoSkhHQTFNcGdWSkVpRkdjSlZuYnpobE9CS2FhVnp2ampoUEtDb0V4YllhWUdxUWlnU3RndHVaVEtzdGF0a0VMMEpRZldkU054d0E1UGZma1lScDVsemxkTGZ5R2xCalFsQXFWK0ZDUWJ1N3pNa3pmNUt2ZmVQbnViTCtUUlpiQmdrT0RYc1lNWmlvYnMwcjlWSlVQR09QVXd4Umt0Q1FRRUpGTTRaZXh6STNiNWtNU3Fiam5Na3dZem9wY1ZWQVJZbWFUWHFMS3pTMkpyQlZDK2FnY0hTMXMzWjhyZmZwcloxOFBvbUVSbUlJNmtsalE1bFl4bEluNVRzN0pkbkVzYkxVWm05VVVGYWV5QnJpcUM0Lzl3Y1RObmNEOCswR2xvRDNnVElyU1JGTXU0RTFNVVlNbFhPRG9uUmo3akl0aW9McWVGcnl3aXZ2TEpiRmcwNzY3Nk1QVWEzRk1WV0puM2w2OWVUcWN2dERQa2pzOVI3VFRaWk5PSGZ1MDF4NDZPUHNEU3RldTNpUmNWWlJGWUwzU2pFTlpLV1NUUUxGdEM3cGhxcWV2d28rRUVKQVhkMm5FQXdFQTJxd1lrbmlHQ09Dc1VJY1d4cEpTcmZYdGhqeitzMWIvYmRuRjJUOG1lODgrYkgzbkovL2tWYlR0cUxJSUFhOGc2SlVxc3F6dmwxeThjcVl5Y1FSQWxoclNLS0luZjYwTGhDanVDcGdETGpLc2I2YjQxeWdFVXU5Y09VY1ZneHgwc0JFRWtaWitaczNidTE5S1FTZGlwQXpteXgrSjM2S0J3RDVmYkJPSnlZRWxmdElFYUpPTzRtT0hlMDkwMmhHeXpVOVd5MHVPODFIdU5Eay9FTWY1dXlaSjBtU0ZkNTQreUk3Z3o1WkJWVWxPSy8xam9kQ1dTcWhEUGdxMUx2b3M5SGQ0Qld0QXFvQlgzbnlyS1RNSzF6bFFNRWFDd0tOWnVLOThzM3IxL2N1QWRISnc1M1Z6M3puOFo4OHN0WjR4SUQ0QU03VjlRVUY5b2FlRzNjeU5uY3l4dE9LUmhwUlZvRTBzWWpDOXM0WU1XWTJBbCtYN2x6bEdVNDlhU3pFdGdhSmVvK0pSR3hzM2NiVzZHZnZiSXhlQjUxSkk4ajlzZ2dIQUhuUTdjLzg2Y2U0Y1hNczArbGREZko0ZldOYVBmSFUya1BOZHZxb0Q0Z3hnZzlDNWd4M2RtNFJ5d3BySzZjNWUvWVIxbGJQc05NZmNlUDJMYVpGZ1F1R3FxaUpHZTZPbVJjZWx3ZkszSk5OSE5OeHlYaVFNZXhQR1E4eXBwT2NxcWdJUHV4ZjhnaENrc1JWWHJybmI5NGFYQUhpSC9qNHNlY2VPN3Y0SThOeGFQWUh0WWNveTBCUktsa1cyQjFVN1BacldialJ1S1NzQXUxbWpBWm9OUk9jRCt6dVRURFdFSHlnS012Wm5pNE1wbzdZQ2tsazBLQXFJRVIyNjlibStPZjd3K3dta0lsUXdEdHZpdmNBSUw5UDlzaXhSVm9MQ1Z2YlU0YkR1OE9LY2VXQ0hqclU3U3d1dDU5QlRFc1VuSWZTQ3p2VGpKZGZlb0ViYnc0NGN1UTRaODlkNE1KRDc2WFhPY1RsS3plNXZiNU9VUWFjaHp3UDVMbW5LbW9QVWhXZTZhaGtzRGRsWjN0SWYyZkVhRGltekFwYzVRamU0MzNBTzRkM0RoR3Bwcm4vNnNiVytPcVo0KzJsZitsSHp2K3B4Ym5PK2IyOWd1RTRrQmNCVlJpT0hOZHVUN2l6TlVXQVpoTFRTQ04yaHpsUkpMUWJNVDRvYVJJeG1WYmtoU09FZ1BPT2FqWUNyeDZ5cWc2MXJBRlVLWnkrZUdjdis4VnBWZzJBRENqajJMcUhIMTVsYTJ0eUFKQUgyU0tCeldIR3FiVWVkN1p6bWRTNkhQc053MmhyY3pvNGZXYnBmQlRIWit2OUNaRktZWklKVXovbGQ3NzBSWDdsNy80bUd1RFFvY004OGNTelBIeitLVnFOUmE1ZXU4T2RqVzJtZVVsZUJJckNNNTVXREljNXcvNlU0V0RNZEpKUmxXWGR1ZGFBcTdtdjdqNGhCRFRvY0RqMS8zaHZrTi8rOFUrZitzaDNmK1QwWjQySm9tN1B5dkppRzFWbE1ISHM5VXVHbzVLaWNPd09NNkxJMG03R3hOYXd0WnZSYWtiRTF0VGJMd2pEY1RHYjZLMVhjVU1BZ3hLQ2twV2Vkc05pQlNaWjlkcG12L2hIcFF2akdVQXFhMDJ3SW96R3hRRkFIaVI3NHRnOHk5MEd1NVA2VUtZR1Z1ZGI5SGNMV2QrWjNwK0hXQ0NhVGl1UHltaGhvZjBFWWhjcXIxcDZaSnA1bkJPNnEwMXUzcmpLMy9tYmY1OWYvZVZmb1NncUhyN3dDRTg5OVQ0KzhvRlBNaGtFUHZlLy9DWTcyeE0ydDRkc2JQWFoyeHN4R0k2WlpEbFZWYzAwRmJXZWRGRzlONFdvcURVR0V5ZmZ1SFpuL0t0clMybjdUMy9tM0UrdUxQVk9xRHJ5TEpja1ZnNnRHcndMdkgxOVFuK1kwMnJHMUdRS09YbmhhRGNUdkZlMkJ4bTlWa3BRaUszQnVVQmVWSlJsN2RrMEJGQWx0blVPWlMwMEVpdWwwMi91VEt2ZnJGd1lBZm1NYURzMGtvaEpWaDBBNUVHeEl3czk1cG9XWXcwYmd4eFZGYS9JcEhCbWtKV21wdlZVdTUra00xT1p1bk5uMU04eXY5MW9OaDRKd2N6bEZWcVdRVndWOEI0V2p2VG9wakZibDlmNTlYLzRPWDd0MTMrZGF6ZXVNNyt3d1BXcjEvblM1Ny9Dai8zUW4rWE15ZmRRWkZDVzlYQmdIZUh2ajMrWnVnR0RZbzNVemJzUWlOUDB6dTdZLzYyZHZlbTE3Ly9Zc1E4OCtmRFM5MlY1bVJaRktVWHVpYU02Wk92M0EzakROUE1VVmFDUlJuUmJDVHQ3R2YxeHdlSmNnOG0wSWlzY3ZWWU5HR3NNL1dGV0Z3azhWS1hPMXJGcUQrTWNZaU56YzFLRi8yRjlVTHl4SDE2SjRGVFJiaWRsUEMwUEFQSWcyTkdsTnFLRy9yU1F6V0V1cGZkbXBqSmx0YWJWM05mclNBUWFVcmN1R2tDcVNtdGpmYlE3SGhWN3h0cmpZT2FEMW9JMzNpbVZWeHBMS1d2SEZwZzNDVGV2M2VUeUYxN2t0ei8zT2I3NC9KY1o1eVh2ZWZ4SjN2dmtzNXcrL2hDSGwwNHcxMXlpSGMvUmFTelJiaTFnNHdaVnFBaStRaEJDQ0JwSFVWNEUrM2R2ckk5L2EzV3gwZjNoN3o3NVE3MTI4bENSZXhtTkhPTnhZSHZQY1d2VHNiSHRTQ1BEZkRmQnVjQndYR0NOb2R0SkdVNEtCcU9DUm1MWkhSYkVrU0dON1YwV2xiM2hsTWdhdkJPcXU0UHNnaXFUVVJIKzFwMXg4Y3MrNkppWnNLY0l3WWpvYUZLK0l6L3JBNEQ4SDdCMkkyWXd6V1dZVlZLNFlGVTFtb0VpNVo0Q1ZCTm9BYzBvc2xGa2JXb2prOWFhSHhMdjdrNTNkclludDlYckdzZ0tOY1ZnVGJ5UWUxd0V5V3FEcGJVZUZ4WlhPZVJpV2hPbG5CUjg2Wld2ODVWdmZKa1hYMzJKMit1MzJPN3Y0cldDdEdLWTd6S1o3bENWVXlRRWZGQ01zV09uMGMvYzNzNStzU2o5OVBGelMrZmU4OWpLRDBaZE8xZElUR0VTU21PNXRWN3g1cVUrU1dLSVk0dTFobTRyeGp1bFA4d3hScGhycDB5eml1MytsQ2d5N0F4eTVqdHBQUkxqUEZYaG1Fd3I0amdpekNaNVJYQ1Y2dis2VjdxL1ViaXdPZk1lT2VEU3lJYjVWc3kwOU8vTXZQTGd1UCt6MjJZL0UwQm1lbjUzd3lmdWFXc2tpNHZ6VFFOcFpFT3YyMnA5cUNxckZTdVJuVXd6VVlLMVVlSW5tZHNiN1U2ZW4rL1k0MWMzUjczMlhKT2trNEsxcU5TQ0hhWWhyQityMEJXdzB5N0grekh4YU15b21ESXNSa3lxZ0VFUkNiZ3lweW9jVm9CUXI0eEhrZDByZy9uWjIxdlRuNmtxWHdKaU9vM3F5Sk56WVdtbERiS0lKNmJJdTVTZDIxemZmWkZYci9RNXR0em02R29MQXl6TU5ZbXM0ZnFkSVZubG1lczJVSVdkd1pTZ3l0VTdBMWJuV3pnZlNCUEJHTVc1UUtzWk1abUdVSG4vNnNENXY1VTd2MDdkRkN3QUowaElZK3FwNW5kcTRlWGd1UDl2V3lPMnVLQTRYKy9IaFh1SmR6Sjdta0M4MW1zZW1rdk5pYm1WRmJPMHZQYit0Ni9lYmxkaHNsd1d4ZmY0b2t3cUh4TmhNTVpnc1JxRTZmblRpK1gzL2NDUjFqLys0aFl2dkxwRFdYcmlWa0xTU3VwYlhFQkRvQ3dkWlZsUk9VZFFqelVlUXlDVWpyeXNaa3NYZ2pFQ3FxSXFQaUF2ajNOK2VxZWYvK1BLaFV3RXEwcnkzRWZYRHEwYzZuVWJqU1djUzhteWlQRlFxYW9KNXg1YkpXbFpYbmx4blozK2xFZlBMSUpBdTUxdzlzUUNyMXphNHM3V2lNVmVnNVdGSmp0N0dlczd0VEJveTlic0p0Mm1aWklGdlBjc2Q3dkZidTUrS2V2dlhSRndXb09qQXJ3eGFGRUZiU1Z5QUpBL3FuWjR2c0h1WkZaZHViY0VGZDBIakphSXRELyt5TnBUcDVjN1AxR1cxV09WU3NpbnU0ZVRhdUt5ckxUajNEVWpvcm94b0xQaWtuamlocGw3Ly91NlBQWm93dUxjWVk0ZDYvSEN5enU4ZFhHTE8xZDJVZW9OUEd2cWZUeURvbHIzS1pSd3R5RnZqWWhCeEtDcVFRb1h1QXo2bFhFZWZtazA4ZnU2Z0tpU0hEM2Fubi95OGNOUGQxcExjMTRiZUo4dzZBZDJ0dGZ4NVFSWFZSdy9Qa2UzbmZEcWkrdThjSEdiTTBkNnMwbGQ1ZXl4Qlc1c2p0Z2I1c3gxVXBZWFdveHY3WEh0em9BVHk2MWFKMGlFWmdQeXFkR1ZkRDVxeEg3eCtyQmZCY1doNmtVa1JNYm9rZmxGdlRQWVpuM2czckdmLzBFTzhudlk2ZVUyTGloZVZVb1g3amI5WmpsR0MrZ2tzZTMrNEhPbnZ1dDk1NWIrOGx3aitrQXJqaGNhUmhmYU5zUnI4NDIwbDVxNG0xb1JWQ29YeEhtVkVGUmNVUG5naHhiNXNSOWJKWW1GSkxMTTl4TG1Wem9zTHZkb3BqRVNBdm5Fa1k4cnFnSjhKVFdMaUlwYWtXQVFGU1dvbDF3RHQ1M25kNHFLdjVNVjRXZDJoLzVYeWtwdk1xTWRtcjJrK0YvKzgrOS81aU1mZmVRbjRxVGRyVnlMMGJERjdaczN5YVo3dUN5SDBxTkFFbG1XbDFwTUM4ZVZHMzFhYVV3anFlL1R4VjREYTRUYkcyUEtxcUxkc1BWdVNGYVJHTUU1c0NabU1WM1VSRkpCNVBhZHllaUxsWGNaa0lsSUZSa2JsanM5TmtmRGQvUVpPUEFndjRmRlJ0aktIRm5sMFhCUGJHWUdqdlpTTjEzOXhDT0gvdGpEaDdwL09rR09PdEJXeDJwdm9TT3VESXhISmFrWWVtbkVVcXRrWEZUMHA0Nk5QVTl2T2VYSC8vZ2hPcjJZOFNTQ2FCWHNsSVhGS1NhT1dGMXAwTjlaNHM3dE1UZXU3TEN4UHFESVBYRmlDR0l2RGNibDEwUzFVTlgxb0hwTlZiY3FIMjVWWHZ2M2dhS2NlWThJaUZ1dEtMN3c4TkduT3IzZVduOVlhVlVzeVdodlFGbE8wRkNBOHpXbmxTcVZDeVNSNGZ6WkpScHB6SnRYZGprMDMySnRzVVZRWmJIWEpCeFNMdDdZZ1ZEUmExcTIrcDVZUGQxbXpLRzVOU0xYbE1GZ0l1MTI0MHl2MFZ6TXFtSkhaaFFPUVFNaEJIMm5uNEVEZ1B3ZWRtMTdTcElZQ1VIM0JTNzN3NnIyNmVYT2lXZU9MZnpVdWFYMmovUldrczdhK1JhZHRVUVFYNThBaGF4ZnNYTXI1ODdWS1Z1M00xcmppbTdUc2RDcENGSGc0cXQ5ZXZNSlM2dHJxRDFCMHNsbzZEWWg5TkVRNmhKcUV0R0lJMXhaTXRpYk1EL2Z3Sm40cmExQi92Tmw0ZnFLRG9ESkxQSGRaM01zOStQOFdaUVFBZEVUVHg1ZFdUdmNmU29yY2hsUFVoME5keGtWTzBnRWxJRVFTZDBaZDRIVTFDVFlsVmRPSEdyVHNjS0xiMnd4emlxT3JyUXBDMCt6RVhQeTBEd1hyMjdoS3FWbExlTnA0TUt4Tlk3TUhXWm5keUJCQStyRDRjVkc2K2pHcUg5SjY0RURxNHA3QjY2Z0g0UlkveXgyWnJYRjVxZzBZVWIrTmdOSDU2RzE3bE1YbGp0LzhlVHh1VTgvL3FtenJVYy9kWlMxYzRiMkFxUnRhSFFOalo2bHN4S3pjcUxKMFllNkxCMXVFc2VXNEFXWDFUb0ZiN3phNTVWdjdERWFHM3BMUzVnWXltcEVsay94enVOOVRlYzVIQlRjdWJtTmVxL05Wa093MGVYdHZleXJsZk1UWUg5a0l3T20rLzJGR1VBVWlFU2tZYTFwL3ZpZmVPcmpIL3pnOFIrYlRKSW9uNlNTVFljVXhZQXlIMU1WUlMyajRHczVCVkZCWmhkOENFb2pqbGhkYUhKN2M4emVzS0NWUnZXTTEyd1ljalN1Y0VYZzdKRWp2TytoUjlGUWo3bFBzNkptVlV6amk5ZjZPNjl3bDIxUy9LVEsxWVZ3QUpBL3F0YU1JeG5sMWI3M1NJSFdRcU54SXRYazM1WTArc1FuZi9LcDZKbnZmMGhzWEJHOGdJOHh4TWorVEpLcjErUk1KTFFYWXBhT3QxZzQya0ZOUkRad3hHSVlEZ3JlZk9VMmI3MXhqZUZnUUt0bk1XazlzZXRtTE8yalFjbnQ2MXN6K2h5UlRxL3I4eW84UHhwbDJ6TkE3SU5pWDlaZ3Y2bFFzem9LN2JWRDNjV2YrclBQL1puZVhQZkNhSkJLTnM3RWxTTjhPYVVzeHFnTFJGSmY3eUVJZWVZSnBTZEtUQzJyNEFLUk5jeTNVM1lIT1h2amdtWmltV1lsVlZGQ2NCeGJXZFB2ZXVKSlNhT1lvbklVWmNWNE1sVU5SR2tTYjE4ZDduNDVxQlpBaWVDZDk2RVIxUnVJQndENW8xYmFUV0pHV1NXK0x1a21RTXVJdE5wUitza3F5Si82OEE4K0hQL0FUejB0SnFyNXFVU2FDQ2xDQ3RMRXV3cFZ4VVNtMXFIU2dMR0d0Qk94ZUxKRDNHdVFiWmNrR0tMSXNyczk1T3JGMjF5NXVFTlJRbXVoUmZCQ1dRVHlxV2R2ZTRTcm5LZ3FyVmFybDdiU2pZM040U1hWK3hXanZ1VWxHQ0FXSXkxVm10LzM2UXZQZnQvM1BmNVRSZGJybElXaHlFZFNGZ09LYkVEd0hsRWxWSXBvN1RHQzFtUUxRczI5NndLVVZYMlFPNjJFV3hzanl0SmgxRE1aWjFSQjE1ODg5K2pXK1VPSHU4UHB4QXduVTRxeVlwcmxCSTlwTlJyRGZwbC9lVnprZzVrWGNTSVNyQmo5MkVPUGNYVm44d0FnZjFUczMvMHJmNTdmL1B6WHVFOC9QQUU2Q3QyMk5EN3o4T01yVC84YmYvVTdaRzUxWHRSYmpOYUt0T29Gd1lKSk1GRktrclF3VVVJVVdaTEVZbzNEQ0NSVzZTNm5GRkhNZUtjaUNtQ3R4WWd3SGt5NWZuR2J2YTBjazhRb2hpTDNGSmxuTXNyeFBsQ1Z6aDQrMUh0b1lhbTVreFg1UnBiNSswRVJJWGZudjFLVU50RDVDLy9xQno5emFIbitBM2tlbXhCVWduTlU1UVJYVFhHRngrY2VONnB3bFNKR3NMT2wrbjF5YWgrVW9naGs0NUl5ZDB6R1UyNXQxcDdIZTcrM1Y0U2ZPN0Z5N1BhcDVZV0hzN3lJS2gra0xFdU1NYUllSW1QdzZJdDN4b1ByTXk5WGlZZy8zRnZRcFhhWEsrOVFnQndrNmIrTHBXbkM0VVBMc3JHNUt5RUVNMU9rVFk4ZFhsbHFhM0xoeVErZU1LdkhWbkNWZ25PSUM0ajMxTlJPQW1LUXVBZDRSQ2NZU1RIaXNMRWxTaXJLb3I2YWpqelVZYTh3N0Z6Y0piclZwK21WdEJOVFZDVjcxM2Vwc294RFoxZnBMblU0OTlnUzV4N3Q0cjNTNmpSWVBiSTgzK3JHLzdJTDFYdkg0MnI5enUzSmE5Lzg2dlhYdnZIOHJac2hNR0hHZVFXa0gvMk9rMmNmZXVqUUI3MXJKSUlCVjZHdXF2ZHFRNkRLUFg3a2NKbkhOQzNXMUd1N1NFa1ZvUFQxN29xSVVCYU9qZlVCazlGVXgxbEptZmxKbzJsK2NYUG9mdlBLNXViNUQ1NDlOVTZUdUdVbHd3aWtjVVJ1S2tUazBGS3ovWXdSK1oyZ09wMzlicEpFa2JqZzM3SForZ0ZBdnMzK28vL0gvNGxmK0llZlp6aWF5RXpzUGdGTnJUWEpULzJKVDMvMDVWZGVmL2pwanp3a2NTeUVzc0JOeDBSWUlqWDE3SlBFV0JNalVVemxDb3haUVdVRU9pYVdPVXprQ0xIUVNJUmVOdURRY1lqYk1mNmhPWnA0bW1tRHBDbTBGNkE5bHhMSENkMkZPWnF0bERpSk1EWWhpaUpFWW5FK3JCSGsrNXp6akVmNTNvYytkTzdtYXkvZitQTGYrL2xYZnVYdGk5dTNBUnNuTnYzaEgzN3N1enV0NUh3SU5YRkM4QVhHSmdpQlNKUllsYUx3WUFTVEdGUVVsUURXMUI1Q0ZTMDllVlp4WjdOUHZ6OVc1d09xcW9XR2Y3alRyMzYyOHFHOHRMNys1ckFvcjNlYTdaVjIyeE1VR1U5eTlnWlRLdWVqeE5vanpTUnRUb284bWdIRWJJK0g0Y2pjd2dGQS9xalkxZXQzUUZVbWszd2ZJTEVxOFE5OHowZFBsbm4xbWNxUDVvNGNTaWpHRThSQlpGTWlVdUlRVU9PQUZERkozWEEzZ1NBNnU4d1RWQ0t3Q2JFUlZEMk51R1N4VTlCTUU2Sk9nME9IbDFpYVh5T09LNnlwaUV3TEVWdkxDRWlFYzI2bVltdFF0VVExU1MvWWlrN0hMTFFhOFVLbkU4NjNldnJNTC96c1czL2o5UmMzTHoxOFlXWDF4TEdsOTFzVE5iSnNpdExDUkRIV0swbTBRSjczUWFIWmkvQUMza2pkSEwxTGFWMUxBZzFHT1RldWJyRzNOOElBVG1Xbjhud3g5LzV2bGk2c0MwU2J3MUUreVBMWERpMHNQbFU0dGFxMUFsYWprWkJQS3hxTnhwbVRjMHVIWHR1OHRRVllWTTI0ek9VclY5L2ltV05uK1ByTnl3Y0FlYWZici83Nmw5bmEyVU1FbzFvUElUWmJqY2FGTXlmZS80VXZmUDI4WjBlSzBSMTJiKzlBNldra2N6UTc4NGlKTUhFWDU4R0htclF3a000MitSeGdFWTBRU2NHa3FLM29MRFdSdE1zazIwS00wbTJrZEJvUnhxUjREYk5SOFRxdHFEZjNMRDdVRElXUnRVUW1KamcvMjd1QXlvTlltNXc2MDNuNnU3Ly9vVVBkZVA0ckgvN29ZYnR5YU82OGR6VUJ0Y3NjVlZrUkFJbWIrR0NJUkxETmlNelhOQ3hlbFdMcThhVm5QSzY0ZFdPUDlaczdWRVdweG9oNHpNVitVZjBYNHpKOE5hajJnUXFSV0ZYVFMrc2JMNTAvY3VTSDQ4aDJyTEVFQXExR2dqcXd5S0Yybkt3QmI4ek9uZ21xdE9KNFJtSng0RUhlMFpZa0NWZXUzOFphdXorTUdBUEo5Mzd5dzBmNy9jRjNybTlzZGhwTjFjbGdLczFHUmpWeGxPTVJSVFdsMVZtaDBaaW4wcHFZTm9xYldCVkVETWEwcVZ5SlNveVFvajRDTFdrMEt4QWhTWlEwRWRyZEZ0WUtsZ2lYRFFqQkV6ZGFlSjhqdGdsWVltdFJkUmlwUUIzR0pFUllOSlNvVll4Uk1SWk9QTlErT3R3Sm56MTdaQ0ZJUmV4bXhEb1NSZGdRQ01XWXN1aVQ5cHFZeUpOTjYwcVdJcmpjNHlZVi9iMmNxMWQzMmJ6ZHg4YUtzVllDdkQzTTliOVozODAvUCt1N1RHWkpkNktxZW5sejY2MnNLTmVOa2JQR0dOcU5wdVJKd1hZNW9vVzB1NDNtVVd0TTdFT0lGS3lBSk5iS083V3JmZ0NRL2ZLUE1VaE44eThoK0gxZGo2VFZhcVNuamgxNSt2WFgzM3JQY0RoRVExTTJOa1lzclhYeEJzUjU4c2tXWlRrbVNoZXdjWThrbmtkRFJNRGlYTUE3UTFYRk9HK3hWb2ppbURoT1VDWTBvb1JPWTRsV0s4SVlQOU02ZDZBZXdaTVAxaW1MakdidkVDWnVvZXFJb3BoYXlUbkNHb014aXNHQ0NvMW1qR2lLM3hqd2lNUDBybTdiTytzN0pLMDJwdFdnU0R2WXhRVTBGdUs0alFTSGt6RjNqMmRReXN5emZudkUyMjl0TVI2V3hJbkYycUJWMEN1RFhQL3pHeHVUejg4YWxDUHFEcjdPQkRpVG5kRm9jMXlXbHcvMWVtZkhreHlaRVdwSFVhenRSclBac0kzblZqcTlYMTBmOXNmM2hWaytObnJnUWQ3cFZsVlZMYkYzcjNQZWVQYTlqeTI1cXZ6RXRXdlg1cXdScXRLeE55akpjcUZ5UXNKTWhxREl5SXVDU3Jld1VaczRYcWJVbE5JSGpCaGFTWk00NmRIdHJoSEVZWmdnQkx3RXJBbnN5L1NKMXJ2Y1NYTVI3d01ocERRc3hIRUhWWSs2S1NxQXREQlJDMnZxWFJBTkVNVktPZ21VVnd1U055YWNxSUpZcDVRRGo3TkRTcTA3ZEhaK0huTm9IajhIcnN3SlhxaUtnQm9ZVHh4WHIrenc5cHM3VEtjbFNTSkVzZUE4bTRQTS8vYzN0ckxmQ3FwRDduWHc5eGZKQmFodTcrNk8zcng5Kzh1eDJPL0lxaXBGTEoxV2s2SndlT2RwTjVvWGx0dmRRK3ZEL3FaQWhJZ05xazZTVnAzd0hBRGtuV3VoN3VnYTZ2R01CSWlYNW5zbjd0eTYvZGplOWpiV1dNMUtMN3Ziam14VXgvd2hGclRXc3FSQUtFTWdHNDNJc3lFU1JUVGJIUnJOTGxGM2pvV0ZOdDJPa2hjanF1bHQ0amlpMFJRR081dFVTWk4yWndVa0JnSWFiRjBOYThlNFBNTjdKYkwxWW05VmpURlJBNE9yRzN4QlVWOVFYTjltOE5KTjhvMEprZ2VzS0VscWlDUm1PSEZNTWs4Y0cvenVnR0l3WnJlaHRFOTBxWUtpa1REb1Y3ejJ5am8zcjJ3aUtyUmFGb3dTWUc5YzZmOTRhenYvbFJCME5BUEhGS2lrNXJPVFdaaFZsczZWMTNkMlhuLzJvZk9iWjdxZDQzdDdBemE4STJzbWtvMExySEtvWWVPandPdlVVMkRHaHlDMyt6dnZ5SGI2Z2NydHQ0TGpYbGFNSmlzcmk2MExaNDkvL003dDlTTWFncUtJVnNyMVMyT3lxU2ZQWVc4TWc2a3d5V0U4VVNaam1FeVVvcXBwT0VNeHBkMk1hQmhJcEFUWnhPb2RwTm9sRWs4MUdXQ0tPdFF5MUlVemNSN3JIYUtPTXM4cHBoT3Fja1JaanFqY2xPQXIxQmRvbGVORFJUbVpzUHUxTjluN3gyOFRkaWRFcWxoWDc3aVhBZm9qaHkrRnlBdlp5TkdmbEd6MXA4VGJPWEo1U0g1cnl2ck5DUys5ZUp1clZ6YnFzcTZsMWhjMFpqeXQ5RzlmMjV6K1BlZkQ0SDdQSVNLdWtTUkJSR1ljdS9Xb3krMmRuWTFHR3IyMXZEQkh1NWxxTTAxWTZIUXd4dWpPYUpTMlRQeFViR3hjVndqVktNamVlQ2lmZXU1akJ5SFdPejBWQWF6VUZabjQ2U2ZPSDJzM0c5OTErODZHamF6Rk84RW9yTjhhTWR3cWNjWXlLWlE0RnBwcExXM2daMHRNWW9VMFNWbGFPc0xDL0RMTnhLSlNVdVlsdnN4cHRCWVFFeVBHMHVvZEpVbm1acmcwUkVtYnlkNEdrOUlRTlphd1VRTU5HVWhCVUlzeFN4Z3ZHUEZVNHo1Ylg3cksrTW9XeGdxSkZTSmo2bzJWbVZaZ0oyMVFpV2Q3VkxBK0tHZ3R4QncrM01KNDhCTkhLd3JrbzRySjVnZ05ZQ05iTjlCRlhGN3BMMTdmbVA1c1ZmbTlid09IQi9UdzRvTHVqc1lNcHRPZ3FoN3dyMTYvMFgvdDZyVmJldVFvb3l4blZGUU1zaW1EZkVxZUZhYWJ4T2ZiU2RycDU5UEo3QXphU3IyWGQyQWw2d0FnOTJ5LzhtK0JSRVNpUng0NjljeVh2dnpOdzNtZXE4SEkvblQyZUZKUzVMVjJYelowREpVNmxMR0NpWVU0RVpwTllXbSt6Y0xDY3QyY0E2b3FRNnFTVUhsS044VGFwSDZTRmlGRXFBc29TdUVDd3hFNGJ5bkxIR09WTkRWWTR5QTBJUWlvVUUxeSt0Kzh5ZVROVFlJUklnelQzR05zVGE4U25ESWFPaHFSME8wbUJJbm9ORDByaXcwYXFhWHlTbVFqUmlPUGpoeXRQR1l2T0FBMVJyUUtmTzMyVHZZejA3emFuRldyYXFvZXhLV3hEZDFPb3BmWE4xam90UGZ6QnovTFNjckpkSHE3UHhybW95eHZHS0NaSnJTYktlcUNkQnFOYzRlN2M2ZjcrWFJUUkdMQWVCL00yemN1aDNkYUhuSUFrRzhGaUJHUlNGWHR3eGRPTFhSYXJROWR1bnlsWVVRSXMzRW5FY0dYeWpqM05DTkxNWEdVV2srLzJsaUlHeEV0TE0ybUpZNEVyWElLRnlna3g1b3BrUkVNS2Q1N0tpZFk0N0F5Qm1KRXdQbkFjSy9QZURyRm1nVHZTdEoyaTNaekRyemdOVUs4RUptRTNaZmZadnVWTFVvZmFIZDZwSEhLTU52REttUlRwVC95VEljVGppNHBWUktUdGlQbWxpeHgyeEt3alBQQXptN0pyWnNEM3J3eVlLZnZvV1hRcFVEcDlkV05RZm5mRGtibFRlcHA0YnM4VmtZSWpVYWtqVWJNdi8vamY1ei80T2QvUWJrbkorMkJZbU00dVBqbzBhTzdDNTMyRVlOZ2pTVnJObVU4bW1wWmxtMXJ6TnFzaWhVcFdCKzhiT3hzSDNpUWR6aEE5bnNmMGZ1ZmVlTGsxdWJPK1d5YUc1QnZ1ZGVDZzd3S1JERmt1YWQwTllXSXNZYW9VSUtyeTJCYm13UFVCd3dKUnFaRWpackV2SmtlQm9uUlVLRFdFa1JSbjZNaE1Ka015UE1DMU9CY1JtcUVidHFwR2R5RDFrZFFFb3FSNCtZM2JqUGFHS0lOeTF5elpEaWRzam1zYWxhVHl0RnVHazRlN3FHbE1wd01xYUtFU1NsRXpqQXBTdGJYQjl6ZUdMUFo5NHluZFhoamNnTVRPeGpaNGg5dTdXWnZjbytGcEFLOGlJVGx4YVpPTW9mM2dYLy83L3djN3ovL0VDOWN1YUtsOHg3VXFlS3ZiZS9lVnBHTk9MSkhhdmVpV0d1SW80aThxQnBIT3ZPUHY3bTkvbHVWOXprMUFZdU1pdXdBSU8vMDhLcm1yU0krdkxKdzlrdGZlSDQrK0gyMXNudDZ5ZU5weFdqaW1GdTJFQnVjVThxcHd6bVBqU3g1SGxOV0NaVlhSdU9TN2x5TGRsTXhWWW14aHFMYUpyYTFmRUNhZG9odFRIQUZXVDZpS1BJNkZaS1lLTFowdW5XdTR2SVIrQUkxOHhndDZMOTJqYTBiZTRBeTM3YjR3akVZT25xbVhwVnR0Uk9TdEM0YkYwNHhKdUxYdm5FTlZlWEVVb2RRZWE3ZW5EQXBMRFpPVUMwd3RRNE9yazlaV2hsU3k1anNTelFIUUVOUU5yYW5kMFBOL2RpcXFKeGFZelFFOVlDN3RMNitOY3p5aXl1ZDd1TWlHcFZsaVE4ZU1TSUthU2RLbmpuVW0xKzVzYmV6Tnp1SDc4aUMwUUZBdmkxQkI2S0YrVjVyTkJ4ZjJOM3Rkd1hxZlk0NnZxckhOVXJIYUZ3Z3NTVnFSRWlsVFBLSzdmVStaVkdTTmhKNkMyMFdWenYwRjF0MDVwVHVuS1hkRmhvcFdEUEZSdEJPQlpFS0w2QUtSVm1SVjVCRVlQRTA0ZzVDUkZsTXNjSGhxZ2toV0lvM2Q4bGZ2Y214cFFhRlY1ck5tT25Vc1pBb1VXSlJsSGE3bnRmYW5hU1V3Ykk3blhKOWU4d2dMNW5tR2RiQmFCd1RSVEZaWGxGNXhSZ0RLT0w4eWp6Ujk1ZEorNDJkWXRLZnZTLzdvcCswbTIwbTJUMG05cTllZktzR2l1cE0rQURmSDAvR3I5Kys5ZFhWUng3OVpCeW5TeUlUUUVuVG1NazBwM0p1NVhCbjd1U052WjIzZ1VoVnpVeGJYcDg1Zm9hdjM3aDhBSkEvYkV2VGxLSW92ajMvaUw3dlV4OWVVK1dSb3Foc1VNSE9wUHpxUXdCR0RVVVdFQXRweXpLWk9wd3FlNE14MldTS0dHRjlZNXYwY2twdm9jdnE0VGxXam5SWldHN1NhRm9hRFNHSmhid3BxR1pFOWJra3k0UXNWNXBSb0pYQWFIZVhMSnBndENKT2xLcDBoTGQyS0YrdmVhZ0NobEZSY2FrL1pqRzFyTFpTaWhEUmFEWFptd3E1ZzhIVU14enRNWnlNYVJuTHRUeHdzMTl3cEdOcHRpS0tJdUNkbnkxRnlTeWFWSWxjZUc2bDJmcUJxZnJyV1pudnIvSld4aGpwTmp0TXNzbTNKTk1Yamh6V0s1dGJvZkkrb09vVnl1dGIyM2ZNZSt6RVdydVV4aEh0UmxwUEZxZ2lMc3d2TmRyblJPU0xxcG9wOVNoQVlpUGt3SU84Zzl5R01ZUVFoRnJ0TlVLSW5uM3lzVWZlZXVQeTJlbDBpcGd3RTUrc2d3bGpRWUpRVlhVOU4yMWI0bWxFdTl1ZzJXNVE1QVUrZU5RTDQ0bGpZM3VIcTVkMldWeEtXVDIyd05yeFJlYVdXblE2RWEybW9UOHdOQnFRUkVKUmVxcXE3c3czRXhCWG9sclFTQVZybEpCNXhxOFBTQXRGRW91SXNGVXFyOXphWXI2VmNtNXBuamhKYUhySXk0cHBYcElWQmJ1REtUdkRDU1pVOUV6RTl0UmpqTERhS1BBaEVMekZoM293cXZTS1J6V0JXRno0cnJtaytXdFpWUXhRaldjaHFKdm1rMytpMHJUWTduRFQ3bEk1dDEvSkNwZldOMjcxUjhOclNXU09KMGxDV1RteHRwNWtkcFZ2UmxGeXVwbWtyV21SajJmbGRkTk9HM1hINlFBZzc0REVZelo3ZFYrQ2JsZVdGOUx4WVB6dzlXdTNGcHlyaUdNQkNTaGdDS2d4b1BYT2VGNEJrY0UySXJxTERjNDlmSVRCWHIwb3RialFJVWxTcHBPUzRUQm5iMitNR3hlTTNoNXo2ODFOdXF0ZEZ0WTZ6TTJsOUhvUnNSWFUxODA5VklsUnpJd3dybFpRcnRWeGQzeEZjV2RNb3hGaEkwTmVlQ1o1d1kzTkVhWHpIRnZvRWdiMUxWMjV3R2hhTXBwa2xNN1RUZzFyVFNneTVlWklpY1hSYTBCUkdvS0NOUkJGZ2drcXFtaFpWa2M3VWZycHlOaFhuSGQzZHppRzAvRS8wZlcyeGpJcGlydVZMSUZ3WjNkMzU5TDYraXVQSHp2eGZtdE1MTlJTQ2MxR3dtUmNTS1J5OGxCM2J1bHlrZS9zNXlGNVZVcmgzVHNHSU8vcWxkczBUWEhPeVN3eFQ0SG1NMDg5dHR4Skd6L3c4aXR2bkMrS0RHdjJDWmdGa2JyY1lsQVdEblZZUERGUFpHdlpnVGcxek0wM09IeDhqa2Zmczh5akQ1L2kyTEU1VnRjaVZvKzBPWE5tbWU5OTdsRjZ2c3VWMTk1bTY5b2VXOWVIN08xTUdJOHJzaUpRT3VydWR4R1lUanpqc1dNODhSUjVvQ3pyN3J4R2xteG5Tbjl2eW1CY1VMbEFIQnUyQndWNzB3SWIxVE5kV2U0b25HTTZ6UWxCaWFNSU1TQjR5bEtZaEVEdWxOZ29CSVAzTlFyM2I0dWdpS3FZU09pbG5kYnp3M3g2bTNxUDNQRzdDRzVlbjVWb3BiNXhMQ0tSUXJJeU45ODZzYnp5aWNrMGErUmxBU3A0cCtSRmhURW1CQ05mdXozY3V3VlVnbFJCTmZTemlUNSs3QlRyZzcwREQvS0hhYlB4RXJrL1FWK2M3eTBNaCtNVGc4RVFHeGtsT0JHUjJYOVVnOFJhSVRoSFdYamFhVVM3VlNzdFJWSnJpbmZiRWMwR2VGZUFVVnFkaEhPOUpaYnRVU1kzYm5MbThCeWJPeU4yK2huOWkxTzIzeHdRZDJJYWl4RnpxMjJXRDgrVFJKYnBzR0E4bUZLVkZVa2MwV3pFcEkyWXVKTmd4Z1d0eUpLbUVYT1M0Z0pjMmU1emZXL0E0VjZIMUVRNDc4bENMZXlaaXNIN1VKTktHMHZQQ2lOZnNwNEZlcVlrSXNFRWkwUHJSU3dFQVEzT0grMjU2S1BXUnQvdzN1MnZudnhlcGlMaVZkVUI3c3JtNXJVMFRmWTY3WFl2cXp6RGJNelVlYWFWWjdIUlhHNUxzalk3aHpQNUNCVWZBdGErTSs3dWR6VkFqREdvNnQwRTNSaUpsaGZtam1mRHlUSFJRS3NSeXlTcjZ2akwxTVRRSWtvc1FBZzFiNVZDcTJtd0Jwb3h4TEdRUmtyUVBsWHdCR000MVYzQWJJOFpOVHhWa2RGTEk2S2xIczBrWW5jNFpUU3B5RWVlVVIvNjEwWnM5UGFZVyt0Z1UwdFJsRXlHWTdLc0JNemQzK05ra25DODJXQXd5aWxLUjJLRVRoS3hQUzZ3Tm1kdHJnTVluQ2lSTVV6TGtyd3N5VW9vbmRER1VrbGc0ajJGOTdTb1dCU0xCVlRxcFNtdHQrdmZIdVRUYi9qZ2ZWMm8rcWZqNHpNZitBQy8vczF2YWxhVyt3MURQODd6L3Jnb0xyWWJqUk90SkVPNkxRayswSW9TVW1OYnRqS1BkUnVOejQzeWZLcjFJcnlrY1N5bGUyZUVXZS82WWNWWkRtSkVKRnBhV2pBcnl3c1hSc054YjNtdW9aOTYvMm5tTzgyYVJOb0sxaXB4QkhGc2F0VllJL2hadk5Gb0dCb3RRN01wSkNra1RVZ1Q0V2pTWkM3M3FGcVFoT2xvUkNUUWppMkw3U2JMdlRZTDh5a0xDekRmQzNSaklleFZiTDY4emMxdmJySitwYy9lYmtGVUJYcEc2UnFocWNybDNZeU5jVm1QdmllV09JMVpuZThTUnpGYmc1S3QwUVFmQW8wMHdVWVdzVktQdXpoRFdmUFdzV2diZEt3bG9Fenc3SVdTUXNIVmsrOEU5R0pmeTc5K3kwMit5bXpPNnZkeUlMRzE5RnF0L1dLZk15THV6dTV1LzdVYk43NmFwa2tSUlJHeGpWaWJuMk91MDFJUVdsSHluclhPM0d3UXJTNzNUb3BjWHI1eGhaOTQvOGNPQVBLSGFYbWU3NGZjUmxWdHA5V00xZm1qT3p0N0VvTG40OC9OOGFQZjh6QzlkbG9ueTFhSklvTzFwZzdTVWNKczFkVXBWRm9ESnE4OGI3MDFaUHZtaFBaZ1JMRzNRNnZkUU1SU1pwTzdEWVZtR3RGcnBmUmFEYnF0QnQxMlRMY0R2VzZnMDZsM1RYVGd5WGNkazc0akxUeExSamlhSkdTRjh0TFdoRWtaVUNPWVpreHZ2czNocFE2Vmc4dnJVKzRNTWp3dzhSVlpDQlRlVUhpd1lrakVJQUY2SkxRd0dBSmpLa3AxeEFJVzdtVGkvc3NOblg1SjBYMmVYNmV6NWQvZjlmMHNTK0lvVXFtbnhieEM1VVB3bS8zQjYrTXMzNHR0Sk1aWWpMR2tTWUlQZ1ZhY0hGcHNkWThCVnVyeGR5c2ljbUpwUmQ0SjlkNkRSbUZkd1RXcUtrdUxjOTFpT2puVTM5MFZWV1dTRi95eFQ1eW1yQUwvNExkZXBTZ2RjUndSR1l1TnpFeUdRR1lMVERVaGN4U2xyRVFkL3NGdlBzK2dQK0hzWjgvUWJWb2lFMUdWQmw4V2lKbUZTaUVRRzBNblNVaU1wWWhpQ2x0Um1KSTRjalVnYzBPVXgyU1Y1L1plWUpCTkVXTVpsekN1SU4yYWNuNDVKZE9BV0VPcmxiRFlUYmk4T2VIdHJZd2lLQTBiR0k4OFZTRVVYckNpQkdiOUNJUTJxUW9GdWVpdEFkVkZsRjZBbjkzUy9EZW85ejZtTTRBRVFVTGJ4SXhEK2J1K2t6ZTJ0akN6OGZmOVBHUmpPTmpJdmJ2ZGJiY09sNVhYYVRXVnZNekZxOWRHMUZoZWFyVWZzc1o4TGFqR292WFlpUStCdmVrZnZpejB1N3FLWll5cHgwdG0wbWxIMWxaT0pFWi8vTWIxRzR2T1cwNGNhc3BqNTdwY09IdWNSbXk0ZEgyUHlpdHBITk9lYjdONGFwNjBGUkZIZ28yRTVia3VEeldXbVI5bnJNUUZOOWRMSGpxK3dPSmNrKzdTQlhaM0hGZmVmQVdvV1F2VjF3SDlQbUFpWTRpTXdWcExaQTJScFFhSmhWZ2lORmltcGJCWndNVFZvZDJ3OEpSRlNUc0syRGhpbkdVWWF0clNmdUVaNUJWRm9ZVEs0R2ZjVm9qT1dwOHlpNWNFaXdIRGF5UDgvM3VpN3RjR1ZNLzdtaGg3eWwxRktId2tob2F4bXVzL0tabDI4ZGF0T2t1L1c4eXFaOXRLNSt3VHAwNmRuMnUxSDU5a21kVGE3VXJ3aWdhTU1XYjc4dDdXNzVUTzFSU3FJbTVTNUNFS3d2WmtkQUNRUDJTQVJDR0VGRWduay9HeDljMnR6K0pDMTFVaTU0NHQ4ZENwSnUxMml3dG5qM0RpK0NMajBZalJxTUJiUysvRUhHblRrTVRDOFU2UHh6dkx5TzZBSXN0WTdnanp2U2JOVnBkSExseWdOWGVlcjN6bEcyemV1bEVUSTdoQTVRSmVvWFIxbjBVQUg1VFNLN2xUeWxEbkRSaEZMSmpJRUJraFJoajcybnRaQWxubENKV2pZV3NHeE5MNWVyaFJoZExEZEVZd25WaGIvK3dnOVE2NmdJcW9paEliNndUNTRrVGRyenQwblhyM1k4S3NnejdyYmVoaTFHVE9wdlQ5NzY1cC9rTWYvQ0NWY3d5bVU4TnNyaTByUy91ZUV5ZlBMTFM3NzgrTDBuZ2ZzRGJHTzQrcnZMRld3dnBrK1BsQlBoMHlHNmNIUWp0TnRaOU5EMEtzZDBLWUJaamdmY2dLaW54YWNYUyt3WkhGSTFSWkM5ZkpNRWI0cm8rOGgvYy9lNGF2ZnUxdFhyOHhvTG5ZWTM2dHc2M3JPN2hzaWxHTFYwK3IxYUtZZWk2Y21XZHA5UUpIVDUzZ0M4Ky94VS8vbzYrUWhuSkc2d21xQWFkS1hvYTZJVGxqYy9jcWpNcDZ5REMyRm9KQk5XQmpVQ3MwbzhDeUViWUtVQldDQ2x0VHhmc3BpNzFvVm9wV2xwcENMSmE5MGpQMm5xRFFNclplM1ozZDlaRllNV0t5S3VnL0dnWDMwdzdkblFIanJ1Y0FRaUpXV3hKcExYLzRUeTh3S2JBeVA4L1Z6YzJBaUtNT3M2b3JHeHV2SEYxWXVwNG15Um52QWxrK0pSQWtxQ2VSNk5pSmhhVUwxL2Uycjg2VzFReUk3RTBuL3p1cXlnY0ErWDB6VlpYN091bkdXTUVhOFZQbmFIZFRqcTRzMGtqV2lLUlA1Zm9NOTRiTUw4enpQWjk0aGs4RUlkZUlwTlhrNTkvOElxKzhlb1gzZnM5NUpJQXZQVkZqaWFPbm5tVjU2U1JpY3BxOUZSNCtld2czM0NFMUVWWTlWUWhrcGFlb0ZLTjFEYlhWakVoc0hmcTRvSlNWWjVKVk9PY0lJVkJXanNvcDh5VXdoTTNNNEZCRWxWRWVRUWcwMDlyanFFTERDRjJ4RE5VVFJRbEwzVG15ZklKemxUcVY3Y3k3MTBGZUdRVDNpNVBnTG5OdjM3eWdya1JwTkFQSG5FbTRWdjF2SzBKZFdkK29SM2k4RHpPQXVXOWNmdnZLMDZmUHZEMlh0czVZVXl2b2lqRzQ0TlVHMDFwdWRSOHhJcjhaYXE5alZWVUcrZlFQL1l3Y2VKQjdvKzRpSWhnckdHTTRkM3lWdzRmWFdEdCtsampLR1U4dmtlVjlkamNkY1p6V0JVQVZja2w1OHVnQ2JtOEg1eU1NbHFpMXlvbEhQc3BjYnduaUdHTThqNy8vSEorNWNZdFh2dmc1MUZ1S3ZBYUlid1RDVEY1QVE4QllvYXhxSGNKb3hqMWtZMHN1U3VVZ2tnaG5EWkd0T0dVOHBjSmViakFvamtCV0dyeXpzNjU0WFdXTGpYQzgxV1c1MjZQWGJKSlZIZElFcVpEcVNuLzR1V3ZiRy84NHFPN09RSkh0Z3lPMlViREdhRmNTQ2xjUi9uY0kzdno5TDMrWkQ1dy9UK1VxM1p0TTdnSmtaelFhRHFmVHE5Mms2WDF3QmxSaWEwaVRtT0ExV21wMnpyVFN0RGZPNjdtc1dZWDFEMTBiK2wxYjV2M3Naeis3bjRQc2cwU1R5QzVsV2JXMHRqREhkN3p2dlJ3OWRZYnV3anlkaFpNc0gvb29pMHRuaUtPQ0toOVQ1bE9jeS9GdXlud241b21IVmpDMnk5ektZNXgrNm51Wld6cUM2YzVCTStYUzlkdmN1SHFEeUVZMVcvcmRZS1J1b3FpdnFYNkMxaElEKzNzbkJpR3lwbGFhaW1xbHFVWVMwNGhqbWtuS1hDdmwxSHhFS3pZNG9NRGo4UGdndFZDUE4vaGdLSVBTYWJUb05PcE54bVprYURmYWVtaHVlZlh4aytmZTIyeTJBbmVGYldvRzBqUk93c25EeDNqbWtTY29nbU1ZQ202NC8zMEpjNi9aWkpUbGlNaitHcTczSWVRYmcvN2JSVmtNbmZkU1ZoVkJBMXBYQ2t5TW5EL2NuVC9DdmFXMXUrUDFCd0Q1UTdCT3B5TlJGTzJEQTJORXpody9lcHBnRzk0SE5UYWgxVzdpcXlucUo4UkppKzdjRXl3dVBjdmMzR0hpV1M5RWZVVWtTcXUxek9MUnB6ajF4TWZwTGgvQ3RKc01KbjMrM3MvOUEvN2FmL2pUUFAvMXE3V3dUdUZyL1EyQm9IcFhZdUJiYXM2bTNqdVIyWjkzUVJMYkdpZ3pXYlkwaWpqVWpUbTdFR09Od1dISVVTcmNESUt6VGRpZ3JBLzY1R1d0cmVORHVSK3lSUTNDOFVZVU5XY0FVVUdDR0tQemMvT3NyUjNTc3FvWXV2eWY2YjB0cW9wSGpoL1h5QmlkTVo0NHdGM2IzcnBjVk5WZXZYaFl2K3c0aWpER1lJenRuVmhZUHM1OVl5ZnZCSkFjaEZqMUp5QkdqRHo2OElXa0dKWnljMzJkaTI5ZllUeTR3TXJoTll6SjBXb0xaWjVHOXlIbVZoNWxNcmpGZE54SFE0bHB6bkc0ZTRTNTFlUFlKQUUvNGMwWFgrRy8rOXUvd2l1dmJiTzhjSXgyc3dPaldtNGdTQzFVWS9leE1adldyVWZxNndUK3Jtc3pZSUlRRzFNVE13Um1leHMxZUl3WGpzNEp1N2x5WjZoVWVDbzhVVDA1VnErNllzaUtncDNKbUNOelRZSXF6Z2Z4ZGJOelpiazd0N3d6SEx6TmJBQkxSREJpVkZWNS92VVgvNW5mejkxeWcwNjZTaXROdzNBNjlmdExWRy9jdW5YbkEyZk9YMC9FbkE0b0lhZ0VsTW83akpPNWprM09VUlAyN1lQa0Q5MkR2R3NCOGkwQ2tsSWZKREYyY1B6d2l0L2QyV0p2ZDVmUmVNTGh0RXVjZENpSGx5RnFFclVXc1dtTGxvbEkyeXY0Y2tqY1d5WmVPSW9ZbUdZRGZ2bm4vamIvNDg5K21SQ1dPWDMwSEJHQytvellsc1RXNG9LaSsrdmxzMEZJa2JwcEo2cDRGTFBmbzFEQnlENWlCRFVRWWU2U1BlOTdtS005WlhOY29VR284RmlFWkI4bUlpUWFzVHNhczlDME5KTVlId0xPZTlJb1dUNjV1UFNlTjI5ZC8vb3NPVGFxS3V2YkcrSmM4YzlVUVpydk5QQkIrYUdQbitIbmYvMG1XVmtTYWtwU0Q0UnhsZzIyUnNOTHk2M3VoNHFxaW56bFJJTlNCWStXbWlRbU90TnR0dVpHMlhUOGJSNUVEd0R5QjJ3WEwxN1VzaXlaY1RHcEtscFZWZFpxSmFvS08vMGhXVmFoeEVUTkxxN2NSbDJHVFZLSUU0d0dNSXFORElKQmZjNlZOOS9rYi96MDMrY1hmdTBiUEhUeVNZNGVPa3lvSEs2c2NFVkdISUcxQmxlUC9kMnREdFJLaHZ2My9kMkt3ZDFXWHRCNmdCQUZJelc3WWkzdVhLdFNnV0crcFN3a01YdUZVbW1vV1JlQmhzUllJNmdhTWxleE1aNXljbkc1em9COVJkQm1PelgyNFhhcjNaMU1KN1d3VGEyczVkTTBCV0I1cm1hcE44YlVKM2EvVEMyMVVLY1J3MkJhMFIvbkxNMDErZTkvK1EwcUY2VHkvbTUrSnlJaHFCYlh0amR2emgxdFZFVlZSYTZzUzk0dUJQS3lJbTRrWjQvM2xrNjhsazAzdWJlbkxuK1lJSG5YQXVUNTU1L0hHTE5QVjZPcXFydUQwWEF4YlFRQkdXY0ZlUm1vVndnRnNTM0VqZXF2VFlSTm01aEdFL0JVMlloZi93Yy96My82WC8xZFhueHJsMCs4L3hNY1hUbE01V1l5NWFKTXhsT0tYbjN6R3dQQjMzVUtzNDlmN3g2RGZRSzEvUk5oN3Y3di9iNzNyTm9tU21ScXFiUk9BdzUxRzNoVmRndkY0ckVFdkFaaVk3SEJZSUt3UGNsWWFCVXN0Q3pCdTVuY2RISjBzZDFlbkV3bjIwQVVWSTBSTVh2RG9RYzR2TlJrdTU5anJjRklMYysyTnQ5aVhEbjJCbE9zdFl5eUNrQ0drNUs5VVM2cVNOM1BtSTJ4ejdRZWIrM3V2SGxzYm1GYnkzQnltazAxdUNEZUN3YkxYSktjNlVTTlowVjRXWldVZTlMV2VsK2I1UUFnZjlEUjFnd2dZYTgvSEp3OGV6cUw0NlFMVUhuQlJFbDl1OXMySWhWaWt6b2tDd3BKeXNiNlRmNzcvK0duK1psZitCeGlWL25RZTkvRDB2d1N6bGZJM1VVclE1WVY5QTdITkJOTFZicTc0WkdnMkZxKzltNTNtMW40WitwTzk3ZmtKTnk5d2JXZTU1cXhPYmJUaVBtV0l5c1NobFZKQ0JBSU9BSWgxQU5PRVpiTWxleE1KblFhRFNRRVhKVmo0dmpvb2Q3Y2lSdGJtMWRtRmFRb3FQckpkS29BcjF3WllMNXRkUERhNXVSdWdZTVo2WVFJVWptL3YxOXpWMEpDaEFaSUUyaXQ5L3VEdCsrczMwalVuaEFVOWRDTVUxQmxuRTNqZGh3ZFNhT2tsMWZsL1ZMV3NoK20vVUdENWQyK2Nucy80UmttTXRuY2ZHK1FKUEVLcXFpRy9VQWZzUzJ3RTlTWGtLU0VKT0xMdi9OVi92ci82Ny9sR3k5ZTRkRnpUM0h1eEttYXR0TUhjSTZxTEREV0VMekhWeG1OaHFIdTRGVTFPSUppUkFnMXAvek1lOXc3RVhmanF0bHBDL2ZRZkxjVXJGSlRua1lvU1NRc05oSUdaY3hPcnZpN1pWOVBiR3BGcWxndC9lbVU1VzZQSkxKVXJxS2RObGZuMjkxSGpaR3ZocURGdllvV2Z2OFhDZmNpd3Z2N1I3UEVhRCt2dXhzUzJkblppcGdwZEJsREEwZ3E3MlZTRkZmYnJmWUhJaE5ab3dhRGdhQXFHcVFWeFk4dU5kdUhiMVZsUG52Sk12cysrekxYKzBEaER3SW9CeDdrSGtBQ01GMDd0REpNazVTc3FQQUJxakluVGd5dXluQStJbFE1dy81RmZ2bUxiL09mL09jL1RYK3Y0a05QZllUVjVWVlFSYjFIZ2xKWGFTcXFvc0I1ajdDQUJvdklmb0pkWTlQSXZlcFZMUmM5QzdIMFcwL2l2c2F6NkxkbUszZXZheU5VcXNTeDRVaTd4YkNxY0Y0UUFwVUdJaXhXaEVRdEUxZHlaOWlubTY2Z2VLMktJbXBFOXJHVitjWGxqZDBkTi91eHNZSy9HOVh4TFFDUmIydXkzdi8xdmpLd01VWWFhNnZkK2JXMXpoTnBaTTk0cjQyaThoTTNVbGM0NzhyZ28yYWNFa1dHRUR5Vjg4UTJPbnBvY2ZtMGFiV0hlLzFoTk02SCsxSVV4UXdreFQ4RktBY0ErZjJvWkltSXFtb1FFZDNlN1EvSCtmVE93bnhITis3Y2tzM2RJV1ZSMEd3MkNNNGhTUS92Y3Y3SHYvMEwvUFcvOFFVV3VrZjQrUHVlb3R2dDRiVWVGNW1SbjZBYUNMN3VqcXNDWWpFbXFwTnp1VXNZY2ErYXBuWHA5eDVxOXdFZzZLd3NiSmdOTDhxOU1FdDBSa3RvaEY0elpxZHdkSk9ZaFNSbU13c1k2dEp2Z3dnajljUndHaXlENlpSQmxySFlzVko1VDV3a1ozdU41dEVON2lya0p0enJaSDg3UUxpdkRLc3pNTVJTRTdJWWEwaU9ISjQvdnJMU2VWKzNrenpkNmFUdmpVUjZycXh3cXFWZlpMcDdwYkNoVWpUVWowSEVJQ1RRdTNEc3hKOTh1Qk4veDJReTNkdmJtN3o0NWRkZi9xM1NsM3YzVmJidWI4ejh2dkw1dnV0RExLMVBhQkNSc0xHMWs3OTE2ZnFWUmhwcjBFcldOKzdncW5xbkd4VkVJdkxKa0ZldVZsUSs1YjN2ZVpadXE0UDN2czRYUWsxQjZrTXRXNkFvU2F1RDlWQTZ4Y2J4ZlFDNUx3bm5YbUplTjlEdWVZZHYvM3AvV3p6Y1BabXpmb3JDWE1Pd00yczBIbW8xR1pZVmhWZEtBbFh3cE1aaWpkQWdwdkE1NjZNaGM4MEdZcHpHM2g2ZWJ6YWZqcXpkaXlNNUhCdXhJa1JwWXBJa2tqYUlqYU5Ja3NqTVI1R1pSNUhKTkFjanB0MUlralNOMnRaSUZFVldwWkUwRzgzNGtlRDltZUJjT2g2aFpWRWdhbVdoZmFUUmpKUEdGbGNwZlZXL2xsQ1FXb3ZCWUlYRWxhT251ODN1MDBkV2p0RjhxTFA5dmllZmVMZy9tWHo5U3k5OTgrWFhMcjkxOC83Y2NmK3gxdUs5UHdESXYrQnVPcVBSNkM1VlRWR1VJYy9MYmNVNjUwTmE1RVd0ejFIRTlaeFU4Q1N0SG11SDFnQ2xjcTdtd05KQVVLMURLeCtveW9JUUhKR3hPT2RKMG9pRjFTVk1NOEhHNXQ2UTBYMVZLeU4xLytPK0hQMWU4bHZIVnZkaW1YckQ2NzdvWnovNG4wVTRzeVdzMVdiSzlmRUVoMUNveDRaNmQ5NklrSXBsbEdYMHM0S2xxRUZ3VmFOancvZGRPTlo1d2xkNnBQSlZGTWRxSTJ0c1dXbWN4SWxwTlNPTVNFTkVHdU54cVdsc2FMY1RtMFJXckxVbXNoR2tLWTEySktHc0NNNWprMGlEQnJyTkpUazhkNWI1NWhyQks5SHBMcGZlZm9QcGVFd01rQ1FrSm1KY2VQd2dZZlhrWXh4ZU9rV24xVnkyUnY2TXE2b2ZQTDE2OGtzLy9SdS8rSis4K3ZiRmEvZUZ4V0UyY0tvSEh1UmZzRlZWZGJjUEFocktxZ3J0VG5NYytTWC8rdXRLZjVReEdVOXB0UzFKbWdDQnlDYk1kOXRNcGxNMjF1OFFyd1hRUUt2VndUbEhrVThKemhGWllYNnh6YW56eC9qWXg1L2h4Sm5qN0YzK0puRWMxYU1rdGQrNkc1UEpyREltMzFhcE1uSVBNSFd4U3dqN2ZrWHV4VHdxMEVpRWRzTlE1Z1l4eW5LenlVNWVNSEdla2tDaUFhc1dZeUFsUXIxanN6K2syMmhKWkNOYVNYTE9GanlVdVVxc3JhdGtWUlhJTTRodG1QVTg2b3BDVVZZa2labnRzQVNNTVRJb0RMMzVRL2l3QjFWT00wMlFPSkxWK2JNY1c3aEFhdi8vN1AxM3NHMzVkZDhIZnRidnQ5TUpONy9VL2JwZlozUkVUZ1FKa0FDWVFKRVdMZEdpWkpJaml4SWxhMlRKWmJrOGR0a3pHbG5qcVpGZDF0aFROVlV6dHNwUjhsaTJLVnVXaHFJbzBxUklpaVFJRUNSQWhBWTZkNy91RjI4OGFhZGZXUFBIYjUvN2JvTWdKVkVBSkE3ZTdqclY3M1cvY084NWUrM2ZXdXVieGpqdlFKWGRyYWU0LzU3NytOSnpuK2ZxMVpkcHVnNG5BZThjVy9kZVFVekdxemRmWldPMHdZWHRDM21WRnhjbnhmamJ2L21wZDMzOEN5ODlmM3NvRHJkZUF3OExsN3NGOGxWdXNSaGFMSTFSUSt4OTZIMDgzTnphYXZPaUdOL1kzK2ZrK0ppZDdaSTh6NGd4RXIzajR1NDJQa1Q2cnNXM0szUVFNSzJXUit4dWpYam1iZmZ6OUZOWGVQenBoN2x3NVFxNWdqR1JldU04dHBnUTQ0SzFZL3pnUVhWS0hWbDdjTjBCK3VYT0VLK0t5cDBXeThpZFBhc0FtVFVVV2NSYjBKZ0lqdWRISStwbGpkZElJQ2J6Q0JKK010SWMxM3ZtVFVOVmxHU1NtZEFiN1Yya1VLSFhTTmREMUdTZTUwTXFXR3N5cVNvTEFqNEdqRnBXYlUreHU4ZDBlNHByRmxoVFVWU1dDOU1IZWZ5ZTk1RG41WkR4WHA2MmludmIyOXh6N2dLL1hHUjg0WE9mWitrYXBydDdNQTI4Y1BOWEtISWxrNHlieDVmbDBRdHYwMHJLelF0YjU3L3RMUTg4L0N2UHYvYnlHNXh4bmY5YXRGZmY4QVV5SG85cG11Wk5tNnlUK2VJa24yd2NaZGJ1cnBaemxpZUhlSCtlNkNPRUZxK1JqVkhGdUtyd3diR3FXeVpqeThYdGpQdmZjUy9mOVA2MzhmU2pqekNham9rS1VwOUFqUFJSc2NVR3hYZ2JqZGZUdkNsblc2WmtMUlFpZDRaMldkTk4xaWRHT25saW12blBJQUo2Q2lnbVhrY2tNem5HR1BaR0k0NjZ3S0p2Y1FSS01vd21NMkFyUWxUbGNMRmdjenhtTEJtNTVCSWNkRUZQTmZkR0lJVEJndFVJYWdLU2pGMXdUbEdOT0dNNHZ6ZkdNZ01UazlOS01lYmVjMitoTEFyS29rREVFbVBBTzQrcWNqdzc0STM5TDVKdnp0aStXSEw3b0dmallnSDVJVlVlS0xPTUVCeTNaeS9TMWEwOGZ1NmRiSTgzdnVVRFQ3M3J2YysvOXZMdE5XWnpCa3pVdXdYeVZieSt2RGlBNkdOWVpsbCtVT1RsbzdQRlFwdjVzZlJ0UzFrV05Lc0ZiWmF6V2NMV3lMSlJHZDc3ekE3dmYrYzVIbm5vZnM1ZmZwUThMd2pPMGMxbXhPaTVmVHpqNDU5K2dWLzc3TXQ4N0NOdlQ1NjdPZ3pYNjdsY2t0K1dHZERCR1BYT0tuamRTNjFuRHJsRGNGeVBxbWJna2hrUk5rY1o4OXFUbStUN05jb3o3cG1NcUwybmk0NU1QVlZjYzdTVURHSFZOTXlhaGxHK3lVWmVjQ3RhNmo2a3pFU0Vvb0FRVW11WDUybUZMWU91dnE0OVZaVlRiSXdwUjU3TUJNcEpqdXQ3eW15S1lVUVVnODBzVlZrU1k2UnBPbDY5OWp6WGp6NUg2MC9JY3VYK2g4WnNuTE5VbTBwVktrWXlRb2owbmFkdE9sci9LdWZLZTdreWZuajcvT2J1dXk3c252c0h0NDhPbW1HakpXL2FDTjR0a0svT0ZVSTRNNE9rQXJsMWNMQjg0b0VyKzN0N3U5eSsrVHJYYnQ3ZzBlVWpqS2RqRk1OcXVXSnpsUEd2L2N2ZnpsdmY4Z2h2ZmZ3eXBXMndXWW12VzV3L3B1dDdYcjk1ekU5Ly9QUDg0aWRlNE5sWDNzQmtodmMrZllITnpDVWErM0FpMkRYUHlrQWNaaEFqNndYL2dIZXNXekFTUlg3Ti9rMHVicElLYmJnM05pdkw1aWpTTzhGZ1VDUHNUWExtTHVmR01tQkpDSDlPanRXQldxL0s3Zm1NN2ZHWUtzdXdSbWhjWkpKbFJCMmlEbU5hbVdXWkljc3NQa1pNY3ZKbVBDbVFhVUVVeFEyRmsrY1pWVEZDUkdpNjluUjFQYTRxYmg2K3hCdkhuOExtamtJenZQUGttV1ZuczhJTk01ZnJIYTd6aE40UEpuMk8vZVYxUGI5NWoreE90OS8zK0pWSEx0NCtPamdSRVp2Z29hL05wdmN1VVBqbWZYcDQvZHFOSnZzbWJvOG5FMTAwWGw1NFk1OXZxbXRXaXdYR1pqalhVRnI0L2c5L0U5WmF2Qk1JR2RyMTNEaDRpUys4ZkoyLy95dGY0RGUvK0FiNG5HWGJNS21tUEhMNUFjN3YzZ1B4YU9DUW5CSnlNVVAraURXR0VEV0pGZGZGTWd6bENkay9RN3hZRCsrcUJKRWhJUmVLZ1M4VmgzV3lFVXNteXFWSnhVbmIwL3RBVGt6bTJHS1NtUU9XazNySi9uTE9QUnNsbVpYa3JCaUg5SndJMFZ0c250cStvaWd3UGhBMUJaaHVUQ3JhekNaVTMwQWJGQXM0ZFJTNUJZVzJhL0hPOGZ5cnovSGMxVjlpTWxZeVd5QVNocGtyWWxReFBySnErdFRTNmgwYWpsZmxlSFZibHUyY0M1T0xGL1kydGk4RHp3M2Q2ZGVNRnY4Tlh5QWhoRGUxV01jbmkvNW90bmd4aXBtRDNicDI2NUNqbzBPeVVVbVdsN2l1STdpVzRIcEdvNEttZHJ6OCtnMSs3bFBQOGF1ZnY4clJjU0NxNWNMT2ViWkdJMXJYYzI1cm16d3JxR1BGaFhNWHliTm5pUmhzU05xUURIQlI4WEY5T3FTNGd6RFE0dVVPbGpqUTVOUEpFWWNlemR4aHFsQ0tVSldHeGdIUnBGTktNamFyaXN2VHdHdnpHUzRxQlVvK25HS1pXS3FRY1hzMjQvejRBcHZWaURmbVBhc1EwcXFvTjRUZ0tiSjBzeHJyUUpRUW9DalNxU0trWkY4eHlTK3NDM0RTenVsOHd6amZ3SHVIaThxdDR6ZVkxVXNDSmRabTZlNGVsZzB4R2RZUk81ZUtmaWgwSDlJM1YzY3pqbFlIZW43NzRqUVRjOW1rSjh2WGxQRjdkd1k1QXpxSkVMd0wvclZydDY5bUtpZGxVVzdOVmlzT0RnL1kzdG1HS3VKZFQzQU44OFV4bjNueEdyLzgrVmY1NHN1MzZidWN2YTA5M25MZk9jYWpVYUt3dTRiTmNZbUl4ZmM5Yjl4Y1VWM2FvZy9LMG5YVWZhQ3VIWFVYYUYzRUJUM0ZWSkp2MUZwaGFMZ0R1Q3VyRUNtdHBiSm1VSHVsVlpocXlqR2MxNDVWcS9SZTByQmpraGVKRlJqWmpEWjZIQ0hkbkdFd3ZrTlpkQTJ2bjh5b0JuTzhOdmpoSVJKeElWSTVTNVlKTnV1U2dYZFVqTTFTK0k1UEo0SEpMVWFWek9aNDU1ajF4NHpzNU5URnBXNWJXbzFrSWJKc0hST2JUakdiQ1NZWVZJUlJabG41Z0lxa2h3Wmd4QkRVY1d2eE92YzJWOXBWM1M2R0xmaGRxc25YcThYUzFGR0U4K2QzV21sQ2V6WExPWnJYSEozTWFaWW5vQlZpTXZLODVCYys4UnovNzcvMTgwUlg4dmo5ajdKMzd4YWpzZ0pKdnJkb2hPZ0oydUJjaXpXQlgvcTUvNFdmYmxzT2J0MU9HZ2dYOFM3aXZBNTNPY1RCTDBzSFJaWEJFSFZnNzRvaHorRElSMFFNTzRQSmRGRU9LK0tZK256ZkQzNWJRZWtJZEVTTUNEbUdPREFLT3p3OW5uQzYrMGxtY3ErZm5KQVpDekg5T2oxRGZnbEVZbEM4UzR1QjNpbXhENnpxanRwRit1dXB0U29LZ3dsSzEzVzRnMCtqOTFwaWpIUjl5M0syd3JlQkZSM1dDTVc0WUpRWjhNbVpNaXFNeHlYYU9WWXVKSU85bU42UEVDS3I1b2pQdmZxRlR6ejcyb3VmMDVTUUc3K1crZXAzQytUT0NYTEhrYnlwNS9kdTdwMFVWY1Z5ZWNTMTJ3YzhjdVVlaW1wTXBpMjJHRkVXVXpxblBMaDNqblBiMnhocmlkRWplQ1MyZUZmait4b2pQWDNmRFk3cGtlVnFpWXJpUWlUNGlLcGdyYVMxYVRySHlIVDRpUkdpQjRsckV3ZklqTENaQzQwcWhVM0djTUVyUlRYOGdpaW9IVmF6Q2hMV09HaFNHQUs0ZEtzUHB4TzRrRExmemREQytSQ0d3Q0JET09PK0dGWHBleVh2VStmdlBZaFJmQWhFRjloL2JSL2J0OWdzRGY0eEtJZHlpOWVlZTRtbUZ6YTNjaTVlbUhCeGIwTHJBcTBMTkM0bU16eHJVaXVwRWNFd3FRcGNhUEVEYzltNUNEcG1kL3BROEdxZnUzbHlxK0czOHNPKzZwZTlXeHVuZkkwMUM3VjYvZG90bm5qb29hZU85bytlYWRxbDdFd0xIcnYvTXBQcERsVUpaVkVpdHVSWHYvQWl2Zy9zam5OeTA1UDVZMEo3Z08rUGNkMEs3ejBpaHJMTUtYTkxrUXREVnpUY2RwSGNRcDVEa1JseW05cXBQRGNZcy82MVFwNFppdHlRaVRDcVlIT3NqSE5oT2hiS2NtQVdac3E0VW94VmlnektuQ0cxeWlJeGJiVE1ZREc2L25kbURGVm1JQWpqd3BLcG5ITEIxdklQUDNDSE14Ukwrbk9zVFlJdEdZYWZ5YWpBOTRyempxM05rc2w0eEdSYVVWVUZnc0Y3aC9lTzZVYko3czZFekJpS3pLWlRRUlZyREVWbWtxSGRJQ2h6empOYjFDeHJ4M3plNEtsNCsrUGZvazlmZnNidWJHMjZOdzV2ZnZ4d2Rqd0gyaUhVeDkrZFFiNCtKNGsyZGV2UFg5bzl6cjlVZWVjMXY3WS80MlErNTl6NW5oaUYvY001eldMT1V4YzNPRGxlTXJhSDBLZFlOb0M4Z0dxY2syZVdHSldpRU1yYzRtTjZKZ2Nma3BwSURFcWtMREtzRlh4UThrd0g0a3VhUVdJaEdBYlFMc0prSkZSbE1ZQjQ2VlllRlhGb2tWTEI2ZUNXVXBZSmZMVExqTzVNM01ZYTMxQlZDRkNhWkZibmdwNktyQWFWUnJKVlBEMUZJcEVJYXUvUVlLSVNZOUxBUjIvWjJONWtlMXBSRmVuVzhpNndhanFPRDlQSkdVS2t6Q3haYmhBajlEN1F1VUJ1aFkwcXgxamw4TERqK1ZjT09adzNpTFZzN1l3NWYzR0VtSlVZalhwdVkvZnB4KzkvNUtublgzL2xxa0EyZUFHYisrKy9YNjlldmFwM0MrVHJjQjNQWnRlekxGczR6KzVzMlhEajFrM0VaRnk3dWM5THI5MWt2bWp4WGMvZUpFUHdZSVFzTjB3cncrNW1BVFlEWTNDdUp3NVBTZU1NWlo2bEh3dmtGaktia3hmWlFEc0pXSWtKZUpCazBDQzVKcGFxRHZoQ1pqRTJZUlVocElIZUZvSzFGdWM5M250MEVGcjVkWEdXa3FMUEFxZUlmRml2alFPVVJYbzBTRFFVQ0o1SUlHVWlGZ2pOVUNRUnhjZEk3eXcyU3ppMkR1MVBXUlJwb0M5eXpMZ2tNNUpPSjRXeXlOaWNWSVNZSU1hNEJqaUhZcTJibnRtOHdRTGVPVjY3UG1mVkJuYjNKang0WlplOTdSSGRxdVhvK0RadTR3bUszbTljT1gvdk0rT3ErdDlXVFdORjBsbVdZcXp2bmlCZnF4YnJyT0NIVC83RzUxOS9lTy84NHQ2ZDBlN1cyUEs1NTY3ejJTKzl3V3paNHAxaU1rdWUyZFAyU0JWc0xteE9jL0xjZ3NrUW13K05Tbm9HYTdpRFUyVEdraG1iZnUyQWxCTUZOUVpqaFJnaWNSaE8xNndVSTRheUtNaUxESTBSRVNFT25ydURLQU5qN0ozZnA4bGRzU2dzR3FIcklNYUJ0eVdKWTJWTUN1L3NRb3BES0l4bHJEa0w5U2hRWVdnSE4xNGRhQ3lkaXhoanNESE5NRjN2R1pVRlZnMWVoVEFxc0VUR1E5dTBzNVV6M1Nqb25USmY5Q3hXUGE0UFdDT1VtV1d5VVNSU3BBdDBuZUdoUi9ZWWp3ck83VzFRWkpibFNjM2lwQ1kzbGxXM0pEZldYTjY5OFBUdXh2YkdxbWxtNnpsa2lOUzdXeUJmNDBMaDNzM1J2ZWRaZmJqeXN2M1FoWXJlUllKM0ZKbGxXbFdFSWdGN2szSE9aSlRtQStlVTNBcEZKc1FZa1ppWXdxTnFCTkhqZlljdFMwS0VLcmNZelFsUjErNkNhUzZ3aVdBbHc5UFZENDRtR1lrQmpLYWJZSTE1bkxKTmhqYkhETkVKcWQ2U0ZoNTErQmhQeVpDbmlxNzFOeXpKVVQ0R1VnczBNQ2lEUmd3cEZ5SlBaK1RwR3hRMTROd2dhckZDM3llaVlKVkR2K3paTFF3NzFqSWVXNnJTa3VXQ3lReCs3dEFJRytNQ0ptbXBrT2NHWXczV21GTUwxaEFWSHlMRVNMM3NXTTRhZ2dzRW1YTTR2eUViNVpTaXlCNjg3OEk5dTYvZnZ2SDZHWC9sdXdYeU5id0c1YXJKTG83emoxWFIvZkJxZGx4VVJjNzJPTWVTNWdpdGhNNmxKOVYwV2xJVkdXS1VtTVdVTUt0cFgyeXNRYUtISU5nc3g1cUVUSXNHZEhQTXZPbFpOVDF0SDArZEZ2UE1wSmJGZTN5SWlESElXdWd0aGhBRDNudDZrOXplamNpUTg2NFlFbkp1QjJERURDQmlqSkVpUnZwY2NDN3BTQktlSXFmb29rYVNYbjJOT3doVVdNelFicFZEZ2NpWmZ6UXFHcEtldnU4aWZlOFpqU3p6b3hyZmVrSmw2YjFKT2ZOaUtITEk4alR3TzU4ZU1GSEJkV0dnM2d4UzRtSDdscEtnbGI3M05FMUhqSXFLNTliSjYxell1SSt4R2FrVmUrb25rSEFzdVZzZ1grc1RSRlYxY0IzTXBsWEpwTW9aRndrTUszS0xSc1dLUll3d3lqT3F2RXBhY29uREtqVDUrWmdzSDhST0FTTVJpeUVhRDlZd0hSZjBtbTZVcUNrSWRNMjVXdDhvVVdQYVBvbWNVUmtPbmRoQTdVNGhBWUlkd01BUUkwaWl2UThCcFpTRGViYlhpSE5KdDM0Nml3emdzOFE3RWRjSmprbC9yeXFEdTFZNDFhSEk4RHNqQ2VHMkNXV2tianhiR3dXNjdMaDFWTE54ejBZU3RXdkNoYnlMR0NPVWhTRTBJUW5LaDJMTWdLN3ptTXhnTW9zUHc2bXF5VWNzTHd1OGJ5SEM0ZUphdkhyd29vNnF2Vjk1NGZWWFhrL1lxUVlSdVZzZ1g1ODFsb1kyNnE4WG1iMCt5dXg5bzh5K21XVTdNSEZSSlFhZmJrcVVFUDJ3b2pTWXpDRERhV0VGeER2Q2dHdllMS05RcFJqOGRrVUtJa3JiZTlxdXgvdlVLbVVtbWNLZGF0SUZNcHNsbmZ0QWhRZFNLNkk2TEcvWFdlZHlLcTR5eG1CUjhpeVNXWVVzL1hmbmgrLzJEazdJMms5aTNjb25leExCSW1SblRlMkdsNCtSR0EwUldDMERHMU1sRitWZ2Y4WDU4MU95TG1DTWtGa2x1TUdlcExCbzQvRWhBWk5HQkFOTXFneVRHZW91NFB1QVdFRlYwcXhYNXRTcmRqaFJPbm4yNnBldU5xNzRYMjdQRHVmRG9pMklpSDR0b3FQdkZzZ1pKSDE0NmF6MzF3dHIzeWl0dVkrWWR2VWlCak9RQ0hVZ0F2cmdNYjVMUTNHTUZFV0pOUm1aSk1kMkh6eHFEVVpLVkIweXJIWFJ0T0tWZ1d5b01aNGhFdW5wc0xtT1pndERWSnRHSFNJSWRKM1ZQSnc4TWtTMVdZd3hwMjFUMUdRdkdsV3hvbGdMM3QzeFJEazlrUVlCRThOSjRvZUFVaDBXdXdZbFIzRkFLUlpSR1g1SFRETlVFTm8yc3FwNzhrSlluVFFjTER1cXpZcmNSV0kyYk9TczZIaWFVeFNHbzFuSG92YXk5b0QwVWNtQ0lsWW9SaWw5eXZrRXB2YXVwKzM2R0VNOENLRjZjZFc0di9uYTRmWFBEaG1JSFNrUFVlOE82VjlqL0dOQTB1UHRaWGZRK2ZDY01lYTkxaHFiSXNNR09vZFprd2JUa3pxRWdJWklKa0tXMG5NUy9ob0ZqYW5sVW5xS29rQXlTOWQzeVhRdVJMd0w5TTZoUnZBK0RBeGVJYk4yK0lJVTU5TTJ5MlNXVXpNc2dlQlRuK1I5QUZXeUxHV0NaSEtuUlZrWG9BdzRTZ3dRWERLL2pzUTNEL3ByV3IybTBnZ0Q1cUVEdmpMc3laSnZjSHJxcTBFMERNWjBYUWVyVldCbjI2Sk56K3k0cGl3enZBZzdtWkhTR2hGRm5BODByYWZ4Z1huYmQvTjVlNkI5bUtNMkZEYmJ0bkJCTkJZeHB1MVkzM3BpcjdwVDdQVW52di9wTDF5LzhUYzdINjRxc1NacFFmeTZRRjU1NVpXN1FPSFhnV3JpVWVwWjY1KzdEMTFZSTl1R1lmVzZadHNPeWo2RElIRndQWkdCdWFRaGtUU01TZVE3d05xQ2dLVnRXbnJua0JCeE1lSTEwb2VJQnFYdWVvTEcxQjROZHFJeHB0TWx4SWg2VDU3blJJMDRGd2tEemNPNTFJYlptTElLallaaDVaeG9MQVpCak5MM2duTkNONENCa1NUQlBidjhzVU9iNXRlR2M5ekJMVUpxaDF4TWlTWlpKb2JNUUJkT09USXNGNUc4aUZnUlRxN042TnFPYTlZd0tuT2ZGZllnUkYzVnE2NWZ6cHJqdm5XM0l2TENjdFcvdkpxM1Myc3l0cXJ4NHhlcnlZL0ZwcitjVzBzbUdXVmVzYnN4NWRKa0o3KzBFWGMrYy8zNlFvbU9NM0piN3RyK2ZOMktKQXhQSlAvQzRlclREKzZPWHlxc2VaZFl3Vm9qUmhUbncrRENMc1FZMGlvVkJxTzRCQWpHRUFuUjRZSkhyQ0c2anFieExKdWVsSytwTEZZZHk3WW5CRS9iUmVvMlBhV05CVEVlVlNoTUtyamVwWDQ4QkljQ3MxV0s3MHdTM2VTa0FzbC9LM2c5cGFjWXc1QXhBbDBiNlYzeXlPcndwNDV3bkZrREdZUnMyRno1bEdzem5CMm5EcU5YRmYzN2FXT21sVURoVVN1SVZkR3NjMUg2STJKaHBBdXpKZlp3bVJrUkc0WHJyZkFKSC9URWUrK0MwNGFVWkxYT1dNdDk5RVhkOStHK0J4NCtqRzEzK2Vqb2hNTG1hY21naUdxMDA3eDQ0UExtenNZclIvdXZuNEw4RU5lK0FuY0w1T3R6aWpnZzNsaTAxL1pYL2FlM3ErSnRGc2trcE5uRDZEQTByMFZQQnF5MTlDNFE2aTVST0NScHhtTUVyNEUrT0phZG8rN1MvQkZDb09sckZyV2o3aFRuRkQvYzJEYmpWTVdYMEhhREQ0YmVCZFFrQ3NqU0F4TEkxalRDZFFpUEtGSFN5dGM2R1RDTmRMcUZBRTRWSjBKUGRucmJ5NWtDQ2FSNEtjRU9Nc2NCTlpVazIvSWFOenVOWDRUNCtTWlFJeVR6cjVRZllVQ2w3WlBwKzNvcmFCQ0phSzkzRE43Q21kZjZyeTZBOGNwMXI5MXpjZS9YTDA0M25uejU2aHQ1czJxSlBxMnFreW1Eak05dm45dDQ1V2gvdlVOUTdscVBmdDBIZFM5Q3IwcDNYTHRuMmFVV1pjdjFZYmp4MDFwVkFRMks5eEh2QXk1RWZGZ1hoVUptQ0tyVVhhVHJsZDdWcUtidFRlczlxODVSVFhkNTRPS0VacjRZa0hMQnE5TEhpRVNUR0s0TUdwRkJocXN4blVCZFNLdmpJcnRqK2lCbU1LTWZWckF1SkNBU2xNN0QwUUtLbUNVamhtR2R1OWEzbjBZNXlWQVc2MncwVVlTbzF2Unk0dHorOVNZY3UwZ0RyTkQxRFBBbXZldXB2Z3ZRZ0g1NVljUXZld25KZkNHcXFsNDlQUHprMC9mZC8vczJ4cU9MQjBjejVpY3JGdk1WaTBYTmZCV214bFE3M0RISFBnVUlFeDUwZDBqL2Vwd2dVZFBDSmx5ZE5WOTQxMzNiTnd2WVltaTFRNHhwaUI1bzRiMUxJNnp6U3RNbkI4TVFGTFZKZStHOXgzdkhvdTJZOThxaWk2eDhBaEovOUx2ZndYZTk2MzVlK1BYUDBDNmIxTi9GOUFXc1c2Y3dxT21pM0tHL3g1ZzRXSW15cFVrU08vdzhtc0ZHeUEvQ3F4anBoei92MWpqUTFBT2xoVVFyTnNJd2RNdWJQWDl0b3F0clZFVFNpbmdjNWZxUkN6ZGRINWZBZkdpUjNEL0c4dVBzSzM3Wnp4bmFKUVBrbjN6aHBXY2ZudXc5dTFQWTgwM2RTbk95a3NYeGdxTlpRNTVWTzluTzZDMmo4ZmdYbXJwZXg3VEozUlBrNjN1RjRVUDN4MDEvY0ZEM3YvbkExdWd4VGY0M2t2Yi9pWlhhZElHbTgvUWgwbmxQNXh3aHB0SFhZT21pY3JCMExGM0VxZEQwMElia3htNU01RE5mZXBWdmUrY2ozUGZ3Zzd6eHhlZlRRQ3lwbGZOQlV3aG5TTFBGbW0rbFJna3FRN0hlY1dKODB4MG9naGw4ZTZNcVRsSWJWdVdCTjQ0OXNZOEpQekYyQ01WUmpKcWhhSFFZOGdNeENxNUwzNDJ4VVFzanUyWFdzZWpwaHcxU3k1MklndCtwUUU1L2JzOW9UL0FBQUlBQVNVUkJWSXhna25BdzZVMEMrQmpNOE9lNHhuVW5WOSs0ZWEwTkdsZXVONTBMb2tHSklhQVM4a0xONHp1VHJhMm1ydWVjU2FHS01YNU5XcTI3ZXBEMWdIcUhDQ3FBRlNGM1Fka2U1WnNYcHRXM2V0VXNvT0tqY2pEdk9GNzIxTDFMQUovcnFQdVd6bnZtdmVlNENWeGJlRzRzUE10T3lYT1k1akROaEszU01zNmdWT0gxbThlSWhmZSs2MGxpdDZSYkxCTkZ4WnloZFF4bytkb0p4YTZYWlNLbmN0elQwTS9oTkxDU0JGUHBaaFF5U2JUM0loUDZJS0FwQ3NGWU96Q0xrd1ZRYXJjR0YrQ29aTllnZzc5V09qWDcrckJwLys3U3hhTmh5TzRLYTd3eEVvYW90YS8wT3ExZEVkSHBOTmZOVFlzUktMS2NJcDlJNTdvRXhZb1VHdFdjMzlxOWNMR292cGtZQ21ORXJGaDZuekxqSitOcFZreEhuN2wyZk92YXVxajRHcnE4bTd1bE1Rd2Y4ZFI2S3FhOWVvcEV2cjNzbnR0ZnRTODIzc3VzN2ZYMnZPYmwvWVo1azA0TEh5T3JObkN3VWw0K0NieDRDTmZuNEx3d3RyQTdna2tHVmdLYm16a1h6MVU4Y3MrRWgrK3BlR2l2NElVdnZjUkxWMit5OTlBampMYzJzS0xrMXBCWktBemtKakZpalIxQ2RnQnJaZWd0a3NwdmpXZWN0a3VpcDlRUks2bmFEZW5QS3ZNRTh1VzJJRXZNcmROYklYbDFDZFprR01uUWFERmlzVFlueTByeXZQVHI2T3kxYmRIbUtOZit1Yi95ai8wK040MW5Oa3VidTg1NU5rWlRIV2dpVVZYN3FERmVYODArM1JsenpZb2hNMFlqU3BHbGhCVGZkdmNYM2p4bTgyd2czSDl0MjZ5N0xkYVpxd1Q2WWRSWVA1MWVQYTZ2bmh0bEh6ODN5Wi94TWNxcTh4elhnZHdJczBZNHFBT3oxdFA2Rks1WldhZ3lKYmRLOHJkTndxQ3lFRFpHQlNkMTVLR0xJelluSlJzYkV6WTM5bERHbU5FbWV3OCt3TUdMenhQY3dMV3lneDIxcHJBZFZjRVA4bHVydzVMZ2RKaGUyNVhlb2FHc214dzlnNXlQY3VGSWhqbER3S2hKYzR6bzhMeE1mN2NNdUk0QXh1YmttUUhwblh5WjVrSkVXUHo5ei96akRYbWF0blYrdmVQQ1U3ZHZZSTFaditjQjhDZjE0cWpkRGwrY2lEd3FJSmxOYSt2TUdycW1NK1hPK01yMjV2YjQ4UENndmxzZ1g4ZkwzZWxlb2lvZTZGeUlxNk82KzN3dTRVaGozRDJvQTdkcjJLOGpuVTliSjRoVUNHTnJ5VVdUVk5Zb2RxQnhJeEZyTW9vaTQvaW80WVAzWGVHRDc3akN4czRtazJxSG9wd2dtVWQzOTlpOGVJN0ZqVnRvU092azB4dDVuVlBvN2tTcXBWTmhJRE9xM3RsOERqL1dzK1piZXFkQWloeDhkOGVrN3RRY203VGlqVzhpdHl2R1dQSThSeVczd3BlYlJDdlNMMy9YNy9rSDMvSnVucnZ4Q2dmTDR5amdGZnlpYTVZTDE3MTRyaGdSdXdhclVGaEZqR2p2ZWhtNytJNE5XMjBmd3NtWk9lUnVnWHhkWnBHQkpUNDgwWHFnUFdqY1p6TFI1MDVxL2NDdFJyVWFqV1JqTkNZY0haRU5pSFFtZHFDYWd6VktuaVdTbmtoUytPMXRqM2owZ1IxZU9LaTVWVWZlK3JhbnFVWlFGRVd5OTdHVy9YS0N1Z2ZwNnhaM2VJSVZjK29zRXVMQUI0TkVrUi9tcGppWStlcUF6OXdaaVUvNXYwTzlKSFErczRJMWFXbGdaRTE3VDdMZWRhVUlXVnJRbnA0aVNwN2xLRVZoRW85ZXpnNXNsTC83K1hqWnJwS0daVGk1QmZFaEJyY0k3bFdmajJZQ080VTFPQk9wTWtQdmVzMmlYam8zM2IzdjFZTnJyNHVTRFFHaFoxUHE3czRnWHlzUUpFc1loNTdaWnZYTFB0eCtiUlorOFdZanQ3d2FzVmE0Nzk2THVya3hVUmtNRU5ZTTJzeWtFeVRMSXNZRWpJa1V1ZkMydDV6anFjZVQrOGt2ZnU0RlBudmpCcGN1WDJJeUdyR3hVVkRrQmZzSGMxNC9yTm00NTBHeXNrd3pRU2JKaThxa3VTT3BFUWRrZXhqQzErY0ZNZEhMMTlQeCtwNGZLRmxERmlMa0VoTnA4a3huSWlwbldyT0I5ejVBR0tvK0ZaRzFwK250WjF1czZibXQzL1Y3M252SDdkbWhEbkI0Vk5RRDRhaHJYbDBHZDNPZ251bHcyZ2tHK2xXelV3U2V5TFBjRHY1M1g3TlQ1TzRXNjh2ZmtFVGZlRk1XWDRob0gvVmxSVjRHYVp6dno0M0hvOG41blQyT1ppZUVHRko4V0Naa0ZveE41Z3U1TlZSRndkN09sRy8vNXZ1NC82RjcrTGxQWFdmUks4ZDl3T2FBOUVTU1dmT1AvOVN2ODdmK3Q5L2duVTljWVhOalNyT1lJYWVvL1lDSFJBYkh4ZlZwa013V1RwM2l6NXdmWnpVZmNaaEZqRURkQmc1WGtjTFlNNzlIQjJOc3VYUGljQ2NzTk04czFyajlHNHZaVHgzWC9hRkFKeUw5eGlpUGorK04rUnUvK3RydjZ2M2VYeHh6WVd1SFBqaGlqT3RrM0FLYloxZW1XMjhybGNkOERCSVZPaGR3UVhHOTUrS1Z5OWR1dGllLzFqUjF6NTJBejYvNk51dHVpL1hsVDdRUUdXVkcrNkFhRXAxNjdZUjdHOXpmQi9uMUdQbjVtd2Y3SDMzOC9lOTl6Mnc1dSsvMU42NUprQUhjMDBUZXlLeGxPaGt4S2tvdW41L3c2S01YV09xWUM1c0ZqZVM4ZmpEblAvL2JIMmVTQytNaTQ5TFdCcC85L0d0OCt0VjkvdDV2dnN3UGZ2T1RUQzVjWkhYN3hyRE9UUmlKTmNQNk5xYk5sRmloc0FZWGROalFEazZFcDl5T05VVmVUdFcyNDhwZ1RUS05NMitxS2owOWRjN21PMnVNeExEQ1dPOGxzVEhmaEc4RTkwOTNYMjZOcHh5dkZneWJyQUQ0NDNxK2JMMTdlY2ZrMnF1VFNXNnBCODlnWWpEUytLZkh0dHc5Z3BQQjJjVHdOYkFmdlh1Q2ZJWHIvbzJDUGlhcXhobkFhOTNmOXNDMXJ1OCt2Ymt4ZWVueXBZdFA3ZDgrM01HcnFpSjVwa3dtTUJtVlRFY1ZaWkh6d09VcFR6eHhpWi80QnkveDZ1MGxURGVaYmxaVTQ1eVlHYm9JKzZzV3JYSjJ6bTl6NkR4SzVORjd6a1B3dUtZWnpLVFRFLzRVRXh2RVRTcUQ2L3NwWUhnblVwb3p3YUl5dEdhNWdXV3JoR0NHeHYyT0ZDbzFVRWtEY3BwSklnRXJuU0R5NnRWWjgvZG1UVDhUYUJGeG85ekdGdzlyM2ppdUtVdUw5Ly9reGJJOTJlQndPUnNDR2RRQXVXcTBsemJQN2U3bStYc2xoSEZtTEszejFDNUlWQ1JUVTUyN2ZPbExMOSs2K29JZ25xOFJzL2R1Z1h5RjY4SWs1NlFOU1YybmI2SkluUEtKUkNRZUhCN3ZQL25ZVzBaVlZyenQ2UEFvRTVDZ2tmRTRlVmVWZVk2SThNaUQyOXc2N3ZqWlQxeWxyYWFNdDhaTXBqbDViaWdLdzdqS0tNYzV4VGhudEZGUWpYSU91bzZ0SXVQU3pnNTkyMEhzVVVnY0s1OU9Ld1kwUFF3YnJYVUxkamJqOE01MlNrNkRRMVZoVmdlY1h5c1AxNnRoUGYxeEtwU0FJV0RFVVdSUmxpNSsvUG1ENVQvc3ZLL1hiVTBmb3A3VVBYMklaSm5GWm9acWxKOGFPZnpqWE1lck9aZTNMOUM0ZGwwZ0daQkhZK3psY3ZKZUUrT2wxZ2VLUEVNRWVoODBSakhWZFBUNnE0dGJuNG9odU9IcnVWc2dYNC9yc1BGa1JwZ1VCajhFMUVUOXJVVVNZcVIzN3NiRER6eHdvVm10SHFsWHRZbHFjQ0dTNTBuRERzSzUzWW92dkh6RXpaVlM3bTZ4dFZVeXFneFZaU2xMUzFZWnlBVEpEVm1SVklRUjVlYXFZU3UzN0V4R3RGMkhhS0xhT3hkUHBiRnJWTk9lWWg1cmxTQmZobGVrSWxrN3hEY3VzR29oTjhsSkpjbDd6K2plTlNINUNaSHZwTXp6ZnI4T1AvWGl3Y2tYdVlOZ0IxWFZ0ZytvcW9RUXlYSkRXV1ZrMXZ3VEZjbDlPK2RaZG8yNDRHVW9rS0tMd1R3MDNYMTdxZnBZQ2lvVm1UdlByUGRJVkRPZFRPY3o2ejZ4WEMwWGdyZzdtL3F2WHBIY0xaRGY1dkpScVhMREkxdGpHaCswQzNyMkpEbGRGSjNNWnQxb05McTV0N3Z6OUdLNXVCaWN4M25vK3JURkVwU3l6SGpwK2h3bVU3WXViREdkWmxRalN6VzJqRGNzMVhiTzVsN0I5bTdPeGtaR01SVEp5aXZYNXlzSzdSbGx5UkpING5xRm5NaVFxbW51NmZ0SVp1VU9aMnNnTDZxYzhTSVppbW9kdkRtcmswejNUZ0hkT1M2VGhGNHhKcEpiVDdEWjY2OHQzTjgvWE5iN3ZKbENjdWVRU2dzTjZWdFBsaGxNSmx4NWNJdXRyUW4zM0x2TndmNXZqNWRjMmo3SHdlS0VjR1pRanpISy9adm43anVmNSsrS01SWXVodVNNMzN1eGlKUjVHZU1rLzlWYnh3YzNoeUg5cTk1bTNTMlEzK0ZxdmVKVmNjTThjc2J0L093SFlJNW5zOFVEVjY1MFJaYTlZemFiajBXRnppbGRIMUYxVktPY2VSc285M2JZUFRkbVBMRk10M1BPM1ZOeCthRk43bjlvbDNzdmI3TzNXN0cxczhGME02ZmFTUFNLMmltdnpqcVdqV016RjdDR2lGRG1Ka2wzSlcxM1hyeTU0dHhHbWRiVkErb3VaMDRUWGN0dWg2SEVSZVZrbGZBYkVjVU1EdGw2NnJDaUdLTVk2YkFHNm5GbDVxVnFYdGlZNWJacEc5Y05SWkZ4QjgxT0ViaXFlQjhGWUxWMFhMNS9sNWRldU0xOUQreHhjbHgvNWJaMmM0ZWoxWnlnY1kxZjVvcmE3Y25XMXA3TnZqa0VQMDA0bGVHazZ3aGV5Ykk4YkYzYysveEx0NjYrZFBaVXUxc2dYOGVyOFpFKy9JN3Z0NFlRek1sc3Z2LzRvNDlzeFJpZVdpeVdWaEI2cjdoZ21FNXlWblhIYUcvSzQ4K2M1NEhITjNuMDZRczg4dmo5M0hmL2ZlenViRk9WSThwOFFsbU5xQ1pqUnFPY2NpUVlFL0VlcmkwQ2I1ejBqSXd5R1dVRGdUQjVhZTB2ZWw0NHJIbnMvQmdkVnI1eVpnaVJ0ZGN2ZHlJUFE0UmJDMDl1TXF5SkdQRnAyaDlzU3hPZnkySG9vU3c1MEZpSzFiZnM3RTQrc0xNM2VjdjJ6dGlLa1hxMTdFNnA2cnhab3lISjRBTHBXa2VXV2ZiT2IyQ01zRnAyditWTnZEMC9abk04cGVsYlJNVG8wR2FKTWZrRDQrMXZNeUdjajVwU3NXNzNMY0ZIQ3B1UE01UGRmS003K0xYZ1EzZTNRUDY1dUFSSjE5bVRSTnF1Q3k2RU4rNjllT0Z5VTljUHRxMHpTT0pLalV0aGUyL0UrNy85TVQ3NHNiZng4RnNlNU9JOTk3QXgzU1l2eHZoZ0VFcnliSXdZQzhhaU1rSnNTWjZCNG9ndU11c2lYM3oxZ0pPRE9YdGJGVGJQS0hQTEs0YzFMOTFlOFUwUGJkRzVsRzh1ZzNaK0hXaW9aOWEzUWRQcGRGUjdVTWlOdytBQVF4U0RrVUFtUFNLT29paFlsaE5td1NNYWhCREwzSm9yNDFIeDNwM3QwVk1YTG16dWlaRjJzV2liVkNDU25Ta1VWSld1ZFFRZmFlcGV4dU1DN3dLalVVN1grVGZmakdJSk1aeDEyaTljRFBiSzVybDNWQm9mU2Q2K0tuVWY2SHhFRUNtcjZzQlBzaytjTEdiTEw4TkQ5RzZCL0RNcWtMTE0rQXJ5ZzJ3Mm43c3NMNjVmUEgvKzZhWnV6bldkSStiSVI3N3ZTWDd3ejN3TDcveldwNWhzbjhQa0UwbzdocGpSOWtvTWdvb2RhQjhaUG9CM1N2U0s2MXA4MHlJaFlHUGs0UGFjeno1M2kydjdOVHNiRmFOUnlTOSs4WUNEWmMrSDNyS0RjOGswWVQxZzI3WGw2Qm16bjBoQzRBL3JIdTlnbEtWdEZVUVF4VWhJUldLRXRpdzVscEk4SDRQMFl0Y3d2bXFWWitiKzBTaC81Kzd1NUIzbkwweDNvK3F5YVZ5cktZejliTnRGaklyckE4dGxSMmFORkVYR280K2U1L2J0eGVrYjZJSmpVazNFQlNmck9TUm9sQXVUcmZ1M3hMeTdkejZMS3RJTzRhdk9SY2JWMkJTVDZ0UFhqbTlkUHpPSDNDMlFmNWJYUGZmdGNHNW5qMVhkU0l6eHJPbDFjVEtmdFhzN08wMVpGSS9iTVJ0LzVFOTlVUDdRajMyUVN3OWVJaS9PWVV4SlpqSzZFT2ljUzZvOTFVU2RENUcyNjNCZGorOERYZE93bkIzUnJScGlIMmtYTFc3VkU0UG4xUnN6WHJsVll4Q3VIVGFNUndWdmUzajdOSkxBbU1HVWJTaVM0ZXhiTy90Z3JPSGFyR08yREd4V0NRMUpkUG5rQkpsWnNLTUoxM3hQRTFxc1JGU1N2V3FXR1RIR0lHSVFKQy9MN09KNFZMenQza3ViNzk3YUdadStEMGQxM1h2T0NKcE9qMXROa1c1bGxaRmxodG1zT1hXQkJOaW9KdEs2YmwzZnVVSTJLc2VqQy9ub1E4SDEwNGl5OEFtL2pUNVNGdFhJRnZrTFY1ZTN2a0RVci9vY2NyZEFmaGZYZTcvNVVlcW1sY1dpd2Jtd2Z0cmxRQVdNam1Zbnk0OTg3NVBiZi9MZit2Q1QzL1g3MzJiSzBZUVFER0pLTWdNaE9McmVFMFBhTklXUWRPMU4zOUswSytwNlJ0dDJyQmFPZXQ3UTF5M3QwckU0ck9sYmowMVZ3R3dWZWVINmtzNHA3M2xrbDczTkFxeVFGNGF5TUtjZ1lwSnd5QjNMb2lIRjUzZ1pPRmgyYkpjRllpTFdER3RkaEtLcXVCMGpCMTJETmFBU1RnVll4aVNXc2pGQ1h0aGhYc3F6c3NqTzcrNk0zM2ZwM3Ewbko5T3k2MXEvYUZzWHZ2dzBVYUR2dko2Y05JTWJwWkJsZHNnT0tXbGNLeUlpeWRlZXlzZlFYcWcyM3BQNWVGOXVoRG9FT1hFOWViUWFvMlpxNWVxTTlsTmQzN1Y4bFdrbmR3dmtuL0NxcXB5OHNOeThkaXp6V1hQYUs0dklDSmhzYlkrMy8veGYrTjd2K0lFZmVkLzNQUHI0cGUzZVIrYWRRekJrUnZDK28yMXFYTFBDdVo3Z2UxeDdUTmMxTk1zWlRkTlRyK2JNVGc1cGx4MTlwL1NyanZudEpjMmlTNDZKSWRLMVhXcFphbGkyZ2FObFIvQ1JjWmtobVQzZFNJbTVZK1pnQnRWaGFtZVU0N3BuMXJUc1ZEbXFLWm5LR2tPZUZ4eFJjTFByME9Ga3NkWWtNKzBVeFRFa1lBbGxtVk9OY3FwUkp1VTRKeXRzTmhybjkrOXNqOTkvOGVMR2ZWbG1UZzcybDdNQmxEOGxGT3JnRnJFR05ZTVBiRzlPeUxNSzd6MHhiYk15a01KWW0xL2EySHVtOE9IcEdLTUVWRTU2UjZZRzc2UHM3dTZKVnRuSEQrWkh4N3haWmFoM0MrVHJlUDNjci8vNy9BLy83Uzl6NjhaTW1xYVhPOFhCU0pYcDV0Wm8reS8rUnovNC9kLzVmVy8vWTV2YjQwcytRQi9CR291MVdZcEhidnZCYWNUZ295UDRodEN0Nkx1RzFleUl2bldzNnA2bTlyakc0OXRJTzI5WkhhN3dmWnEwKzk3aG5hZHVQTXNtRGVDTHh2UEs3U1h6UlVjcEpLc2ZJNWhNS0F0TG1SdnFOakJiZVdhcndNMlo1OVdEbXMzU1VnM3h6bFdlTVM0TFRsUzQyZ1F3VlRMdGtZQXg5bzcwVjlZRllpakxqS0xLS2NxTVltUWxMNnlZZElxTnA5UHlMVHU3NDdmdW5wdFVpM203M3pUT2ZkazlkM29EMjh4UzVCbWJveTE2NytoOUw1SWNldk9vbW0wVjR3dFRNZDhxTWRoTURFc2ZLSTBSRjVReUsyeXQvUy9zMThjM3o1d2c0ZTRKOG5XOHNzencxTnZ1bDA5OTRtVlpMdHJUSVJJWUF4czd1NVBkdi9nZi91RHYvN2J2Zk9aSGl6Sy8wTHRBVUQwTnl4R1JaQkhrQXM1Nyt1Z0kwZEc3SHRkN3VxNmxiaHhOMjlPME9WM3RjRTFQdDJ4WkhyYTR4cUV4dFdLZDh5bkRiOTdUdEdjTTRCUnM4UFJOdzhGSk54ZzRHSlpkNFBydEpkY09lMTQ5OHJ4NlVuTjF0bVRwZXdwckNTcEVUVVRBV1l5OFZpL3Bvc09JUWRjaGJPdk4yQnBWSk0weFpabFRqSEx5MHBMbkJwc0pOaytTQUpzWnlzS2VtMnhVNzdod2Flc3hFVGs0T2E2UEJ2Mkd2S2xJRkVKSTc5Zng4Z1NUaUdNR1NBVXltazczOHRHSGNQMDBONFpGOE9rRUNWRUxreGVUM2MyWGJ6WEhudzhoK0RORmN2Y0UrWHBkMWdxZitKVVg1Zmh3S1RIcWV1WVlBeHZUaldyclAvaFBmK1FIUHZUdHovenZUVzdPeGFoREtsaUNyZU5nSnQxNWg0dUJ0cTFwbXpuZTlmVGRrcWFiVTNjTlhTT3NWcEcyai9STlIxKzNORE5QTytzSjNvRU9IbHcrME5RZCs0Y2VIKzdjWTRVUkxrOE5wZlUwYmMvSnZHRzU2dGlmT1Y0OGFIaGozbkZqdGVLZ2JXaWpKMGhrRVR5TDRGbEZUeDBEKzc2bGl4NGtFTFZIakpJR2NqanRrSVpDTVZhb3FzUWR5d3FURkpTWlVCU0prNFdJMk54b01jNktvc3dmMk5vY3ZYTThMbU96Nm0rM3JYTkRBYXhuZDQycUttSW84b0xlOTJ0ZWxnWEtVVG5LOXNyeE80enY3NDhhdFZPVjNGcENnQmpVN08zdTlTZmEvdEppdGFoRjVLczJoOXd0a0gvRTlXTi85aU5NTnlxdXZuSkEyenFqZDRwakpNTEdlRkp1L2gvL3J6L3d2ZC95NGFmK1JER3lsN3p2eE1XUTJxaDFQZ1k1em51Y0QybnU2RmJFNkdqN2hyWmQwWFk5VFIyWXoxdWF1aU8wUGNFSjNkelJ6Qnl1NzBFRE1VWjZsMEowWmtjdHh6TjNDZ2NhVWM2UERPZEhtbVlPQVRTeWJCMnZ6ajM3cmFjT1BaRVUrV3lIaUlVMFd5Z2VwWmVFUzlqVE5pb040eW14U2srZFZXVElXRFFpbEZWQk1jb1NVVEczS2ZwQkJMSHJ1UVZKaFdNb3FteDdPcTNlc2JVMXVtS05IQjBkMVVkZmRwS29TKzNWblozNmNGSTN3ZXRlT2IxM0l2SXVDOVpIUmNWZ0l0SjRMOXZqamV3a05MOTB2SnJkUHNQdS9hY3VrTHQ2a04vaGV2ZjdIbHBqQ0RLWTlobFZNcUFVWVFveS9lTi8raU1mK3VqSDN2cW5xMGwrdnd0Qm80cW83MU1JcHMweEprOWJxaGdJb1NlRURteUcrc1FXUm5LNnRtZTFjSFJ0VEo1VmJhQnJvSm4zZEswbmhzVEI4aTZrVEVJZmFCWU9veWxqSXhQbFFtVzR2SUhhd1hORUV5dUZWYkRTTVlUanJFMFoxaUlzQVNzWnhrWVlpSkJyd21MYVVxWGlJQ2F0aWVod21neGhuQnFFNk1QcE5vNkJ6eFdIWFhLZUNjWWFRbEF5azdCVmtYSWp5ODMzbEZWMlg1NWxmL1ZMejkzOHBlRkVIa0IvUGRzZW5kckJPdGQxallhWG8yUzFScjlwZ1Y2VVVXN3BuZEl0NjUwcmwrNTU5S1hiVjU5VjlDeFlxWGNMNUd0MHZmYmFJYk5ady82dE9TTFlHSFZkSEJOVkpuL3lYLy9vQjM3d1gvbmdueXNueGYxTjEydEVKYlFONGh6WmRCTVZROXQxZEQ3Z2c4ZjNEdWVVRUtIdWU2TDNlT2ZvV3FWdG9lOGo2bE9jZERQdjZab1dvbUlsNG56QXV6U0hyQmFPdXZGa0tJVXhlcjZ5Y200c1pCTGlXbHlGU095Q3NTZE9aSTJnaTNBNlpBdUR0N0JtUTNwVWl4SUh2OTg3YVZjNlpKbWMrbWV0dzN0Q1RNbFlJYWJBMFJBVHBwTWx2cFJxcXNxaU1uUmRUSFU1dEYxaVVadE5uOG1NK1hmeTNGeDY5dGtiLzZ0TDNLMnpzdGsxekw0MkZIZXRoaHNtTDI2TGw4MUV1QXhZWXhGQis2NHRwMnc5Z2NqZlF6VWI3dTEvNmxQa2JvdjFPMXozUGJESDhlRlNUbzVyTXp5VlRvdmorLzdnZTU3NEUzLzJPLzdOOHhkMjNxcFJOQklsb21SNVJWR05FV3R3THMwTHJlL29YRU1JaXZNZFhiK2k3VnBXOVpMNXJHTzFDclJ0UUwzU3RZRm03bGdjdDRUZUk1ckNMSFd3RDNYT2MzaTdwVjFGckZneVJESlQxSUg4eFRhR24zTXh2dFJIdm5UY3hsL2NiMnp3bUl1UzNLakJyREdSdFo3ZERKRnJLUVdFSVpmVERCRU1ETHRabTV6c3pzd2ZkNXhXaWpLanJBcnlZaGpTamNIWXROU3d1YUJHaURHZFptYVk4c1dJaURXUzVkbFdWZVp2TDR2TW54elhML2tRQTcvVm52UjBXN2lLbnN2Vnh0dExlSVNvMUNFZ0dQb1FFUlZiVnRWaW5vZGZYdFhMNVZkcm0zVzNRTDdDOWQvOHovOFd5MlhMcXkvZGxKT2pXbFJqTmtTR2oxR20zL205NzNqa3oveWJ2Ky9QWHI1Lzd3TUdFVlVWUkNsc2dSaUx4OU4xUFczdjZic2FGMXFjYXlCYXZIUDBmWWR6TGZXcW8xNHB2azgrdUtHUGRFdlA2cmpGTjMwaUhvWWg1RE1xM2dkT2pwdTRPSTZNelNoYWs5MHl4andialBsYlI2NzlyMjQxN2M4ZXRQR1g5dHZ3eTBkTitHd2Y0dWN6TVNOcnpVT1lkYmVRNHFPTm1GT1IxR2tVbTVyaHh0ZlRWbXVkL1NIckUyVGR0UXdvZlpibjJDTEQ1cGFpc0pnc21kemxtWnlhY1VjZGpDVUdsMGhqSk5Id3JTSExiVlhrMmRQVFVXR1h5KzZWcnZQOWx4VUphNWFDanpHN2IvUDhrM2tJYjQwK3lDSjQ2YUppVmFUWHlPWjRRL3ZLZkhMLzVPQzZTSnBEUkNRZ292LzFYL2x2K2RzLy9iL2ViYkcrR3RkZzV5bXB0UktyT3FEa3l1UytLM3U3UC9KakgvN0JSeDYvNTZPRVlBRkpVaEV6Q0kwQ0lhU0IzUHVVLzVHWmlpNUdmQmpqZzZYckRxaWJobFd0ZEwyaVBra0JZeStFeHVCWFBUcVlUMnVJaUdwYURmZStuaTI2WDZxOTdtK1h4U0k2L2N5eWIxK28yL2IyOE1RY2drS1NZM29mdzJyWjkvL1pWUEpGbnR2dkY2T2J3N29vZGZ2RGtaRWlvem1Oanc3cjZJTkJxYmpPWEZkTlZoQlc4cFN1RlFOOTc2bDhhcSs4aTJSWmNzK09RY256NUEyMlprTkxpdUdGQ0ZtV010dkxhY1ptR0cwYTlJOGFJWDd1Q3pmKytxcnUrWXF0Vmd6MTdYcnh1Y3BrSnpIcXVSZ2luVVIycGNBSDFkVjhzVGs5VjEzQnlLYzEzcGxEM3Y3azIzL1hzOGpkQXZteTZ5Lzg1Ui9rWjMvcTEvbmk1MTVMdE90RXZDdEVtQlJsUHYzVC84YjNmT3dkNzN6dyt6WDRERlhwUStKUW1jRTROemNXTlNVZEVhSlBjV2FocDIzbWhORGdmYUR2RzlvNjBEVVIzeXQ5Rytocmoxc0V1bVUvOVBuSk9USEdWQ1RCUityYS9lYmhjZjFYNjliZm1MZUxKYkRpRHZmSW4xbHRydHVTcWcrK256WGhQOXZROHZXcXpQNmtTRHczaUtuRXNIWnZIMFM1ZzBjdkpJdWdkVGp6MldnQk1aTGFzWmh3RStzQ3dRVmlWTUlRQnlFaUdEdmt2YXVTcFJ6cklUY3huVDVpd1dUSk1xbWM1aENxaVFUOUVXTkVmL1B6MS8vYWF0V3ZUNUh1N0N6U0V2Wk5OcXJWZVNxeE9BMkpJb09LODM1clMwYnZtMDZtUDdkY0xHcEJySWpZTjI2OEViMzNkMXVzZjlyckxVL2Z4NVVIOXZpWm4veE5lZjNWQXdOcTA5d2hVMVZHUC95ajMvcmVIL3JSYi8zejAzRjFqNnFpa3J3UGpZRk1rbGFoZGYyUVFwVUdWKzg3TkFRTWh1aWc2MnJxbGFOZUNsMFg2RHVQYXlPK0MvVExudFh4NnRUS1hXTWNpaVBnWFRpNXRiLzhidytQbTE4REZxVDRnZWJNYTgxRFdsTXQxZ1VURkZ6bi9VdFd6Q3l6NW9vMWJBc2liN1ovazZHRllvaEYwTk9DV01mQ3lkb28reFFySERJVmk0eFJsVk5XR2V1VmJwYW5GczRQQldHdE9RVXo5ZlM0R2dEQ3REVlRVYW9pczA5T3h1WHF4cTM1Q3hyMWJLdVZOQ2ZHbUhzblcrOHkzbDF4UGhCQlNtdFMvbUxBR0dNV2JKWWZQNW9kbmF6Zmg3N3Y0OGMvL1N1NnFsZDNDK1NmNXJwd3p6YWYvT1hudVhuanhJUVExMGo1QkpoOCsvZTg3YkUvOStjLzlxL2RlK25DMnl3R0pVaU1mdGdZNlJEbDNPTmRRSUlTWEdLY2lvSUdJZmlTcnF2bzJzaHFPYWRwQW4wZmNGMGdkSUYrN2xqTld2cW1UMUhQcC9rZ1VUV3FMSmJ0ejErOU52Ly8rQkNQdVpQTjBRQ2RrSUF4K2NvQk5hY3U2NzMzcjZqSzg1a3g1ek1qbHlVOTRBYy9MTzVrcFErVFJ1SnYzWEdQWHpPQmRkRHBDMEtXVzRveXg1cjA0M1JTcE5ZcTVmQU1wbmQydU1zSG83c3d0RjNoVHVTMEdCR2lqK1dvekI0ZmovTWJOMjdPM3pnemp3aVF0NjRMNTZiYnU2V1A3K3FjeitjYXBESVdRakt3R0kzSFZOc2J2L0g2NGZVMzdqd3NOQ3pyV2k5c1RsaDE3bTZCL0c2dWIvclFXN2gyOVlqVnNwVys4MnVGWEFWTUx0Mjd2ZmZ2L3FVLytNZWVlZnJCNzFFMXVkTW9RVDBhUXdxdFFXaGRvRzRhUXRjUFdZTEppajM0UU5mVjlGMUwzM2FzVm5QcXVxSDNxVGhjRzNHMXB6NXU2VmRkd2hpR3hGdFZSYU5LMS9xWGI5eGEvT2ZIcy9hNTRmUllEY1hSV3pHaHlzdVlITklUR3YybVkrSE95d0M1QytFNGhQaHlKaksyeGx5MnhoU0Q1bERXanUzcjMyNU1PaDNUMXNxazRoaXFLWVlBeG1CelMxNWsyTXllbmg3V0NwbE4xV2JPdkdMa2ptbGo0TlJPWCtQWkFGOVIxL3J4eHFSOFpESXRyOTY0TVgvakRKaG9BVk5sK2M2dUtUN3MybjVVYTZRd0JoT0ZUaU41bGhmWnFQcmk5ZmJ3aThINTlZa2E4c3pxb3VsT1p5RVI0ZExGUzd6dmZlL2p3WWNlNU5WWFgvM0s4K2pkMGtqWHgzL3h2NllzcmJTSmhIaVd2ajcrbC8vWUI5LzcrQlAzZjVkaXk5WVBpV05Cc1pJaEdFSVg4SzBqOXFrZGFwb2xiVjFUdHpWdFc5UDNEWFY3Uk4wZTB6WnpKRVpzVUV4UW9vdlV5NTYrZFhkU2NoanNmRklDYm44eWIvNi9OL2RYbnpyVFRuV0FOMkxpSksvaWRqWFY3V3FzOHVaaVdOTTAxcTgxcmNPMFB0dzRyTHUvWG5mK2Iyams5anBoYXIxS1BtWGFSaUdFbUR5NUJJeTFRNHUxRHJSSjJ2YmVCMVFrSFYrYUVQUjQyaHdOQTM2ODQ0T3FNUldlc1pCYlllMzJLOFpnQ3l0NWxRdkt3NWN1YlB6UkJ4L1lmV3o0SElwMW9jeDkvd1pGY1VzRnRZb0dUU3BLajlMMWZVbnJIdCtvcHVQaE04d1VqQTl4dlhNNGxRV3I2dnFGdGZidWtQN2JYWC9wUC83ZnNibjVIZlRPSXlJbXhwaVIwaERHNzM3L0krZS83YU52L3dON096djN0SjNUMGhqcG1pVmRVMk16aXhoRDdEelNPWEpWbklGNlZoTTk2TWdUeGRBN1Q5OUYrczRUZ3RKMGtlZ1VEWXAyZ1ZoN1lqK2NHbkhkZWtTSVN0MzJuejg0YXY1QmpGb1BiVlVIQkNNU2pSRzk1OEtVd2haODhZMGpTUzM3cVZ3MUcyNnE4c3lyeURPVDVaa3RmSWp0Y2RQOVhPUDg3YzFSK1M4V2VmWTRndFVZaVdLVE0yTk1acmhpZEdpUEJ0cUpNVU94R0t5MUtHbGcxeUhSeW50RmpXSmpNZ1NPVVRFeENiZENUSGg1R21Ia3RPMEtNYmxHUmlQa293elhPY0h4M3FlZnVQaXZlaC8rSDI5Y20xMGJCblhiQlhmWUVsK3p4anlHVTNGQkdTZWNSVjNuSkl2bXdRdlR2WE9IUndlejRmc09xbXFNaUs3aFVXTk1QRHc2MUYvNzFLOUZFWkU4enpVRmhkNHRrTjl5YlcxTnVIalB0cno4NHMwMUViRVFZYlN6TzkzNFUzLzIrLzdJMDA4Ly9pRlJKTTk2UXRzZ3NTZXZjcHh6U0FqRUdEQjVSbUVNYmpXbkhCVnBNdFlBRWxoMUt3NW5EVVlOMWxnMEpvMjJieno5MGhFN1A1aGM2ZW5wRVlNU2ZHaFd5LzduRG8vclY0WWh2RnZQR3ROSnpzWTQ1OC84OFB2NTczL3lNNFFRMTZFZTY4SVlEVGRIOWNDbHpYc2V2N0w5cnFyTTdnVzJqTERudk1hbTljMTgxYzJPNXUwbmZhOGxLZzlGTlViRXBOa2hjNms0VkFnK1lLMU5DVmhyRi92TVVoWVorWkFrR29jVHhLVytFeDhVQ1hvSEpEUVFOV0t5aElPRVlUTm1VK2c4VVZOckZ2TmtQbGYzWFQ3SzdIYzk5dERlY3pkdkxmNTc3Nk1UUkJyWDliWEdxOVBNUnROaFY5R3haVElLRWZIUlFRejNaWUhMd0kzaDFMVHBzTlBCMTB4REROR0xTS2pyT2gxOHFucjNCUGx0cm4vd003L0phdFVSWTNMMUU1RktWYXVQZmQvN252eklSOS8xL1ZWdXEraHJOSFRFNE1pS2doQURlVkhnV2s4Z0lGbDZPcXJtaktkVkFnUHJqcVpic2xxMmRQMlFPdTRNRWpKODUybVhucjV4QkJlUXFNUVkxcUNnUmgra2E5MnoxMjh0Zmw2VkZYZnlBSU9DTHBhOWZzdmJIK0xuZisxbFhyMStuRzZ4UkxHb0JFWUs0MHU3NDR2Zjh2WjdQbnh4ZC93ZG0rUGlmU0hxSkVRaHN4bTVOWlM1d1dhMjdid2NSM0s1Y1d1dS8vQlRMMUczUFVXWkV6WERSSSt4YVVBSVE3dVVlRm9XbTJYSU1LaklzSldLVVUvOXVrSlViRWpreVg1d1NsRURXVXdtM3lrN01iVnpHWWt3R1FkeFZsWllFTlhsck0wM1I4Vy8rTVNqNXovLytTL2QrZ0tpK09EejQ3Nzk0a2hNbXd2VDFjQVNzQUlCb1YrMTU2dXQvTEVzeTU3MzN1Y2s2VzV6WnRqdmdWNVZlMVU5QzdyOEZ0TzViK2dDK2IvOUp6L0d2L2R2L2hmODdSLy91QmhyMWsvZkVyVGMzZHZjK2lNLzlOSHZtMVQ1aGVCWEdyU1RwbWtJM2tOUVRKYWhNYU1mRktXQ3dic2V0UldxaHJhZDA5UUxWc3VHMEVZeVZWWk5vR3NqMWd1K2R2U3JIbndZYnFZNEpDOFpZbkFTb3k1bWkrNG5UeGJkbTA4UElScGpram1QS2ovL3FaZmxlSEZHMlppS1kvS1crN2NmK2M3M1hma3p1MXZsUjR6SVp0Y0hxckppTXA1b2tlZFVaU21UeVlpOEtFZUNHVmxyZVB5aGhxMk5pbC80NUl2c0g2K3dHS0phN0pCeXUzN0lydEh3SkRWY2t4cmxsTU9sTVlHUmEzUXVSdTY0MUVlSVhoTjRxT21tVmhMdTQwOEhhT2hiejhuaFNselhxekI2K01IN3RuL2s5UnV6LzJRMmEydlFiTjQzODNQWnhuNUVwMTZqOWlHSUpEZElkVzFuSjV1ajk0L3k2bGNicmJ2N2Q2YjNQYnczdmVmY3VEeFhaQnZuUG4vay84Nm5YMzcyeFNIR21xRmd2cUlqNHpmOENmS09kejNDczErNGl1dmQrdlFvVmJYNEYvN2dCNTU1NG9uN3ZrVmptNFhZMGZXZW9CYXZQWm1rSjZpUE11Z2VFbW5QbWtUMzlwMmg2MWMwYlVlOWl2Z3VwcTFOaUJnSG9YZDB5NTUyMGROMWpyNXp4QUhWOWo1cTczeGMxZjNQWEx1NStDbmVuQ1liUm1XbVc5T1NiMy9QL2Z6c3A5NWcxZlJEcGpPWlFLVXdldktoODFlKys1dnUvOWUzcDluSGlGZ2ZWTGUyZG1SdmU1TVl2T1JseGRiMk9ld0FBSHJ2OE41ampPV3BSeS9TOVEyZi9PenIzRGlvc2JsQnhZSUVNZ2xFWTRoV2g4U3IxRmFkS3MxTm9wbUk2SnV5U2RaNzVLaEQwY1NCZG5JbnMrZlVaVUdHM2ZQc1lFbGJ0MWhqcEY1MWJHVDJ2VTg5ZXY0anYvb2JyLys4SUxtYTBGVWI1bzJ0WXZ4UUhucW1SdkN0b1dzaWFqd2IwajM1TDczN3ZqKzZ0Y0hlSk1zdVpFSDNSRzMxOGsxYjNEc2VQOXc5OUphLzh1ekx6NzkrNXVRNFMyM1J1d1ZDVXNSZGVlaWlmTzQzWDVIaEdDaFV0WGppNlN1WGZ2aVBmZGNmcnNiWmZZdjZDQ05DQ0FXWmlSaWpxSGU0b0VTVHB4TUZnL09Cdkp3Z21qT3JGL1F1MEhZUjUwWjRKN2h1ampoRlhhU1pPNWFMZnFDdks4SEhsSUVlSXIwUEVrSThQanl1ZjdycC9PRndjcHhTd0hzWHRDd01xN1puVkJyeFBxNGpDd3VGYW1kanRQUGRIM2p3aDdjbTV0dGp3bkxZM3R5UzdlMWQrbjdKWkxyTjl2WWV6am04RHdsY3lDeld3UDdCSVNmekE2NWN0Rno2dHZ2NTlXY1ArZHhMeDZkZXdDSmhHTXF6WVRtMXRoRktZR0IyeHZRQklQZzRHRDZrTzk5b3drUVV3VWRGMXFmTUlDb3prdUljNXJWamViSWFxR0RwNUdwWDNlYTVyZEgzUDNqbHdyRUoyeGZlZW5IeW5pZDJ3cE1qOFdoUUtUT0Q2NVZiUjA0Mk5qSjJkL0x6NWFiOUY2SVJXemRlY2lOY3Z4M2o4Y0tKU1B6dXk5WEdqWnRiTzMvMWFIYThEa3RhRjBqZ0RFMytHN3BBWG50MW4wOTk0bmtTblVReVZBdWcrTUVmK3NqYjdyLy8zRHU5YTB6UWlHcUdoajdkcTFHSVhVL25QTkVHVEpZUlFzVDFBZWRhK3RDeFhCMnlxbXZhMWhORFR2UkMxMFdDaTdqZTA2eDY2bFdmakd6VGFna1hBaUdxYWxTV2RmL1RoOGZOYnd5RjBheEpkOWFJK3BBeXpuLzE4emVZTFYxaWM1eHhWUGtESDMza2c3dWJ4ZS9yTzFlRm9Fd25JN1kyeDZ6cUdZYU1JcXRvbW5vQTl2S0J0QWhIeHllNC9waWRxUkJEaGlzTTczdnJlYlkzU3o3NTdEN0xwc2RJd25YRUpsOHFpMGwySlpyQXdSQWlXVFJFMFlSQVN0cE9tWGptb1R3OENOWTc2YldjMEF3RHZnVGxaSCtKWDV2S0RlbSszZ2VhVlhmLzNzYmtqOGRsZFg3WHhpbGRKM1dJU2NWb2hTb1g3am1YTVJwbDVLV1lHRlFJVU9XWnJub2oxMjgzSmxGbk5CdkRIM3JtOG9QWFAxNnZmdHk1L3BSMThHVW55VGN1VVBqd28vZnlzei8xNnl3WHRkR1VjMWNCazhlZnZPL0NqLzdZeDM3b2dmdDMzdDIwTXhFVDBkQVNKWG5vaE01REZGUnlmQlN5YklQZUJicXV3WWVVNVYydlppd1dDOXJHMGZjOWJkL2lYVWdGc2twVTlyNTFaekNQU0F4UmZRalNOTzZGMndlci8zeSs2Rjg5QXdnNkViUXNySG9mRVFOdEg2VnV2U0VKdUNwZzhzeWplL2QrNUQwUC9Ha3I4cmF1YzJSWnh0N09Ma1ZSRXFKaGIyL3YxRDZ1S0VxS29zQ0lzRnF0YUpvWm96SmlUQ3I0azBXUFlMbDBhY3c5ejJ6aGZPVFd0UVl4bWxxb0FXd1RZekEyVVVuTU1JK2s5ZThkQjVYQnpUUlJiOWJtMmxGUGpiVE5vRmN4Um1pWEhiZXVudEMxRHBGa0s1VGwyYURwOTFuZnRydjE4YXljenhjY3IzcXFYR1E2S1NoeWd3S3RDNno2bEVXWGVSVWpJakVpVjk5d0hDOUJqQ1hQTXpTR3Fzckt5K090N1M5ZVA3aDFTKzd3MmRidDFqYzJVUGp5aTljWmpVdEpCZ0pxUlNRSGltLzUxbWNldk8vS3VXOXlzVE5ZSlhoSDF6bUk2YmczUlVZMkhxVmVPNllUSWZyMTA5WFR0ejF0M2VON1QzRFF0VEhSU1hxbFczbm1SdzFkM1NmRzZ6ck1JMkVJRW9MNnBuRS90My9ZZk9uczdDRkNNRWIwSTk5OERvRHZlditWZGRzdm1tYVBVb1R5Ylk5ZGV1ZjJ4dmdkSWFhV2FEcVpzREhkSnFwbE90MWhhM3VYYWp4T2tkRlJBWXNQa2RuaUpDSG1rdU5DWkxIeWlLUVlBOTIxdlBYOWUvekJIMzZjRDN6YkF4QXl1amJndWg3bjNDQWpEamlYbEk5ckRVd0llcHBWRXIzaVEzckZNQVFCeFRTM3JTTWJqQUY4NVBpZ29XMDl4aHJ5SXFlb0NvcHhTVG10S01jbFdRR3oyUExwZzVYOHcrc25jclB1cWRiMEZvRlJibkI5VDFmM2FCUHdLOGZKTEhEN0pPQjhURkVXWVFoa2RQMGpsNnZwanp4NCtjcTU0UlF1emdDSjM5Z3p5SWMrK2xZKy9vdGZRSWNCMXhqSzBiZ3MzL0d1eDc1NWU2TzZwMWtlRUtRalJvTVJTMmFFcUdiWTNhY2RmdTlhZk5lZ2VMd1gyaWF3V2k1bzZtTjg1d2hkSUxhQlVIdUNVNXFUam1iZUVWeEMzQmtrczhOYVZKMlBuejQ0YW41U1ZSZG5Cdk1vSXZyUWxSMnUzNGJ2K1pZcmZQSUx0Nlh1N2hqV0tWUVhkNmRiVHo1MDRUdXFxdHp1K3BsbVdTWTcyM3NKbjRpUnlYU0NpTVhhbktLVTB4WHRiTDZnNzJxeVN2QkJtYzFiZXVmWm5KUjBoYko3cFdDVWp5ajJkdm1PNzcrSGN4ZTIrTVdmZVo3VktuRWpSZTRZMGxrYjBzbGlCR1BqUUUweFNFanpSbFlZeEthVFJOUC9JUTdSY1JLVWR1bHhUU0F2ayt2aWVGd3htaGJZM0tZQmZsZ1ozenFvY1NlZUt6dFRuamkva1RUMklsU1ZSZFV5cngyck9yQ3htZU9EY3ZzazBIUksxSWp6aml6TDhTRmdyQmhwdTIrOU10NysvdGZrOWY5S1ZidmhQVjFINytrM2JJSGN2SDRrSXNhSXBNaXZHTFY0NUxGN3o3LzFuUTk4SUdocmxLQXhHTW1NUld4QWZVL3dpZzhCSHhxNmZ1aVJRNFAzamhnelF0Y2x0NUt1d2ZlUnZsZGlIeEd2ZEl1ZVp0NmlMcVorZTgxb0hWb05GOExoOGF6NThhT1Q1c1ZoTUQ5ZDY2WlpOVkhmczB5NGRWUVRveHFGVElRU3BYam5FeGVmdVh4eDg3M2VxemdmWkhPNlFWR01nSUN4bHFMSUVXUElyTVhZL0xUVjd2dCtPRDJVemlkcWZXWXRJU3JWZWN0MGN3cm1IcUt6OU0wTjduOWd4SWMrOGlDZi84eHRidDZjbzBQeTFkbXc5WFVrYlZRbHl4T0NibUpDMktNR3NzS0FqNUJiTkVhQ1QxRVJyZ3RVbzR6Tk9FYWpNaDRYVk9NY2t4czBwcUVmSm14dGpiaTNqWHpIVy9hNHZGY2xXVENRbWVTb1A2MXl2STJZa1dGVlIyNGRoNkVkdHNreWFaQVJGRVdHUkpmNXR0MFJrYkdxTnJ6Wk11Z2JzMEMrOS9lL2g3LzdkejZGTVVaVTFZcElJVUwydm05NjdNbnpGN1llNjN3dlltMEM3N3hIQmhGVWpBWE9OWVMrUWJzdXRVYSt4c2FNdmwzUXpHZTB5NTZ1RHJnMkZZZXE0cnBBcytqcEd6YzhQZGRldVVvRURScmpzbkVmZi8zYTdCZUh3bGpQSFdGVTVmSGMzcGlYWGowR0lIL3kvTUFZSFBoaVNqa2RGNU4zUFhIeE96TEQrZGx5UWZDQjhYaEtubG1jUzdydHpGclFTQXlCckxDSVpQUjlTNHd0NDFHRkVGblZDeERJak1VWncyalRvdEVTVFViZm5kQ3VUcWhyei9idWlHZmVkUS81c3dXdnYzcElzK2lScy9qSU1IeG9IQXk1YzBQTUJIRUJHdzFpQjgzNm9KUmtvTmhZZ2JLMFdGc2xWV0p1eUhNN2lLN1NxVk5XT2VmT2IvRE8zU21QbjV2UXUwZ3hiTVo2VFdtTDQxR0dsbWt0ZHVNNFVIZkpaZCthdEZLcm14NGpoanpQcUYyLy84cko3ZWVNbURLaUpXZ3p2TGZoRzdiRmlsR1pUQ3FwNjg0QW1hcm11M3ZUemUvODJMdS8wK2JaVkgyZExOZERQNWdTcE0yZmFFZGxGSXFNUlRjbnVBWFdON1M5U1lLbnVzTTNFZDhPS2tFZkNWMmdXWFQwZGY4bVZSNHhFbFRWQjZWejRZMkR3L3AvOFQ2ZXJGbTZ3MU1zNXJsbFBDNU92L1l2dkh4RTU0S29Za1VvVk1rZXVYL3J5dVVMazNlSDJGdGpSS3V5WWpRYXBlMVA4SWd4S0lOMGx6UmtaOVl5YXhvME92SzhZTG5xOGM0UERGNGhsakFhRzBMbzhOMVZtbVZMdDBxdDRtb1Y4QUV1M2I5SlVWbXV2MzVDdldqVGZESDhFeW1UODRra1VxUEJwQXg2a3dpUUpsR3l5QWJ4bEVSRE52Z0tCNituOGx4ckRjWkFMaWt3S1BqSTVlMEpqM2lsYVQwYUlPWXA2VGNWVmFJTEJ4KzVkZXk1TmRQVEU4Nkh0S2JPczBTbGFidWVXOGNIZTFWMC8rcmpPK2NmUFhEZGYzbHJkclRpakpmd04xeUIvT3QvL252NWliL3phL1M5UzB0RWtVSlZ6YmQ5OUptM1BQYlVnKy9KSk5pdWIrbTZaZHF1ckowemhuUlphM0pDQUhVZVh5OXhiVS9kS0NjTFpkbEM2QlhmUlZ5dm1KaEF3cmIycVQySVo2V3J5VTBucXJZbnMrWnYzcnkxK1BTWGc0SlpablUrYi9YU3hlbnAxOTkyUVl4SlNrZFZjbXZONkh1KytaSHZHWS9LQjRNUGFyTmN0cmRMaW1IOTNIWTFrL0gwdEcxQ3dRL0xoTVZpbVZxWHZxZnZCMG9KRUxGSXFkak1FTDBuT0VmZmFZckhEV0hnamlXeTVlWldSWmJ0Y3ZQYW5QbXNKdmc2a1M3WHhnNEQxZDByT0N2a2tsQ1NiTWhoVnl1SUNsbVJnS2dNQ0RZbGU2a3F4b0Fha0dINXFoSE9pVkJwT2hXY1N3QnRWaVlHY2UrVW9oQmNORnc5akt5M3hUR213czBISXp3ZkluWGZVWGVMc1pIdytFWldqdXhvK2pPM1prZTNSQ1FiM0IvRE4rb0pJaUdrTER4VnpZSHlmUjk0L01rc2srMStWV3ZvdlJCQ3N2ZlhpRG9IQVl5VXRHMmdiV1lzajI2eldIU3NWdEExZ2FPRjB2bzdTWjhhRk5mRm9lVktvT0JhMngyVDVGVlJwRzdjTDkrNHRmakpNMnpkSHZEV21yaTdWZW5Kck9XNUZ3N09mdm1DbmtZRDJHY2VPWGYvcGZOYjN5VFl3aGpCb2xSVmhqWFpNQnM1c3J4STd1bHRuN0FHSDBrTml5REcwcnFldGgyc1JpTmtOaWNVSWNsaUFlTVRhU3E1L2FSWkFpQ3owSGNSWXcyN0Y2ZGtwZUg0OW9yRlVVTWNObFRKT1dVUWxjV1VvVmprQmxPc2ZScUZnQkxOMEhhdHlZd3VSVGlrK0dzWmJGUlRqVzRNVzdETUNzVWtJN05DQ0lQT0pBcXU5OXc4amh6TVErTDREeWRSMC9tMTZBUURMTHVHWGdNVExFYXpEZGY3cmVIOS9jYmVZaTBXN1Zwdm5nRTJ6OHowa2NmdmZ5SjI5VGo2dVJnVHlLMUJnZ2VKckc3ZnhIVTk0OTNMckJhSHJFNzJPWmwxMUxYU0Q2ZUY2d0t1ajRSQmFJUVl1dHF6bW5jSk1OUjR1ajlNa1FkQll1VDJmTm4vNUh6UjNlQU9sZDBCTVViVld3ZS9WU0lxZ2tSVkkwTTI0T01QN2oyVUdiblh1dzdWU01RZ1dGendlTjhqQ0Q0RSt0NFJOWkpsR2RZbWVXMVpqa0JiWEcveEVRcWIrQjgyTDFEVEpZSnhTRTlmTkduT0VSQnJDSDFJV25XWFZyb0NqS2NseGdyTDQ0YlZTY0orMGk2NklpOHNHdE5UUGdwRUsvUkFNYlJTbUVIdkhnemVwL2ZSRDBoN0RKRWlSRVlLbzZCTVhLUVBrYTFSUVo3SnNPVFF3YTBGbWs1NWZkL1R1VWlXRFlJdGtpVnFpQkhSeENwZXRUVVNZYkl4b2NqeXZxL1hiaEg2amNuRitvLyt5aDlHeVRrOFdHQ01uQXFLUHZUaHB5NWQyTnQ4ZEZLSXdRcXVkNmdLMWdyN0x4enoyWjk0aldBOTl6N2xtTjdUVVRjdHkrT0lqeVJYd2FDb2owaElqL1lZUWF6U3Q1NXUxV0ZQSTlBR3pVUVNSYmkyOS8vYjY5ZG52OHdkVGJrRFFsbGtPcDNrSE0rNlU3T0Vzd2NJcUZHd0lyYTZjcy91STVtVlRSK1NzalpxUkZXSW9WdXZrd2plRDdRUVExRVVaRFpSZ2treEkya0Q1eFUxUWxHVUdDbm9tdzdmcFRXMDh4QUNlSitLUlFiMHpJZUl6UzFXazdJeXM0YU5hY1c0eXBtZE5NeVBhMXgvVERpM3djYldoS3pJRUp1U29YS1QvTFkwcGxaT1RxVmVnamRDSGdMRnNtY2p0K1F1a0RVcExpNkxpbGhoUENrU3lDNWdNakFoZ1pkUmxlc25nVlUvSkFFUG1GQ0l3MW81UnF5MXpPb1Z6cmNVeHVoa05KVm81R2J0dXRzRGJ2bU55Y1hhM0J6eEgvOUhQOG5RdzY4TEpIdm5leDUrb0RMaG5rd1Vja3NJRmo5dm1lK3YrTnhQWE9YbForZUk3Ymo5eW9KekQ0N1llblNVUEdqYlNPampFS09XSU8yd1JvMWR3SGVlMktkWU0xay9oWWUzM3ZuNDJhdlhaei9ldE82UU15cEJraDVKWmNBdnZzSzEzbUNaeWFnWWJVN0dEK2Q1WHZRdURFLzhMclVtd1pQbkk1elAwbitQYStlUzFGcTV6dUZkVERnTWtvaVcxaUFtSThzSzFBLytQRU03STRPVnFaTGFwUFR6dEdsS05KTkExS1JGejhxTXZYTlRxbEhCeWRHU281c3ordGF6c1RPbEdpZVR1V0FoR0hDa0IxR2FMNFJnaEh6bG1GeWRjUzdQR0k4elJCVWZOVmtLWlNrVW9TZ3NNU1FsWVZTd1ZaSW9MdWVCVzNPMzNvMFAydmYwNEJLVFhPd2IxM1BVekZCVlJtVWx1YTEwMmJlL2Nkak05b2Z0MVpweThvMVZJQysrY0l2cHRCUlZSUFZVVmxzKy9OREZCM2YzcGx0aU9qMTVvNVpidjNIRTZ0b3hyNzI4ejdYck0xUVV3UkpjNVByblRyajE4b0xkeHpZWW55dnhhVTlMTnZUU0VrRjlwRms1VnZNVzUzMUtkR0l3ZjFNbHd1R3R3OVhmdUxtL2ZING9qRlBFWEVSaTAzckdvL3hOWC90ZitsTWY1Uy8rMVo4N0s2YzE0eW92Z0ltcUVJSlRqU0txR1dJc0lYUVlXMkZNbWgyNnRxTW9pN1FPZFpHMlRkMUUyM2hVSTBpQnhwVHlKQVNxUEFkdFdTdFJrODVqY0daTTN3UERhSkU4ZTVIVDVYVTZ4WlRKdEdTeVViS1lOUndkTEtnWERidm5ONWxzalRHa0U4Q0lFSndrUGtDTUZBY040LzBWbThhUTJkUXVtanpscS9ob3FOdVdNdk9VUlVhUm1mUjFJQVE4U3M2Tm81N1pNdEFuSjVpa3REZkQxeWVRNTViRFprN3RHc2JHc2puYUpDSzNGcTc1NVQ3NG1qZEh1SDNqNENCWmJ2aTdmL2ZUdlBMUzRacURsZ0haMWxZMTJUdS8vWEFXeS9MYUoyNXk3ZFA3aEpNVit3Y3p2dlR5Q1dJY0c1UFVObWxVOHBIRk5aNWJuemxpZW5sQ2ZzK1lJRUxmeC9SaG1hUXpuKzJ2T054Zm9FYW9UT0k4dVJnVklTenEvcWV2M1p6L3lwc3dqK1JleTZqS1dkVTloOGZObTcvK3pIQitaOExCU2IwK1JjemxpOXRWVldTalJGa3h4TkJqckJCalFFUEEreWE1Ry9wQUNHSFFuRVM4YzRsNmJqS0NLcG5OaUFRVThBR2Fwa1pINEIza1ZScCtvdzRLUVN2WTNCRGJnTzhEcmc5MG5VLzYrYWpFdGRQbjhCVEtNOHVGaTV0c2JGVWM3UytaM1ZoUUx6dTJ6azB4T3hPTUdIcHJLSDFrdEwraXZMV2l5QTIxVmZZUE94WjlvRTllUVdpTUhDOVdiSThLM3Z2WVpjYmpDU3I1TUpqM3JEckg2N2NibXNhak1peERZdHBhQlRTWjFhRXMyaVdxa1hFeElzK3JXSHYzeVJ2TGt5L3hGYkxXLy8rcVFQN3YvNjgvUlZZS3YvSHhGL2lmLzRkZllibHNULytmS3J6ODBvRzRQdGpCREM0SGl2ZC95ME1YZC9PTmgyLzgvQUhYZnVPMnF1K2thMWZzbjh3UUV4aVZhZDBVWWlCMHlpaFBFV1ZkNXptNVdsUE9ldkp6SStKR2pqRkMzMFdXaTU2VGt4cm5QQ2JMQnM0VkdqVks1L1c1NjdlVy8xUFQrc09Cak5nQ1RpR21SL2xYdmo3MXBSdW52cnJyQXRuZXFNYlR5Y2JZbU9GemxiVmxpSUFFbktzcGk4a0FUcWFXbzFrMUdKc2tKTVpZakMzU3orTUtIeFRWREdNVVYyY3Nac3BtbHF4NWROait1RWp5MndXY1Z6cVhPRTYrZDBra05iakdtOEZGTVE2dDJNYWtaRG91bVhVbkxBNDdUcGJIZE11VzdmT2JYQ295OHBPYTQ1c0w1bTFQMHp0YTU0bDRvcVp0Vm1ZTTQ2cWtkWUdUcG1IMGVzN2U1cGlONllRc241QnB4aHUzVHpoWjlxQnBDUkVHUVVyZkJXeG0wQmc0NlpZcys1WU1RNVdQUU96eHdpMS9jZEUzKzl6eEZZdS9wd3ZrTC96bEgrYlc5V1ArMS8vcFY3aDk2eVFSK0g3ZnUvbUZuLzJzN08vUHVIM2pHT2ZDT3N0Y0FJS1BFa05jeHhkVXd5cTl1bi83M2l1ODBsMDVldjJBamJISThXSEw5VnZIK09qWkhCdjZHR2o3bUJxSUdHbDhaRFF1Y0NvRTljamMwUzA4eGJrUjJibVNlZU00T1c1b3UzWFlwaEpkTWpnTHFqY1BUNXEvdG4rNGVwRTdEaVVPaUprMTZrUGt5MnczNzJ6ZW1wNjZkWEtXU0RjcVREbXFpaEVhME9qRjJDS1pLc1RCQ21zSTNBblJnRWFLTEdmUk5lQVZWVE9rNEZwa2FMdlREVzVvKzBCVmplbm1EYzEwb013TWc0Y09xelJqVTc2Z2M0R3U2L0Z0bjNoVkpxMVV4VnFNVVd4STY5c1FGV01OMDRsaDB3bE5LS2dQSE0zeFBsOWFkalJMUjlNRk1odW9xaFRGWUkya2JlS2c5Zk0ra3VlR1plKzRkcktrOTVGRjA0T2NVTmljL1pPZTNrVkNTTEpnTVVMd2NjQkFMSzN2dWQyY29Cb1oyWklpRzZrblBydmZ6ajg5Rk1kdkNkNzVQVmtnRzVzajJxWW5MMDdaK3ZKelAvMXBFV1BRcUtLcTV0VGI3TGZhNEdRRDcyWmpkMmRuKzRuTlJ6NFFiL1c3bFkwczZvYnJCMGQ0QXRaRWdpVG1hVzZVcEdsS2pvRks4b1hLTWtHakliaElmWDFGdHVocEM1aWQxQWt0SHA2NlBrYkVHcmRxL2Q5NTZlckp6NGFvcXpPWVJ6Q0RwOVh1VnNYUnJQMkszM1B4WmxzYUFTZ0ttK2RaVmtSdjE4NXJnMTJvQWhreDlNVFlFUlZtc3dXanlRWlpsdUY5Uklua1JVRmVqUEYraGNrcWd1K3dVZWxkUktTajhVS3hxN2lRVGdzR2FheXN0ZVNxQkIvb216NUZWN3NBQW5tZVliUGtzaGlqUmFOU1JNVmtCaU5LN0h0S2E1bVVCUXVYY1czbHFGdkZ4cFJLNUh1REdSSjY4MGxTYldZSTR6eVpReXpGTTI4ZEY3WUVGeU1XNFhDMXdNZUEwWXhrZnhYSmgwSGVoWWlnSFBZejJ0Z3pGc3ZXYUlPaUtBOXZ0UE8vZWRLc3JwOHBrUEI3K2dRWmowdis3WC90ditBajMvVjJtYzlxc2RaSWpDcmVSeXVpQnNHUUJuQ2JiUCt4bXZRN2EyK29YRlVueHRqeEQzM2JoNy9qa2EzTmozV3JsYmgyeFN2WGJ6R3JGNVNGZ0NRTXhOcTBtaldEVTBjMFN0Y0hyQjNzYkRURnM0V282TEpud3hxV1ByRU1sZlRrVkVOMExuN3k2czNGVC9nUTUyZTNWaUxFODN0am5Zd0xiaDh1Zjl2dnUyMjdVMHVnTy8vTng5NkhVT1lsRVlOVmk1SVFzMFFNTkFQajFySnNPcHFtVDF1bXpPQjhlaUlYWlVuYnJzaXluTmE1Qk94aENkRmpZOGJ5YU1WNHU4Ujc2RDE0cnppdk9KL1NydUlkYTlSRWErRU80bzAxaUtZOEZLY1JHOU9hVnpTU2hZQnhrWFBqRVJjZlBjZnRXYzFydDQ1WU5KSGVXU1kya3BsSVUzdktTckJGd2JTc21FN0diRy8wck5xZW9zZ29ja3VPb2ZPZThRaktMTktJSFZ4VEJ0WkNnR1dvV1lRbUZacXB0TElqYmRUL3lvMzY1Sk5EYUUvSFY0aHQrejFUSUpOcGxXdzlCYkxNeXMvL3pHZGxiUzQ5QUg0NWtLSGtvSmxxS296MVd0UVl5VWVqWXBRVitkamhxL2MvOXRSajc3bi95citjK2JDM2YzTEVyei83T2NaNXlhZzA5SDBjTmpOcFRkaEhLRFRwTi9yV1VCVEpFZjNVb05rSWVXNXhmWUFZT0NjWlZvUWo5VVNpQnBYWDN0aGYvbmY3Ui9YcncxUHE5TU5RUmJjM0s5M2VySGo1NnZGdisvMEhOYi9GVWFCdW5ldDcxMDlIWTVCU2UrY2xzd0ZWbTNCeWt5SU5GRWRkZTA1bUM3YTJ0dEpKZ0NHcVVoUUZZa3BVSFNFT0J0TVkycnFoTE1Zc2JpZ1VudUFodVBSK0JEZUVrZlllNTlKNlY0Y29EOVZrS3VkVmg0OWpFRXA1ZytsOTRsZU5NbWdkT2VEYkRwTjd6bFZRbnFzNFhuYURBWGFhRy92Qk9WNVZXZFFOM2hoMkp5UHUzOW1tQ1QwOUFTdkNxTWhaK0paeEdWZzJpV29TVk1uempLQTk4MzRGS0lYSm1PWmpRY3pKUWJ2NGU0M3JUN2pqYS94N3MwQTJ0MGJNWncxVlZkQjJiazBGc0RIR2ZMMnFCY28xTTNmdjNOYjR5b043Mi9mZHYzdit3cVh0UytjdVRNOWRlV2p2NHZtTGt3dk1GdFBteGFNeUxpL2ZOMm16QjRnZHIxMS9qWC80aFMreFBaN3k5UDNuMmRrWXBhMVFUTWZ6NlljZkxlUEtRZ2JMbFdOODZ0RTNXRkpKSk1aRW9kZ21NVmtQb0w1eDB2ekUxUnZ6THcxdi91bWVmVzEzR3p6VXE5L1pmZHphNG93dDZLbCtOYWlLTjJMWjJ0am04R2dmd1E2aG9TRXhhY1dpYXJDMjRYaDJ5R1E2Qlkza3VSMkFNeUV2U3BwbWpzWkE1ejBpRnVjZEloMmxHVE8vVlpOdEdseWZwTVZkNytuNk1FVEx4UUVYa2FHbFhEczBCdkNEeUR0S3dvRjhTUFNXTEIzejQ4SFJwRzU3TkNwbFpyaXdXZEY3ejZycnlMS0szcmxURTcwdUJHZ2JEcjNEaE1qbXhuZ0FkR0ZjNVN4V0xlTktxY3FJYjRUY0dJeFJacm9rcUdlRVlTc2ZhMVZXMG9uL3hGRzMrdnh3ZXJTOE9ZM3E5eFpRdUp4MWFURHVnOFNnUmxHRG5yb0dqb0RxYmU5OGNPZERIMzNtN1JjdmJsMTU2TEVMajErK2IrZkp6ZTN5ZkZXWmlkaVl4YWJQVnA5NTNYYlA3WnVtdmlRck44YTNoN3gwL1NXZWZlazV5Z3dPVnd0KzVibUdSeTV0OGNpbFhkQ00zRUNXQ1prSU1WZXlBb3JNa3B1a05wUVVDcGdrdFFyV0pnT0V2dmU2alNYMGV2enFJcjdHSGFYYXFmMmxLbUtNeUJzMzU5bzZ4Mlk1WWQ1OVpRZnlvL2tTRVRsclRhT2tJQnFKQ3FQUlNMYTJkbGtzanRaZUk4UW93N296WXNUUzFNY3M1MXRNTjdZVFNCaDFrR1ZraU9RWWE0bk9vOUZEaE1WeVJWbE9hRHVQUVhBQm1wV25yWk92Y0l3REdURkxzd2FxcDJJb1ZOR1FvckFaTUFoVkJ1MTlwUFVSQ1pGeG5yWjgzZ1V5YTVLdTNSaEdSWUVMZ1hGWjRIM0FhOFFGandtR1JlYzRXUFE4WTRUeHhvUVFIVmxteUsybEZjZTRpblErUTZPd2FHdG1ycVpBMk1wTEtxbWs5N28vay9hbmw2NDk0YzFKVkcvU28vK2VLSkNOblRIOXl1RmNrQkRpYVY0SGd3N2JHSm44Mi8vblAvUk4zL3pCSi8vQXc0OWQvSlpxWkRZVUowUzFQblJFaWJUWEZpeCs2WVoyejUrZzA4dUViRWZiK2V2eS9JdWY0ZFg5UTVZKzZXT3FYR21kNDNOWGp6aGV0VHh5WVlkekd4T3kzTEpjS2F0V3FieGpjNm9KQzlCa2dMWnFrb05KV1ZvR2gzSnNaaVQ2eUxuYzNQdk5sM2QvOVB5NHlqNTViZi9uSWE1dFFGT0FjMVR2Zll5bExmVDhaUE8zTFpBc3k0aDN6UDhVMExydHV4QzBVNDM0RUhROG5vcjNnYnBlZ1FRUWgwYVgyaDVOZ05uaDhURjVNY0ZtYVlNUkJ2RlFuby9wKzJTZzBqdEhESUcyNzFuVWpySWMwL2tlSFVQZnA3a2pwZDBtVGZvYVpnOCtyVlpsYlRFVlU1SElBQ3pHZUlkNHVGUkw5RUhQK1NDVElrT3N3UThuVCs4ODFpUWpiR01OaFVBV2t3UlhCV1oxei9HcTQ5TE9pRTNnK3FMajNyMlN6WUVMbG1lZVpSdXAyOGl5cjhrVmNtUFltVzRUZXFOTC9DZXV0eWVmVlZWL0J2ZjRpaXYyZjY0TEpCdklOajZ1VjdTbnhURUNwcU5Sc2ZtWC9zTS8rbDBmKzc1My82dGIyK09IbllzRTc0Y1BxRmNSZzd2YXl2eG5EM0EzUmVMb2ZvSXRPTHA5aStPVEE2SXBzRFpIUXlEUDAzclREcDN6R3djMUo0dU9SeTl0YzgvT0ZyM0xCbEtjc0dvOGt5RUxvMjQ2VmsweWZUTUNaWkhqTmRMM0VMeVM1Wmp0bktmZmVuN3k1d3BqcWs5Y08vaTdMcnJUREw2VWd4bklqUDF0N1MrSHpTcXJ1anZWSWdGNmNMeG9ldWRxQVlKem1NSlNWU1BhcnFQdi9PQkVtaWdySVNTWVpiRThaanJaWkc5dkwrV1lpSUJFOGp3blVoQkp3M3ZpWHdsMTYrbGRUMTRJYmQ5QklhZVIwT3ZKUTlleTRXRTZqOE15UVJtTUdmUk5na01BRlNLTkVZNDBSRUx3MHp6UGZZamtSU0VXYU5zK3lZSWxVZVVuVlltMUJqWFFCOWdjWjFSRlJtbVU0MlZObnNPVjdSR2IweEhqMG5OMHN1VFd2S2RYaHhWaG1vK0p6bERraFo0ZmJjNWYyajlvZVhOY3hGYzBqdnZuMHRWa2QydEswL1ZZSzdndVNJeS9wVGcycWxHeCtYLzZEMzc0WTkvL0ErLy9jK094ZWJEck94QkRiak14UmlXWUtOM3JyU3ord1NGYUZ6ZzdvUS9LclJ0WHVYYnpSZXJ1Qk5jN3RqZW1HR05UVUNiSklSd2lSWlpvSWZ1TG1sbmRzVDBwMkJ4bllKTkdJYzhpem5tYUx1QTg1Rm42Nk5zK0lobVVPWlNGV1h0SGFaN0o1dDY0ZkdwYWx2VzFSZk5TVEN1cDlUeWlVVlU3NzNEeEs4OGkxMitmckF2bDFFVXhoREQ2d05zZmVQLzJ4dmp4dGxzaEp0bENsMldPZDQ2MmE1Sm9LWVlVeGdPSVJKcmVNWjVzSWNZT1BLcVVEQlZWNkhwUDNYcWFOaEtDSlVaaFVYZEloQXlESXdtZ2VqZHNybHpBZVk5M2Z0Q09CRUlRUXBCQk5aZ1dHc3BwRUk4YUE5WVFRUStXWHYvZXZJNC9hMExjc1lTOUNHUjVKcmF3Q2UyWFpKVTZIVlZNcXBMRnF1ZWtkZHk3TitYOHhwZ2dVRmloR0F5d0YzWFA3WG5Mckc0NHFWc0NTbUVLZGtZYmhBQlp6Q1N6MmZHUzd1T3J2ajArU3hMOTU3NUEvdVFQZml0Rm52SENhN2VZVGtaNEh5V2NLUTRSeHNER2RHTzArZS8rK3ovMCsvN0FEMzdneitXRnZ4eER3SWdScFJmblZqU0hDOW9qUi8vcEJxa3puQlEwVGN1Tk4xN2tqUnN2NGR3Uzd6eE4yMU1ZT0wrM3c0Vno1NGpSNDRLamQ0bDJVVldHb0RDckhZMXIyWmhrN0c1V2pITEI5WkY1SFlnRCtKMW5RcEVMdlNhNlNXN1g5R293UmtSUXJRcVpiaGJGVzZmRnBIMWpzWG8rYXZSM2lrUzFqLzRmSjBkdmplZVV6c2ZzSFkvZisvREZ2ZW03Rkt5cWtTeFoycERaSE8rVEhkR2FTS2lhREtlNzNyRmE5a3pHR3drRjl4SG5JeUVFTkJxNnZtZlZEdHVrNFFTYUx6dUlGaE1FTHdFWFV6UTFJZUtkSi9SRGtRUWhHY1VNcVR5RFNGMVNVV0NOaEtqNld0dkhuemhaK2YvbWNPRi85cWdObjIrOVBsOVlPelhvaGQ2N0FoTHVaRTNTZWh3dVdyQ0c4eHNUem05VjVNWlFadWFVRW0rTllJMFpJdThDeTZiR21JQkV5OWh1VU9RbE11eW9vbXAwMGYvcXNWdmRQQ014OFA5Y0Y4ak81b2p2L3RhMzhzYk5FNjdmT2lHRUtEN0U5UXEzSkNVOWJWU2pZdlBmKzcvODBQZisvaC80cGo5cjdQSmVGNWFxQmxFTmRHNkpjdzF1NVpuL2VvczlFWnBXV2MwWHZQelM1M2o5NWl2MHZoMElkVG9rSjBIbk9qWTN4dXh1NzdKYzFUanZ3YVFOVmdpcGRXcWlaMzllVSthV3JYRkpEQ1E3MGpoUXdBY0hEMUNxVVU1VjVZbHlNZUFsR2xTS29tSmpPaGx0bC9renBkalo5V1h6cGFEeGJEclU3MWdnMWdpRGUrZmF3VDNibXBRWEhyeDM3d1BqTXF1Y0R5SkV2R3RSaGFvYUVkWFM5dDN3QkljWWs5dklZclVpeEl5aXJPaDdSKzhWMXdkQ1RJelhya3UycUtERFRlcVlyMXFDQXh2TjhQNEVtcWFqYnpwQzc0bUIwNEU4cVFuQldCMThzMENFdHV2MXAvWlArdi8wY09GL3V1N2lLMUZaQUcwZDljWnhIei9WOXZHNmllSGVxckI3MDdKS2V6aFJ1dDZ4YkhzbXBXVjNPbUxaZENtR09rdU9KMlZ1eVlkY2twM0ppQ3JMa25LeUt5bnpDVDRFNkNJOVFVZFpVUm5EbDI3MDh5K2VvWmQ4eFRua24zbUJmT1M5VDdDek9XYXhhbm5wNnI1Y3YzVWl5N296M2djN2VCV1ZJaklHTm5iM05uZi80bC8rNFgveHU3NzMzVDlXVmx5T1lha2lRV0xzOFc1RkRJNWlQSUpaU2ZkRmp4R0w4NTZycjM2T0YxNTVEaGZTazdMcEJ0K2xQSDM3UlpsaHM1ek1abHpjMlVOMTBFOUkyZ0toU1FRVmdmMlRobVhiVTFxREVaTTBJY1BiNm4yU2U1WWpReldxTU1iZ25NZmFqR1FVWGRGNXIyMWJqekxNZ3lIa3o5NXVWcStrUnVRclA4SE9YbFdSRVVJVVNjclVITWlucGJseWNXL3pRenRiMVZSOW04eDBqRVV4aEFoNVhwSGxGYjBMTkoxTDlHOFZWQ09ISjB2eWJJUXhGdWZTU1pKbWxYUUNkSzZuNjMwQ0tHTkUxYk9zRzlyYUkzM2E3RG5YMGRSMXlnUlJjK3JVYUF6WW9SMDFZbEJ2bG4yZi9hMzlrLzYvV0hUK1JWWFdJYVNuZkxTZzJpeWlQdTlWWHBrV2RtZFUySHR5YTdQT0IyWjFqMWpENXFSa21tZW9zUnczTGROeGlaV0U2YVFGUWFLNmpLcWNHL3VldXNuVEtybnZNWUNUU0dtTFBLcStmdE12dmh3ay9PZm5CSG53bmgzK203LzhyL0JMdi9FU2JldmwydjZKSEJ3dlpMSHFyS3BtT29TL2lEQlJaWE5uYjJQNzMvNzNmdUFQZnVmM3ZQTlBqNmJsSlEwclFxekY5U3VpN3dqT0pSditZR2srSDlFVHdlU0dHNis5d0plZSt3SjE1MDhacWV0Y0NrbXNPbmEyZDJqYW5sc0grNVJXbUk3S3BJY1dReVFtaHFvSU5rdCtXTGRQZW82V0xhS1JVWjVSalRMeXdsSVdoaUxQeVl0a3E1UGJrc2w0bXl6UFFBSUhSeXR1SHkxbDFYcFdIZDJzRGI5MHUxMDlONXdnLzhnQ3lUUEJCUjAwNmFsSXptMVh1OVBTZm5CYzJkMVJhUWpCZ0F6S3ZaaEVUVmxXWW0xTzJ6bVdUVVBuVXR5emN6MjNEK2NVMllqTVp2Z3dzSDZERytBZFMrOTZWazFEMjZkTWs2aVJ0dTJZSFRkMHE0QU5GbEZ6ZWhvYlNkb0xKQW1pOEJaZlp5ZkxPdjcxZzJYMzEyclhYeHVLWXNFZEZlVlpIaFJOMUZ2TFBqeWJHOG5hM2o4d3EvdHlPaTU0K09JMjkxM1lUS0l6TEZWVnBJSmViOGcwVWQvejNOSTZ6OVhySG8wWmJlenhNWkJqYVZFQ0twWEo2a1hzZnJWVE56dlRZb1YvNWdYeWwvNk5QOHg4MmZERmwyOHdHUlY4NmVWYjhzTFZXK3RaSXhzeXlVdGdERXlCNlZ1ZXZPL1N2L01YL3ZBZi9zN3Zmc2Vmc0VXMnF6aUNYeEI4TTJScUNFRk5Fdi9NRmYrS0pUTUZSN2V2OGZGZi9rVU81c3UwenRUazZwSDI3Y2xMdHNnenNnenFWUU5LY21Sdk9uSnJxUEtNM2tYNkVBaWFRTEcxNGRtaWpSeXVPaktyWE5pYlVCWEo3TXlZOUNHTnFpazJ5Mm03anVCN1ZuWER5YnpCUjlYR20zaDk3bjc2eGZueC8rUTBMSG16RjlOdmUvbHdHajk0T3FndmFxZVBYOWw2My9Hc2VYQnpVaVIrR01NSm9oRlZpdytwV0hLYllXMUIwMFhhTHVFT3pqdU81dzFGWG1Gc01zYUxnOCt1U0NJMHVwQ01yanVYNWd3M3BQTXVUbG9XOHc3ZktqWmtaT1FwNjcwWFFtc0lqU1YwOW1UbHduKzVYOWMvM2tkM3dKMk14UmJvNWM3RFliMnc4SUIya2Zxd0RjLzFQaXd2VGNzbkhqaS9PYnF3TlVGVU1NV3dYUENCNDFWREh3SlZtU2RDWTR3VW1lWHdwT1BhZ1NNUTZLTW53YUlHaTVGV0lwdFpsVGZhLzhJaXRqZS9FczM5bjAyQkNQenc5MytJbDE2N3lhMzlZL25TeXpmbDV1RmNRb2gyWFJpUzhJM3BVQ0RiMy9iaFp4NytQL3pGUC9LakgveldaLzVJWHBhYkVZZnZaN2oybUJBa2VWVUZoNGFVQXh5dVo4aCtnZXNiUHZOckgrZU4yd2UwdmFmdDNPa0tNL2lRRWxtUlFXdWRVR0VVZ2lxOWo2ZjBrWTF4Uldic0tYWGFlYVh1MG9aR0VBNVdqcWJ0cVRKRFZSV01xZ25HRkhSOXo3SmVzRnd1VG5Yb3ZmTzRpQndzNDR2UEhSLy9KOHZRdmNvZGs3aC81QXlTVnQ5bXNFdE5KNGdQc1hqYlErZmVWUlgyeVpObEwxc2JPV1Z1aVdvUXlaUFFLYVJaeVhrd0pxTW9xdlI5TkJGaklJU2VvNU1WUlZHUkQyNG9QZ1Q4a0YwaW1FSHZrYlFmOWNyUk5ZSGcxMm04U3R0NW1zWWxqWDZuRUlTcXpMVWwvSzJiOWVKL0RCcFBnTm1aNHZBZ01SdUFmN25qaWJ0K21hREVJczhXNzc2ODg0R0xHNk56ZVdad1FjbkxiSkRvQ2xHZ3pHektLQXlwVGJSV3VIM1V4ZDZWRGRGblRmQmlCNHVJU2pKYWRSUjVVUmdqbno4S3F5OE14ZkVWSDFKZlV4emt1ejc0TnVhcmhrOS80Vlc2WkxQRGovL2t4K1Uzdi9pcXRKMGZ4R2g2bXFjbklpTlZMVE5ycHQvOXdiZSs3WnMvOHRTSDN2ZlJkNy9yeW1PWG51NTlQNHErd2ZzNW9admorZ2FrU09acnZrdDliaERDQWVRcTNENDQ1QXV2WEdWdEVKdmxLWURTSmVvNTRqeTV0ZFNEVzNxZVdZSW0yb1ROMHRZbGFDcVV5K2MyR1ZVRlIzWEw4V0lKc2FkcDF5d1Q0YlhEaG5uamVPcSt5SVd0MU5hNDZDaHp5M2hVMHRRT043aWtMRm8vdjdhcy85bzhkQzhPSDBnL3pDQmFrTkh4TzFOT0xwM2IxT3Y3czdRaVZvMEtkZTN0NSs3YjN2anVnNlA1eHJNdkhNcmpqMW8yTjNKNjV3bFJDQ0drQjBNTStCQUpIcWFqRVNLRytiTEdXTUUxRGE5Y3ZjcTU3VjAycHVQVEczODlsNGlhWkJYbVUrOW1KYVhmNkZyT2lrbktTeEh5ekZJVVZyZDJLM3dkVjNFZWErNkVBUFdBeTZ5Sm95SmowZlJxNURSZE40UjFnbWhxdjJ4bVRMMHpIYlZsbWFldDJlQ3JoUkdxY1hKeTcvdEFjQUVOU2pCbzEzczVXTG5uWWxtOU1JM0Y5eXhjbjRmQjVkdWlqREM2OEszZG1tdzhVYnJDTkw1N0UwdjZhMW9nNzMzcU1sOThaWi9WSU9sVTFUdC9xU0kvODB1Zk5TS0lxbG9kbm9KRGFNMFlLTi8reEpYTEgzbi9FOS96MXZjLzlQdmYrZUYzUEh6aDBoWFQ5QXRWVm5UZE1SSWJmTC9DdXpreFdzUXAzanRNTlVZN0dNVk5YTk53Y1BNNkwrK2ZFSHprbmtsQlZSYW9hdEl5cXc1UHh5R3dkbERhUlFiZHN3ZzY1UFNsOUZmWW1WWk1KeVc1RWFLZllhV244d0lodFZYTDN2SDVhd2ZjczF4eDc5NG1rNnFrTExOaGtPOW9PcytxMTNocjZYNzJSclA4QjVvYy9FN1ZoQWFqRS9KL1pJRllhekVpNmxXamlIaFUrLzI1ZS9tN0hueHdPWjRjYnI3MDZuVis4OW1iUFBHb1lYdHJBeGxhSmgrU0J0MTduNng3Z3FXd3NMdFowWHZCU001OHNlSzE2OWNvOHpIbmQ3ZkpNa3Z2SEczVHNWbzFyQllkWGUzUmtIUWsyTWdkSThWa0laUlp3VmpMYUpwamN5SFA3RGpMYkhRK25QYjUxaG90YzZzN0c2T2s1d0FtMW1xYnpQVEM4RVR2Qk1yRHByL3h4cno1K0RQajdDbFY4aUdUbXFKSXJHUWkzRHh1ZU8zMlVoOCtQOVZwa2N2ek41Y3Z2YkJjL25jWEo0VTVWNDAvV2pSMTNwRWNYeHlSQ1prZStFNGFsMDhNRW43SEUvdXJYU0RiR3hWRm5yRnNlbjdwMTUrVHRLNE54aHBqb3FvaEdaNVpUWEZodVNhU1liVXhxU1kvK0QwZmVNODczL3JnajF4KzZzSTdIM25YZzVQSjVoNTFYOU9IbFlTd2dsZ1RYRXNNSGFvZHdRZGkzeU94cEhjS3JXSm5DNzcwdWVmNStHOSttaEI3Ymk0Y3M5YngyQjZNUjBWcWRBZnJGOUYxVWxMS243QzVwUStCMHVTSk1qSWtKaW5nZTArV1c4NXRqT25xRHFOSzVpTjFGL0F4SGQ5ZENMeHlXTk9wOHZERmJZcmM0SU5QQlJpVm8yVjQ5dHF5L2h1ZCtvTXpBNm9INGtnc0F6RDlPMTY1elloUk5ZV1o0UUM5ZnZ2NG12TzhjZm5TNVh1bTR3MnUzenFRNTErNnllN3VpbnZPYnliUzRoQ1FtY3lrMDBZcURHSW1heUxUeWpJcXBveXJnc1BqSmE5ZWZZUHhlSXExME5ZZHEyVkR1K3B3WFRMZE5oWXM5dlNaYTBRd1ptQWNHOFhhRkFVaFNtNk5VWmZzS2xSRXRNcHpYYlVkdTlNaGdHZG9iUUdtUmNhcTkxR0hJdkZSVjgvZW12L01sYzNxdThkVi9uQ3drcnJiUWZCanJHaVpHNTY3UGUvZW1MYy9kMkZhWG4zMXNQbk5FK2VlMnlMZUU2eDVLYmYyN1Yxd0drRUNVUXRibUUzSlh6L29aaDl2USsvT3NIaS9ObHVzdmUwS0krQjhwQ3d5MlQrcEpVUzEzZ2NUTldZeGFvRnFpVWlGeUZnVEdqNEdKcU15My82Mjk3N2x5VC8rTDMzNGozemdYWS8vNlBaRE8wOC8vTDZIaTJxOGhjYUFqdzI5WHhEY2toaGFYTmZSOThmRTBLRFJFN3FBR2d0R2FLNDJmT2J2UDgrdmZlNExIQ3hYaUNqUncxR2p6SDJreWhPdko4UzBvVXE4SFR1RVVzb3dvd1R5ekJKamNpZ3hXWElDREM2MUQ2TXFZMXdVNUZrMjJPYkVwQUUzU1R5bHFzeFdudFk1cHFNTUswYWIzc3ZCVW1ldkhmZC8vVnEzK0hrNFhYSDJnTTh3bW90Vmk2SDVSNXdnTzVzVFRwYjErblMySXBJdjZ0YmZlMkZyNDZGN3o3OC95eko3WVc5WE5yYzJ1SFZZMDd0SW5pVjJiNHdlWSsycEJaRVJRZFVsZ3psTjg4UzRzR3h0bEpTRnNtcFczTGcxbzE1MHVDNE42RWswbFRBVlk4M1FaQ2J2S1ZYUzRxTzBnMHc1Z3VIV3JPNStzZmRoQWJRaXVNemErTVNWaTd4dy9ZNGhuaHZXdEx1alhCcVhndDBHODVUc3BQWHpDeHRWdkc5My9QNDhNNW5OalJTWlhYdDFkVzN2bDYvZmJuN2g1VVh6Lzd5NmFINWg0ZjFyUUx2eS9WR2xXY3dENytxaXJ3U0pCakc1MklVVC90cTFzUGdmbllibXk5RDByMTZCZlBCdDk3STFMZkF4Sm5kdUYrVncxb2hQMFYrNXF1YXFWSktLWWp3UURDdGcrOHFsblVzZmVkL2pUMy8vaDkvMkE5LzlyZS84WTI5Lyt0RVBMNkxidXZmdEQ4aDBhMnNJbnU4Sm9lYi8xOTZiQmRtV1huVit2Ky83OW5EMk9YbE9EbmVvdW5WcnJsS3BORXVBU2hOSWpRQVpBNks3QllIRDNYYndRSHNLMjJHSEhlMEhQM1g0MVErbTJ3MTBSSnR1RUFIWVpoYmQ0QTQwZ1dpRUp0QmNrMnE2WStiTjhVeDcrS2JsaDIrZnZGa1hsVlNhR2xWRnJvZ1RlVzlHNXIyWmU1KzExN2ZXK2cvQnpmRyt3N1g3ZE8wQnRwa1R4Q2FsUHE4UUZWazhVL1BsMzduTVkwOWNvWFllcFJWdGE4azBHSWtzTzJHbjhlUWFKb09jTWpOa1dtT1VJc3N6dEVuZ3VMSW9RSU5iZWU3MXNqSlozaWRSVE9mbFVWbFFHSU1MQVpTUUYybTNFRUphaWpXZDU3QnVNVXBVWjdWN2R0LysxclBMMlc4RzRrRmZQWktTQ1VvMkdMQkdTVlNSK3Vza3lPRnN5WU4zM2FhT0ZyWHFDUmdtUnNrSFJjR3JIN2p6QjR6T0p0WUZCb09TMjg2ZEljOEh0SjNRZEFtMG1KdWkvNTNTcEV1dDFCNmo0SHp5KzJpYWpycTJ0SzNGdG83bG9xTnBMYzdINU92UkgwMlRuRkRxMjBLTWlBU3lQQ1dOajZLMFZrcHB1bG5UL1VubndnSFFLWVhMdElwM254dHpaVy8yTjJFQ1N0SDY1L25YS0FHbGxkcS91Rkc5dXNqTitWbm5MM2MrUEx0MzFENys1V3V6Zi9mWXp2ejNyOHpiMzJwanVOb2ZXMnVnaVRIYW1lOHVyNUhIZ0J3R2VFcGdwOEgveGhXWi8zWWQzUkhQMTBMKzlwaDQvdmMvOVVZKzg5Z09yN3B2azcvODRqYTdoNjJLRWNXS3dIU3o2UzZCZ1lqa2E4TnE3WHRlYzkrOXIzM3d3Z01QM0hYbTRjM0o4Q0VEZDI1dXJ0OTk5dHhaTTF1MGtwK3ZtSnpiU0UwWUhzS1M2QnVDN2VqcUE3cDJCKys2OUJUck43NVNhcG9ybGkvODdoV2VmbXlYckRTTVRFRnRIV3ZEaXFacGNabEhLemhzSTAvdU43UmVlR0JyU0NuUWRKSFJTajVHYWJ6MzZVcGxmZkprK3ZoT1JSZlRzczBsL3JiSkRSZTJKa3hheTd5enpFM0hvWGYwdG9Yc0hQbURhVDI5VXBuQnBlY1c3dGN0L2hvM1JlSThFQTFLYXB4VTVPeEo4Nkt1LzhYekcvTHN0VDJKU09pUEl1N0o1M2FlZnZicS9pY2Z1dWYydnhlalFtc1VSQ1pyRlZWWmNEZ3RhZHUycDg2R1k1MG9LVXFDQkhRSXlhblhlNVpOeDJ6UnNsdzZ1amFlY0tNRmtaQmtQbFZmTy9SS2Z6ZjFSNGlpczQ2OE1EMkEweGlsOUFubVRNS0xQWERoQWg5LzdNcmYrTjNPalFvR21XYXZkaElUMnJZRDFGZjJGNWN1WHEvKythUXE3djdpdGRtemU0dDJPdTNjUENDck43ay9NWTFhMlQxbm5majJTVG42QllVYUZKaVJBVm1JMjBHT2lXdmRMVnlRYnkxQnptME0rV2YvNDkvaHgvL3hIL0QrUDNxY1BGUEt1YWdGVmxLZWhZSlNvQktSd1owWHpreCs5SjF2ZXZNanI3bjNSemJIK2F2WEo4T3p6b1UxNzN3UklnelgxbEJLYzdDY3F6dmVjRzgvNysrUTBJRFV4T2pwR2tjNzN3UHRpRDV4RGxBS3JTTjJOL0w0djlubThsY084UktSb0tpcWdpdzNUQmNOYlpJZ1pEVFVGQVhNckhCcDJqRVBrUWZYUzBhWllibnNDQXJLUVo2SS9yM0ZzZW1sWXlRa1RTanZrNmhDVzNka3VXR1lEMWlyU2liREFXdWR4ZTBka2h1TEZtSHV6TjRzcUYvZHFmMi9oOFZlZ0t1M0NEV0VEQzBGdVNnaVY1bTk2SHZ3bjczM1hYejg4MCtKZUlrOWJkZnVIUzNtVDEzZS90aGR0MisrT3krSzlSaWx4MUtsOThwa1BHSzh0a2JiT281bUM2eHQwVnJRT3Zaa3IyU2JWcFk1emhYWUttM0dZMGlZWTljZE8yRWxneHkxMnNpb1l5SlhVbDUwdlVvS0dGMHdHQXc3WStxWWZ1MTBjbEpLTXhpZCsrckg5U3FuTUZxV0xsSmJ2M29BNEtMRUQzN2x4a2Y2WjFYV0o4Q3FGL1B5TnlFanh4WVJFZWxBVEVOVUoxQzc3c1NDOEFYUnZOOVFndHkrTmVLZGIzOHo3L21mZm8rZGc2V3kzaXZyajBYWWpnbE1Bb003Yjl2YytvbDNmKzhiMy95NkIzL2k5cTNSMjRxY3JYSlE2czRHdXM1S0RCR2RaUXdHSlYzYm9rYUs4ZFlRNzF1OFd4SmNnNGdsU3NBNXdma09US1NaUlhEQ1lGT3h2TzU0N0FNN1BQV0ZQVHdSVEpxTGR5NzBmWU9ucWtxS1Fja0tQemZvTEhycTJKOWJQdGM2WG5HbTR1eW9URDU0bVVrRXFMQlNZRmRKZkt4SHZNYVFwalk2MDZoTTkwUWpUYVlVQlpxdFFRWGp5TUd5UTFwOXlSSS9GcERuZ0ZtL0lHdE8zaFNORm9OaW50NERMenIreVMvOVA0UVlwZWNnZVJFNmtQS3pqMTM2cXd0bnRqNTlkbVA5Qjh1eTBJTkJrVHd4RXVjWXBhQVlGMlJaUnRPMGhCaXBtd2JyMGhITWU1TjBjSXNoNDVHbUtuTW00NHJwdEdWMnRLU3RPN3hmYmNxUEI1TjR2MUl3VEgxSmxoZFVWU1ZGa2FPVWNwSkFtY2R2UUswVmoxKysvTldweFJHR3VVS0JhSzFpakxLeU5RejkrM1ZsVGJDaUM1eFVRZ3lwMENraFRVcFhpOGVWSHNFcVZydVdZTFNKS3dKTENPRmJxeUFiNDVJUGYrd1QxSjFYbmZXcUYwUXczRFN3SHdLRGQzN2ZRdy8rZy9mK3dQdGU4OHA3ZjZKWkxMWml0R3BRalhBK3NGelVLSWtxQm8vSkRablIxTjR6T2pPa0tCUmRXeE45aTNNV0VZdEVoNDhOWkFabkJUOUxqazFXRkkvOTRRNlAvdlVPWHAzY2lxY0cwWWZJb0NvcHM0ek9wOTJIalFGclBSdERUV0dFM1ZyNDBvMmFlODhJOTUwZEoyWmJ6MlhRL1hLd3RRSGRONStwTGRGVWc0SkJtYUVrc25jMHg2RG9Pa2N4S05nY3I3SHNJdHI0cFUzbjd2cEV6Mkg3bTdneVFrQytpU1B1U2t4YWFTVVNqOGVpOXFrck4zWSsrUEhQL3NGOXQyKzlkckkydm0yOGxxckdvQ3d3V2M3YVlFQ1dKeENmQ0dTWm9jZ0wyalpnYmNlTnZSbldMcWtHR1UzZEpsaU9oN1oxZE01amcrQmlTSURIL3BtclNFT09QTThZbEFWWm5sTVU1cVlHc2FZUjRXU0NpQkxGYlBiVmlXR2Z1VDdsM28waDUwY0YwOVp4MExpVDlzeit4RkZOVHI1NkhYN0psQ0ZEMCtIRktLMTgwa0FLdCt3NGpySEdJYWJwMm1ReVlUYWJmV3NKMHJsQWEzMWE4dDNzTlVxbDFFaEVxbzIxOHN3Ly9MRkhmdkNIM3ZubW43N3J6dHRlT3oyYWxhM3RaSDE5U0JSUnR1MVFxV1lUWXFBeVNhOHBCRUh3Uk5ja2d6aVhqcEhST1RvN3d3V1hsdXZCb3FzQUdDNTlac2JUWDl6SGEwbCs0MFJzQUJkRDc0TWhsR1dPeVRSNVB5RkJaeFQ5MUtvYVFwWjM3TTBqWDlsdE9HZ0Q5NHh6dGtZRFZHYXcwYU9pUnZ1STZvV1BNNU4wWVNYQ2ROSFN1U1NuWHhaWkVrenI1VVVyazdOV21obHVPVnMxakt2a3lGQlJsQkt0MHMvcUNOOXdnbHk3TWVOMTk1MWhiOXJLOXNGeU5SSnRSU2l1NzA4Lzg4REYwYWNoL3VqKzBhR1p6ak5pMElnWXNpeEg2M1E2TVVZenFreFBkN1dVdWVmTWVpREVETi83ZTh5WEZoczhObmhjU0NvbXRtK2dNNVZjcTRvaW95d3lNcFBjWTVNdVY3cmVxWEhuTU1SNGtwd2tTc0d5ZmVGKzY5bWptZ2MyaHowcm1lZXhLRy81VXRHSmhrd2xHVXNjSzZXbjEyL2V4Wlhsb1J6YW0zN3I2aVlDTHcxZ0pISk5oTFB3VlpQalJTZkkvWGRNZVByYWpKMkRwV3E3b09KTlpjSkJncUhMNlBXdk9IZnYrMzc0KzM3bUxXOTY3WHR2di8zYzJXWGR5bUsrWURLcGxDSWRUN291SFpsV0VQRXNNL2pnOGQ3aFhNU0ZnSFFXYjF1NjJQV0N6MWt2SFpNbmxHbWhFVFRETzB2WU1MUlhhcFFXbG9zV2syVUpRcUxTQlRHWlJuU0dEYUVIc3dsVldTYlBDZDFqRzZSQkxlREd0R1BXV0I3WUZNNlBpMTVWQWJMK2doYkdKSDVDYm5BU2FKeExWRlZqc05aVG1LVGQyell0VFN2N1V5c2Y2Y2U1cXlZd2FGVE0wREtXbkgyNmI0MGVzRFpnWGp2UldrbElWY1FDM2RHaTIzdHVaLzZCNzNuby9KdldodVlPMTcraGk5eVFaem5HWkluM0lRRVJTNWJCb0RTRWtCRmpZRllMYmVlU2hJK0tES29Na3hzbTZ5WGVLdXBGaDIwZFJtbE1QL2xiNlgrRkVER0ZJaHRFOGt4VTUrVEcvbUh6a1dYYk5xc0VFUkh4TVNTOXBLOFJUeDNXejB1RVc4VVUxQzNaSXNDRWtwbWs2N3JYTFk0WmorcDVXU2JIS3NJQWQzdzlhTStMb3I1bW1pTFROSjAvS2ZwY3BRV29IdituUC9yYWQ3enREZmY5M0QxMzN2Zkd6YzJOd2xyUC92NlJRaUtaVVVTZnJJR2RkWW1TdWZvQmxlcmgxZUJ0SkFaRlBWdGlZNHVyRHltR295UThFQkplcUhPQjZCVktoTFhiQnJ6Kzc5N0hYLzNiWjlsNzZpQkJISG8vdXl4TEg0c2lMVjZycWtnalNoOVFtV0haMm5RczBJWkJycGtVQVlMaXlBcWYyNjA1UDdmY3NhWVpEektpa0hZZW1jSDVrSnJQTEQyQlEwaUo3VVBFYW8yUFFab091NzJVMzcvbTJ3K2RRS2tHQlRIcm40Z040U1MvL0p1S0VJVm5kMllZclpKdVE1cjR0RUR4MkhNSG4zend6alAvNXQ0NzFuL1d1bGdra1VGRGtXZEljQVJ0OE5IZ2ZPTEZkTmJqZmFSem5pSXZ5SXNSZFcyWmpBc0c1Wml1ODRsRU5XK0lIblFQbHorMmRDQTE2bVlBZzBsQVp5SW1NMG9GMmJFejkyaUk4WGw4aTZhejhLMzkramVQbS8xMXJHL3A0NjRzRDE3NGU1QVhtRmw5RmVUQzExMENibzZRR0hGQmxQTnlNam5XZ0xXZi9jazMvZUFQdmVXaC8yV3l0dkhxalRQbnNySW9DQ0V3bXk4WUR6Tk12MHRJWUxZdUNRakVpUE9XNFdoRWtlZDByYU9PSGVQYkozaHZDVEdnWXRKbURkNFJmTUM1R2Q1YnJJVm9vYW1GYkpBenVqQ2hYZ1Rjd2gzNzR5V1RHSlBJLzBhenViR0dNUXJyVXc5aU8zZU1UWkplRUM3UElqa0s3eFVITHJLd2tWd3Boa1ZLdUR6UEVwOGdCSHh2UHBuRzBhekFmZUk5NmtiTnA2OWE5ODg5OFFhM21PSVlGSmFJZmJGMzUydkU1ZDA1azJIQnNNeXdMcHg4c0tvWVJUV2QzejIzT1hxNHlQV2QzaWZwelJEQzhSa25TcGJFNWt4Qk5keGdVSzB6SEo3aHpOWWRWT1dFekF3d3VrejZXVEhKSEs3QWlTTDBlNnAwYjAwQmd6RU1Kb0xLUUNtdHROSDRLRS91SDdWL1V0ZDJuK2RyVDNFd1gvQlNpSzliUWFveVovZGdvYXdMeitPRks5VDRINzN2VGU5KzIrdnYrZStNVXZmNm1JQjUyaWhjbTR3dmpja1Q0SzlYK2pzV0ZvdEpNOVpaVHlqU3hWY3VvMnNYS0JWU2s2MEIzNEVrQTVob0xUcm1PTnZoMjRRWTdheWc4NHo3MzNFWFY4Y0ZsejkzRFRwUFZnalJwMlp5MFhUa1pVNm0raVR0YkhxanhKaHNpbzJoS0JJWDBPU3AxeWlzTUhmQ1k0ZVdxWTNjdTlHN0wybURpNUcyYzNTdFJlc2tOWk5sUmhvcjZyQ1c1M2JiK1A0Ty94d24xUk1oNXVodjEwUHpPR2ExNWV4a1FEVW9xWnN1Q3VMU3Rsb1Z6MjFQbjMzMit2elgzLzdHaHg3TTgvS005V25KYVhSR25tY0k2YWlsdFVIcjdOamp3N25rcDZpVkpzc3luUGNVZVlaV2hsQW1weXJ0TEZvZ0d3aFpDVVVGSmsvYVlFazFQaDI3Z28vWGxyV2RyVEJZZmFYanBSUmZ0NExNbDUyS0l1b0U5WFVJak43N3JvZS85d2NmZWZCL1hodG1EemV0WjMzanZGcGZINmVMN0FOdDJ6QWM1SVFRaVJHNnp1RnM4cUx3UG1LdEl5OUxCbVdGRDBKbkxVd2lXV0dJUGpYc01YVFlib0Z0NXpnYmFGcWhhU0p0SXpnYnFWdkI5OExTYTJkSEZKTWh6ZHpTVEJ0OFRQcEx0blBVbmFYdFBMVzFXTjkvUHZqRVo5WUo5S1pVOHFNb0MwVW1TVFVuQ2h6YXlOd0dkQlMwVHpiT3FXRk5vTC9nZ3ppUDJsdHcvVVlydjNnZzdvTnlreW5YOVdCRXFjaWsvU1lhOHE4WGRlYzV0N1dlNFB5SkNIYXNSMnk5T3J6N3dsM2wrdmpNdzRxaVVJbWxTNHdKR3A3V0Y1cllPL2s2NXdpOVRKRDBtRFY2dUx1Tmp0WXRhUHdjbFZueUtsSU1vU2hWZ3B3bzFldGtKUjY1Z0N3Yjl5ZVhyODgrM2xlUFJpbjFnZ3U1bDJ5QzlLT0VsWi9HQUZpNzcrTFc3ZS83b2RmL1YrZTMxdDd1Ykt0aVZPcnMrUXVzamxlQ29tMlR6d1A5SW1tNTdPaHNoekdKN05KMmxoaWhxaXFjODBRZm9CTE1VT0hhQm12bnhOamlYWWR6bnE0UmxtMXljN0tkRUt4ZysvbDdVdnlMcUxMQWpDcVd0V1U1WFdKYm15eTlZcVR6SGh0QzBuenF6ODJ0alRTZElGR25UYkdrVVhGUktNcGNNVENLVEFsekc5bHVrc3E3VVJGSnZTWWhDTE1hMlYvS2N6czIvT0lCL284Rk9jbDVjS3NGOUlDTTdqdVFJT2toMXZEZzNSZlU0V3dwbkhoQ0wrb21YTjNadTNyN3ViUDNEd2FEKzBJSXl2dGtLZUI4U0ZWZTYwUVpXS2toU2xLRmo1S09rQzQ2TEV0YXRTRG9GcFR2cWJRckJxRkNWUHF6dGVHNEYvUlJMdTFOMjk4OG5EWlA5eGdzcTVUeTYrc0RhVnYvc2trUWRXSWpXUUpyV2FiWDN2ZnVoMy9zMWZlZit3ZUtVSWxFUWxSc2J0N0dvQnIwT3F5V3BtbDdoR2NhSzRZUWFWdlh6L0VESVdoYTY0NFRSR1Bvb2tWVmM3eGI0bXhOOEIzQkM4N0NZaWswZGFUdEJPK0VhQVVKTVJHQnJOQTJnYVlKeVRCK3JhSzJRajFyQ2NFaldxRnpRMk9UWUlHWEpFdmpmSUpEdEExWUM3blI1RVVDSnc2cmdyVnhUcDVIY29UZzRNQUorNTM0NEdLblJlWHpWdnRkeTE4Y3hQaFBGNFNQU0ZvSUxrK0EzMktPbGhKRGs5QmQzeUZlLyt0UVNuRjE5MkNGUFYrTlJQV3lhZHNZNDg2NWpmVlhHcTF2aXpGS2lFR2xUYnZIdWFRakZsZHlRejNHeW5xSFZUVnhXS09IZ2J4SVB1WkYzazhLYjVrdGFaMDB0QmExWXp6TS9iSU5mL1RFcy90L0VJSXNWMk51RVdMWEJYazVWWkRqZGIxU3FURi81RFczUGZTZXQ5NzczNDZxN040WWt4aFpqRENabktjY2xEaWZ6ckQxTW9rRloxbE9DSUxXaHE3MU9PdWgzNVF0NnhwdGN2SThTL3BLTGhDeUdTWnJjVGJCU3F5RFpTTXNsMEpqSlFrb3UwaHdFZGRGYkJmcHVvanJBdDVGbXFWbGZ0U3c3RHBxRi9BZGVOdXp6MFRqUS9yb25NWmJDRDVWT0JlZ3RjbXJiekljVUJTR0lzc1k1RG1sVVdRcUNBR2FvUC82S01UZmI1M2FYZ1Q1MUpUd0N5M3hzMzFEdnJnRkdTb0M4akJiYkZOL3gyN2l4Zk5uV0xZdE8vdEhxK0hnU2ZLUDN0ay9PQlNSM2RHZ2ZFV2VaMmVkOXhKQ1VLdGxYakxnTkJUOXZXcmprbGpWbURWTFZtcnlMUEU4c2t4VGxqbTZNRWtUeTRiamQ0bFM2VHJ1VDFzR2hYbHVlNy8rNVlPajVpdmM5SDczTDdYajFkZExrTDlSUGZKTWo5NzdBL2YveklOM24va3hIOUNLb0JTQ3RaN2gyaGJWc01JN2o5YWF4YUlseEVCUkRvNUh1c3Q2MVNBTDFqazZtMUNpazhra0tTaDIwSFJMektqRldtaGJvZTJnYmlQdDFPTmQ4cXJ3YmNTN1NPc2l0bzA0RnhOM3ZISE1EeHNPOTJiTUR4Wko3MGtaWE5DME5iZ09uTlVFbjVMRGVvaWlqcGRMc2E5R1lNaE5zaElvY29OUkNxMmlVakVHNi9WdlRTWDhUazM4ODRiNDBRRFhUaUJJajNjZU9WcEdaR0tKN0h3SGt3UGc4dlllTnc2bUFFeldob1FRVlQvK1BPWTRYTi9idjQ1d2JWU1Y5K1FtUDUrQUtrcEZWZzg1bFk1VGVvN1phS2dtVUpUbUdNNnVwUGNHeVF3dUNyWnp1TmIxY2tkcHFtV01rcTZMYmw3YjM3MjJ1L2kzdlEvS0N0WWZlQWxHOWlJcXlFcURLYi92NHVaZHI3eDM4NGU4RDVuV3FrZEtSMXdRbXJidGhjTWlXVkZRbENWZDExc1N4MEFRaFRLR0tJcmdBNGltekhPTzVpM0x1cVVhbEVsNi8yaklyR3dKWmFCdDAzSEtlK2tmeDBMd1F0ZUdWRUZjNmoyaWo3U2Q1Mmgvd1d4L3pueGFFMXovVkRPQ0RCVWhVN2hhQ0RZa3I0cEU0aGRCbElnaTc1OEVFb1hwdEdXeEFKUEJjR2dZREJKdlpGQklFOXY0TEZGV2ZJN0ZDUnFwWHowbEZVb01TaXF5YnhobjlhM0djRkFRWTVTNmlhRlBrbU5IbnM5LzVlay9XOVR0OUxVUDNQdGZuTjFjZnhkS21SQWpqV3RwWTAybkdvYVRqSE9ERVZscGt2KzVFNVJLMEg5RVAyK2xmYXcyMzZ0SElpSmxxVDkxN2VyOGQ2d0w4NU1JZ2hjQ0E3NlVLNGcra1J3am8vWGFQL3p4Ti8rOWV5Nk0zcU9OTHJTK3FZQWhaQmd6WUR4ZUI2V1JHRk5qM25RSkJ5YlExQTBoUktiekdjNVpzaXhISWxnWG1jNGJ4cU1LN3dQUkc3b0d1cnpEMlVobkJSK1N1YVIxeVpiWXU0aHJRMjlJR1ZndUhVY0hTdzczcHRTekpkNGxXSUZTaVp0aGpHQXlSVEZVNkNKWk1VdFVVWW5Tc1FkK3FuNkJkRkkwdHd1dzN3YVp0MTZGRUVQajlGOGRXdm1kam5pdFQ0NGFhTlV4YlZaRmhlcjlwUlU1K3V2eU83NzlDVkpTRlFWQklpSEcxVUJxSllnZ2gvUDU3bzNEd3k5dFRzWm50ZExyY3pjMXRaNWxqZzdWK3hFMnRhZHBFcWNteTNUdnBaNldjZ3BZMUlrbmdrMEx6eWdpSXFLc2kwL2ZPR3grZnUrby9WTC9BR2xleXRYamF5WElTcVkvVnozNzd6V3Z1T3ZlLy9nZHIvclpRUmJ2UzR5eWxZWjMzNFJIeFdSOUU2VU1JcXRqVnFMSWlpUzhqOGtNcy9tU0dBTGFaTFRXRVNXd3MzZUljekFvQjlTZHhiY2FXM3VzY2dRUm5CTnMvd3BlQ0RZZHA2d04yQzZ3bkxYTWp4WTA4eVhScDdHazBlbkpwMVRpTXF6Y0N0UGMzclErNms4RXl3Mk5PcWZCQ0txblpONUV4WFZFOFVUVnh0aE1yWHprME1WZm1FdDR0RStPazBTYmtFUVhEQU15WE84WnUrUS8vTFJtMlhUOHJ6LzMwMXk5Y2NEKzBieC9QQjIvQWtCcjdXejNjUHFsNnpmMnY5Q3BabTgwTGk0TXFueE5aOG5DcnFzdEJ6c3pqblpudU5ZbmlvSElzUXpRd2VHQ3R2R1lmcC9sRTYxNk9hM3RMMS9hWG54UVJCWW5BSnIrcFZvOXZsYUM2Qk85eHdnWS81Yy84KzRmdWVmQzJmZUdNQjlFU1UrVklMcTMrVkk0NTFnYmI1SVhPU0drQk9rNnorSFJFVnBKd3VwNElVYkYwV0tKa29CZ2tnNXVET3dkTFh2RktRZ0JwRTNDQ1Y0bHNRSG5oT2dsL2JsTG9zbnQwdEV1TzJaSFM1cjVFdWQ4NzdDNjh1dmpwSng0T2lGb1RSVHpsYjNHL3N1WmRYK2VvUThWYXFKUTZ3cWxZb0pONGdnNHZCTFk5L0NyRGZ4ZkRmR3hXNTZNWHFGaS84OWowQW5aMjFzcS8yMkZSS0h1TEd2RENtTU1kZHVkckNJQmlLMjE4M2xUWDk2OU1YOVVvYTZPSjRPN2l5STdHM3lrV2JTMDgxb2QzSml4dHpObmYzZktkRy9PY2xyVE5wYmRuWnAyMmFCaUlQZ2dBdEg2K01GcnU4MnZOYTNiNVhuU1BpL2Q2dkZDQ1hKY1BYcEl5ZkF0cjMvdzd2ZTk1NUdmMjVpc1BUU2RIaEdDSjhhQWp5cytNdFJOUzkxR3RqYlhrUkNUMDZveWJPL3UwellOdzZva2VLRW9jbzRXTlRjT0RzbXpncnBONCtDMjgrd2R6ZG1ZakFraHBtMnVMd2xCNk9pSUxzRWNqckZQWFdBKzc1alBhcGJUSmM2RmhBOWF1VUdoamlrMWNZWGVOSW9ZVEwyYzg0SDllZnRubm5panhuOFcxT2NFZGhXTUZHb1RSQXN4QnRUakh2VkxDK0x2QkdTSG04amM0eWxWeXJ0ZU5CbjV0c0JJdnRWNDV0b05kZzZPZU9Ncjd5T0V5S0p1RUJIcGJhYmxCQzVLQk96QjRmS3lzK0d4NktNWDd5L09wOHRCVTNjcnJKV0tJZUtzbzJzNjluYVh6STQ2aG9VU25manBNVVErdjMzUS9OTzl3K2JKVzY2UnZ4VmsrSEpKa09PdHVURnE3WkZYWC9qaFY5NS84YWZXMXplS2c4T1ppdEpnc2h4VWtReFNTTnBMTi9hbXJFODJFeWVqWjU5NTU3bDI0NGd5ejRuUjBiUU9vd3lYcnUyeFhDNHA4Z3pud1ppTW85bUNvNk1GazlHUWlLSnVPcVFGb3d3T2ovWEp1TjYyZ1hwcFdVd2JsdE1GYmQwUll6eHVKaFVhclJLVE1BbElhNHpSRXNWUUw5Um45aGJ0djdMQlgrK2ZkRXRMM0c2Sm4vWElwdzJxMW1nUjFDZGErRCtXeEQrWG0ycUFkYi84ODBBczBETEFZTDlMSDVJWHoyMHhyMXVLVEZPM2poN25FVTlVa2xXaWgrbXN1YkczdS9qcmV0RTlLaUZzS2lVVFJCVW9wWHZsZExGTzFIUW1zajdPVkRYUVNwUTZXclQrOTY3djFmL3N4bUg3NklucTJyM1VqMVl2bENDM1ZvL1JuZWZIRjEvL3dQcC9iWnZaL1NFYThtSk5FVHNrSnBKV2drMHJpaXlqYVdzYXF6bC9aalBockh5Z0xBcEU1Vnk2dHN0d1VLVG0xOWFVdWVMS2pTa3hKRm44RURYR1pOellQNkJ1VzRaVmhmT2V6anJjSXFKY0RrQUlqbWJaTVR1c1dVNFhkSzA5Rm84MlJwUHBwRlBWZThkZ1RISXBpc0dvZHE0UEZwMy9oV25iL0hYZlJ4ejNFZ0xXSVhzZDhTOWE0b2NiNG9kYXdncFRkWEw1RnpLbFk2R01HSlRrS0xydjB2SCtwZTA5RHFaempOWUppWXlRYWRORHhZK3J5V3I2RmtJVXUyamM1V1VUUHVXRFBBWjZxaURYQ1gyemZ6UUxqMWVsTWFOS2JidkFYeDNNN0wrK3ZMUDh6WG5qcjN5VjVJZ3Y5ZVI0b1RHdjdoZURBNlAxNEYzZjkvQWpiM2oxbmErYno2YzgrZFJqcWhyZXpybXRpa0Z1UVZ6ZmxFT01udkdvNU1yMXk1dy91OFY0TkV4YXNrcHhkbk5DMDFxMjl3NDR0N25XSjVUaGpyT2JYTDV4Ukl5UkxBT1U1c3ptaEdzNys4eVhIZmZkZlFjSTFFMURXUFFlRThPU1VzQTFoOVRMR3UvQ3NXbThXZ2tSQ01leU5ENkNxeFhLWmxHai9uVFd6VDk1eTFJdm5LaWFXVUN5Z0t6WU02dCsvWmdtYTlCeHFIT0dLcE50djN4SjNPVERlZm81dGRhY0hhM0xvcXVsZHAyS01Zbzh2NkpZWU5DNTBIYlRjRmxOdTQrT2g5azk2MVgyeW9ocWp4cjMxR1ltRjYvdWhmMXA3Uzg1THdmOXRUbXBtdWlOMFhFMEtwak4ycGQ2Zmp5dmdxeXFSOWJyNDQ3dXVyQjU5ai8veWJmOG8vdnZ2dU9WVzF0YmpFZEQxVFFMNWt0UGthL2UxRGxDa3NIWEt0SzBEVHY3TmJlZFBkTS94cE5TeHJDcU9KelhQSGYxT21XdTZHenk2RGFtNVBMMVhjcWlTSHlGR0NtS25PbXNadTl3VHBIbkdLMVpMQnZxdW1WKzJOSE1IZUlVZzdLa3FrcGk2UHVQdURLNzEwalF0QTEwYzROeEdYbVdmV25xMi8venFHNHU4M3hkcXVOamhycVpESzRmM1Q1UENDQlRXZ3BseENoRnBqVEw2RjVTTjF0RUdCWEpSVFkzR1VacFFycG84VVJmY3RMUXN1MWMzSjQxL3RGNTQ1LzBJZTR2R3Y5RTNjVXJNVEx2aytLbWhKRlNYaWxpbmhzNXN6VjgyU1pJb1dBb01QeVovK2hONzM3a2RRLzhqQ2c5ekl4UjQrR1FNNXRiRE1vaStkV0pUOXBVU1N5S0VEeFZXWEpsZTRlbTA1emRuUFRRazlTUFZJTWgwM25EbFoyREpLS2NsV2lWbUg1N1J3dVVpbVFtOGZLTFRETmJMcmk4czArWmwrUjV3ZEYwd1d5NlpIOTN4blN2d1MwRjVUUEU1WWpUUktmeGpjYlZDbkVaeW1aa0dQSThxK3ZvM24vMWFQcG5KL3FKNHltVVNaeXprd0lBSjE5UjlWeU9VbWZ5dHEzYnVkYlVISVRtSlhuRGw3YkY5dmkwVW1ka3VUb1dmdjRxL1lrN1VVRlBMa1NQSlhNU0NERmRLMk4wM0Zpdk9MczFKQVJoUHU5ZVZnbXlxaDZsd1BEaStjbUZuL3VwZC93MzYrUFJxMEx2ZWhyN2MvNmd6Qm1QeG1SRmlYUEo1REdHZ0ZJUW9xSEloVXZYOXBtTU55anlwQmFPTWxndmpLc2hMaWlldXJTTlNZS0lESWNWZzBIRndXeEpad05hWnpqbkdSUVpJb0hMMi90TVp6Vk5iZWxxaTdlZTZDSnRhNm1YSFYzakVualJLOFFuL1R5dEU3ak9HSTFYOHFrYnpmSlhXK2R1bkRoYXVjem9tQnNqSmlxU2pBRmY5WldXZm9xSVlydXRtY2VYL28xZnp5dUNSTzY1ZmNLOGNkaWIzZ3BSS1VUMUZWV3RxcWxLRmJWUENOZS8wZ05HcXhDRnFMVmlNaTdKQzhPbHkwZThIT0p2SmtoeWN5ci96dmU5NGcxdmVjTURQNTNuWnIyWGVNUTVpNCt4TjMvMEZFWGljeGdOWGVkeFBpRldpOElRUThmbG5SbGJHMXNNeWh6cjB5aDNVVGVVZWM1b3VNYnV3WXhadlVDaEdJOUdqS29CaTZhaGJscFdBcXlaempGS2NYZzBZL2RvVHR1NUpKY21rS1hwVkM5Y2xwWllScXVrMjZSVjhnQ0pjdFJFOXh0NzlmSVRJc2ZTTzFZcEZZWmx3Ym4xTWRPNlRUVE1yN0UxVFVKS0VTdmhaWEhqMitDdzBlTkNzbExyS3dpRElzZG9MYjNsYnJ4bGYvSzh5cHBuV29hRFRLcEJKbTBYMEZvbHRSY1VzNWRCOVRpWklDdFE0c3BGZHZLemYvOXRQMzczN1dmZUZhUFAwTHF2QW9scGhrcmZsaFova1R4UDlzTmFhMXJiVVRlZU10Y3M2am1YdDZlYzNUaWJVS0tkV3gyR0tZdU1Jc3VKb3BndGF6cmJVbWFHNFdDQUFIWGIwbllPNTJQeXptc2plR2l0b3dtV1RnSStCSHJHTEY0aVFaTGh2SThSNjRKSUZNekFmSEtuWHI3ZmVuL2p4SGs1QU5INklPdWppc1A2YTRNSlYrK1FsMk8wMWg4bkIzQ3NvNVVnUk1lLy9xMnYvbXNWV2YrQWFydmtKVkxYN21XVEhDY1Q1T1RtZkhCdWMzVGJEejN5MEg5U1pPb2hheTFsV1NSTExaT2hkWjdVOWxReXB3emVJdEVqUkFhRGlrRlJFYUxCZW84R0RvK21YTm1lc2JreElUTWEzM3R6Vyt0WU5ndktJbWQ5c2tIbkk0ZXpLVW9KaGRHVVJRWWlXTnR4TkZ0d01LMVJMaG5LbTk0NU5ZcGdZOERGbnQzWHMvMGtDSVV4cWhxVjI3UFEvZnpCY3ZubFBqbHFCZFpvSFVkbElkWUhwblhEYWR5TUVHT1M2M2tSWDV0UTJjbXQ2dVVhSnl2SVNzWm4rSmJYM3Zud3hiUDUzMS9NRHM1TTU0dGtJeFkwV2hteTNDUXFacTlxbmpnaENVTFNhNjZoQ1F5SFEwUXB0TXE0dm5mSXBhdjdiRTdHeWNUR083eXpDZHVqTTZMM0ZDWlZGT3NEblhNZ1Naby9PTmRiRENkbnFOVW8xNmlrblpzclE2bHlNalJHSjl1MHNzaGxPQno0bUt2ZnZYeDQrSUVveCtqYlRrRllxMHE1c0xuTy9ueDVtaEduOGFMMklNY2pYaUM3ODdiSnhUUHJnd3Q1bHVEcXppNjRQbHRRRkVQV056WVlGQ1Zscm5zYnJEU0ZDbEVRSWxxbEhpQzZobUZaY2R2Wm5EeXZlT0taYlQ3eitVZTU1NjZMM0g1MmczWmxwS2tnaEVEVEpIdEZneWFxSElrS284Q1luQmcwSmhoeWZiUEFKeFJwTDVpOEtvTmFrUmVaRkhtbXNqSjdkcmVlL3BFUFlYSHJBcXZwbk54OWJwTW5ydDA0ZlFlY3hvdEtFTDFLa09FZ0g1emJHTHl5TE13d3hoeEZvQm9NeURKTjV4b085NjhqNUF3R0E5YkhFL0lpN1M1V3AxVWZJa1lWa01WZW1sSnhkck5nV0ExNTZ0SjFubmptV2J5N3lKbk5OWHhJS2hrSjErV1RmSTZQT085WkxtM3k0TzQ4MGFkcGxDSlZsZGhyOEN1UlkyK1B6R2hNcmxGS3F5dzNvUTd1M3gwc2xrOXlndEdtbElwVlVlQzg1NE9mZS96MDdwL0dpMHFRazh4QmMyNXpPQnhWMVVORzU5b0hMMW9aRldMeTRNaHpSVzZnZFo3NS9KQ2o2WUpCTldFNEtGa2JGa1FSakU3a0pzU2dUY0NJUWJ6SDZNaDlkNTdqelBxUUt6dTdYTi9kWTJ0OXpHaFlvWFNDcWpnSmhINWtaSzFqdVdpcDUyMENMcEttVmtycnBMQ0lPc1pmS2IyeUlVN0F5YURrQzRkMS9VSG53N0diS3NuVFQ0bzhsN3JyVHUvOGFYeGpDYUlTdlU2ZjM2elcxeXJPQnVtWlpHcGxMQjhnR2tJMFpEcVNWd29mQXRQNUxydDd3bmc4WVd0OVFqWFFTYVFzSnJaaDZQK0xsVkhqZUszaS9seXh2VHZqdVd2WEdGVWp6cXlQMHpSRUtZaVJybk5KYjljbmpWM2Q0OWFqUkxTcytNK1ExS3ppTVI5YUlvaGhmKzdhLzNkdlBuK0tteEFJdnhLTXJvcUNvOVA3ZmhyZlpBL0MrbHArZGxTWk02a1BYM2svcUpRa1NnaVNoRU5GQUtXWmpDdXEwakt2cDN6bGFNYkdaRVExR0RJY0ZDaDFVeGRMZWs5QWlhQlV4bTFuUmxRRHc5VWJNNTU0NWdyVm9HS3lWaEZEeEZxZkZFdGNPRmF4VVNwTnJTU3BtaWZKRHAyU1pHWFBFcU9JQytGek83UHB4MFZrMVhjNElHYkpPSkxyQndlbmQvMDB2dUVFV2ZVaHlqa1pIeDQxNHp6M2lDamxRMENwREpTaHFuTEtQRzI1WTdRWXJZaVNvNVJoZld3b2NzZDhkc1MxblgzR293bTNuZDBnTTRZUU5DRjZsRTVnamdULzBSUlp4bDIzVFpnTUIxeTZkc2hUbDQ0SUlRbEYrNVhRWEpCakpadlZBRUQxV3JEU1oycUlRbXN0U3N1OGsvQ25yZk0zdU9rZTVMVlNzY2dNYTRPQ1JldE83L3BwZkZNVlJBSEsybEJNNTIwMktKTTlydytSRUpQTVorY1V3K0VhNXpZSERFcWRudG8rSkMxZFNSSS9rMGxHVWJRY3pRNzUzR01Ibk4wNncrWjRqRkpKR3hZOFdRWmRsNkdVQTFGVXBlR2VPOWFackxVOGMvbUE3UnN6dXVDVE02dEtJdE82OXhQVVJxRklvMlVrdVNqRkVGRUdxclg4bVZsVC8rV0pvNVVEd25oWXlQbjFrY3lXcDczSGFYenpGUVJBRlpuS2pGWXE5cVl4V21lTXgyUFdKTU41aTNXT1o2OGVVdWFHYzFzVlJTNGNuNE5FaUFFeXJUbS9PYUFhUkM1dlgrT3A1K0RlaXhlWWpNcGV0VThUeGFZcVFFYVVaQ1V3S0RRWHpxNWhHNCtiSnRaaVFBZ2tVenpWZ3o2VVNxSUlXaExFUklFTUs5TjArRDlldHU0YU44RjFRU2tsTVlnVWVjYk85UFI0ZFJyZmZJSUlJQzVFNzJNVVFzYm01bmt1M0hFdncrRTZTR3JLdmV0d3dYSjkrNEJsdmFDc2NwQU9DYXR0ZG9BWWlFb29pd0YzWDh3NE9Genl6SlVyaktzQjU4K3NVVlhyNURrNDcxSEtKdzhRNVRFcTJacHRyVmVFR0RtYXQ1aW9LTkx1L0ZnNElBbEc5RHBOQ2pGR0lZWkhENXYyd3lMU25SenJhb1UwblhzZW5PSTBUdU1iVFpCampFM3I1R0J0Y3U3b25qdnZydFluVytSRlJkTjJ2WTJCQVpVenJJYTg0djR0ckxVb2xaeUVnbmVJV0JiTEpjdkZFWFd6eERxTDliQTJISkJuR1FkSGN4NTlhczdhMm9LN0w1enRaVWtqV3B1a0pPNGtiZCsxWnBUblVFRnRFeDRySnlGMGxlcTlLUUJ0MG5Rc0w3UllpWjl1ck4vaEJDeGJLK0w1OVNIWEQ1YzhmbVh2OUc2ZnhyZVVJQkdRTEJ2dDMzN2J2WHRiVytjdmROWko2RG9WZ3ZEMHM5ZlpueDdodkVNZDAxZ0R5ZUxOa0ttYzlmR1FNNXNiYko3ZFl0Z3VxWnVHNmJ4aHVUeEN4TE81UG1SdG1QUGtwU08yOTJZOGVQZHRyRlVEdE82aFlNcjN0U0dkMmdwanlFcEZyVDNCQ1VZcGVzY3RzcFY0c2xIS0ZPYXlqL0hqUHNTVHZVZk1zMHhHZzF4T2IvTnBmQ3NKa3FwSDBreUxyUXRONTN5VHR1UEMwVkhEWjcvOEJQbm1BUSs5OVJXc1RjNmpqZUNzcFd0cU9wdmV2TE9qS2JzN0J6eit4YWM1T3o3SG5lZlBVdzIyMENaU1ZadlU5WnkyWFlLYThzQmRPZHQ3Y3o3L3hETnNyVSs0OC93WmpCYTAwc21nTXNaanZWZXRGY004STJiUWRxSDM5RWlLNG9oUWxKbGtnK0pUczhQbG95ZXF4N0ZScHBMVG85VnBmQnNxeUlwTnQzYzRteS9xZGovTERFOC9kNE5QZmZGTFBQQ0d3UGQrL3dicm0yZkl6RzM0ME5LMkN4UnJlTitodFViQ0dOZk4yWjg1bm5weWx5ZWUzV1VRdGhnTjFoa09Da2JWaExJYzBYWHJMSmVIWEZBWjQySEcwMWNQdUxFLzUvNkxaeGprV1lLVXBNWTdOZU1tNnhtTGFaUGVkb21oYURKRk9jaFpHMWZiaStnL3RLamJ3NU9UcXl3elVtUVpjNStkM3VYVCtLYmpKTnhkQTlteTZjekQ5OTExNzhIQjRpM1BiRCtwM3ZqOU9kL3o5azJVaW9TZzBOa1czanFDNy9DaHdmdVdHRHhkTTZXdGp4aFVCVnRuTXFwSnBGTUxucjI4emU3T2dtRlZrZmRHSzFsZVVSUnJHRk13cWdycXR1SHk5Z0ZkNTVKc3BrL2I5TFE5VDh0QnJSVEdLUElpQTYwcGk1enhaQmhVWVQ3MDlPN3ViemtmcHZRQzBrcXBNQmxXckE4cnJ1NmRUcTVPNDF0UGtOVWVKQk5GZG5Dd0tQVmc5cG9mL3J1Ylp4NTRlQ05aK29ia0o2RVo5bDdpbnVBYmtCV0pLaUFxNG9NbE9BL1JVRTBLTm03UDhLYmgrdlloWFIwd09zUDBlS3NzS3lpTE1WVTVRSW5seHVHVS9XbERwbnFrY0ZJZ1A4WlppU1Jsamp4UFBaREs5T00zbG90L3NUOWJQRVZDN0I3N2NyVFd5V1EwWkhiSzl6aU5iMk9DYUtVb0RtYUxvN2UrODB6MmZXODUvMFl2NUNHS0NxS3hyY010VzhSa3lZakdlU1RhbnVKcWlDR2lsZERVbm1VZDhCR0tJbVByZkVXMW9aaTdCZGQyRGxoTWJiSWsxZ29saWp3ckdBNUhhQVd6K1lMZDZhSlBwT1IrdEZJUlQvQVdVRXFKTWFxZUIvc3JsL2IyUDhoTlViZE9LUldNMWdMQ2RIbWFIS2Z4N1VrUVRpUklCdWoxemJKNDdhdk92S1VjWkpzK1JrRGpBOFFZMFZsRlZBb2lDQUd0QWtVMnBHMW1YTDB5bzY0VHdEQXRHd1hiUlVScGhtczVtN2RuTE4yY1o1NjVRZlNDTVZtZm5ZWWlyOGkwd1hVZGU3TTVuUXNVMmlUbC9SVUZWQ0ZhRWEyRUQxNmJ6WDdGK25oRUw4U2d3R2ZHeEkxUlJkMmRRa3BPNDl0ZlFaUlN5VkZxdVF6cTdlKzQvZTNWV25hbnRTS2lVRmx1NkdJZ09BRktvbmlJZ1dwd0h0c08rZWhISDJNMjdUaC92a0tiMUdUYk9pVHVHcWFQRUFBQUIxOUpSRUZVdWtBTVFwNFp0czROcWRZMXMyYkIzdjZVNklROHl4SWRWd3plUmFMenpKdU9MbmdLWStpcDBvaWdvdWF4dmJiNStXblRQY05OZFVTbklBUVIrY2MvL2s3KzlMRm5UdS91YVh4Yks4aHhGUUZ5MndYOXhqZWZmM2c0cVY2bEVTMGl5bmZKOFduWk9DUTR4SGZrV3FqcmRUN3crNStoYVdwZTlhcDF0RTdZTGU5QlhDU1M2TGk5M2pvaFJNb3laMjJyUkZkdzlmb3V2b2xrMnJCYzFnUWZDVTRRR3hQYjBEdHluWkZuQmtFdXo1ejdwYjFsL1FtNVNhWHRGNE5LQkU2VDR6UytZMGNzVnNlc0dJWHgrbUR3NnRkdGZYK1dxeXFJeG51d0xoblpCTy9JTXVIeWN6Tis3VmMvU1FpZTczL0hCU0tlemdsZEhRbGR4QlFyT0hyQ2hTQ0pXdUo2MTZpeXpLbldNbWF6aHRDQWM1N2xzaUhHNVBOQmpHaVNSMGhtOUxKVDhUZXV6dWUvRjJKY0dXWjJnTk5LUmFXVUdKMjh1ay9qTkw1VEZXUjF6Q3FjRmYrYU41eDk0Mml0dUJnQ1JGR0tDQnBGMXdZKzlaZmIvUDV2UDg3YWVNQ1B2T2QrOHR6aFlzVDBEWWdHbEVtSkVVbDlSR2RqV3JwNHdVV0lMaVRRWWFacDU0RjYzdEMxRGtUSXNtUURKakdDcU5pRzhPRUQxL3lyem9lVEhoUldRUndQS3piSFErcW1PMDJRMC9pMmhiN2w3MExDQkRxbGxiOXllYmI5MkpjUFBsZ1VKa1JSU2tuRTZPU0gvZEUvZVk0UC9PN2o5UjEzVHRvZi84bjd5TXFPb0NLNVZzbjZRQ3RVbnFpd3hpUUY5OVlLUlpVVFkycmVvNDE0RzJuYmdMT1dyRXFqMytCamIrOFdHRlNsYUpPaGNyNDBDOTB2THp0M2padjZWbFpCTkVxTDhsR00xdmg0dWprL2plOWNnc0N4RHB0MDNzWHVpUzhmL3VWOFpyNVNGZ09VUm1aSGx2L3ZBMC83Zi8reHkwODg4TXJOSjk3OHRqdmRZdW14ZFVTdkFPbTlUSkxwd1lTWmdtYnBDRkh3WGNCMUNjTWxQbGs2ZXh2b0drZmJMaW1HQnBNbGltQTZNaW15d2x5ckNmOXlHZHlqM0RSb3NVRElqSTVyVlNFaXdwWGR3OU03ZWhyZjhRcXljaURxZ082dlBybjk5Qk5mUHZxb01VYjI5NXo4NGU5OVpmcXhqejcza2U5NTgva3YvZkI3SHJ5Z1ZMWTJYd1lPWjU1cGI5VXMwdTh1ZWdmSlp1bTVmR1dKUnRFY2R0aUZ3M2VCMkR0SnVjN1QxUjN6eFF3dkhWbVdRWlEwc1VLc1ZlRzNENXZtWXlMSFhoMHJFZVU0eURNWkR3cG16cDdlemRQNGp2Y2d6K3RGQU9WY2xJMnp4VndoRC83Wmg1OTc1cy8vN1BLdnZma3R0OC9mK3RaN2ZrU2l1U05FVWNiMEh1Tk9jRllJTVVIUkJWQ2llT3pKUThxMWtrSXAydG9uUUNJS0NhbWlOQXRMUFd2d3pxRlZUblNLWnRraEN1OVUrTU9keGV4WFR2UWRxNUZ1TkQzTHNNd3k1dTFwZ3B6R3R6L1UxMGlPbFFYMFlEd3AxOWRHK2F1bjB6WSs4clk3NzMva2tUdi9CNXkrM3lYOWhDUW1iUlRlQzdaTktPQ3NVQXlIR1ZjdVQ3bSsxL0xJMnk0eTNXNTZpRzA2aHZuT3M1dzJITzR1V015V2RJMGoyQUhTYVZ6bll0QjhaS2ViLysrenVubUttNTRlSzU2NUdLM0ZoWEI2RjAvalAyaUNyRDUvMGlkOUNBemUrdjMzdk83ZDc3N25uN2hndmllNFNQU2lZaGNnQ0pKcmZFdzloVVRCQitIRzlSbGZlbXlYTjcvekxvYkF3VzVEYnh1STdUeTJ0alRMRHRzNW5IUE1Ea1ZpazZ0QmtVZEgvTkNSYjMveG9GNTgrVVJ5dElEUHN5em1tUkh2UFBZMFFVN2pPeGd2aEFVLzJZdXNMTGIwWW03M0xqMjNlT0xDeGNscmxVaUJEYUpCZVFYQlI3eVgxSHlMY0xDM2RKLzk3RUc4L1lGSnFXekhaejk1dVIrLzlvMThUREtsV210RW9qUzE0R29qaGRHN1RYQi9mR0RyMzF5NGJnVkNURGdyOEFLeHlESVpGQm43N2FrSXcybjg3ZlFnWHkxWjFJMmRSWFA1MHV4TDFTQ1A0MkZ4dDlGNkpJa0JxR3pyc2JVSHBWak8yK2J6bjl2K1FpZ0crbFd2R2srZSs4SlZ1c2FuY3RYRDE0MU9pRnhCcEdtOXI2ZW1sYWcvWG92OUY3dnQ0cmZhNEs5eEFvUklMLzRHU0o0WmpOYTA5aFJ2ZFJwLyt3bHlNbEZVMnpyN3pETUhYNnhuM2RQRFVYa3VLN1BiRUdXQ2k0U0lMQmV0UFA3bGF4K2Z1dUxwMTcvcHRqY3N0M2VMNmU0eThjZTFKa2xiSlp0bUg5bHJyUC9FNFZRKzNyWHF3N1BZL3VMTWQxK0l5S0pQakpwanE3Umo4WGljRDZmSmNScmZkUWx5bkNnaXlNN3U0dExoVWZNWWNPUnRNTUM0YVZ4NTVibTl2MzdpbWVuN1gvL0lmYThkbWU3MTE3K3lBeWlsbFZLOVNtTVFZYit4NFVPSEMvZnIxL2Z0L3ozdi9JZGFjWi95RW8vNnBEaHB1K3hWd2xpOTVEMjNUK1BsMDZSL3RhOVptZXprUUttVUdvaElBVlJuMW9kMzNYWFh4dXVpYy9kZTNaNStlbmhtZlBpcWg4NzhiL3ZQM1hodHZiQ0hvTFpEbE5aSHVSS0RQRzY5UExzM3M1K3pYZzY1NlNSclQvejUyR2sxTTFweWswWHZQZTUwUzM0YTM0VUp3bVNqcEcyOHNsMjRkYnBWOUFsejhuTjZZN05hTzdkVnZubCtzQ3hEVkFjK3lBMGZZdGY1T0xkT2puc0tianFwV201NmtvZStVa1NsRkVXV3ljVXptenk3czN1S3NUcU43ODRFZWRlUDNNZW4vdUlLOWRMZFdrMU1ueGpteE9kVy9QYlZ2MjlPL0QyZVNBeC9JaUZXdnR6eHhERkt0TlprV3JNK3F0aWR6ay92MW1sOGQvWWd6Z2JxcGNQN2VHdlRmdEw5MU45U0ZWYWZYMVdJbGVKaGM4dHhLcHlvR3R6YVo0UVlxYnZUTGZscGZCZFhrQmZ4L1NjLzN2bzZtVkF2NUpoNmVuWTZqWmRsZ3J6UXY3bXlGbGRmSlFGT2srRTBYakx4L3dPNklHM1huUVd2ZlFBQUFFeDBSVmgwWTI5dGJXVnVkQUJHYVd4bElITnZkWEpqWlRvZ2FIUjBjRG92TDJWdUxuZHBhMmx3WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2xSTlRsUkViMjVoZEdWc2JHOHlNREV5TG5CdVoxSVE1REFBQUFBbGRFVllkR1JoZEdVNlkzSmxZWFJsQURJd01UVXRNRE10TURkVU1qTTZOVEE2TlRrck1EQTZNRENmMUpsRkFBQUFKWFJGV0hSa1lYUmxPbTF2WkdsbWVRQXlNREUxTFRBekxUQTNWREl6T2pVd09qVTVLekF3T2pBdzdva2grUUFBQUVaMFJWaDBjMjltZEhkaGNtVUFTVzFoWjJWTllXZHBZMnNnTmk0Mkxqa3ROeUF5TURFMExUQXpMVEEySUZFeE5pQm9kSFJ3T2k4dmQzZDNMbWx0WVdkbGJXRm5hV05yTG05eVo0SFRzOE1BQUFBWWRFVllkRlJvZFcxaU9qcEViMk4xYldWdWREbzZVR0ZuWlhNQU1hZi91eThBQUFBWWRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNmFHVnBaMmgwQURRd05ERnFyaElBQUFBWGRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNlYybGtkR2dBTWpRM0ZDNFZrd0FBQUJsMFJWaDBWR2gxYldJNk9rMXBiV1YwZVhCbEFHbHRZV2RsTDNCdVp6K3lWazRBQUFBWGRFVllkRlJvZFcxaU9qcE5WR2x0WlFBeE5ESTFOemN5TWpVNVB1ZkRrd0FBQUJKMFJWaDBWR2gxYldJNk9sTnBlbVVBTVRJelMwSkM0ZnV5Y2dBQUFETjBSVmgwVkdoMWJXSTZPbFZTU1FCbWFXeGxPaTh2TDNSdGNDOXNiMk5oYkdOdmNIbGZZamczWXpRMU9XTTBNelExTFRFdWNHNW5FWmFYeUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL2RvbmF0ZWxsby5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRTRDQVlBQUFBZXZid3pBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQUJJQUFBQVNBQkd5V3MrQUFDQUFFbEVRVlI0MnV6OVo3Q2wxM25mQy81V2VOTk9KNGZPQVVDanU1RURBWUtaVkxJa3l6SmxPY2l5Wk5tVzdaTHZCNnVtUE9VcHUxUlROYXFabWc4T2QrenJLYzlZMStuYWxpMUxsbWxMRmttUkVoTklnZ1FKZ0lnTm9IUDN5V25ITjYwd0g5WjdEcG9VSlpHVXFMR2s4eFFPemtFM3NIdGp2K3UvbnZSLy9vL2cwUDdZV0tmVElZb2lmdlJIZjVTNXVUaysvT0VQODh3enp3Qnc3dHc1N3I3N2J2SHhqMzljVkZWRnE5WHlEei84TUU4Ly9iVC9lcSsxdkx6TVQvM1VUeEZGRVQvMll6L0c5MzNmOTlIdGR2bnNaei83UitvekU0Zkg1bjl1KzhtZi9FbXlMQ05KRXJ3UFo5VTVSNi9Ybzl2dDhuZit6dC81WFYvalozLzJaL2tmLytOL2NPblNKUUJPblRvbHJMWGN2SGxUREFZRGNjYzVFTmJhL1orOWxCSWh4TmNDeEFQRWNleVhsNWM1ZnZ5NHI2cktHMlA0MHBlK3hBYys4QUVlZWVRUi91RS8vSWQvSkQ1L2ZYZ0UvK2Uwdi90My95N1BQZmNjWlZtU0pJbHd6aDBBeEZxTHRaYmhjT2puNXViWTN0Nyt1cStobE9LSGYvaUhzZGJpdlJmOWZoOHBwWGp4eFJlRjkxNTQ3NlgzWGdJS2tBMVFEZ0RTMkFFb211OGU4RVZSdUJzM2J2Z2JOMjQ0SVlTUDQ5aHJyYjF6anZGNDdIL3FwMzZLOCtmUDg3Zi85dDgrOUNDSDl2dHZQL016UDhOSFAvcFJjZm55WmFJb1FnaHh4eGtWSkVsQ1ZWVllhLzNhMnRwditlL241K2NaRG9la2FVcXIxUkw5Zmw4VVJTSDJBZUc5MTRBV29IMEFpTG9ESUhjQzRxdUFjY2VYRlVJWTc3MFZRbGpBU2lsZGtpUysxV3I1dDcvOTdmektyL3lLUC9RZ2gvWnRzVGZmZkZPOCtlYWI5UHQ5bkhNQ1FBZ2g3cmpSdlpTUzJkblpPdzgwQUwxZUR5a2x4aGlHdzZFY0RvZjcza0lCRVJBSlFlTDlBVGcwRUxWaWxaeWM3NlN0T05hRHZITFhOb2RqNDV3QkRFZ05PSEExWUFHUDkwWkE3YjJ2Z05wYVcrZDVicXVxY2gvNzJNZjhYWGZkeGVYTGx3ODl5S0g5L3RyeDQ4ZFpYMThYMXRyOVVFZzBJZEQrN1kwUWVDR2tuNXViODMvLzcvOTkvOU0vL2RNQUhEbHloTWxrZ3JWV0ZFVWhyTFYzQWlNV2tIaElBQlZyMlRtMzJEdjZ0cE96WjA3T2Q4NzJldG14ZGhKTmV5K3lRdmo2RnovMStuOTc5dnIyaXovNjlyUDMzM2Q2L3ZHODl1WHJ0MGF2MzlnY3JEOTdZL1BxcU1pM2dRcW9nUklvZ0ZvSVlhU1VkbXBxeXUvczdQeWg5aUtISHVSL012dDdmKy92OFcvK3piL0JPWGVRSndBeWJYWGxRMi8vODNPdlBmZkpTWC8zalpIM3dvTjNNek16Zmo4LytkbWYvVm4rMlQvN1o1UmxLYXFxRXQ3Ny9WQXFCbElnOHhBZjZXVXozM0h4eU9NUEhadDlhcm1iM1I5cHNaUzE0dGs0UzJLRXdudUgxNEozWFZ6cXZlUEMwcVg3anM5OW9OdE9qa25uL2FsZXVyT3psUTdmZldidXRaV3hlZTM2enZnclg3NisrdEx1cE5odTNtdnV2ZmZPT2IrN3Uyc1BRNnhEKzMyMXhjWEZyOHF6OXhQb1l5Y3ZKQTg5K2wwL3ZuTDE4bS8yZDkvNGtoQW9LYVV2eTVMTGx5K0xPSTc5ei8zY3o3Rzl2WDJRZkh2dm93WWNMU0JyeDZyN2d3OGNmK0xKcy9NL2VIeGg2b2swaldmU1ZxS2M5K1JGU2Vrc1RrR2Nhc1o1eWJrekM0OUdVandjS1Iyck9FWG1sWWk5bit0b01kZWRTVTdkczlSNS85WmlxNitIa3pkZWMvNy9lejB2bnZadjVUQmVTdW1kYzlaN3ozdmYrMTQrK2NsUEhnTGswSDV2OXN3eno2Q1VPamprUWdqdHZlZWQ3L3JPdTZZNjJidVRXSDM4em9SNmIyOVBDQ0hjaFFzWCtQakhQeTRBNFp5VGplZElnQXhvUFg1Njd0U2ZlOXZaSDdod2JQYlBwYTE0YVZJYnFaTFlrMFJVa3hLa0lyYzFUZ21rZGRqU2tFVmFaNjJFV0VVb3E0aG1wK2p2WEVVb1Nhc1ZNUzVzL05rWHJpNnVybTB0VGtrbDVyTDB4bFplM0FDTTk5NDY1NXdRd3A4K2ZkcnRWK0FPQVhKbzM3STk5TkJEL1B6UC8vd0JRQURkZUFFZWZlSUQzN2UxVlhUamlKM200TmZPT2ZyOVByLzRpNzhvaHNPaGVQbmxsM0hPcVRzOVI2emwxTjk0ejdsM3ZPM1V3bytlV0o1NVNyZGJjVkdVS0c4WjcrV2lOaU9TYmdKU0lLWEdPNDhmbERCMGxLYkFUUmwwSzBGblhTYWpFZURKSXMzZXNCUWZmdVl5MTFaM0VIaWNrdzhlYTZmZnMxdlYvOTVhVysrREJIRGVlMUZWMVI5S2hNakRZL2svaC8yamYvU1BtRXdtek16TWlDYi9VQWloQWZuSVkrOWNUcnNMNzFsYlhjblhWNjhWQVRqc0orK3NyNitMeVdRaW5YUDdnRW9GZElEVzk5MS8vSUVuenl6OTlHS3Y5YjdkNFNTK2RYMWQ3S3p2Q2U4RnNwVWlVazFwYWtwckVjYVJHbytaR0dvMGs4b2dyRUZMamFzcmh0dGJkTnNKcGZWODdObXJYRm5aUmtxUUNpU3VvNHJ5ZTQ2MHNyTU5nT1BtQXBhN3U3dDg3L2QrTDRjQU9iUnYyYnozUFBUUVErUjV6a0h6TGh4MjliNC84YU1QNXhYblZtL2Z1TG16ZmNPQ2tPQVB1dC83eWJqM1BtbnlqYmFITGpCMS91ajAyOUk0dW1kblVySTltSWk4cmttbld1alpOclFqb202R1R4SlVxcEZKaEphS0Z0QlREaWNzMHNONHMwL2RINkU4akNjVm4zemhCcGRYdG9samlZNFZTZ3VpeUtOOGZkK0NFdCtmeFZHM0FZa1dRc2pSYUNRKzhwR1BISVpZaC9hdFd4UkZaRmttdlBkQ0NISFF5SnViWDg3aXp0RW5qR0hKdWVxV3A1S2hIeExBY1VjaWYxQ3BhaWZSdEJiTXpMYlQyVzRTUCtBbGNXbXQ5eURpVm9KSU5LTnh5YTN0UHZsNFREdVdaRXFTYUVXczJyUTdYVmEyKzJ6MEJ4U1RJUkVTTFRScEhQUGlqUjFldUx5S2xCNnROVUpKbkFXSDk5TGJPUGJsK3hkaTlaRWJWVDBFWXVkY0xZU3dYL3ppRnc5SzFJY0FPYlJ2Mmo3OTZVL3pwUzk5aWJxdTkzc2VHdEFQUGZuOUo2M3VmbUNjRjZJcUpwdmN3WnU2QXlCeGs0eG43NzU3K2E1SFR5MzhpQmZpWkR1SnV0MHNPVmRiYU1VZHNaZjNjYzZ4TzhqWkhJN3czakFWU3pvNklwS0tWcFl5TzNjRVl6eDZOT0RNc1VYeW5RSEdPamIyUmx4ZEgvREd5cERhT3JKVW9XS0ZsSkxLV1lUd0lrcWt0N1U5UFpOa1QyMFkvMXBSbEJHZ2hCRFNHR09YbHBaWVgxOC9CTWloZlhQMjVKTlBjdlhxVmE1ZXZZb1FRbnJ2bFJBaTh0NUhpOGZ1UHEvVDNxbGlNaXB0UGVyejFad3AzUUFrQXpwdk96bC84bDFubHY5V0V1bnZWMmtVeFVvZ2hHUjZlcDVCN3RERkhrTnlKdEdFMmVtTXVhbFpZcVVvUndXVGNVbFZXa3h0dWIyMlNUV2FvQ1gwcHRvTUo0YVhWelo0OGRvT3dqaGFpVVJIQWluQTFqWE9XclNXSU1CWXA5UElQZG1TNHBjTG1Pem5JVFJFZ01NYzVOQitWL3NyZitXdjhQREREeC93cXg1NzdESHF1aFphYTlGMHZiWEh4OGVPblVqbUZwYWZTckpXdHlvbVpqZ1kxSUM4bzdPdW03Q3FmWHlxTmZjZGR4LzV5WFlVZjkrNHNsRlpHVitVTlNDb2l4SXg2Tk5SZ3FXc3c5MUhqekE3MVNWSlk1SWtKczFTb2tnekhJMjVkZnNhZGJWSGxrbTg4dHpZR3ZFcm43L01pNWMzY0xVREQ4Wjd2UGVZeWxBWGhraEpsSktZMmdubkViNHE3dTFvZVFSUUl2QytoQkJDTk94Z29pamlneC84SVAva24veVRRdzl5YUY5dFI0OGVaWEZ4RWEzMUFUdjNGMzdoRjBSWmxoaGp4QjI5RDNYcTdNWGxoYU4zUHpRYzU2SW9DamNjRDJ6ak9lNWs0R2JUYWRUN3N3K2UvZ3RMczFNL01EWStWbmk4RkNKS1k2d1UzTmpjeEk1eVRuY3paSktpYk14ZXRZdTNCaThqZk8xSWxVUzNFMnJuaUZTRXNQRGM2eHQ4L0xWVmhnSW1XVVErcVVnOHpEbFBXVm9rQWgxSnBGTFVsYVcyQW1NOHNhWTEzMmtkdlRuTVh3U2lKcDh5Mjl2YisvMFEzK2wwV0Z4YzVNaVJJNnl1cmg0QzVORGdneC84SU04ODh3eS8rSXUvS01iak1Vb3BBTEd6czBOREt6a2dEaW9wOVlYNzMzYkJrSnllakNwMnQvYktRWC9YM2hGaUtVQjNFcDMrdFNmdi9wTm41M28vUHJHK0hTVVIxSWFpc2tnTWRWN1NINDhZMUJNV2wwOWp4a01teFlDa0sybGJpYmVPL3Q2QVdFdHdsakt2RVZMd3dodGJmRzQwWXZwUG5HVnBxY05rV0pQdjVyaU5DZTd5RHZXd1FCYzFrUUNuSE01N1BCQnB3UHNJNjQ2RVNwYXZnTmg3YjZ1cVFpbmx2UGYrRTUvNGhMOTgrVEpDQ0gvczJESHF1dWJJa1NORVVjU3p6ejU3Q0pBL2pwYW1LU2RQbmhUUFBmY2N4aGpSc0hUMyt4bjdPWVVHNGlUTmt1T25IM3hxczE5MWhCRGUyR3ExeVB1ak93Q2lFVUw5eEdPbm43ci8yTXhmSzZ5WXFTYldseFl4TG1xc3RTanYyWm5rOVBNaFR6NTZtbWl4aHhzVnBIZ0VEcm52aXFUQ0NDaExnM1B3NHJVdFh1eDZUbi93QWJMWkREeElJVkJTVVJlV3ZiVWg1VTVPK2VZTzlkVmRpbHQ3T0FOYUNZenp2ckpPUmNLZDBGcTE2OW80QWRhSFVyWnlnUjFzYjkrKzdWWlhWNTJVa2xPblR0SHBkUHpTMGhMMzNYZmZJVUQrdU5ySFB2WXhCb01CVlZYdER5cmR5ZEtWaEw1QjVMM1hkOTk5WVZaa0N4ZDJWd3ZWYVNXZ0lxRjBMTytzWU9rb1VpMGRuWjcwUjhlR3RjTWtxYkJPb0tRR0JLWDFyTzMxZWVUY0FxZG1wNmdyZzVZQ3ZLTW9hc1lXcGxKSkZGSm9sTlo4WlhPWDY2Y3pqci96T0hFV1lXb1gva0FQd2pwMElwZzcyVU9jbk1JK3RFaXhYWkMvdWN2azlXM0dsOWFwOTBxOHQwb2JjNndWUlRQOTJsZ1Bwdm4vMjZmR0crOTk3Wnd6UWdoNzVjb1ZueVNKMjl2YjQ0MDMzdkJTU280ZE84YkpreWQ1K3VtbkR3SHl4OEhlK2M1Mzh2VFRUeU5DWnI2ZlE2ZzRqZVhqNy95clo2dXl0czkrNW45Zm9hR2lIemwrOTNFcmtvV3lHcEFtTWNZd0kyWFV1dk0xVFZYNU4vY21yODFGclZ0U3VGTW1Od3hMeDhTQWlqTFd0dmM0ZDZUTGhaT0xlR3VSM2lFOGVDR1JRbUtxR2l0QVNFRWtKYTl1RHJoMUltWDVIVWV4Qm56cGtGS0FBT2RCaXNDWlI0SjNEdWM4MlV4QysyM0wxUGZNTVh6c0NMM1ZJY1gxSFZGdjFvdHUzRisrNTlSaS9JSEg3N24zU3k5Y1hYMzJ6WlZiTkhSNDczMEJWTjU3NDV3elJWSFk2OWV2TzVwSlJxV1ViN1ZhdlB2ZDcrYmVlKy9sNTM3dTV3NEI4a2ZkMnUyMm1Fd20rMFJDRGVnZi9XdC9ieXFLbHYvR2xUY3Vmd1pZYndDaU96UEhUNHdMUDFYWHhrdUJ5TEtrRmFkcDNMelVRZFB0MmRYKzFmdm5XcS9NUmZKVUhDbThyUmlOeDJ6dDlSbU5TNkpqTFY2NmRJczRVU3pOOWVoTmR5aU5wU3dOa2ZmNEtFSnF4ZWJPZ0RjVFQvcmdBczRDdGNQN3QvNGdWMXVzRktoRW9SRnZGWnFsd05RT3A2Rno5elRKUGROQzUwZHA3L2hqUHl3N1AvN1FzWVY0Y1c3MjJPb0g3ci94K1JjdS8rYS8vOGp6bjNuMXh0WnRJQlZDbE9CTDczM3B2YStGRUlZd3FlaTJ0clpjdjkvbi92dnZ4em5uRHozSUgzRjcrZVdYUlZtVys5NGpBcEVJS2VUeWtidmVPek56L0IzUGYrR1RId1ZhM3Zzb2pxUHU4dW1IN2g4VnB1MmN4enBQbkxaVWtuWWkzbW9VV2tEZDNCNzBiL1dudnRScVIrK2Rpa1EyMTAxRUNjaW9SR0s1dWI1SHJBWHRWREdvU3VhR1kzcnREQ1VVaVpURVdVSi9sUFA4YUlKKzZnaTZrNEVRbE00Z25FY3JnWFUyMEVtMFJPREFDNHoxQ0FsQ2hUY1RkU1ZkRlhFNjdYRCs2QXgzM2RlZFRxeDRYejRjTXg3djBjazQ5ZTVIVHo1ODEvSHA3M3orMHZybmZ2a1RMMy8wMHUyZFZjS2dWUW1VM3Z1eUNjUE1lRHkyZ0gzMjJXZjUzT2MrdDM4cEhBTGtqNnJ0N2UwaHBXeG1ORVFFUG5uOHllOWVXRDUyejA4TkIyTzF0bnFqSVBDbzRpUnBkMFV5ZmJheWFDRUVVZ3E4SUZWS1pSeGtCTjRCdFhldWVubG44dHpKenZRdE9TelBKVm1FcUd2eTBRU3NaVkRDM3A1QkwyVWNmL3NDMndKT1hLOVlOaEtkYUtySzhNcGtSUFh1b3lTTDdZQS9MNmlOUThjU0xUMUtDVVNEU3dlNFpxQUtvTENHMlRqbG9mWWNGMXJUSEk5U1hGNHc2SSs0M1ord3V6Y0E1K24xT3N6T0wzWm41aGVmT25mbXhNTVBuRHYydGhjdXJYN201YXRyejMzOGkyOWNMWXdiTk41ekh5dzFZSXFpc00xbHdCM2U4eEFnZjFUczhjY2Y1OWxubjBWS0taeHpLaVRpWkZLcStORzNmKzkzRVU4OXVEdmFmdFBZWW45MkkxbytkcmJuaFd6SGtTSk5OVW9JVkJMSk9OTDdpYjF2RG8wRHpMTTN0cSsrNzlUOGMxMXQ3d0prS29TZ3JrbWx3T0laZTBmci9BeHVQcVZPTkJ0WlRmcmltQ3lIdGQwaFd4YzZwSXNkWEdFd0NrYTVJUktnQXpBUGpxVlNna1FydlBkTUtvUDBrc2Q3U3p6ZW11RmtsRElaam5oOWJaM056UjJzdFN3dXpuRHVuaE9rV1p1cU10UzF4U05JWjlxdGR6NTUvdDFQUG5idkU2dHJ1N2UvODIzM2ZPTHByMXovalE5Ly90THJvNkxxTjBBcDdnUks4K1gvb0VHaURvL3d0OWVPSFR0R1VSUWl6L01tdEFxY3FRY2VmUExrUSsvNmtiKzFsWXV6a2ZKMmUrWHlWMVp1dnJ3RlJQYzkraDFuWm84Ly9CMmowaytYeGpVWnZiY3IxMTc0MVByS2EyK0NxQWl6NEU2QWRONkxYcnRWbityRmowdnBwN1JXdnF5dHFDcERwQlR0KzJZNThzZ1NjYUxRVXFLNktmbTRRcTNuM0Q2Um91NWJ3RThzMW52UWlpaVNSQkZnUE1xR1JOMUwwWVJiSHU4OHkybUw5OCtlNGozVHAwZ3JlUDNLTFY2L2ZKUGQzU0d6TTIzdU9uT0VwU1BMdEtlbXlkcGRCQTVUbG5oblJaSm9wSkRnblc2bmV1YllmUGYrVTR2VER4L3BKaWRNYWFyVnZYSGZCdzdYblVvclgydS8zYThmZXBBL0xQWWJ2L0ViL016UC9NeCt4M3kvY2hVQitqM2YvU1B2NmxmUmcydkRBZmVkbkZxNDYvd2pEejM3MlY5OHczdm5uR2pOVGtyZkdSVTFDRTlSV2ZCZVF6d0hUYlFUK25MV1F5WEFmUGJxMmd2MzlFNTg1bVJML1hCdWpHckZFUnJGc0tlSTdsL0FacHE2OHRqY2dMRG9xWWlKSHBCZE9JYU1OWFZ0d3JpdEZtQWRibUx3ZUxTV3FFaWdJMFZlR1hyRXZHUHhGQmZUSG5GcHVYSDFKbGV1citCTXp0SGxHVTRjWDZMWDY2RjFqSmN4U2tmb1NKT2tDVHFLS2Naanh2MGhrMUV1aHVPQ3phMkJINDZyMk5UMjNGM0w3Yk1MNzduN3FZc25adjdiUjU2Ny9qOVcrcE9WNXZQS204OXVYeUJpMzN2NlE0RDhJYmZsNVdXZWVlYVpnODQzRUIwL2ZucU8xdEczcnczSzdyQTBmbUpFdEh6eTNOdVhqMTE0WnZYV3k2dDFWYXJ4TUNldkZYRXJDUm01ZFhnbjJxRmpFWktRNXFEVUNNcCtYdVhQckEwL2xCN3AzaDJiK25GcEhiVzFUTTdPVVhaU1RBN08rY0Qva21DVENIM1hGSEdpY01ZaVlnSE80ZkJvNVZFZGpkUUM0d0VwY2NKeHBqZk45eXhlNUpoc2NmM3FWVjU4NlUzR2s1eVR4MmU1Njh4cGVsTlRwSzBPUW1pRWxqZ1hRalR2RGQ3WERQZjIyTjdZNGZiS0RqZHViWlBuTldta1JSd3BFQUlwcFpydUpYYzlkZC95M3p4OWZPcngyN3ZqWC92OHErdWYrOHFWalRVZ0VwRDdrS05VVGNqbHZ0MUFPUVRJdDltTU1ZTEFaTjB2NzZyNzN2YjlkeHMxOVdCUk9tcnJHRTlLZi9ib3FidlBYWGppZ2RWYkwyK05KME14R3VWMlVrZFlJTzBrT0FRb3ZkOXd1ek84Y041akFQdk05YzNyQzRuODFjY1hXbWZLYmpTM3RwUXhXZTZnSzFDcFJHa0pIblNrTU41VFRxVm9ZOUUyZUlwSUNXSUZyb1FrVnNoSWdna2gxaG5kNXQzeEF0emM0Sk5YYnpNZTdOSHBkbm4wOFFjNGN2UUkzaFFvclJGU1lhd25pZHRnS2liREhYWTN0MW01dmNIS3lnNGJHMzM2bzVKdUsySjVQbVc2azZJalJacGx4R2xMS0FrNG56MFN5WGVOSi9VRDc3aDQ4dlAvNGFNdi9mdVB2bkQ5S3o3a2I5cDdaSlBNMS91ZndiY0xKSWNBK1RiYmh6NzBJYStVdXBOOUcwMHRuVGxYaTNTaE5FTzhkYUlvS3Ara1UrbVp1eDU0NU9uZmpKOFZJdTU1Uk9ZODFLWEJ0eE5Va29vbzdYU0ZVQktjL0pyNE94d083M2x1bUYvajR1eWFXY2ptNnVtVVJFa2lLWkFJZkpObzc5ZkJTaW1vY2tNYVNSSXZtVTZUMEFqVW5qVFZPQWxLU082eE1RKzZOcU5yYTd6NDZpMmlSUEhJSXhjNGNmWWluWmxGdkNzdzVRUXBKYzVaNGtTREVLeXZyUExtYTVlNWNuMmRmbjlJTjRzNGNYeVdoMmU2ZE5zUmNhUlJVaUdFSUU0em9xeUhNUjVUMTJJMEdQb2tLYWZPMzVYOWliLzRBWGZ5N2lOVHYvUnJYNzcrOGFzYi9iV3Z1U1NxYjJmeWZnaVFiNk45NEFNZitOcUVVa29wZGJmVE82YmpPTFBXZWxNN1VSUzF5Q3ZEOG9sekY2Wm5qaXpYVmEzcnNwSkNSamc4MWxxUFNHajNGbzlHVVJaWDFYaWZSaVh2eUcyVVRuWFVmV1R4SFpzTDZWbHBQVmxoMFZvajJTOFZCNUE0N3ltTUN6cUpFNFB0UkRqcDZUcFBta2hhN1FTcEpNTERBMVhLa1NHc2IrMndzZFhuMU9sRkxqN3dBUFBIN2thb0JPOExYSldqbEVZb2pTMExkaloyZVAzVjExbTd0Y3JPM2dBZEN4NjhlSUxqUiticFRVK2hkSXlwRFVyR0NLbW95eEpuTFZWdEtmSUtIV1hFYVZjNElySld5b1dMeWNXWnFmYnhrd3N6VC96YXM1Zi94U2RmdmZYeW5SNjBBWVk3Qk1nZlh0djNJSEo2ZWk1dXAxbTM5T0JzZUo3ajBySTF5Sm1lWFpvNmV1S2hlL2RHdTV2V21vbkR0ZTNFVXJkaVBFNmd1MGUwYm5lcWFyUjdSMDZ6UDFHb3o3enY1RlBUSjNwLzJ2U3JyTFllcFJTMjVkRmU0TDFBS2hFeW1PWWsxYzRqU28rS0hWWko5aVlHandZcGlDVThwbG9jMzZ1NGNYT1hTVkZ5LzROM2NjL0ZCNG15R1lTS3daVGdIVjVxd0ZBVkZWZmZ1TUxsTjY0eEdnM0pFbmpvL2hQTXpjMlFwVEZLUmFnb3dudUIwaEZLUmxSVmpYR0s4U2dIQ1pGV2FDMm9Ta3VyMnlQSk1vckMwSnVlNlYyOEovcXVXS25GZHBMOHJ4OTU4ZW9YclhWMzVpRDdaV0IvQ0pBL3pFaVJTdWExazg0NmhBaWNwdUdrWkdkWTBFbDcrc1E5ajl4OTh6Zi8zUzFuaTZHejJZSURwSkpZNTRWT3VuTlIzSmxqc242N2FUYjZwc3FUbkhoOCtlN0Y4M00vWm5NM1g1ZkdneERPZVVycndYcThCZUU5VVJST2xCQUNJVHpXZUp3RFQwaklKN1hIWXVsNXdhTDA3R3oyS1lzSjkxNDR3NzBQUGdveUN6emdlb0t2SzNRY1k2MWhiM09WcmJVTmRuWjM2ZllVODB0SE9IbDhtWm5wV1VhakNmbGdGNkVNV2tZb0JmbHdURjROS0V1TGNSSWhJNHl4U0dtcHlweXFDRjdGbG1PY3FYSGVVK1pHUnNnSEh6czI5My95ZGYzLytyV1hienpOYnhYVi9uMzFKSWNBK1lNMnFWRmF5VWdKbEFpSHNxb011Nk9TNlU0dGwwOWVQSXYzWHpMbGNFSXl6VlF2bzlkTlJGazVaTnpweGRuVU5Ic29Rak5OQXBGVW9uWDY3VWMvcUJOOWZyZ3p4bGt2cEpKNEI2WjJTT1BBT0pBZ3BRd05QeUVRVWxCNE1MbkJ0alRPUTIxQ3dqNHRJOUlLZHEybE81Vnc4dTY3MEhFTDV3VkNXSVNPc2E1bWZlVTJtN2V1VXd6MzhBS1dUeHhsYnZrNGFSU2pCT1NqUG5HU0VjK25PT2N3ZFUyUkc2cGFVZGNXNjROVHM2YkFWQlpiZ3hTT01xL1l5MnMyTnZxc3JPMnd0ak5tYUN3RDc2VVQvb0dwaGVTN0l5MWZxbzNicitidGcrSWI4U1MvNWZlT1Q4VWNuNHI1L0kzUklVRCsvMkMrbVNkeTFsYldPMXNMN3hIR0lwekhDK2dQU3phVENlMzIzTnpDOHZtanBoenNwUjNsank5MXhmeE1peXNyZlIrMTJtbDM3dVN4emRVdng4MURWb0ErL3ZqeXVXZ3FlWHZWcjVYSkRiWjJPTmVjQSt2dzFvZWVocEpJSllramhjSGg2c0RJcmNlR3RHTWdWcFRXNDJyTEVaWFJFaEpUMTdSN0dWRVVZZkk5ZE5JR0ZNSk91UG5HYTl5OGNwMGtodTdzQWtmTzNrdDM0UVRLVzhyaE51VmtoSzByVkJSUkd5aUxDbU04eFhnU2NpR25xQ3FMY3pWYWhzNzkzczZRSzlkWHViSGU1K2J1a08yNlpKeEt4SHdiMzh2SWhSQnVVb3RxeTc1dDVzejBnNXR2N2p6clBlN09LK2hyQVBPMXdQQmY3K2ZwVFBOUGZ2QTBUL3pUbHc0QjhnZGxmLzN2L1V2K3hmL2pyeExBNFIzZytqdWIrZDd1enMzWnRxblRST3ZLVkVqbktmT0t3VEFubTIyM1RwMTc4dlNWTjE5Y3orYnVMd1NraVphaXFpMVJIQ2R6Ujg3ZmQrVWwrYkhRUkFjVnlXanB2dmwzS0ttTzI3ckVHWWUzRHFWaytGbUFpaVJhU1pRVVlTMkNEZmxISU1rS2JHWEpSeldkNlFUcndWalBESm82TDZscXkxeWFoQ1RmRzd3cEVFb3oydDFrM045aHVoZVRUTTl3NXI3SFNkSWV5QXhiajFFNklXbEhDS0dvaXB3eXp5bUxrckl3VFdydHFNc0tVOWFNQmdWck8zMHViKzF3YWJmUHByVGs3UWh4YkJxVnhoQXJoQURsSUtzZExvc1FTcDVkVXVLblZLeit4ZHFyVzg5NDUvZDdUU1ZmVFV1NTAvYUJaTCttaCtKdTdwWCtlLy8zMS94aGlQVUg2emc0Ly9CN3hCc3ZQdTJiVzg1NDcrdGIxMTcrU212dTNIcVd4TWVMMGxEV0Z1OWduRmZrWlNhbUZrK2ZzQzkvZGxXNGFqd1lWOW5wRUk0SlFFM1BIVGtUeDUzWnFocDRnT01QTDU3cExyYmZqL0dwTFN6V09aSldqSTRVem5wc2FhbHlnNDRVT3BKNDR6QVRpM1VlcVFWQ0NGU2tLRWVHUEs4UlNoS2g2WGxOZjdpSE1ZNGtTNG1TOXY3aUJVdzVZWE45QTJzcWtuYkcwYnZ1SlVsYmVGYzE5N0pIeGhuU1M0Uk9xZW8xdk05eHhsQk1DcVJTQ0cvWldOM2hqZHViWEhNRnQ2UmhkMXBSTGMvaVk0WHlvU1hxdlVmNmtEODVBVEpXQ0FuSmRJWlE4bEVoeEUvcmR2THZWcDVmL1ppdGJFemdjSm1nb09MdnFKSUlQRGp3MW5zc2IvRzdET0FHaGIyek8rOFBBZklIRWxmRkxKKzh5T3R2QWNRQzVzMlhQbjNsK0wwZnVKUmtpOGV6SktJMmpzb1k4dHlUNXlYZHFhV2xoZVd6czhWa2ZiYzA4M09EY1FVZ2pQTjBwNllYT3QzRll6dmJnd0tCbkQ0NTlaRFUrdHhrdThBV0JxMFVXUzlGWlJFeTBaaktzbldyajdXVzVYUHp6TXkyUUFtVUZzMnVLcEJLVUU0Y3crMlNiRDVCT0ljeXNEY284TjZIRXE2M0NCbmhoYVRzRHhuMTkwaXptS1RUb1RNOUh4eGtuVlBuV3lBMU1wM0NtSnB5UE1RNWozT0NxalJFV2pMc1QzamxqUnU4bUE5WW00dVpUS1dJTENiMkFsRVpiR214bGNGR0N0RVFMbVhEc0hITzR5c0hFaEYzWXJEdDg4N3hVenpnM0szblZqL2huVzhCbFJiWUpGSm9LVVJSTzIrYzkxSUtXeGwvOEJ3Z1RCcDdxUHdkWUxrejBUOEV5TGNWSUpLcXJIeWN0RVNaai9ZNzNtYjkxcVhOd2ZhTkw4NmZYSHlIamxUbXJROUZmZS9KeDRXZmFrMUhDMGZPTEs5c3JPOWE0K3o2WHFHTHlpS1ZJbTIzVzYzTzdOTE9ObXRUeTUycHpsTDdmWG0vVEVkYk9YNWNFMlVKVVNjbG5rclFhWVJRa25TNnhjYnJHN3p4Mldzc25Kbmp6SDNMSkVtRXoydGs1WmprRlhWcEdXMlZ5SjRtaVJRNGlDS0Z0WjZ5S1BHMndsbUxqRkx5d3FDMHdIbEJkM29hcFNUNENLOXFoSy9BRzF3cHFjdWFLczhweG1NbTR6SGpVYzdsYSt0OFpYZUgyM09LeWVucEFBTHJFVDRVRmJSU3FBak11RVpMVHkzbFFlOUdOQzEwR1FkNkRBcFVKeUt6NlRIZ0ordlNLbmR0OThYN0ZyT2pwMmZTYzcxTUg0MlVTTWVsM2FpTjM4dGlvZmNLYzJWMVdOKytQU2czWGwzUE4zMm9BbGFONTlrUHp3NzZLNGNBK1RiYjYxLzVGRUxJL2ZLamFSNUcvWlhQL3NMSDN6bC85cjJTN3RzbEhpa1FFa0ZaV3pFdUttYVAzbk5pNWZhVjU0MHB6TGlJdFBNZVp5eEpuS1F6ODNQSGN0OVdVMGVuSHh2dlZCZTlBVmQ1aE5KRXZReXlDS3ZEN1NzbFpMMkVrdzhlWmYyMWRhNTkrVG8ycnpuLytHbHdZSzNIMW82Nk1oUzVnMjFOTXEvSkRWZ0hRaW1VbE5SRmp0UXhlTWxrTk1LWm1zcEswdDQwcmh3aDRpbGsyaUhTR2x0T0tFZDk2cnhnUEJneEdlWGN1cmJPYTdmWGVVbm5ETytmd21jSjJvQ3lEdU5Ec2NCSkVkNlRGTkNOMGQ3anZhUHdIdWs4emZRdlhncVVWampya0JxUzZSUVo2Yk5PaXA4NFA1dXN2S3VqSHRTUmJFY3lmUERDNDVYSFI3RkVRMVY3TjlndTdLWGJnL0xUWDdneC9PUm5ydzJ2OGRVYWNRZGw0ME82KzdmUm52dk1mNkU3czhUZTFxMDdsbkFpUWVqaDdtclI3c3hYODh2M1BJS1U3Y3E0L1pra3BJUTBiVVY1ZjNOa2lXU2NUWFdzdFRpZ2t5VmlYTHcwcjJmMm5rcG11dzk3SWVNb2loQmFvVm9KMFV5SzdzVG9SS09rUU1ud3ZMMFNwTk10YkdXNS9kb0srYVFtbTJyaGFrdFZXSXFpcHNvTlptS1F2Wmh6N1M3VGxhTW9jN3E5akttcEhuSGFCU2xZdjMyYmNqUWc2VTF4NU9neVFpYUl1QlhDTENIeHRnUVg4cXJCN2g0dnYzaVZqenozTXRmUEpOaUw4d2l0OENhczJoRmU0bnpUbHlGNEN1ZDlVeFJvT2oxNHRBeS9MenpnSGZzalhPRmpEY2dSV3M2S1NKMDY3bXdhV3kvclFCWUlZbllDNVlRUVNvbzRrcUxUaWZYcEk5MzRpZFBkNUo2bGRqUitkVHUvYmQxQmVHVVBBZklIWk9QQjFsdUo0bHNvRVFnUjdXMWQzejU2NmtKbmV1SDR3MlZaeTZxeTRjRUxpT05ZS09FWUQzZEdTZS9JZEZIVlFraEpKSVVhRjVkbVRHZW5FNldKU05JNENFZ2ppR0pOTkpNU3RUU3lPVkNxT1dEZWVid1VkT2M3Mk1weTQ1V2JHT05RT3FhY1ZKU1RpcXFzS0FZRlZubk9INXZuakU3Wkd3eHB0UklXbHhlUU9zSVl4M2l3VFYxTW1GbGNaR2J4R0NLWkFtL3gxUWhzdFQvRXpuZzQ1Sk9mZW9FUFAvOEs3c2xGV2hmbWNjN2hiS2lnT1JzVUdxVVFEWHMvNU5YZWU3UVFCNVJsSlVDS29NcklRZEx1RHBZMWdzZDVVRnBTUmhIOTJ0TXloa1EwY2tyTmgrb2R3Z3VQY1UwdVUzdUY1VlNNdUcrcG8xZGUyU3l1TjduSVFjSitDSkEvSUl2aVRIZzgzcnZtb1FsWmwyT2ZaVW4vMUYwUFBpQkZ1bGhVdGJmV0NlL0N2SGNyYThmai9uYUpicVcxRlVySGlsaDZCdm1MK0hUYngwa3NWS1NvZlZBZGlkb1JlanBCYWdGK253RFd4TzVDb0ZYNHRjNXNoM0tRczNOck8zaVBVVWsxS2hqdGpkaTlzYzNnOXBEamQ4OXpJVzJSand1NjNSWUxpd3NJQlAzK2dMeS9BOTZ3ZUdTUk9Pdmk2d2w0aDZ0SENLbnhwZ1J2ZWVITHIvS2ZQdlVzMlhjZVkvbWhvM2diQk9iTXdiVk80ejM4UWFVSlBMTDVFZ1Q2cnVBdEZSWFhxRkVlS0lrNXYxOWNDNlZnSmRteHNGNVk1dkcwQU9zOVZvVHYrMWVVOTFDVlR1d09hMTlWZHFZZFNUbDI3dk5ybzNyVUFNUUM3aEFnZjBDMmNPUUNkVFVtTEY5NlM1bDljL1hOeWFrejUxbGNQdjFZWVh4U1ZLYkJEN1E3TGVIS2tiTUlLYUlzc3Q2akpCaDVDWkh0Q0ozR29CVmVTbVEzSmwxczBlMmxKRXFFWG9peDdPOUpjS1U5dUkyalJCRkhFY1h1aFA1bW4rSFdnT0hPaVBIR0NMTmJVcTBYR0MxNDZPZzB1bmEwdXlrejh6TW9xUmlQUjFTVEVWVnRXRGl5aUpTQU13aVZJSVRBTzR2SmgyeXZydkdSejc1QS9XQ1BFNDhkcFRJVkRrRmxITUo1bEE5Q2RDQkNoNmp4SEhMZlMrQURSSHpqL1VTRENoRnlFZC9vQTlPVWd4VnZoV21SbGd5UmJCbkxySzFKbk1NMWJPWlFtUW96OThQY01DNnRhR3RGTDQyR0cwWDlpVGQzeWgzZUdzbzY5Q0RmVHJ2cmUwNFJkMkx5bllLc1BVMVI3R0tORVc4RnpranZ2Y3hITzdzbnp6NndtSFJtNzZwcXAyd3pkYTZWRkZrU3FUelBuZGNCSU1KYnJINEQyZXNqWkNBVzZsaVJkbU95YmtLaUZUaUxzdzdxWmx4WENad1A0Z3RJc0Y1Z0MwczlycGdNeGd4M3g1amM0RTF6dzJvWUR5YmNmWFNhbzcwV0RsaFltQTNTcEdXRnJVdWtkQ3djUFlLT00yVFVRZWdFb1FUTzFPQU1uLy9DeTd5aWRqajczaVBnSFhsdG1SU091bmJZTUlWRnBOVkJxT1djYjhiQWdtZkJPUkJ2NVIyaUdSTVRmcC81S1pCQ05zQUpUQUhuSExXM0dHZFFFbXFWVXB1VVNSK0dlVW1tUElxZ3lGTFZqa2xwaVlSZ3FSMGpOSmVmMnhwOTdNWmV2ZGNBeEFEdXNJcjFiYkp6N3o3R3JhZFhPUGErNDJ4ZjJxWFNLM2pxdDY2eHR4aW85dnFiTCt4ODhaUC84Yi9lLys2L2RyR1ZwT2VNY3hqcm1CUVZ2U1RSUW1pVUV0NGFJYnpMSVI2alUwVlZodHMzaWlVcVUwZ05SVmtoclFQcnNRMFpYZ3BCMUhTalVRcGJXQ2JiWTVTU0pLMllWaWZDMUJaalExd2Z4UXBpeHhldXJYUHY0Z3htVkRJY2wweDFVcHl6ZUMrYUcvd2d1VUpFR2E0ZW82S0V3YzR1MSt3ZUo5NDVSeEk1aklFSVNTUWRLRW5wUElOSmpYQVdJUlMrbVhJTW9uWWVJVHhlTmhHVW9LbHU3V2ZzSHV0ZFlCRTdqNVlScmJoRkorN1Fpaks2Y1pkTUpreEhYUmF6T1ZLVHNuTnprMnR2dk1ybm52c2t4NU9jRXpNWjFqaVVnL2wyUkN0V2pBcTNjWFczR3ZFMTVNZERnSHdickxPUTBacEphQzIxMkh4cFc3amFNcnc5RXQ1OTFVYW8vUzhoaE5BdmYrbkR0M29MOS96NnFmdS9aOW5ZcURlcExIbHVrRlpLSFdXYVNJT1VtTWx0NVBRQUtSVTZFZFFXaURVeWtzajlBOVhrcmxJSUZNME5MWUoyTGg2cVFVazlMdkVDSXFWb3RSTHF1c1pZaDFDU0pJNXB0Vk91VDhyaTFjM0I0UDZaMXV6MjdsQlBUL2RDaUtRMVdacUdNeVFrUWltRVNwQW9xTFo0L2ZJVnpDblA5R3hHV2I0VkRpa0JVa3VVZzFJNkN1dndYb1llUjVNamhNUkRJaXlOVndrVkt1c3R0a25NTzNHYmsrMGx6czZmNGVUVWNZNzFsdWdrYlNLZEVDbU5SRklWSlhWVlUxVVYyMm1IVnFUWjNodng5RE9mNHQ1QnlZUExIZVphQ2QxRW9hVXdnOHBldWQydmgzZmtINGNBK2YyMkgvdS9QTW96SDduSjFrN0I3WmUyeFdncnB4aFdJZDhVU1B4YmMra0lZbnhZbVJaMkRGcSsrTEYvOVhTbk8zZDA5dVFUMzE5VWVZd2U0aEtJdkpjcWxaaGNZTVNidEJjc0JvVjBvSTFIcFlJa0Vnam5zZGFISVJFbFFtRy9ZVW42aGczbWpLUFluU0Mwd05jaDVsZGE0d0FWQzVJa0prbGpzazdxWE8yLzhNd1hiM3o1OUx2UC9vV3R6ZDNsbzhjV2lhS0lPQTFIeDFtTGQ2RzBpd2djd2QyTmJXN2tHM1RQWnBqYVk1M0M0U0IwSkRET01iRWhwM0FPbkRjYzRNQWRWUHNRVGRQRFlsRE8wMnQxV1c0dmMySGhIT2NYejNHc3MwUkh0eEJTa2hjVDhza1lhVDFTUzJwVFkxeU5jVlhJK1pweTN2bXpaOWphM3VKTEx6M0xYZE1wOTh5MWZDd0ZnOW8rOXhzM0JwL3cva0FVNHJDVC92dHBjYXFhdURvODM3M2JZNFJBT09QRUFTakN1WTJGRUxIM1BzR2pFU1J4TytyTm5aMDZOWCswZTgvMGtleGtOUGNiTTlIQ2pwMmRtWURzbzVUQjVsQ1hFYXAyeFBFcTlWcE5yUVY2T2lWS05LMU0wMGswVldrcG11UW1pRkVMblBXWS9ZcVJnMnBVWXlZVlVrbVVsRWl0d3E1QktaQmEwVW9USDZjUmtWYlhWOS9jL3VYcnQwWTNMeDd2TGI2OUhmL1E3czRnN2JSaW5LdW95aHBURzNSZG9oSUgzaUJzd2FXcjE5bHNqNWhyVFZGV0JKa2dMNUJlb0VRNGdRNlBJNEJBdWxCbEN6aVRDQW14bG5qbmNjNnkxRm5nd1lVSGVHRHhmbzVQSGFjYnRSRUluSGRVZFlWM2pxcXFNSFdOTlFaakxkWWE2ckppMkIvUTM5dWx2N3ZINXVZbXc4bUlrMGVQc3I1NURDRW5QdEhDajQxNzg3TXJvMy81cWV1RE41dVF0NzdEZ3h3QzVQZHFXU2ZDQkhGL2Z2MC92Q0VHdXlYZWVlbTgzL2NZY2ZPVkVQWmtKSzM1ckhQa2dkbXpSeTdNUHJSNGN1clI2Wm5zYkJ5ckJTVkVLaUF5OW1XVitSQmlWSlhIeUREeTBPbzVsRFRrZTRaNlVGQkdJL1Jzd3RTNWVWcFRNYVl1aUlRSWdtL09JNXVTcXJPZ0dubmJZbWVDc3dhVXdCc0xBcUpZSTUwaVRqUnBGb3NvMGNQKyt1US9iMXpaZThGN3ozLzkxT1gvZkdTaE43T3d0UHZkV3MxS1crVEMyeXBjczg1Z3kzNlE5Qm5zY21WckZYMGhDdlB2c2dGaDA5K1FRb1I4U0VycVVMYkNHb2Uwb2Nxa0lsQlNFRXVMbERWM0w1M2pUMS84U3h4UGptS3JDbXNOeGhqcXVrSUlNTWJnbmFjdUMwYkRFZVBSbUxxdXFhdUtzaWlveXB5NnJpakw4Ty9yU0pHa0tRK2R1OEFKY2MyUFRYSGwxNjhOL3VuUHY3VDFqQWg4cklLMytGaUhBUG05bXRhQ2srZW51ZnBTV0lDemZtc2s4RjU2ZjZCL3RiOTVOZ0hTeFlzeml5Y2ZXM3hvK2Q3cDl5NmNtSHE4azhhTHdvbkVHeWRVQ0l1OHN3QlNPQmU0cDBHUjNTTzFRbHFMaWtHbkhqMVJGTHNUSnR0amJtL2xtQWVYaUdZeWxCUVk2NEtlcjlndnBYcWNjTlJqUXowcFFZbW1KQnRtUkx5VVJFS1FwaEZ4R3RXVFFmbkx0MS9lL0ZYdi9SQncxMWI2ZS8vNnY3LzRMNFRTclhkbDJUdWxRMk10Ulo0amtNaGlURXRLdHRZM1dCbnQwRXZiR091eHphWTRpU1ZSNG1DVlFsQ0tEd21aRHdPUG9YdnVQRXBMa2hnV092UDh5WWYvSEJmbkh5QWZEcGlNaDB5R2c4RHdkWjY2cmhnTmh2UjMrMnh0YkZGWE5YVmRvYlNnMVdwampLR3FEUG1rWURMT0dROUhUQ1k1ZFZrVFJ4a2pNYnYrN0xYWC9vLy84T0xXbHduQUtQaHF6UzBPQWZKN3RLU2Jjdm1GYmZBSTc1QWVydzY4aGdqNUJaNmtOWmZPUHZSRGQ3MTk2ZUxNRDB3dlpJOTJXMUZYMWxJS0pONjdneWsvaFJlaE1oTkdZTjErQjR5bTlrOW9aTVJ0amFsQ0I1elNrZTlNdVBuTVRXYk9MOUJlNm1JYlV0OStlZFExUk85eVdHQ2R4U3VKcnl4U0NyUldPQTg2VnNSSlpLdlNmbmIxMHZZdkZLTnFxemswRmxDdlh0dSs5TjgrOGRyLzJtc25rd3QzSC8yQXEzV3l0VDFpY1E1YTNSNnVITEMxdmtMZkc2WlZXSzlRMUFMdlFqazJkTHREbWRXN1p1Y0l3YXVVRnVySzRLV21oU2FKTk8rODUzdTRzUFFvZUkvU2dyckt5Zk14SGlqemtyV1ZOWGEydHFtcmlqaU5TVnNwa2RXVWVjbk8xaTVGWGxLVkJjN1owTEczZ1c4Q250cFpMdGV0MFhQOTlQWWRZVlg5dFFuNklVQytSV3QxSTF6aHFRdURzMTRHb3FuWGQzaU5ERThtdFdoZmZPK0o4dy8vcWJ2K2JES1h2a2VuYWtGNUQxWjQ1d1ZlK0REWTVCcW1uSlFIbVdwdHdxMGFhVWtxWTNTcTJQVTVnOHFoRkNTSkp0ZUtPZzhOTkZ0YVJwZTM4Y2FUTFBWUWVLeXhHT2VBMFBlb0JqbXk4UjZtSWY3SlNJSHpZWDdFKzB2Yk4vci9hdmYyOEJvd0pteXB0VTIxcmY3TTg3ZGVHK2IxUC83SkgzcGk1NjdqczM5NnR6OXA5enFSVDFwRzFHWE55dW9tSTJ0d0Fvd1RCKzN1ZlE5QlExMDNEcXJTNGNxZ1NXMUtTejZwRVFKS0FiM1pvenh5L0QxRVF1SmNpYU5DU3M5NE1tWjlkWU85blIxTVhkUHRkZWxOZFpoTUN2SnhUbFhVbEVXSk1RWlRHNnF5d3VJWWxoTjI4ajEyeDMxRzFZUnhsV05yYzFLMHhGMWF5T2VOUHhCL09Kd0grYjFhbW1rZWVzY0NYL3o0R3E3aVRuRHM1eGx0SUwzM2JZdW5ILzJCdS83VXNmT3pmMEsxNDFOMTVaU3JReC9BT2k5RW8xVlZHSWRzNnJMV09JUUxMTnA5VG9RMW5ycTJSQTJWWXFhYlVZd3JqSzZKRWtVNWxuaGp3amhHYVpqY0dqQjY4eWpabktaMWNoMXJnNXBpMmMreHhoTFdTVFYrU1Fpa2xtSFdRb24rN3UzaGY3ejk4dWFYRzJDTWVZditMWnZ2L29WTDY5Zi8wYi85elAvbnIvL3dFNU1IenM3K2hZM3RVVGZPTW5RcllYZFlzYkl6NWh3TDRBWGVoeWtPWjMzVFBaZDQ0U21zeFZZaGRLd3RURVlsK1c2SnFqMFI4UGFUNzJHcGN3U0h4WGlQOHdZaXVIM3JGdGV2WEdkK2NaN1pxWGxzYmFnckE4WlJWaFdiK1M1cm93MUd3ekhEblFGOUpsU1JKYThyS2x0aHJFRUtnVWdFdGEwU2wzSXl6aUpsSnVWdkgwWWZIdmx2M0I1K3h4R2VlL3Bma1dUZmovTmVoUFRnQUJ4WkE0N3NmWC8ybm9lZStzR3pQelcxMUhyU09oRlh4dmtvSW9EREM0enpPQlA2RThvSGRaSGFoakJJd01GM0pjTWF0YnlzRVEwYXBSTlk1OEsxSGl1a2twaUtmZWxPYkdXb05scFVPeDFFYncwVkdhejFWSU1jSVVOVlNVclJVRlhGZmpXcm5PemsvM0hsNWMyUEVuUnd4M2ZFNU82T3hpWkM0Sy9lM2wzL0ovLytzLy82Si83a1E2TzMzYi84bDlJc1dXaGxpMHpQOURDWGE0cUpKVzRKbkJQRVFpRmw2SVhnSEpHVHRKUm5KR3VNRGVPOTBubTBDMkdRcnlXam5aS1hyMytGbmNrcTE3ZXVjV3Z6TnFzYmExVGJGVWQ3aTV5ZW5TWVZDZU42Ukw4YWNYMTRtMnVEVzZ5T3R4am1ZL0tkQ2YzYmU3VG1PL1NtcHFoR0JtYzhXcXBRSGJQT2UrZUZUZnlqcllWc2VYSzkzQllDNWYxdkZjUStCTWczWVVMQzJRcy9nck5lK0pDTTc0T2pCYlIxb25vLzhKUDNmZUNSOXgvL2lhbTU3SDY4Si9lZVJBdmh2S0N5b0pDNDJtRU8wT0J4WGhCR0lYeXo3aXpjdXJqdzY3S3BTdFhXNHlxRE5SWXRCYldXQ0NrT2JtbHZMTTZkQkgwY200OFozNWdpV3JxTm5WZ3dCcVZsMDR3VEI2ZGRhV1hNdVByTnRVdmJIeXJIOWFBQlNIRUgzZUxPT1czdlBVNEkzTnJXMFAzai8vQzVmL2NUZi9MaGRhblUzK2gwMm1kUEhwdGg0Ym5JbDdrVkxoTkVLa0o2UmFZVnBYUzR1b1RDb3ZFQm1NYlRsdENhYmxPMkVxcks0UXZQaDUvK0NLKy8rakxLR2paM3Q3aFdyWkcyV2p4NitpSGVmdlp0SEdrdFlrdkQxc1ltYjc1K2srYzNYbU50dElud0F1a2tXc1ZFU1lJcFRXaEFDVUdWVjNqamc1U1FzY0xrdFJkS0hKZlNud1JlYVFvcjhtdWYrU0VYNjVzSnIxb1IyNnRqVVpWV2VJZHVRcW9NNlBSbTA5bS85bjk5KzUrNy81MUgvOWIwYkhwWEZDbzB3cmo5Wm5CejZCRkVTak9wSE9YK0pDRmdTb2UzQVF4NUZjcWVsZlVVZGFCVTRBZ0FxQjNXT2t6bE1JV2hHdGZVaGNFYWc2ZEZGSDBYWm1qeHBzUk5Va3EzaHEwSHFFWWdHcHE1YmlHYXhKWFhWMTdlL09jN04vcFhtdEJxd2xlTFEzK3RyS2VIQUJKanZmM1NxNnZYUUY2WFVsVHRSRTN2VnFNdXAxS1J4aTBTbWFKbFNxSVNuQmVVcGNWN1M1eEswamlzWXFoS3FBdkxZbXVKUnhmdTQ1SGVPUjZhdVljamFwNGxzY0JzUFVYUHRIbi8vZS9odmVmZXdWdzIyeWd4R3J5SGhkWXNwenJIeWVxWWplMXQ5c1lEQkFKYlcweGwwRm1NbWRRVWc1eDZVbEtYaHJxc1ExSEFleWtqOWVKNHIveUtkNzcrZXBmQ0lVQytRVHQ2cHNmTk4vdFVwYjF6alVFS2RIb3o2ZlNmKyttSFAvakFFMHQvWTdvYkxVYWgzaS9xQmhCaEpFUGdnRlRGS0JsUlZJSDdKQnVHNjJSY29aVU1oOWczcW9jZU1DSDB3SHZxeWxJV2xycXl1TXBTREN1S1VZV3BhcHpWdER2dndJMW1xRWRiQ0NHaGpuR1ZSdmYyRU5vZDVEWXFVWUcwV05tTnpTdTcvMzd0MWUwWG0zeGpmK3owcTVwbGQzcVFPNzRPcWowdlg5NVkvY3lYcjcrMHN6Mis2dHUrdFhEdjlKRXNiYWxFdDBsVWhpQUtCRWtLT2xNQ0hVVWtxV2FxSGFNamVPTE1PL21SaC80TTkvUk9Jb2NHYVp1SkFDV1FrU0p4bW5Jbnh6a1g2TWcwZzFVdWhHM3pNL01jeWVhWUVXM2NwR2FydjhOb01LWWFGM2lsUXRnNUxyRzF4VnVMTVFibkRONTduMDFuYnd3Mzh5ODY0L1pYd1gxVm1mY1FJTitnZFdjUzhuRjlaMmlWSU9qb1NMYi8vTjkrK1BzZmVzK3gvNldWcWNWSUtrcmpHMG1xd0J4VkluZ0ZZNkd5bmtGUlUxcUg4eUdmS0V6b1I2U3hScUpDcDltQmRCQkxTUnJGQ09lWlRHcktJb2dhVkJORE5ha3hlWUczTGVhUC9Wbjg1QWlUclZVOE5sREdoWUs2ZzRoQnRmZkNVNWNDbldvZlJScS9PcnBjWFJ1OFVGUnUxeGc3NXExcE92czFYdU1neXZ6NmdCRXlMMnZ4MHRXdHphb3JSdysvNzlUalNxZnRTS1lva1lhcWxkOGpUaXFVMUZpcmlMVW1Wb0x6U3hmNTRHTS93WFRjbzZwS3FycWtLSEpxVTlIdXRDbXJtdExXbEZWQmYyZVBNcytKRWtXcmxaR21ZWXB4WjJ1VHE5ZmY1TWJ0YTl6Y3VNM05qVFh5d1Rnd2ZBU1kybUtMQ21jTXpqcXNEZGhXa1NSdUoxY0c2NU9uclhINTEzak93eHprRzdVZi9wc1grZXhIYmlLVkVOWWNxTFFuZU5MSDMzdjg3Q05QTGYvNWhlbDQwVnZ2alVOb0lmRkNvS1FOOHcwTm5jSTNVcUNWOFUzM1hSSXJCU3FRREpXUTFBMjR2QTBDMDRsUVpJUndLRklDR1VkTXlyQUN6ZFFHVDQvMnpIZGcrbDJHSzlmd1Fka0dzVjh5dGhhM3ZRaWRDYVNyZ2RLaGxZaUdPWjNSK1A3V1lyUTBQeE45ZW50Z2YrM0tqYjBYd08rREk3K2plblduTjdsVE1Mc2g1bnVMd09DeFRrbDJLeWRxVTFFeG9kMkd3bzZ4YWtUa0ZWV3RVRUtoRUxUakxrK2UvaE5NcGRPTXh1dGs3WlNGNVdXVVVnd0hRenllK2NWNWVsTlRsR1ZPTWNyWlhObGdiMnVIaTQvY2g5ZWF6My9oYVo1NzVRV3VydDFrWXpMQVNsQkpCR09CcVdwa0lUSE80NHU2VVE4WFNDMlFTaEdsTVZMS3I1VXVQYXhpZmZQWk9jd3NaR0w5NWxqYzBTVlBlak5KNS92KzBya2ZYMWpLN2hjV1VkdVFFQ29sS0t3TFUzd3lsSEsxa09STlB5QldNakJjWFJnZnpaUUtzMEFpOUVhcU9vUlVrUWRURy9iS0VFWmhQYW1LS1lSRFNvL1V5eVM5OTJCM0phUE5ONXROVmg3dmcxQU9Rb0h5MkVKUTNyNExmY1JBZXpPb3ZHOE5LQVlqcGFKb3VhWDVJZDBUOTgvY3QvUkxOOVpHbjlyYUdkKzZZMVYxY1VkY2Z1ZU9kOTM4dkUrbDBZQXNKc2FNSjhZSlU0V1l6ZWU0dUVJN01IaThFMFJDZ29NemM0OXlySGNYM2hURVNVUzMxMElyUlZua3hHbUtxeTNqd1lpNkxGalpYT09OYTIrd3ZybE8zaC96eXVvbEJwbmgrVmRlWkRJcXlPS0VORW1wZmJqODR5eGx0TmZIR1kycERMYXFhYlVTVkt4UldxSzBRaVhhbWNMY3RMVXJ2MTRQNUJBZzM2RE56bWZrbzVwbXJrMEpRZXc5MFR1LzYrUURSMC8zM2xOYmRHMUNJaDRyTU00VGlkQ1FtM2lIYWRaNWFCeENDQ29Ia1JRNFowUEtJWm9HV2pPU3FrWFlCWWh6elU1QWk3QU9aeXlWQlc4TEVFc0k5WDdxMVlweTl5Yk8yNE9SVllFTUhDa0VNdEVJSWJCNWhGZy9qenhXSXJBTjQxZFJlVTlWRzRtUUY3cVIvT243VDNlL2MzdXU5UzlmdmJMOVRHM3NQaVcvYWc3UW5lQzQ4MnVmVWhQWHhrbGJPcXozT0JWRXB6RWVyMElGVDN1SE1SVkx2Wk04ZlB6OUpETEMxamxhYVdTN1E1UzJTVHRkM25qcFZiNzA0cGQ1NmNvclhOOWRaVHZ2TTZrcnZQVzQydlA2cFMxYXN4bnhkRVpsd2hDV1FsRFZCdXM5YVpaU2xVWElBSDF3ZW5FN1JrY2FLV1VJTlNNOUdteE1YcmZHbWNORzRlL0IvczAvZUo2NmRrR1dLZFRMb3poUjJaUGZjZnlkS3BLejN1SlZVTXhvSEU2WTRLdXNvNm9GV3NpRy9oRldrcWx3ditOazBJSnloUDFpU29UVk9FNEs4b2FqcER4STcvRlNZbkhVZFVsVm42TXVIcWRjR1dQNnEzaHZBNWk4UTRoQTh3aXFoQWFjUXVrSVl5cHNJUkIxQkw1R09FS25XVW1FYzhJTFQxbFZuVGp5VHk1MDQ0WDQ3cGxmdUxvNitlL2IvY2xXQXdDSFFDcWR6QUV6M3RrRUlUTHYzSlIzZGg0ZjZCcDc2NU56dDk3c0owZm1RWGNVVVNIb2RTTlVyUEJPa2tZZ25PTGVJMDh5bTh4aXFzbUJieEk2eHBpSzUxLy9Nci8waGYvS0M2OWVZalFhSDh5RUtLbXd4aUFGR0dQSkJ5V2R1UllxVWhTakhBVjQ0M0FpWEJLdGJndnZMTTRadElZb2laR0JSdTlWcEVSZHVSZUcyNU9YRzBEYzJmTTU5Q0RmakpXRlJVZ2hmR0RvYWtDZE9OTmJtRC9hZmtnSUVjZHlYMmFnVWN2d1VGdVBzU0NjdUVONVEyQ3RhNlJyUVBwQTI5NS9DSlh6Q09NUk5oQU5TeGZVTzF4RC9WWVNTbnNmeGVBeGlxMENxakVlUjFGTW1uNkpCS213M2lHbFFzb296SG5Mc0k5RFJFT2tHaUdzd0NRS1QyRDhldSt4M2hKQTRxbU1PZHRLbzU5NjRHejMzc0U0KzlEemIrNDg3NXczT3M3bXN1N3NUeUhFUTlZYWlmZVI5ejV6dG03amZlV2NyWWJyZGV0ai8veWxYbTgySTI1SnBJTGo5MHpUV2Nob2R5TE8zRFhGeWFYekhHdmZod2h2TjRTQ1VqR2VWSHpzNlYvbFV5c2ZaMjl1UXJLY1VWeXZNWVVOL1l2SzRHdUx0eTZJTGd3TGh0SkQ3VERXSEd6Z0ZSSnNiWWhiTVNoSFZWcDBGSU1VRURTS2hWREttTHArcHB5WVFlTWg3NVFlRllkY3JHL1FubmpmVWI3d2laWDlNeTU5RTJJODhkNWpwNUtXUGhMSlpsbGxNeFdWNmhUcm9EUTVTZ2kwaEdKaThJMk16WDZXS3p3WTY0aWFwMUU1RjFxNTNsTWJGenEvQk5xSngrSjlpNnA0Z04zTmMrUzdCYjR1OGRaaGJjSEMwaFRqa2FNcXl5Wm45bGhiaFpLdVY0RlNMc0dJTlp3ZFlhc09ZcnFOMUtHejdCdVBaNTNGNDRTVWtzcjVxVTdtZjJpbUxSWm5POUUvM0JwVUt6ckpIbFJ4OGgxQ3FrVnByZmQ0c1MrMlFBTTA1d3hWNmRsYThRYzA5eHN2cmVPOUlXNUY5S1lGTTUycmZPcmVWUjU2OEY0V1ptZTQ5L3c1dXAwMlg3ajhPVjRZdlFBemttUWNrL1ZpaGkyTkhWWFlzcG16RDUzd1VDV3Nhc3h1Mk1ZclRQRFFFQnFzaUxCWFJjU1NMSXVDVjVGaDA1WlFFaVhrVFRlMHo5bks1bCtuNzNNWVluMmpacTFEUnpKMHo5L2FNNmlQbk9tZHpaSm9VWGpaREFVRk5RMHRGYU9pQ3FPd1hvUlZCSVdobGdLTElGWXkxTys5Ui92bUFUU3IwV29iNkNmU0NweHplT1B3eGxLWnU5amVlcHpoWnB0aWxJZDVqdHF4T0ovdzEvL21YMFluVS95RC8rY3ZzN3R4TTRSYjNpUDJGVU9FeDltYXN0cGk3RitoVzBYaGRYc1pkUlNoeG1YZ1NEWU1ZT05ETHBSSXgzaFNjMnVyN1BRbnBnUE1KSEYyYnh5bE04NDc3NndObWlQZWkvMTZyNUFpckZYYkY4QlRDb0ZDT3hlMHJpSk5uanZHZzVLYk41L212Ly9hcjZPVm9OTnVreVNhNUxoazd1NFpPdk1kZXZQZG9ETThrMUZzNXFIWEV6YjlCQyt4TC85VFd5WlZTWXdrVWpGUkpNTW1MY0JMVHlmTzBLbG5aTXNnQW1BdDdUUzIwN0w3OUkzYm0yODBvVlgxMi9SOURnSHlPOWxQL3AxSCtkd252b3pTV2xoajdoeVpqWHVkWkxZZEoybGhiSmpZYTlReWRzc3hveUxrczZHYzI1UVdteFE2OWxCV0ZsU29jT0diRzlHQmFDU1ZwWEZvWnlocXoyRHdBSU85eHhsc1NxcDhoS2tNRkJYZTlQbkxQL2w5ZlBDSDNzWC8rK2MremU3MlpwaDhKVUtxc1B0UEtBazZRcmdKdzhscmVEWEM1RjFjWlJGS3NoTjNFYmRITE15cVJqOHIwTStGa3VDRnVMeWEyOTJ4dldLdE4xTHAyU2hPVHl1dEkra2Qzam1NQ2NXdE8xUWp3dzB0QkVLRWhaN0dHZlkxWE9yYW9wUkNSU2t5VXpqYnhwaWE3YnpFOW5OWWM3enh4WFdVRWt3dHRjaDZNZGxzaTJJbmRNRjFGUGFiaERtQU1BS2dJNFUwa2pLdlVZbEVaZ20yVVVjcGplR1k3RkFsRVVXNXkyelNwcU5pc2lTN3ZMTmUvR3AvUEJuYzRUMXNZQWdJNzk4UzFqZ0V5TzlrM3NQeTBiTzg4ZEoxOFRVbHpqaFNJckVFNFlGbWVST2p3alRpRzgwT2pzcGlqUU9oU0hYd0VyWXd4RjZUSkJtamZCeElpejZRRjdFQ2IycTg4UlQ1RVRZMzcySjc4elRGMkZGWE9iYW9rWFdOSDYremxWaHVWUW5QdmJ6T2h6LzhMTTRVeEVtTWpMcklwSTFNRXBBS2dXTnIvVk9NcSt1MHNoaGJtYUI0VWxrNng2ZFp1YlJCT25iRVNaQ2ZGMGkwRjl6ZXJ2eld3RGdQSGU4NXI2WHljWkllaTZLWTJsUjRFVHlDa0FINmdabHJjUzU0c0tCT0lsQlNIaWlnZUIvV1hrTUZWUWgzUUJCRkNWR1U0dkY0RjhEWDM2ellXNStBSCtLc1FRaEhGQWV0WWEwaHlqUkpTOU5KVy9SNmJVYmxFQUVZWjZtY1JRdkZrV1NhWlRGTjFQV2M2YzJTS3UzN1BpL1h0Z2UvOW9VdnYvN1NIZXdCRTJvbThvQndkZ2lRYjhBZWU5OE1yNzI0Sm54UUZaQjRyd0RWNnM3SHFOWjBhYzFCMTl3TGlSSVNoYWR1VkJLeVNHRmtrT2J4bGNYV0ZvUmtyamRQbEtSTVJqa21yM0ZhaFVOcmFpb3p4ZTdlUlc3Zk9NcHdrR0pyZ3lscnFBMnFOdmg4aTUydFo5bnBhbjdsTng3aXVZODh5L1hYTGhFbEtUS2JRYlI2UkswV0tvNlIzck4xKzNOczczMkJLTE5oUXJGcGxBMTNjenFkbUd4NWlzM2JXeHhiMURnY3NaSnM3ZFdzN2RUQ0JmYjV1NENId05mQXJQZU9TR2w4bklVUldobUtFeEtCc2lhRWhzNFN0SVE5Ymova3c0YzhiRDhEM3M5ZDhBYy83NHNUQ3luUmFSWjJlalRleW51SHN4WlRtOERwR3BUb3FHYlVxdWpPdGhCU1VGbURyQ1ZMOFF3bjJ2TXNkYVpKbFdhb3h0eklkL3lPbmRqZFVmN1JhNjl1L0hKdDdRRmpXWUJOMDhTZlhGNzBiOXk0ZlJoaWZhTTJOWDhYUlhFYjc5YkRtbGlFRWxMS2t3Lys0R01qdC9DTzJyNEJTSXlEV0FyYWtXS1VHeEloaVZRWUdKTFc0WHpRdUVKSW9rUlQrNXJSSUhDTGhBUnJMSk04cHQ4L3crN1dnMnl1dHhuMmh6aWY0NTBBWTlITzRDWWI3SzUvbnEyOTU0a1h2cFB0U3pmWTNiNkJUanFJOWdLMDJ1ZzBJbXNsUk1xenZmbzBhMnUvaW94R1NLWFJTcEsxRWtRa21kMHFtQjlQV0pwS3FPUXNVMW5FU0ZodTdQVFpHQmpLdHdxZUxhQWxnTm9aY0JvdE5ZbUs3aWc4aEE2UlZocWhvVFoxOEN4ZVlLd0p2QzlqOE5hRUEwL1RGRzJtRFBlQjRmZFRBQitBSWZ4KzMxNGd2RWJJQ0JrM0Y1S3plTzhaRGNlVWt3R25UODB6bi9VNDJWc21reEhDMnhEV0NzRjJPWEpYeTUxaG5idlBibHplKzZmVmJuMjdZUXJzejd1NGUwNGU5OS94OXNmNHgvLzJGdzRCOG8xYVZmU1lESS9pL1pzaWtOMmRhbmRuVlcveHd1TXIyOW55MHZDcWI3ZXM4SzRSRC9DR1RFc1NJY2lyY0N2R1NpUGptSmxzbHRGa1FHRU1lNk1SdFpIVVZadkJNR05uYjRHZHpTUDA5MmFwY2tkWmpMRStxTlFLNTVBNDZzRnRScVBiREk0dWttUVBzY2hSNHVFMm9yMkE3eXhDa2hCRm5uYW5SUnFWREFlZlpXZndNV1E4Sm80aVZLSnA5VExpVG94V2ttNWVJL2R5SXExSXN4Z0JuSjViWkNqbkdONTZFOStzeVZBSFhVQ1BxeXVNMHBnbWhQRUVZUVlwUXYxSUNSbHlrRWdlS0k3b1NEZVNweXFVV2dGbmJLT0RGYnhxMEN6ZTl5Wmg1Y0VCSmQvdDYvYnUxd21iVGxNVDJra2QwNWFDSjViUE05M3FoQ2FwdDFoYkk0WEFldXUwa1YvWnZUSDZwY0g2NUxQNXNMcE5ZQ3puUUNXRU1ONTc5OXJWNi81UGYrRGRIQ2JwMzRUOWxmZi9BMDdkODhoWEpXMVNLVFU5bFNhandWMDgvUmxIdDczTjdGeWZKS2xJWTBNM3JwQkU1R1ZNVmFVSUZDY1dqcEdJTHE5ZHU4cEtYNUxYTGNveVpqS09tWXhTakduampNUGFtc3BhakErM2FGQ2FjOWp4TGxQcGlQZDh6L3Y0M00wWWUzMkZxQmhnMjIzb3pxTzBKSTRnalFScG5ETXBQOG1nZUFhdEtwSTRRa1dLcEpzUlpYRVFiaE5ncmFWMEVMdFFlVERPVWZZSHZQK0JoMW5wR3k2OS91WUJoeVJxK3ZOMWJhbDlnZmNXSlhVakdCMlVTNFJVWVVsb28yU1NSanB3NHQxQitSalpaT3RlU29RSEpTS2NESXVCWEJPV2VlOE9jZ0JyQTdtUXBrSW1oV3hDcmlBMXFsVG81VVJTRVFtSk1UVmFxVVpBTDRpV0txbUxmR0EvdnY3bTNzZDRhNHg0c2c4T0tZVlBrNVR4Sk9mLzlzLy85U0ZBdmhuN29iLy9hYjc0bi8vUGdSSWFCbzNFcUw5dHRyZFd0NUxaZXhsdm4yS3RPa2JhRXBSMUJiSW1rcE93YnN4RTFKVkNTVUdXUkJURGtsRitCaWNqcEZKQnNOa0VZcUhTRmM0NlRGbUhwTDZaRS9GNFJKa2pKemQ1N3dlZndLWW4wZGUrZ3ZBQ04zTVUxV3FobENCTkZHbWtrSEtMV242YTJyNkdVaHBuSUlvald0TXRWS3FEQXFLV0tPTVFoY0Y0UjhzTDJtRjdEM1l5d2Q2OHduZGVPRW14dWNGNGIzQ3dsd3dWNDRYRW1lQlp2SzFDVlZRSWFzSjZnbHFHQVM3bmc3eWppbFE0c0VxaGxNSTYwM1N5SmRqUXR4TTZURFh1ODRlOWwxaHJpWFNFMHhGMVhZZUdaaU53dHgrRldWT2pkRVE1R1pCb1RhUlZJMm9OUlZnMFJMZlZvdGRKN2FXTmxlMm1XcFh2ZTQ0bTkzQlptdnAybHZyeEpQKzZaK0FRSUwrRFNTVkF4UWYvTER6TzJaciszczZ0YUh0dlltdmJ3VUh0Sk1aNGpGV1l1aDJVQXZFb2dzN3NlRmlIWVNtbG16VUJOdWpRTnRMOVpteHdWYUNMb0lJb3JiY2VhUTFpc2tmYXlYajVUYy9ORzYvZzR3VFptU2FLQS9pVWdGUnJwTDVGcm40RDY5Y3d4akhjR1dLOElla21lQ1ZDMlZlRzBFUVdCcGVicGpIcEFudkxlWVNRYkt5c2NQcWVMai80M2UvaUZ6NzBjV3haQmNwTEhCT25LYWF1d3lxQy9adSt5U0djTjZIdlkrQzd6MG5Pem1pZXZscXlQb0pKS1JuWW9HYWlWUEFFU2ttVTB0QW9yUWZkcWhqckxFcEhlQnMwdThUK3FXK3FTODQ1cEpBSDRSck9Ja1I0blVpbkNLSElVa1d2blpKR21pVFJycXpLRVRBUlVQaW1yQ3VFc0VvTDRrajVzanljU2YvV0tDWjVoWFg3MndQOS9obzFWNDQyYjVscXNvZk1PdFkwMDJrTlEwSEowUDZXVGJWbVA0bVYrd2QvWDRUWkU4aFdUYmRaYU5rMDk0Sm44Y0lpdkVYRmJVcTZYTDA1UWJXRE9FS1NxQ0FUSkFWSjVMSHlFa1h5V1VTMGh4aElSaHNEcW5GTzFzdklPaWxsWllLMHFBek8wQmFHdWpha3pjcXoydTFMOG9TY1l1ZldEVTVlNkhINjVGRmVlLzFhbUttd0ZvRWppcE9tcW1TeGp0QzBkSUVEVnRhT3Q1MlUvTzEzeFN5Mk5OOS9qMmR2NGxnWmVsN2NkRnpkOWx6YU5PeVdua2xCQ01sQy9JUlVDaW5EZDYwRExVU2lTR0tOY3c3ajZrQ2xhZklRcFRSQ1NhU0FORTdwdGFmSVloMG9QYzZBTjFqbmhiSFdqZk5pQ0ZRSVVRV0NHbFpGRXFIdzNlNHk3UmJzWFhyakVDRGZyT1hqRW1PczMxZlgzOTkxUHQ2NXZtbXEwWHJVYWg4WEt1aFgxWlZGS2hsVVFxUkNPaGQwY3B2R21Xc1NUcUhDVWtwdkhQc3JsRlN6emRWWkI4YmdoUU1wOEVwalJBZVVRaVlhbldteUxDYUpRcnl2UkVtVmZZRXFlUUZCeVdpbFlQZnFPbVpTRWJkaWhCSlVkWWhsNUQ3TlFrb1lGbUFNVW9lNDNYaFBMQVVvaFVKUldjdm1heS96L2dmdlpXUXNiMTY1Z2JFVitXUVBMUU1iTmxJcWNLaTBSS013em5Oc3h2Ty92QStPOVNUajBqUGZFeXkwRkhmTndEdE93TER3WE8xN1h0NnlmUGlOaXBXK1kxd0hFVGxuVFZDSmw1S1NISnh2UUtNT3RrVTQ3MEtqVVdtc05Vamh3Vm1PemMweDAyMVJWU1hPZTVJb0JweXY2a0lvRlEwcVUrK3l2OVZXQ09lOTk2YXlQc29VMTIrKzhUdWVnVU9BL0E0bWhHQzQ5aFdFbFBnd1VHNEJWNDNYeDhKVjY5NDRSRlh4RjcvdkFsZlhKM3p5ODI4aVpDczhXQUV5YWxRQWhHaG9IR0dKalhmK2dFUW9tc1V1MXRoQUFUbndVeUMwd2dWaEJhSkVreWFhZGlzbTFSR0NNWlBvMHpEMUd0cFl0aTd0c3Y3YWJZUjNwSjBrS0RFMlZTV2xRKzRobEVRTG1GS2FLRko0VTFNYkc5NlBsa2doTUNLb3JvaTY0cGdiODQ0SDd1YmF5Z2ExOTlqYTRxUUY0U2xGME9OV1VtS2xwamFDZTA4S0hydFBvM2NkSFMyd3RjQ0ZsSXE2RnFSYWNHNUdjclFyT1RPanVMUmgrTVRWaXRlM2JhQUtBOTY2QTIxaDczMllQVCtZNlRjaFdWZGhIRUI2RlRidkNzQ0hIZkhHR3ZDV09GSWdSYjI2dC9mTXl2YnVha01qY1lETHNwaUhIenpENTU2NTlMdWVnY09SMjkvQnJuengzOUU3K2pEbGFBUHY3TUVrWVYyTzlQRjczM1V4N1MwOVhGUldQSEx2SW84OWRveVBmUFEvcy8zNlo1RlJpbFJ0dkJVVWhXa1VCSnZ1bUd0Q0tpRm85SEN3emQ0KzlzdWFQc3hqQ3lYUnNTYk5ZdHFkaUhhV2tNWVM0aHU0emlmUU0xZHhFOFBOcjZ5dzl1cE52TE8wdWhrcUNvbXhrS0pKa2tOMVNhY1JpWWRrcFk4YUYyQkRlVG9jdmxCbDhrM1lFMG5GWkcvQVhDZkZaRDF1YlBhUlNSYjJlQWdWRkVTYVFvTDNEbThxSGowM3hjS3BwN2k2MTZNc0p2VGlPbHdFeWdjNUxnbDFMU2x0SURqUHA1S3pNekkwTkNlZXdyd2x2TDNmVFF3VkxmRlZOQ25mY04vd0RsZE91SEQ4R01mbjVoamxFNncxVk5UY3FuZkVWd1kzWC9uc2k2LzliemR1YjYwMGxhdENDRkZIN2NqNUdjbmV5dWgzUFFPSEh1UjMrNEM4KzYwTUZHZHR6SGkxMTRrS1k5THNsMy96TW0vdlQ1aTkrMEd1dnZKcGRsKzl6dHUrNTZmNXdhZk84L3hyRzd4eWVSdFQyNE5rVTZwUXliSE92N1dJUm9vd1dPUUp0NzhPWGVvMDFiUmFtaXhKaVZTTjZEd0gweStneEpEdDIyTnVQSCtUbmR2YkpKRWlicWZvV0tOMGlPZUZGS0dacHdSS1MyU2s4TnNqN000SVQ2RFJ5eVovY0w3Sk02eWtBbUloOFRqSzlWVis0UEhIMmFyZzVtN2RWS05zV0M5Z2E2dzFXT2M0ZmV3NEM4ZmZ4UnZqczd5MjhnYUwrUzd2TzV1eTVwYkpHRE1qeC9Ua2lDaWFrR2xOS1NSMWJlbkdrdmVlaW1pTGlzL2Z0bXpVeWNGcXRYM3Z1OTl0YnloZFlTY0o0R3gxc0tMTldrUGxhOWFLWGE3VVczNGdDcEdQcXpkdnIrMXMrcEIzQkw2VndIc2xHTGppRzN2K2h4RDQ3ZTBIL3VvLzR2blAvTksrTHNsQjVBV0lUaXJkVkR1eGVXNnBTczl6bDNiSjR0T2NmKy9mb3VodjA1Mlpvek9UY3ZkZGM5emNuakFaVndnWGtuVkhvTG9MMllSZnNuRXVxdEc1YWtaQzAwVFJ5U0t5TEVIckFYcjY4MlR6VjhqSEZkZGUyZUxhYzljcCsyT1NOS0xWVHRGcGpOWWFGWVdOc1B2N3hLV1NxQ2lFVy9GZVFlUUNEVVEwSThCaE01dkEyckMzM0hwQjdTMUNLL0pKZ2IxNWhSOTQyemwrL3BuYkdHT2JybmRvOUZWbFNiZmI0azkrejNld01Edkg1VGRmWjI5cmcyenBBbDkwWGFMdU10aWExVWd5SDQ4NUc2MmdOMTlnVmc1SmxDU2FCSFdTRXhtc3RBVWJlNUk0anNNbUsyY0RkYVhSOG5wckhLM1pMMklEV2RKSXk2dURtMXdacjdNMTNzTm9LZEoyZ3EvY2JqMHhZKzVZcVFaNEtZVGYrZkx1SVVCK3I3WjY0eFdpSkFscjhjSnoyUmNzMEV0TFJ4ZmEzVmE3UDZ4SWxDRE9ZcXh6eExNbnFXZE9NUm9aL3UySFhnTVR4S0pWclBIT0laVU1Bejh1Sk85U0I2S2Y4NEMwelc1elFacG9ldTBVclJ4eDl6S2RwZWZSNlRwYnQwWmMrc0lOMXE1c0lKMmwwMDJKa3RBcDF6cFUwWUxPcndoYVdEcFV2SWdWS3ErUmUrTm1ZNndqaWFLd0FkWTdoRyttS1V4Z0dsdmhzVFlzeDlsYVhhTW9CTFdWbE5ZUmFZM3dJUWRaWGxyaXlVY2ZaS3JiNGNxVk45aFlYK1BvMGVQTUxpeWhPeDBpSFlHT2FIVjd6QncvemtnNjdNeWp4Q3Vmb2JYN01rSlczRmdyS0VyUDFjMEJaVDZDVnBjb2E2UGo1Q0RNOGswdE1heUFjd2lDdHBmQjhVYTVnaDRvYW05Qks2SklJYVMwU0xubnZkK25zbHNoaEkvYWtSOXZUYjd4Q09JUUJyKzlQZmZ4bndPZDRlcEtOQXRQRmFEVG1EVFIrVXlXYWRGcEpkaXFRaXVCVHhLa01tam5VRVpqQlpqSzRQQ2gvb1U2S1BFbVNiT3VVQWZkS3lWQU80R1draXhOYUNXYU5OdWt1L1FDMGRRMUpzTUpsNS9aNVBWbnIxRU1KcVNaSWs3U1VEV0xOTEdNc1dQTHVNcFJMVVhXeTBLcFdRbGtyRkZLNHE5djQwWUZUdG13UDkyN01BL3ZMRkZET2d3andCNHJRa2ZmU3pCV3NMNitSWCtRNElXa1VncnY0Y1RSbzd6bjdZOHgxVzF6L2RwVmRyYTJXRm8reXZ6Q0l0MWVMNVNWZ2FYbEplNjU1MjZHd3pGcmErc2s2WEVtSi84TVNYcUUyODk4aUMrOHRzdHJlNWFWUVlFSGlrRkJXUXlSV1lhVUdxMGl0STVJa3pSUTdFVmdIVmQxU1MyZ2tpWXM2SkdocWlZRTRCamcvRW9ERG9NSUJSWlRHUCsrdi84K1B2Ri8vOFFoUUg0dmRtSzZ5OHB3Z3F2ei9YQjRYODBrdW5oUGRQek03SnVQMnRZNzZiZGlqSVEwaXhDUllsSkhqUElLWlN5MUQzcFhnUzdoRDhaeGpiQUhLd0NjY3pnSlVpcVVFeWlsNkUxUG1KNjlSV3ZtRlp6ZVlPWHFrRGUvZkl1dDZ4dll1cWJWMXVoWUk3U2trL1dZaldhUnVXS3dOMkswdGM2dUdERjl4akZ6YkNxVVNST05XUnVnVjNiUjZxMDk0OFpZYWhyYXVmQW9vWUozT2VCRU5adGphMUE0TURYR1M2eW9PWFprbWNjZnZFaW5sWEg3MWszV1ZsYzVmdUlraTB0TGRMcmRwaHlybUoyWjVlTEY4d2lwbWF4dG9iV2lya3AyZHZiNDZILzdNbGRmdk0ydG5ZcCtaZDhLWkwzRDF5VldLS3h5MUxKRVNvVnpEcTFEbjBSNmdiVVZLb0trRlIrRXJ0NkhTNkVxemZwZ2EzS05yNWtVZExYNzVuTFFReWo4VnJ0L2NaWitWWk1vS1hKbjkrZlFJeUJSU21RUFA3RDh2cWNlS0U5dU1QSERZVnVZVEpQRUt2UVR0Q2VMRlhscEdIcmVTaTRQWnN2RHdhd3FnM09lc25KNDQwa2p6OXpNa0xuRkZYcHpLeGl4eHVicUx0ZGUzK0hXcFZWMlYzZFFBcEpFb1JOTjFtNnowRm5nU0xKTWJHSktTbFJQTXhnTjJPMlBHZThXekoyYVFiVWozS2hpOHZJV00xV055QnI1VWNENUlFMGtmYWhHYVJrS0Ivdk55LzNZM3pwUEtpeXBqSmhVaHRQSGovS2VwNTZnMTJtenNiN0d6dlkyUzh0SG1GOVlaSHA2RnU4Y0FzSHkwaEluVDU1QUNNWHRXeXNZYTJpMTJteHZiL1B6UC85ditjSXpuNmMyOWRkL0NNMVNSZEZNV3pyckdFK0dDT0dKNDRUcHFYbVUwczBrNDF0bFllOGNRbWlFbEtVcGJiNWYyaFVJcnhKRk9wMSt3OTdqRUNCZnh4SUNsMmRTMXFLb3pmNGs2cjRPYjN6cVdIYnlpY2RPZnMvODdHeXl1djNyZm5IeFNVeCtBdWRWaU9lZFkxald4RkxTaWhSbDdacUtpME1wQ1I1R2s3RDlTUGdhcmNlME9oc3NMcS9UbmQ3RytnRXI2M3RjdmJ6RjJodWJyRi9mWkxRM1FncFBuRVZFV2NMQ3pCS25aMDR6Rzg4Z2FvOFJocXFzR1ZjRHR2TStvaVdaWHVvUWQxT2M5ZXk4dElIYW1xQ21ZSCtqNkQ2L1RCNlVVVU5vSlJwQTJFWmNPd2hMQ0dMcFNTVXNMeTd3cmljZnA5ZHBzN3U3dzg3T05yTno4eHc1Y294ZWJ3b3BBM1drMSsxeTdwNjdpWk9FVzdmV3FHdURWSXFxcXZpdi8vVy84TXd6bjhPR3NkM2ZPdWU2RHhEcmtGSG8zd2pCd1FycXVxcm85M2R4VlVtY2hOekpXQnZXT1VqaG5VY0lKWGF0OFdQdWtFa1ZVdmp1c1M2anRkRWhRTDdsNWlCd2JYZUFBK0c4bDl5eEZFZEowWHI4b2RudnZQZjgyZU0zYjFUK3h0NkxZdTdDR3BPZGU3RGxLWlJkUURHSEhrRWRTNFNJcUsxSENJT3hWYUN0dTRwdWI0ODQybUZ1WnNEc3pKRGNiYk16SEhCamRjRHFhcC9OVzN0czM5cGhzTDdMZURoQkswR1VLTnE5Tm5jZHZZZTdadThtSVFxaURWZ0dvd0ZydTdlNHNuNkxPbllzbk9neWUzd0s1MkhsMlJYS3EzMldkQ05yNi9mNVRRMFowb3Nna2RqSURBa3ZrTjVobWh2Y05nczR2YWs0Zitvc1IrNS9uRjQ3WldOampmN2VIdFBUc3l3dUx0UHQ5UkFTcXFwa3FqZkZxZE9uaU9LRWpZMXRpcUtnTEF1VTF2emFyLzUzZnYzWGY2MFoxLzJkeklPcGNJVkNaVzFVRkhJUnBTTzhDRXhmYTBwVVYySjhvTUlUR0F0Q2VyRFdiOWFUZXNMWENERW9KUTlEck4rTE5aK21hRFoyS3lBU2dwYjNwS2RPdHU5Ni8zdFBmV0J1NWtUMG9ZODk0emZMVGJMalhVVHJpeEEvQzc2RHM0dk1UN1daVko2OGpNaGtnaEY5RUgxaUpZaGpSeXQxS0J6anZPYks2b2piVzBPMnQ4YU05d3BHdXhQNmF6djAxM1lvSmtVUWdrZ2szZTRVRjA3ZHo5M3pkNk1Kc3ByYnUzdXNydDVpWTdERjFyaVA3Y0RDYkp1Wkl6MnNrS3gvZVpYKzFWMW1QQ1NxYVZZMnQ3Tm90ai9SckYxUXppTTBvZi9pbWhhZ0YxanZVZDZSTHAzZ2dZY2V4YVJ0ZHJhM0dPenQwcHVhWVdGeGlYYW5nMWFLb2l6b2RMcWNQMzh2OC9QenJLNnVVMVZWbU1XUFl6NzU2VS94b1EvOUZ5YVRiN1NLWlBFMnh4WUM3ek4wRklXUlpDRVF1Q0I4a1VRSFY1dG92S0dRd3JyY2JGZmpLdWNPUVRnVlNSK1VSZzhCOGkzWk94Njh3T2RlZkMxd0RNTjRiUVFrM3BOcEtkdm5qbmVlV0pvK2N2ekc5VjF1M0xndXhLaGs3Zk8zbVhyaU9CcURGYnVnOW9qU0ZCMDc0aVRNSnlUTmZrRnJJUzhGYTl1ZTdlMkM3ZDBKK2JpbXlBMlRjVW5STCtodjdESFkzS1V1YXFKWUVhV2FZMHNudVhEcUFZNU1IY1ZYaHRGd3lJMmJON20rZHBWQzVmak1JeFRNdEJLNmkxMHFLMW45NGdyRjJvaTJoNjZHTkFJdEdrSGRneUdrOERmSi9odDBDS1V4UGt4SVdqeVltdGFaaTBRUHY1Y0N4ZmJHR29OK24xNXZpdVhsWlRxZERrcEt5cXFpMisxeC90NTdtSnFhNHViTjFVWkYzUkpITWM5LzVRWCsweS85TXR2OTBVRjQ5dzJadC9oNmd2VWU3ek9VRGtqM3JzWTVpMnpZMXZ0TWhTRHRnOE9UMzVHZ08rKzljOGFSemFTSEFQbFc3RWUrOTcxODVkSlYwamlpcUtvNzg0NXNzWlBOZitEczBvK2YwY21mZnZYajIrMDZuWkRhS2J3WTBmL1NHcE5PUk90VUQrR2g5cDZ0Zms2a1FoZGJhY2NvTnhTRlp6U29HQTlySnVPZzB1NUtSNVhYbEpPSzhlNkV3WGFmNGU0UVZ4dmlXSksxMnp4NDdtRWVPUHNvbW9qaGNJL2QwUzZibzAyMld0dllveDR6Y2RpOHBqZWJrazUzbU9TVzFWZlhxVFltdEFSMEJMUWlTS0lRWXNrbTVmQjNnRU0xU293SWdaTWNVUEdkczZUTHAwZ2VlQWVGaU5qWjNtQm5hNXVwNmVuZ09kcmRNQTlpYWxwWml3dm43K1gwNlpOY3VYcURxaTRENDlZTFhuNzFWZjdkTC93aU80TVJVYnVIbVl6d3RteTRuOStZWHhmQ2d3Z3JITFNNOEk0bUw5UEJjMWlIYjVxaVdzcUJNKzRXWHkwblNqV3V2WGVISHVSYm81UW94ZXIycmlqcitrNkI2a3dJa1Q1MWV2RmREeXoxL3FKQWRLV0pTR2pSbVQxTlVVeVlUUHI0VndYanFDYnZlYndOV3J0YUJwblJxb2JSc0tZWUdreHB3dUtiMGxBWGhrbS9ZTFEzSmgrTUdlOU9HUGR6ZEtTWm56M0NtUk9uT0hmMlBMUFRjd3lMQWR2akxmYnFYWGJORHFPcXoyaG5nTTBOT3BKMFp0b1FSV3plSHJGMXRZOGJWMlFDT2dUdmtVVmhOZUUrbS81T2dIZ2ZwZ2xsc3cxWE5md3RaMnVtemw1ZzlySHZZR0FGdzkxdGhvM25PSEwwR04xdUR5bUR0SStVa25QMzNzT1pNNmZZMk5pbUxDdTAxa2loV0Z0ZjVmLzRwWi9uNXRwdFloMWhuY0tuQXB2N1JtUDR0OHZTdnpvZjhiWkcrQVFkTmV4ZTUxQ1JJRzVGK05xQ2xHRWdMRlRmUnRXa1hyc0RJQWNnZWYwalZ3OEI4cTNZMXQ0QUljU2Q0bkF4a0o2WWJpL2ZQZFA2Zm9udmlMVHJaWndJVTFWSUVaS1RtYWxabEZBa1YycHUzVlZUNm9iOHB5VkNRajV4akljR1V4aDhaWmlNU2tiRENXWnNjYm5Eaml5eWlwanRMUFBJM1NjNWZ1d1kwL1BUdU5neHFQczh2L01sOXZaMkdRNEdqQWNqaW1HQksycmlXSk5OdGZGU3NUY29HS3p2VXV3RWNlY1U2TWpHZXlRUVJ4RElyVytKSSt4VHlKdS8zdUxRZUk4cERiTW43K0hZdS84VXU2VmxaLzBXbzlHUVZxdk40dEl5M1c0M0pQcE52K1RlYy9kdzd0dzliRy92TVJpR0VNcldsbUhWNTludFQ5Tjd4SEwvaFdYMlZncEdhd1hqdnFBWWRURVRqeTFLdnFFNzNkVzRmSXhGb3BNRTBTZ25nc2NhaDRvbFdJdlFFbTk5UGxnWjdYeFYvcUdsbjEzSzJMdzlQZ1RJdDJLZitPSlhSRzFzbVBrTUN1Nko5MFNQSEpsKzEwSVdQNDRYNkZaYklCU3VMaHVCWkJGVXlTUE5ySW1KVnoyWHVuMkt6Q0hxSUpaVkZSWlRXbXhsbVd3WGRQVVVENXg5aUJNTEp6a3lmd1F0RkVtVWtpWVpHK010WGw5L2pXc2JiM0Q3Mm0yMjFyWVo3NDRwUndXaUtSUEhXVXc4MzhPakdJNUtCbHQ5aWtHSnIwTlpRUXRJZkpBaTZjWVF4d0VjKzhMYStMZUUzcng0cXlKeHNPbWp0c3llT2MvU2s5L0QxcmhrYTNPZHlYaEVtcldZWDFoa2FtcnFRTytxcW1ydVBYK09CeDY0bjgzTmJWWlgxMm0zMjBRNllsUU5lSHIxbzZ6SU41azYzY1pZVCs5TWkyS25JcDhZYXV2SnQ4WU1ydTVRaldxS2NVbXhWN3hGK2Y4dHEzczgrQXBiVEFMangxcVNkalBqUXBqRHdYdVVCS1ZsYlNwVEh2UkFwUEI0ejlLcDNpRkF2aFc3Y05kSlhyMTh3MHNwWkJOZXhkNmpMeTVPblh4a3VmZG5Za0ZtNGpTc0VTdkdlR09JR2txNUwzTzhTSEVxeHEzVmRLL1g1RWNNNWJ3S0t1MkRtdEYyenQ3ck8zei9rOS9Oai8rbHY4cXhJeWVJVklRQVNsTnpmZU1xbjMvOXMzejYwaWQ1N1pYWDJia1pnR0ZyaTRvbFVSS1JkRE4wSEdFdERQWnFSbnNEeWxGMW9NcTQ3d0ZTRDEwSnJVaVFScDVZRVlhMnBHZ2tkdmJielhkb1ZCMHNBblVzWG55Y0krLzRiamI2WTliWFZwaE14blM2UGVibmw1aVpuZ0hDOGhsckxQZmZkNUZISDMyRTNiMCsyOXU3R0dNWURvZDBXbTJlMy93OFY0clhVVW9oUS9vUXBocTdFV21xU0x5bk14TXpjNlJOT2FvWWIwL1l1NzNIY0dNUE03SjQwOHhqcWNBeUVFb1R4UXJ2STd3U3hHbEMydFpCaENKU3pYSWM1YVVRSHV0dXU3QXhhbjhHeEZ2cnZmMG11K2lIQUxuRDRraUwydGo5MHE3dXRMTDA5R3ozdTFiM0p2Y09ZaVc2MHpHVU9kS0hVVkZiMTZIcEZrVlk2OG1MblA2a29CNFg2STJjYWw1Z2o2V1FoY08wZVhXYjE5STMrZks1THpQOWdXbW1abWU0dm5PTkw3eitlWDdqNlkveDNITmZZZWZtRHZXa0RFSU1MWTNRS1VKcWpQR01ScFlpSDFKT2FteGxtNzJGZDF5d09xeHN5eHhNdFNTOUdDTHYwUUtFOEx6VkRueEx2bHdjeEZjQzd3Ukg3bitDNllmZnc4M05QZloydGhpUHg3VGJIUmJtRjVtWm5UbkkxVXhWYy9yTWFlNjcveUk3Tzd1c2IyeUY5eUFFUlZIeHpQcm51RlI4Q1YrQ0V4YTBiTGI0QmthQmNFR0VPZ3p2aDdtWUtJdElPekY1WDJKemk1UUVHa2txaWJPSU5FdUoyd2txVWlncDBaR2lyTTBkbTBYRC9JencySHBTclRqcml6c0JBdkRxRjljUEFmTE4ybzk5MzN2NTBxVnJ6VFk3ZjdBY3B0dEt1MXVWdStpa2JaMmY2ckJkbEd4czdxR0VwSlZFNEJ5dE5LSFg2V0FJYmo4dks0cWl4T1FsWm1PTXVRYitWSWZ1Zk1iUng1ZDU1dVhuZU8xL2U1MkJXcVZ6YXBhUGZmcGpQUC9NVjlpNnRvMHRhblFzU0xJSWhNWVlxRWFlYWp5aHltdHFZMzVyMk5IMHZJUUNHVU5rb0tzZ1ZwNElIMElyMFlSUWpVQ0VhR1pQdkgrTG91RnF6NUVManpMN3R1OWdaWE9IclkxVnlxSmdabmFPK2ZrRnBxWm5tZ2xJaVhHVzAyZE84OVJUVDFLV0ZWdGIyNVJGZ2ZPZVNDdDJkMTdsbFowdlViVTltWlM0U1kyTEhEUks4dnY3M3dQbEpnQkY0Z1BEMmRyOUtXU1VETjRqSUZsQU01SXNoRUJvcUtvd0J5MWxvUGJ2cjhOV3FTNjMxMFp2bXNyVys5SXdFdUV0L2xzNkgzL3NBYUowR05zMHpvWnJxR2tPN2c1RzhpODhjYTY2WjdaTlhWVzhzVDVBQzdET1VCcEJFb2U2YVQvUHFaMExZN21BOTRhaXloa1hZOXpJSXJmSDJLNW1acm5GMUdOTHFIYkVmL3FOWDJUdDlpNjd0L3U0dkc0bzhKSkpEcmF1TVhXSnJVUHkrVldUUW5jdVFRczQ0b0ExQW1RU09oRm81L2NGQ2ZmbmplN0l3dS9ZeE9tRGtzbkN4Y2ZJTGo3SnpkVjErbnM3RkhsQmQ2ckgwdklSZXIwZTNudWlLRWp3TEM4djhkUlRUNEtIbmUzZGc2R3ZxbloweFJhUEwremh6UktmM050a25aSldMS0d3UWRGZWhjTXNtejBRWWVWQzJDbUJkZGphWVBkSGFKdXJYelVKb1JDaEVlaXR3ZWtvREZUSk8wU3poVUFxSVVRa0o2NzJhM2Q0andQWklPZjlJVUMrV2F1S0VoVm1QVUsyMTRoN1BIUnk2Y2hDR3AydHk1S3RRY0hlcEFvUFUwZ2lMWWlsSUdpaU82UVdWTTdpUFdTdENFc2J0R1F5Q2JMOWNsQ1Jid3l4MG1PbFlLdGZzV01zdFJLNFJnN0hOY3RmZnR1THpuL056NzQ1UFRJazVyRVRtTm96dElKSStFYnAvVUFYNHEwODk0NEdvVUN4ZE4vYmljOCt6TnIyTHBQeGlMcXVtSjBMbnFQVDdXS2RDMk83UXJDd01NL2JuM3dTNzJGdGJaMjhLRkJTa3FRWmtWM2haSEtiVkhnK2NPSVlGK2NXK0pYTFY3aFVEeWlWQUF0T2VGVFRZNEVnYU9GRW1HWmkzOHZkc1lUQWV3NG1Jdy9BTFFMSUVISmZTUVB0dzM2UXBMSXNWVkhyV0dmcXJuVzE4MFZqblpOU2VDa2xqNTAveGpNdjNUZ0V5RGRyazhHSTBYaXl2Mzl3ZnlCSzNyVXdmUWJ2VDVURytkSTZrZGNWU25pU09BazZWTUQyWUV4UjVSeWJtNmJLRFVLRmhCb0JXVHZENlJDdjI3S2lNQVpmbFVnSFV6aHFDM3RWT0NpMjJjcXpYNVA4WFZvQ0I0dWFmUjJFSVJKZ1JrTHBCWnNGSkltazR4MVJFK0ovRmNZYWhyR09NN3BuTHBMUG5tWjdZeE5UVnhoam1KcWVDZHlxVGpkSXAwWXhRZ2hhclRaUFB2RTJzaXpqMXMzYjVIblJoSGNSc3RyaVhPOGEycGM0SW02dmJ0TE5Ndjd5aFh0NVk2ZlBGMVp1YzRXQ0xXY3BmVmptZ3hOb0xiRlNZSm93U2lxSlV1S2d1cmJ2WmNLQVdlQ0ZIU3cvMVNIeGo0MWp5aXFtaldCR3hYNGhpVkxmMWFlVFNHRWFhcklBbnlqMUxjVllmK3dCOHZpWjQzenBqZXROb0lzQUw3VlNlcmFkbmtzajFaa1VocksyWkZvM0N5RURUVndnZUhWOW14YVd4YWtlYVJLRnVMb0t1clhPV1NLcGtCcUt2RVJKaGRjUnhqaWs5dlNjSmNJSGNVVVo5QnNLQ3lQMzFpWVhkUWNlOXY5WjhGYjQ0UzA0Ry9RMGErbHBSd0loUEx0V01PVUVxUXZnay9LT0JOMExWTnhpL3NHbkdHWnpUUHBEQkE2cEZMMnBhUllXRnVsMmUrQWhpaUtVVWt4TjlYam93UWZvZEhxc3JXMHdISTZhMlhTUEdhNXh6OVJOWmpxQ3dTRGtQYkZXN1BVSExDL084TUN4UlU2MFUyN3Y3ZkZtZjhRYmt6RjdydWEycWJET1VUbFBKVUxmU0VaQmZjVVNjaEhWdk92YUduQVIyb2RPcHpTV3VIRE1FREZIekh5U2tDV0tTQWxpUmZYcTF1QzFTV2ttZ1gzaW5YZk9yOTllNXhBZzM4b0hNRFZOcTkxQzdBNE9QUHZGdTA1MWRCeWZ1N3krbzErN3ZlWFgrbU9rZ0lrTnl1VFRXY1JzcXRCVU9Ed2ZmdVVLZEdMaUxLR0ZZT2xJbDJTcHcxNXBtZHpjSlk0Rk1TbVpqYWpLQWhNSnRQTEUybEhXUHRBbklrRm1JYWs5YnIreVpJTmZxNW8zcHBvdXBpUG85dWQzZ0tWd1VKV2hBWmdiUitRRkpKQ3BRQzlKVkFpeFpOUm02dndqak5vTGpNZmowRHdVZ3FtcGFlYm01bW0xTzRBblNST01zU1JKd2tNUFBzanM3RFRyNnh1c2Iyd2lnTm80OHNFR3grV3J6S2NwMWtWSUJVVlpNTlZPS0l1Y3F6ZldPWFh5R0oxdW0rUFdNcXNTN20vM3lJM2hlcEZ6ZXp6bVVqRmtXd3BNSEZFa01hMXVpamFTWW1DeHRVY25nbTRyWTZyZElVR1JXRUdTZTJMcm1ZcGplbGxFSzlFTk5kOExaMzEvWTI5eTJYdnZoUWpycXowd3FjMGhRTDRWaTQ2ZkplNThDY1RhdnZxK2MxVTE5YkdYcnM1ZVhkODB4bG5kU3p4VExXaTNJMDdNZEZob0o2UktvSWhaRzVXOG1oaW03NTlqL3Q1WmVqT2E3a3hNNFJYRlNzV21xaGk4dVluWW5wRGxGdWtkdlZpR3lUalhpS1o1ajdVZXFhQVhnWEdpU2JBbFdhengzbU5xaHpFZUtUMTU2Wmw4bmFLV3V5TlhXU2s5MnpWMHd1b1JsalBCK1JOelRKMTltQjNSb2R6cms2WXhPbzZabXBwbWZtNmVPRWx4enBJa0tWSXFabWU3UFBEQS9Td3VMckRYNzNQejVpMnF1aVpOVTF5eFEzZnlQSE1MaHJMVXBFSWM2TzVhWjVpZjZWSGJBYSs4Zm9Oelo0NlF0REx5eXBJSmFQbVk1VjZIeWt6ejd0bUt2Ynhra0Jlc1RNMVNGaFd4bDJ4dWp0amVHeVB3ZEtLSVJDaDg3YWh0alZjZUZRbGFpVUlyVDJscXBCQytwU1U3UmZIeWxaM1IxZUE4c0lRMDU3ZHFCeDBDNUJ1enkyOWNJbFlITFRNSGNHVjFZOU43L3k5MTdQOU1KbmlIRWtSVG5aU0x4NmVaVG1PVWF3UU5yS2VjYnZIQTl4M2p3Z1BUcE8wZ2F1WXFUMy9vR0FwQnRUTmg1L0l1cm0rYlhrSFlrWjVJaUVYWVV4aExTQlhFa1VBclFXMDh0dllJSGJheVNpSElvdER3YzlheVY1ZFV2eHN6QThoZDhDd2VRSGE1KzhURGJQcU11cXBvdHpPeVZvdVptVmw2M2FuQWtnV1NPQUZnZW5xYUo1OTRuS21wSGpzN2U5eTRmb3ZSYUlSVWl2WFYyNXhKcm5LczNXZXc1MGpUTEFpNHlUQVhIc1VKU3FlY1Bqbk44TFVyZlBMenIvSDRRMmVabSswd0daZE04cEtLc0xOeGRpcWxreWp5V0NQM0t0NVkzV05ZV1dSbDZGVU83MEFiaTVmaDlTTWQ1dmJqV0tHQTJscU1jeVJhQ3VQczVPclc0S1ByZzdMUHZwS0p4elhhZk45U0R2TEhYaml1RzNsdXJXMkl3V2dpR3BwSlZGc3JqWFdicDA2MEY0cUpmV1J4S28wZU9ETkxONGx3Sml4MmtVQmRPOXpqUzl6MzNrV20yb0pXckVpVUFLOHB5d2pyRmROemJkSnVodmVlY2xEaWJNZ0xLZ2U1aGZFZDMwc1R3aUZ2UXpWSGlsQ244VXBncGFEMk1La2RPNldsK2lhYXdsTlRVNXk3NXp3aXp2RE9NemMzeS9UMERET3pjMHhOVFIzMEVySXN2TS9wbVdrZWV2QUI1dWZuMk5uWlkzTmppN0tzTU5iUTM5dmk3UFNRODBjRmVWNHdHWTdwZEZ1QjFWdlZnTVI1UVpxMUVVSXcxMHNaakhLZWZmRWFvM0hGN0hRbjZPMmEwTk5RS2lqTDE1WGgwdVVOM25oam5iMytpRHd2eUtzSzR4MUpySW0xSklrMXVpbW5BNHpMbXNwWVhGRDFFbHZEL01XWDFrWS92NXZYbXdTaHVES2tjTUozWThXZ3RJY2gxamRybS8wUmR4QXdEdkpmcGFReWxWeHNwVkY2OGU0NXVwbUd1bWxVQWJaMnRFNTNPZnYrUlZRSGFpdEpJNFdySS9walFWMWFPaTFKZEVTVHpiVTVjdjhTS3krdmMvM1RONWhzVDNEbXJSTmVFN1Q0Y3cvajNKT0ZOZ2VwZzFSNmRMTWpYV2lGRXRDdEJmblloejBpdjRNSkllajFlcHcvZjRGVzFpYUpJeFlXRm1sM09yUmFIZEkwUFFnK3NrWkJaSHA2bWtjZWVaRDV1VG0ydHJaWldWMm5LaXZpSktIZUtqbloyZVd4dXp0NEE1TkJSQlFycXRxd01EVkZWUnVjRjVpaVpqd2FFY2ZoZUQxd3oxRWlZWG4yK2V0Y3VyekN3eGRPY0dTeFJ4cEgxRVdPTlJibkxWSjVhbHNUS1luV1FZamE0cW5xR2kwRk5ZYkttSVBtVGxIVmVPbXdsUkZEWTh2MXNmblVqYjE4aFdhOUFXQ2x3TTIzTmJjRzFiZDBQZzZwSmtMaE1WNUltZ21oVUpIWFd2c0w5eDdOV3FxVVU0bkFWNVpHRUJGZmUwU3FPUGJkeDVnNTNxTElLeUlwTURabVp6ZGlzSmZqZ0ZZU29ZVUU2L0hUS2FlZVBNSE1xUmxXWDF4ajVVc3JGRHRGRUVhUVFBSmVRekdHTWl4WUlyV1FURHhaYmNraVI5WWlyRlN3L21Ebk9sK251ZTZiV0c1NWVablRKODhRUlRGSmtuRHMyQW5hN1RacDFpS0tva1lXVkJMRk1VSklabWVtdVhqeFBMTXpNMnh2NzdDMnZrbGQxUmhqS0lvSlIxbzd2TzNjSEs3S0tjcTgyVHFyNmZjbnpNejkvOWo3NzJmTHovdk9EM3c5NFp0T3Zxbjdka0kzME1pQklNQWdNWWxKRktYSkhubWtDZHF4dlM3WHVzcTc5Z1NQYS8rQnRYZC9jTmphdGNkQjBtaEhNeHFLa2loUmxDaFJGRW1SRUFtS0dRUUlFRUFqZHU2YlR2NkdKKzBQei9mY3ZvQ284bGlqR1JKU1AxV251dEVKOTU3emZMNmY5QTdiYUMzeHpwQm5tcW95TEJaTnRFb3pOV2RQYlpCSXlYTXYzdUJyVDd4SXA5ZmgvTmt0VG01MDZLUWFwYUpLUENHUVowbHJ5Qm0zN05aWmxsVWtRN25nMFNxT0tvdzNMQllsM25xOFVNOWNucHJQV1I4V2JlWXdvaDBBS2lIQ24vWjYvSVV2c2JZM1JpUnBZREt0aFBkK3hVSFA3angvY3YwLyt3L2YrMkhmek8rb1ptVmNScldnTzJjOG8vdlh1TzBEcDFBeThxRzk2N00vVHRpWjFwVE9VYmYwejBURjV0WGE2QUtiOWxLR3A0YjBUL1FKSWxCTnF1ai92Ykp6YW9PRmdjVDNOYWFqYVFyTnNpMnhHdXVabFlIYWZ3L0FhL3RYY3lrNGZ2SVU1OC9malpLUy9tREl1WFBuR0kxR1pIbU8xaHJ2QTFvcnNpd2pUVFBXTnphNC8vNTdHQTZIWExseWxXdlhidUJhWC9LcXJFa1czMkVydWNIWmM3ZmpUSVgzRG85aU1wNnhXTmJValdGamJSRDNGajdnbmFNcWE2cHlTWkttS0Nub2RYS09idzF4MXJHM00rSHk5UVBHMHdwRUlORUp6ejEvblV0WDlxTzNlM0FJS1REV3hTRUdqckt1cVkzQkI4dHNzZVJndHNBWWgxWjZ1dCtFZi9iTTd2SkwzTFJYTXdMY3FOQ2hTQ1NUeXQzS0lIK2E4KzNuWHViTkQ1NXRJZUJDQ0JGRUNJVHpaN2N5SVVTdnFTMjY5VGtQSWZwb0JDVVkzRDBpNnlWNDR6Qmh3SEtSTXBuUENDc3RMT3VwamNYN3FNZ1JGMWVPeWppa2xteWNYMmQ0b3MvNmJXdGMvdFlWcHJ0VHZQQ1FSK0dFYkpTUjlUc2tXcU96Qk45eUxHempFQXREVVZuTXVNWXVvbTMwU3REWlNjbXBZOGM1ZGRzNXZQY01oeVBPM1g0Ny9WNFBwWFhyWHg0WG5ta2EzYTQyMWplNCsrNDc2ZmY3WExwMG1iMjlBdzdHQnhSWmp2R0IvZVlaUG56T1kyZUt2YjA5Tm9ZRldaYVFkUVBYZDZiWTVUNDd1L3QwTThWdzBHOUZzK1AzckVSR25xV0FSMHFIVGxMdU9YOGM2eHpYYmt4b3lvcHZmT2N5WmVYNHpuZGV4Wm9LVkRUbzFDMUsxenFQYzQ2eWNnamhVVUt5ckExWnFrSXZUMzN0d21QUDdWV2ZiWU9qV2pYb1Vnby96RlhZNkNTOE9xNXZCY2lmdXNxUzh2VVBZbGtVYWJKWUxCTHZMQzNrQ1NkaUZaQ09NamJ1R1VVWEtkSEYxSDBPRmxPYzk0ZmJhb25BZUVmcGZBVGxIZUpuQlVGR3BVV2RhMDQvZXBLMTI5YTQrSzFMWEgzcEtzWTEwQVNDaFRSSnlMczVhUzlEcGtuVTBVMFVNb3NlZjY1cWFLWTE1ZDZTeGZVRmR0cHdZbmlTNDhkUDROdmR4dGx6NStqMyt5aXBJbm8zQkxJOEo4OVNwRlFjUDNhTWUrKzlHNlVVTDc3NE1zdEZpVEVOcyttVXNaMXdXVDVQNzQ0YjVQMkgwVEtoV2s2UW0wTUlVQlNhTysrNWh5ZWZlSko2UG1GL09tZHRiVWp3VVVLMUtGS2NUK0xtVzZZSUxNdXlwbHRrUEh6ZmFaSkU4OElyTzVSTHc5TXYzdUQ1cXhNU0FZVnFTRlgwWFBRQmpBRXA0NDRuU1FXMWRTZ3RRNTVxZ1pRWEwwN01MODRidDlNR3g4cTVOb1FRZVBtZ1pxMzQwMS96V3dFQ2pBYjV5amh5TmU5bE9NaHpvS05sTkwrSmJhSEF1MEMybnRGZnkwbVFURXJCbGNtTXBXbGFINUNXWnlFQ1dnaHNDKzAyTGQ0cVdoaTNyRDRpTGlrZlpkeit6dHNwdGpwY2ZlNFMxYVRFVFJvcU5VZHJIYzAzSlNSRlN0THlaNlVVNktTREV1Q3RwNmtkeGZXVTVGb0NJYkIxN0JpblQ1K2hLRG94T0Zwd1ZwWkdnZXMwelRpMnRjWHAweWVaenlQY3hyZDg3YVl4S0ttNU1QODI1cDVMOUhzRmxSRGNlZkkycmw5N2ljVnNUTGM3SkFUQitzWVdaOCtlNDZYbm5xYXBhbVpseGFEYndabFdMem9FdkxXNEVHMnd0Ukl4Q3hLNCs3WU4rbm5LYi8zQjB6eC9jUzg2UDRSSS9XMThvREVCS1NJamtsYjkwWGxJRWtXZWFwRW15ZDY0OGI5MGNkbzgwNVpWaDc3bldhTDhaamNONDBYRE42OHNiZ1hJdjFrS2VZMSt1eUFLZjRqbG9zUmFHMzM4VmxLY1FEckswWW5FT3hndkxmUEtBSUk4MFVpL0FxeUV3d3NuUktTeXloWUg1VjNyZTlFcWNmZ1dpcjUrK3dacEwyUC9wUnZzdjdEUDR2cWl0UzZJRUF5ZFJYaWtsQ3Z6UzRGS0pFV2VNNXhvbWwwREliQjUvRGluVHAybTZIU1FoMlBSUUtmb2tMWUJzbjA4Wm83WmRNN3U3Z0ZTUnZOTXJSWGVCUzR1bnNmZmVabitXc0xTR1c1UWNZL0tTWktDNWV5QUJBOHF3M3ZZM09nejNsem4rYWN2c0xTQ0IrNDlSeWZMV1M0cnJLMXhUU1IyU1NXeHJwWG1FWkt5ZEZ5Nk1tWHY2cGp0WEtLN0VxMDB6amtXdFltYVlnaFVLeHduQktRNm1naXRkWXRtYnNPdlBILzk0RGZheG53MTFyVlNDbitzbC9HbTB5Tis2OGtyLzJaSWkxdlJBZmcvRGtQSXMwdzU1N1V6VWVqWmk0amNEVDZnYzAyU3BWUzFaOUdFVnZ6QUk2UW1TVk44TUZnWHNETENyRmZjdmVBajZDNjAxc2FoSFJjN0Z6VndBVHBiUFpKT1NsS2tYSHY2S3VWQlNWb3NVS25DWlJxVitCZ2NXaUlVNUNJbGZUbGg5dHdDcFRYSFQ1N2crUEhqRkoxT2hPQ0hRSkxFakpGbEdVVlJzRFlhY3U3c2JTeVhGYlA1Z3FJb01NYmduTU1heHpNWG51VDYxak9jTzlFaGVFRVZIQmZtVjdsUGJyRzVmUnZqM1ZkNDVaV1hHZlNHQ0ozZ3ZlWFlacCtMZ3hFdnZySkhtbWdlZk9CdWhFcVIwcEFVT2JZeFZIV0RkUUdsTk1ZWXZ2WFVKVDczaDgrd1hKYU11am02aGNQN29DZ3lGUzNYaEVCcmhSSWlPdGxLRlhwRjVob3ZQdlBNenZoajQ5S01qL1FldHBYNUNtVnR3cC9GMWJnVklJQktzaitXVTd4M3d2c29GV3BEKzY2SFZ1UkFRa0JoYkpTODhUNWdyTVBZa29Da3NnN1hUckhpM0RobUNXdDlkSk5hR2NSNHdNYmdjRWNrY0pKdXdzWmR4M0dOWTNMNWdIcGVvck9FckpNaENvLzBDa1dnNzd0d0FhYXZ4RkpzKytRSnRyZFBrT2NGTW42UnBFbEtwMU1RRUhRNkhiWTJOemgzN2l5VHlaVEZZaG1Ed2ptVVVsUlZ6ZS84NW0veWtuNkMrOTl5RXVWRGk3eVZYR3oyZUdGNWxXT2pOWHI5SWEvYXExeS9zY1BHeGhCclBFcHB6dDkrZ3N2WERyaHc0UXFiNndORy9SNUtDcVJRYU8yUUJrTHQyVCtZOHFXdnZjaVh2bktCcG03b0ZobFNLbEl0VzQ1SElOR3U3VjBpbFUxTFNab2tJVThTRVFSUGZlUFMvdi95eXNIeVlycytLbGVOdVpMQyt4Q0NFT0xmT0h2Y0NwRDJuTC85QkYvNDRqT3Y2VUhTUktWYXlnd0JKdHljaDBzcENJM0hHcytpOFRUV0k0a2ZwSFVlNTJOOWJiMGplSWx4Z2JvTkRHakxLOS9hSWJTMm9NclRpa1I3L0lyNm9DV2oyN2ZRV2xPT0Z3VHI4TXNHbHlsMEpoZ3hKTDJRc2ZmS0FVVzN3NGtUSjluYzNLSW9pa09NdTlhS0xNOVJTdFBwZHRuYzJPRHN1ZHM0T0JoemNEQkdhMDFWVllRQVNacnk3UzgvemhQUGZZRzcvazluNmVXNnZkeHhNbUh3Zkt1NXl1MlRQdXRTY052SlRXN3M3bUdNb2QvdmszV0hiQ3FKRDRFdi9PR1RQUEhrQ3p6eTRHMTA4Z0puRGFhdXNiWG55dFV4bi8vUzgzenJxVmNBajlZUmF5YmFjbE9KdUNRVVRyUVcweXRXcmd5WlZpTEE1V2QzNS8vYlMvdkxDOFRnV0xhTFFTY0U0Y3d3NTl4Nnp1ZGVPT0JXQnZtenlpRHlqK20xaWtRblVrbWhEcjNBZzJqcE9iQzRQS2VaR1ZBYTAzaWM4UWdYRG1IcGtkVXFxTDNqSmdLeVJYcTFVQkp2ajdDQzJnOWlCUmlTSW5JaXNsNkdHeGFJRURDbElWaVBLQzJqZkFPMWs3Qi9lVXluMzR2QnNiRkpsdWV0NFdVZ3ozS0VsQ1JKUW44dzROU3BrNXc2c2MxOHZvUWc4TjdUTkFaakRiWnhmUDBMWCtDN24vdE5UcjEveFBxWlBoMFZQZGg5aVA2Q3pncWVYKzd4bUh5VnY5UTdoWll3N09STUYzSFAwU2xTaE02NDk3NjdXSlFOMy9qbTh6ejc0aFZ1UDdWQk1JR3liTGg0OFlEUFBQWXN6Nzk0SGZCUkJkRUY4aXhxNW1vVktRWE8rVU55MTBxcVNBc3BrT0xLaS92TC8vR2JseWRmYU11cStkSEdYRUI0K2FBTTY1M2t6K3h1M0FxUTFmcjVkV2UrbUxyRlV0djJ3WS8xTjcwRXE1MlN4YXRMdXZjY3gvdVNhbTdpbENWUjBYd21CTHlMdUtyb3hCVHhwQzc0bTd6d0VJMXpWZzI2YkQzVVl6TWFNVXJJU0NLS2phcEFwWXJOOUJqaWN0eTU5SWNEdGsrY1pHMXRuU3hMWTNZRGV0MWV0R0tUa2w2L3o0a1QyOXgyK2pSMUhlRVdTbXV5TEtjc2wxamplT0w1Si9qRXAzK04vcmJrN0p1T1J4TVVKV2xjWkVrbUlpb3VoQ0I0WXJIRGJXU2NwNE5yRE1JYTluZXVFNXhsdUhrYTAxVGNlOWNwZW9YbTg0ODl5ZTdlZ2pNYlBiNzU1RFcrK2NTclhMMDJCaG5RV3BJa0dxVkUxQ3h1elhZQ1lGM2NQWVdXcHF1MUJDRXVYOWhiL24rK2VYWHlLUmZDS2pqcXR1OXdRb2lncFFqV2U3NStlWG9yUVA0c1Q3REx3eWY5NnZSNjNVUW5KTTRITElKMFJjUVFBVmRaZHA2NndkcnBJVjZCazlBc0RhSVQ4RHBPYWx4cmMyWmRpQk9jTmpCQ0swQWdSS3l0aFkvMFdHYzlRVVNSaGRCNkdjWitSeEI4SkJCdDZnM0Vmc0ppdG1Rd0duTGl4RW5XTnpaSVd0WWZDRHA1VHBhbTVFVkJVUlRjZHR0cE5qYzJtTThYZUI5b2pLVnBHa0x3ZU9mNTBqZSt4Tzk5NDNmd3B5VFp1ODZnT3ByZ0E1V0pycmRhQ2lKd09hQVFWTmJ5eWZGbGZpSTd6am1Sa1NnTlVyQ1l6WUFiSkttbW5rN1lHQ1NjTzdYQmIzMzJPL3pHdFdlWlRFcnFnd1Y1SzBPVWEwV1JhVklkNmJ4U1JxRnNLV2lOZXdLcVpSZ0N1NWRtOWM5KzVkTDRkME1JODlkbkRpbEZFQ0h1UFh6NHM3MGJ0d0lFd0srQWJEYzlqcklzMVlSYU5kYWpZbkxBT1lGdG4zTTNudDZodW5zRGsyVHhOOU9BTVE0RXVNWmlmYUR4NEp6SHVKdVRLOUZhUVFjZk1WV0phcjA1MmtEQlJ3RmRaNktrcHdpZWJ0SmhJenVHM1lmS1ZZdzIxaml4ZllMUjJocHBrc2FzSkFTRFFSK3ROVVhSSWM5eXp0NTJodE9uVGpHZHprQUlyRFdZcHNFNVM1YmtQSEh0Mnp6Mjh1ZTV2bk9OUkdwdTc5Nk94T044OUVwUFZXekxsSWp3Rlh5c1krWVl2bWozU09RR215cWhHQXdRSVRBYjc2Q1V3amFXeTVmM21ld3R5THhnc2pPbnFpMk5FQ3dhajVhQlRyQjRHWkFpSVUralYySmpMU0V1aVdMWmF3UkxVMTNmcjh6UHZ6QTF2eDFDV0xUQlViWjloeFZDK0xVaVpYZFIveWtCN2JjQzVILzNYTHRoT0NLakJzQjB1bWhTMjVpVkVZTDE4UW5uMjhWR3RiZWsrZXlMaERlZmdVNE9TdUpDWE5wNUgzREc0MFBzOEdVUUdOK1dVS3ZwbG8rTmU5VHlCVzhqWVlva2xtUWlSRHhUUjJZVWRMQmpnZk9XOVkyTmFGWXpIS0IxQkJ5bVdVYW5VOUR0OUVqVGxLSlRjUExFTmllMnQ1bTNrNnFtYWFpYkd1Y2QzZ2FldmZZZEhyLzJlWXJ0blBYNUZ2TWJZeElaU0ZWY2RybzJHS0tLaFVRaDQ4OWIyTTFPYVBoOWM0TWYwZXZjcTljUlFwRGxHYnM3KzR3UEtwNSsvanBmZi9JUzEyNk1PZGJOTUluRVdFdGpIRTBJTk5Zekx4MU40OGtTUXhNRXBYRjRIM3VvRUt1N2d5WGhaNi9VNFdNQnBzQ01teE1yRjU4cmdkMUZIZTdZNlBIaTN2eFdnUHpiT0FmemFrWGFYdlhZd1RsdnRWWk9TNFYxaGlyT2VuRStvQ1ZJSjVoOFo0Zlp1S0gzam5QSU5FSGtHaS9BQzBtUVVXa2ovbU8rOWZPT1hQYW9EOVhDS0p4dlpYc0NabUZRbVVaMUVwU0UzQmI0YVU0MU5namgyTmpjWlB2RVNRYURHQndDeVBLTVR0RWh5L05EQ01tWjB5ZnBGQjNLc3FLcWFxcTZ3clY0cHVEZ3d0WHY4dlh4NTJGUVU5aVUzbnFYNEN4Rm9kcHBYUXdRRXdKQ3hiR2FFcEpNeGVsYkNKSCt1NGZqVSthQTJUVGw0WFRBWWxxeHQxUHk0c3U3dlBqcVBvdktFS1JrYmhxcXNtbDdyRUFxNHNPZ01aNmxpVDg2b0RraWhwZG9OWEZTL3N2OXh2MVdJTXlPWkk0VmxNUWZUZnYvTm9MalZvQzB4N2xXWmZCbzN5NlZUVFIyQlFxeElTNzVqUGRjMjZ1NXNsZFMxNDdpNHBTVHk0cXRkNTFIaEE0aTE2MU5zV2dOTUZjcWlGSGtUQXVCcVF4dTJSQmtuSXpaSnVCRVFMY3FiMExDd1BVeEwzZ1cxMmFrV2NiV3NXTWNXL2x4cVBpeDZTU2gzK3VUSkVsY0F1WTU2K3NqbXNiZzNaSXN6eWlyS2daR2lKT3pGM2FmNVk4bWY4QmN6ZWwzYy9DQytYNkc5d1dkYm9KQ3RMNkFBby9BQlFGQnhCNnR2Yit4UjRqbDRKNDEvUGJ5RXM4dWN6WnZORng3ZFkvOS9TWFRneEpiTmJpcUFXdElsY0MxSTNNdkJBNUhVSUk4VVJTSkJ1RndiWStuRXoydGd2ekZDK1A2STZYMSsyMXdMSThFUjNoOVRmeHY2OXdLRUdBK1d5SmVtMEg4bFd2ajZYcVdqVmVoNDBMZ1lHRjQ0ZktDOGRKeWFpdm5qa3pRRTRIbHhYMzJIZzkwM25ZSCtuZ2Y2NkkwU1hBaGNocGE4WmxnZlZ6MXR0bUVGaUZjZXhmMWNSTkptbWQweXc3MmxjRDB4cHk4VTdCMTdEakhqeCtuMCswaVpmVHk2QlFGYVpxU3BuRTdQaGoyT1gzcUpNNTZsbVVaRjVpbHAyNGRua1NRZlBmNlUzeHQvSG1XYW9GM0VxOEYzVjVHWjVCU3ppRkxKSm1VcmJHblFJbUlQZlBCNDRWb1RXcEVWRW9SWUYyZ25odXVYVjd5NVFzdlVsK2VzTjU0Umw2alRGUk9kTmJoRzR2emdTU1JkRlBkM3Vwb1k1QW1zVkgzM3VGQ0NGTElxa0orL01XZDVjZm10UnNUUlZzT2R4MnZ6eHkzQXVUZndhbnFaclZjaTBSL0NOLzZ6cXZUZTA2ZDM5R3RVUE5rWWZuV0MxT21pNFlQdm5tVFJ4N2FvS2t0TzVmbk5GY2R5eGR1c0ZON2l2ZmRUVDdNY2RZZndrZGlyeEZYOHNaNXZQVTRKYkhHUldYQ3RubFBsYWF6WDdCNHNhU3BETDErbiszdEU2eHRyRWZHWDlRS3BjaHp1dDF1eStWSVdWc2JjdHVaTTdnUWtjTkNDT2J6T1VvcnROSTAxdkxTK0x0OFkvcUgxSEtKOHBMV3FJbWdvTGRXSUJpUUoxRWUxTGRHT2xJSWdtL2g1dTFPUW9sQVFGSWJ4L2lnNXVyTFUvWmVuVEhmbWJLL1ArYWxnd3E1aEM2YVZFQWhBNFdNMzJPbUZZbU9vMTJKaU5BU0tWQVNyQmRCQmhpWDdzSjNENWEvT3EzdHdaSGdxTnUrSS95N0RJNWJBZEtlOTczbklXNzgraGVwSTM0bkFQNWd2S2pYMWtkVnZad3hYVlI4NTZVSk81T2F1MDhXYlBZU2pnMFZKODUyV042WDhhbmZxcGxkcnVERkhmYWJRUEd1TytodWRoRXVnUFVZNndpMVF6YnhTV3ljdjJrN0VDR3M1RG9qdjU0eHZ4eFYzWHVEQWRzblRyQzVzVVdhUmNhZmxKSmV2MGVTcEhTS0FtTXN4NDl2Y2R1Wk01akdZaHBEVlpYTVc0OE9pTnBaTCt3L3pUY21mMGdsU2tLSS9tU0prbEhLTTBDbm01RVZvd2pyQ0FMVnZndk9SbWxRNStKK3hyZjFqYkdXR3pjcWRsNmFjSEJsU2oydEtHZEw3S3pCTHp5bWd0bzNvQ0ROSVVrZ1NRUUxZZWhKNkNTS3JrZ0lTUlRnRTk0VG5CQ0wybk4xMXJ3OHErMGVONVdObXUvVmM5d0trSCtINTczdmVvQ2YveGVmQ1MybzE0ZUFuODhXdFZCcURESTgvY0pZWEx4ZWNudzk1ZFJtZ1hXZTZaN2x0anNLM3ZSUUZ5V084WnNmdDd4eWFZNTYrUWJWc21iNTBDbUc1emFpamJLTnV4Q3pyQW1wSmtoSmFDSkFVaXRKYm5MVUs1TEZmb2xVa3ZYTlRiYTNUekljRGtuU0pDNEtwYVRUN2NTc2thVE1Gd3UydGpZNGMrbzA1YkxDT2tkVDEzRzVKZ1ZOM2VCS3o0Njd3amNtWDZTaEpCSFJFVmJKMkZPMGZ4U2xCVVdheElGZGl6dXpOa1N6ekRhQWZldUt1Nnc5KzlkS2RsNGFNOTlkVWkxcTZubEpOUytwWnhiWGFxcEhROUM0aERWRWRQTlllMHB0MFJwMElra3pCVk9MdnI1RU5wNUpoT1UraHhRTGZLaSszOEZ4SzBEYWMrWGFBWFZ0Z3BReXhFRTh6dnRncHJQbGl4ZGVIZTg4K2NMa1dKWUt6cC9vME0wMFBzQ3lkSHpycTNPT2J4L243VytWcEJvKzhpc1h1ZkRTZ214M3l2NWpKZFh1Z28wSFQwYTByZ3VFVklNWEJPdHdQa0l0dWxXQnVDUllUa3JTUEdOelk1UGoyeWZvOWZ0b3JSQkNrTGFjOGl6THlkS2NwbWs0ZVhLYnUrKzZpLzM5QTRSY29XQWo0MUZKaFphYWIxOStuQmQ0QnFzcXRJZys3aXYvek5WUU80cFFCR1FpSXhTbTlTMlVnUFVjUXZTZGgrWENjdjNLa3ZIVkdmVzB4anFQTlphNnJLam1OZTVJRVNTT2VDMG9FZTNmZEl0Qzl1MG9yTnFycWErVjZOcVJBazZJdVJOYzlENlVSM3FPb3dpZWYrZEgzUW9QK05SbnZ0bCtxR0xsYnF1QWJIZC9NZCtkTFk1TjU4M2RaN1lLY1c2N0sxSVZtL2FOWVVxNU1IalI0WTY3dHptOTdUbTJsZkhzaFNVSEU0c09nZDJMTStabFEyZXJFejFGR2srd0xtck5Ha2ltQ1Z3R016ZDB1aDIyVDV6ZytQWTJ2WDZFaWdnRW5XNlhMTThwaWdLbEZQUGxuUHZ2djVmNzdyMkhjbGtqcEVSSmlmTytkWlgxQkFMUGpwL2ttZkxyTkpSSW9WcVA5TkNpZkZlQkVzZFN4bnFranNMYlNzVEZvR3d2dHc5UTFwN3hmczN1eFRtekcwdHNhVEMxcFZuV1ZMTUZpOG1TWnVianZ2V0lTV2dJTVl2b0ZOSk1rdVFKV2lkb0tYRXp6L0phaFcvOHplMlRrcThHclQ1Uk9YK1IxN0lEL2ZmcmJ0d0trUGFzRFF1czg2SUZrR29nMzkxZk5Eb0pEK2FKZk9UZXN3UFJ6YlZJcFVBRTZHU0tmai9GR3dOQk1senJjY2U1bFB2djZWS2F3TzYrNGVFSCtyejN3WVFmdmpQaCtRdExaZzNSU3ExUkZBY0Y0Vm9nbUhDSXFUcDJiRFdwaXBrakx3cVNSR090b2FwcWhJQTN2L2xObkRsOW10a3NMZ0RqRU1CaHJVV0syS0RRMmU0QUFJQUFTVVJCVlBnL2NmM0xmRzNuTVJhMlFzallqYS9ReEpMb3Zudm9YeE1DVmVOSkUwR3ZvMXRUejV1QnMxaGE5cStYVEs0dEthYzF6YUxHbEFaYkd1clprdVZrVHJPdytBckNpbGJUVWdLa2hpU0xMNTFLa2pSQnE0UnF4MUx2TmpGRnJjQU1BRkk4VVFsKzAvZ3diZ09rT1pKQnZpL25Wb25WbnBNbmhqejk3TFZWNit3QUk2V3dSWmFGRThPRVVTOFZBdEFpYnNHTjlhMGtxR1AvMmc2WHN3M3VmWGlUTnorcWVlTEZKZWtvNWIvNkw4NGlPNUwvNlo5ZTR1c2ZmNVd6ZHc3b25ObkdqQlZtWVJCS01oeU4yRDV4Z3RGb2pTelBrQzBDVit1RU5JMGU0UFA1bkxXMU5UNzR3ZmVSWnprN08vc29wVnFjVnF2eUdBUlZYZkgxeTEvbVd3ZGZ4bG1EYkJ4QlNZS0wzNUNRNFBIUmRRckFSN0pXczJpZ2t5SkZMS1VBcXNZeG54bG1lelhWdU1Fc0RhNjIyTVpSbHczTnZLU2FMV2dXRmx1Qk4zRFV4a3FxbURsMEFqSlY2Q3hGQ1VWNXJhYmNyMWs5aVlodmRrQmdkT0NaeXZvRFZxcUlyVWFaL0Q2bWtGc0IwcDdwckNKUEZWWGpmQ3lIc1NGZzc3bmorUFhqWGU5c1kvVE51aDJhT25MTnh4UExzVTNGZUdlUFo1K29HWnhaNXpjL2U4Q2piK254cmFjTUY1NWI4c1hQVHppL21hS3FISDhsYWZrWENhTzFkYlpQYk5QdkQwaDBFdnVOTktYYjZlS2NRMG5GZUhMQTJ0cUlEMzdnZmZTN2ZmYjJ4d2dCZFZXUnB0bmg0bTczWUpldlhQMGkzNTArU2ZBdVdnbGtDdWQ5M1A1cmdXcGh5d0VaOXpBQkd1T29Ta1B3MFVyT2VhaHF4M3phc0J3M21Ga3NwMnh0Y2JVRjY2Sll4S0trWERUVWkwQ29YM3VEaFlpMkREb0hsVXQwcWxGZVVWNnZxU2ZtME1qbWNHUVlLZnhYYmZCLzVPUGt5dEt5QXdPd0NkeTRWV0o5L3dQaytMR2VXQ3lOQ0VGSUlZUUdrdHRPcllsVFc5MTNtcXBlRTFLc1BHdHdMdEF0Rk5hQnRZSDE5UVJ2R3VaN0MzcVo0T1VYRjN6N2lRWFhMaTdKdE1BbG0xaTlpUXVTTE0vWTJqckdpUk1uNkErR0pHMjIwRWxDbm1ka2VXekV4K01EYnIvOUhPOTczNCtRWlRrSCsrTkRGTzRLTFN5RllGSE9lZXpsei9Ma3dSUFl5bUJ0M0dXMGpVZHJCU2hhRjl3V2RPaGk1cWtyUjdWWG9ZTWpIMlhNRjViWjFGQk9MV1poY1kzREdSOUxxOHJFdm1OZVVpOUxUT053VmZRcHVSa2RJQkpRV1ZRZ1VWcWlha0YxdmNITzdkR2dPQVJVQlZnSStJaUYzd3V2QlNQNnJDMnY2bHNaNVB0L25JdURUaUdDRHlGWXdIMzNoYjFYN2o4My9HcWFxYlBHdEQyS2pGdnkrZHd5NktmczdsdTJwd21kZ2Flc0RJL2UxZVBCczExODhGd2ZTejc3YmNsNE4vSTZ1dDJDWThlMzJkamNwRk4wVUZxanRVWW5DVm9waG9NaDArbU04V1RNdmZmZXpidmY5VTdLc3VGZ01uNU5TZVY5M0ZJdldmQ1ZxMS9rK2VxN0VUbThqSmRRZUE5U29YVkVCQnNMUGtpRURNZ1FyWmE5amYvV3FQWXNuOXBuY3FxSHJYenNLUnBIc0I1alBOYTQ2R1hvQTdheDBTck4rTmh6aE9pUkdGcGROcUhqeTY5U3d4S2FzY0diY09oMTRtKyt3akJWWVpqcHoxNWJOQjg3TXIyeWdKZFNSRlZFOTMzcjBXOEZ5TkVqcFl6dzBDTTdzV3M3czhYdTFIeHhzOXY1WUhNdzIxQXlYZ1lwb2F3ZGcwN2NqRis1WmxpM2d2L3AxeTl4YWl2anZ0czY5SG9qSG44KzVmcUJJMDFWNjk1MG5OSGFHbGtXK3cwbFpmUS9UeE9Lb21CM2J3OWpHdDcxem5md3dBUDNjK1BHRG90bEdjR09JU29RbXJZaFg5b2xuN3Y0dTd3d2VZYkZ3bEhPRytweGliZU9ZcXRIVW1pOEM4Z1FDTTRkYW5hcGxxeGxqU2MwamtiRHlmMmF2UzlmUTkyMWp2TXRLdGw1dlBINHh0RXNHa3h0TWNiaFFwU0w5cTdsNTdmTmhKQ3g5d0RvRlNsWkEvWEVSQlJCR3h5V1ErYzRPaEx4NkNpdEJtdWRQL3JrQ3djSE1sRDdFQXd0alAzNElBdDNIdXZ5eEhON3R3TGtCK0dFRU9VNHJYV0hBZUtkTTgrL012bE83NjcrZDlORXZjc2JGMlJBQ0NHd0xyQ3NISW1XWE4rcE9iN1pZM3N0NWROZm0vREVpd21ibXhLaEE1MU96dHJhQnNlT0g2ZmY3MGVDazR3U1BrSUtpcUpEbHFYczdjV0w4Tjczdm9kNzdyNkhxMWV1c3JkM2dERU5hWnFobEl4QzBqcmwydklxZjdUN1JWNnNuNmVlTk94ZDJPWGcrb1RGL3BMZTlwRGl4Q0NXTTlaajI0V2dGQjRyNC9ZODJJQnRITTU2Rk5EVmdzNlRlK3p1VmRSM0RQRkZHc2xkYlNubVcwU3lXS20wdERiTnZybVpQVkNRRnBLTmZvL2JoMXZzWFp0d3llMGVsbFJIRnhvYkNkeWVDVTRXZXZaSzVWNDJMaGhCT0JTZEpnUi9iVktGZDkrMXptUGZ4enR4cXdjNWN1YUxtcUpJc2RZSmdaQ3RySFF5V3pUK2p0UEQ5U0xsTGRZNnZYSjZJclR3ZHkyWkxnMnBscVJGd2JWNWo0M05MWFNTME92MzJONCt5ZkUyT0hTU0hOb05kRG9kZXIwK1pibGtQQjZ6dHJiR0I5Ny9QdTY0L1J4WHIxNWpkMitmTkkxTnZkWWFLU1JhSjF6Y3U4UW52L3NKbnIveU5OTVhEN2o2ekRVbTE4WVFvRHZzc0huM01ZcTFRekc4bTR2QlFCVFM5aUdXVDlZeE1uRFBnZUhWQ3pzbzV6bmxJRnlaWVpZR2F4MEdhRXBETURhcXQ5UUcwMFN2ZGxjRmZOMW0xQlNHNnhsM2JHNXkxL0FFZlZVUUJPek01NWdXeTdXS28yMEZkeFd3bFNuV1J2M0xGMHYzNjFlbTFRNndGRkJMS2V6SlVSR21wZVhwSzdQdjY1MjRsVUZlZDM3OGcyL21jNDg5RmNhVGhTZGdnSG8rTDh2OXVmdkc2SGg2VVVoeko5NjNxdXhSbExxdUxDRUV2djZDNDRZWk1CcEdCNmwrZjhEVzhlT3NyYTJSNXpsU0taU0lRbTVGbmxOMENwWmx5V1F5NGZiYnovR2pIL3dBYTZNUnU3djdHR1BwZGpwQWxPNXBtZ2JyUEM5OTl6djgraS8vUEZmM1hrR1VEcmRvME1IVDZ5ZUVzMnNVV3dOMHFxTUJTZXVETHRvTnV4RUNIV0l2WUgxZzFBVHV1RjR5ZjJXUDZiSmliQVJuTi91Y2JBelpxeE9tMXJDYmFKb2lwYzRWaGtEVEdLcGxRN1B3dURLS2VSZER5Y1phbDFQNUJrUFZJVmM1V2lzMlIwUDYrd2ZNOXcvd2JWbDFYTUFaQlprZzVGa3Frank1TU4rdkRrZTdJV2FQTU1oMXVQd0RjQjl1QmNqclRwcEsxdGQ2akNjTEx5S0owQUwyOFc5ZWV2bnNqOS8xakZEcURtT2N0QzZRU2tnRnpDckJqYnJMdGJMQUJVR1d4Ukh1OGVQSEdRd0dwR2tXamU1YjdyWFNVVFI2Zi8rQXBxa1BnMlBRNzNQeDBoWHF1c1lhRytWQzI5RlFrdVY4NWJPZjRiZCs0V2VaWDcrR2JxVkxrM1pZSmZaclJIbURjSFdDTzdkT2Zkc2FjcEFqTTAxd0FTMERTc1RBRUFGTzFvRmpWNWZNcjAxWUdzT3dTRmtHZzBYUTdXYVVlSHpwU1d2RCtySmgzOEtlQ293WE5WWGw4Q1plK0dKTjB1OFVuRXpXa1pXblNwdDJqeU1wc296and5RlhKMU15N3pnbFlCMGlrbGdLTWVnVjVjVHhsZWQzNXBQVmFKZm9GaDJldVRyN2diZ1B0MHFzMTUyWFhyN0M5UnV6UTBtbTlqM0s2dHB3NXVUYW9GZUl0MVMxeVFTSVZBcW1UY2FMc3g3N2RZNlVtbTZ2eTdGang5c1I3b0FrVFpGU0lvVkVTWVZTR3VjOWk4V2NOTkc4N1MyUDh1NTN2Wk0wVGJsOCtTclQ2WXpnbzJtTTk3RW9LY3VTTC96T0ovbnRYL3dGbHJzM1NGUWNFbWdkTDV2V2tLWlFKSUcrdGZTbUM0b2JFK1N5aWFXUWlsbkxlOUNsNVo2RGhoT1haeHhjbjBhZmNTbFJDRElsVUVJeUd2VFFVaUtrUXFuNHltV2dhQXpkeGlFYThFNGdXcDkzTlFzYzd3MlJTckZZTEtJN3JvaWFXa29wcHVNSjI5YXlMa0FweUJJb1VrMnZsMSs4YnZtMTUzWVhGOXZSYmkwRUpwTWlETFNpOU9GV2dQeWduRGU5NmMxeGcxd3RrUkhFdXZKTlQ0UWdCWElYZ2poM3N2K290L2FZbG9KSmxmUEtyRXZsRTlJc1lUUWFjZUxrS1RZM055bUtBcTMwb1RxSmxBb3BKY1lhNnJvaVNSSisrSWQvaUxlLy9XMkVFTGgyN1FiajhhUlZWNG5RRUdNYVp2TTV2L1BSai9BSHYvb1J6R3hNb2tESk5qQVVKRHFLTzJjcDVDbGtxYVRRa242QS9yd20yMXZTbXplSTBxSnM0UDY1STdzNDVmS05NVktyQ0V6MGtDZWFQRW5KbEVKS2daZUNSZFhRT0U5akxkUGxFbU1jdlVMVDE3Q2VTZnBDSUpvQWpTTVlTNy9maTVkS1NicWRiclN1RnBETjUraXFndmJyVGxQb0Z4bEZyL2phbDIvTVB6RmVtakZRQ2tHTkVONzY0QXNsZnlBQzVDOThpZld1ZC84SUJ3Zjd2UHZkNytPVG4vdzR1N3NoMnFHSHcreWhRa0FLSVpKWExvMzNwdmR0Zmx1TC9KN0xrMFJQeWhTUHBOc3RXRnRmWjMxamszNnZUNXFtaUphWkYwTEFPWWNRRGlFRVRkT3dzYkhPZTMva1BaeS80dzZxcW1iL1lNeDhOc2M2UnlvVHlxcWsxK3V4UDUveHFZOStoSy8vM2lmQjFLUTZaZzRsNGtWVGJSYkpFbEJTa0dsSm9qV0pWRkVWUkFseXBlaVVEYWtUaklKaU9hKzVPRmtpbFVTdW5wQWhTdXhvclZIZTB4aUh6aE9rVG1pcWhyS3FTWkRSVkpSb09wcklRS0ZobEN2bVpXQlJMNWpzM1NEdmpYRE8weGhEcjlzbENacitvTWZ1Wkl5VVVjbzAwU29NdW5udGxQcjJsWEUxWGcyNVFvaDAvaVRYN0ZmMkIrSisvSVVQa0MvKzRSZDQwOE52NXFNZi9SZWlhUnFjRHlzelQwM3JOZ1VVSVlRa1NmUCtxN3RGa01pd0tBVmFTL3E5THB0Ylc2eXZiOFNzb2VPVUNxSlEzR3Avc1hxZFBuMmFELzNvQnpoeFlwdkplTXJCZUJ6OXlQTU1CS1JwUnBybFhIcmxGVDczc1YvbXFjYytpMnJKUjBvZXlSNjZWUnZTa0dpSmxwSkVhVktsVUZKRjUxNHBZcFpRa3MxZVJsMDFYSm1VcEltSzRoTEdFUkpCWXl6R1F6ZUxEckpKcWdsZTBDOHloUGRJSDVndGx2UVNqWE9CaGJGb3JjanpoTEt4ZEhJNGU3eEhKMHU1dW1od1h0TTBEUXVpL0tsSVV3UUNMUUo1SnVoa3FSaXVkeTkvK3VyczY0MzFxL1dJRTBLRXpub1JUank2ellWUHZYZ3JRTDdmWjIxdGplUEh0N2x4NDdvNE9EakFleStKY0hlOUNnd2hSQytFVUp3N2Qvczl3OEh3Sit0R3Z6OEVuK1JGeW1Bd1lHUHJHS1BSaURUTFVES1dKeUdBc3lZcUprcDVDT0M3KzY2N2VPK1B2SWRlcjh2ZTNnR3oyWnltTVhFTUt4U2RvZ3RDOHN5VFQvTHhuLzJuWEwvd0pGTDR3MEpZdHNHUktFaVVJRThqNFNwUkNpMFZxVklFQkZtaW9tZWlEK3d2REVKS1R2UURyK3pOYVV5ME5oTktZYTJOWktiZ1djc1RWS3VUR3h2NXVMWG9Gem5kTEdXOVUyQTlUS3VHeHNUZnEycEhraWFjM3U3VHlUUEt5ckNXMWh3czlqR01TTk1FNnh4SlhwQW1ta3daa2tReDZHUTBwL3Z1MWZHeVBySWk4WUJYbVdvRnJMa1ZJTitQOC9ERGovRHFxeTh6bVV6dzNuUGx5bVV4bTgwRUlFTUlSN05HQitnTUJvUFIyZHZPZlRqUnlVOFR1QXVCN25SNnJHOXNzTEd4UWJmYkkwbVQ2R0dCUkNxSk1lWndNKzljdkpCdmZjdWovTkRiM2thZUYrenM3TEMzUHlaSkl1ZkRXUnZIc0NGdzhjVVgrZFMvL0hsMlhuZ1NyY1BoWnEwVlpFUzFmVWVlQ0ZJZGd5TlJpa1NxeUxOb2pUU3V6QnB1TEEzanh2SEFWcCtyQjNObTg1SWlUZUttSE05b09HQ3QzNldwRzB5SVkyRmpBazFqMGUzL1ZFcElwU0RQY3E0dkdpb1hTSktjRytNNW5Vd3dHT1FFQjR2YVJRa2pBbDFsS2VjN1RLb2wrWEF0cWowV0NTbU9icGFUanpxOHNwYmwrU2p2OFJxWVkyQnhmUkY0aUZzQjh2MDQ1OC9mU2FmVFFTbUY5NTdwZExvS2pKVjVad3JrUUFFVXg0NGRQM1gyek5tZkN0Ny8rODc1a1U0MHZWNmZ6YzFOUm10cmREcGRsTllvcFZyMm4yd0ppZEhXelRsTHY5Zm5iVzkvSzI5NjZDR2tsT3p1N3JKL01NWjdoN1d4cEhJdWF2WSs4NjJ2ODN1LzlQUHN2UG84S3ZVRXp4RjFjOUFDTWcxWklraTBKRTBTMGpaQUpJSzU4Y3lzWlc5aFdCaFBnNlJJY2daNVFXVWFUR1dwNW9hc2s5QWJkTmpvRlF4N1BjckVVVllMSEk2NmNSSEU2Qnl0MWpaMmFjaXpsRUpLbEJUNExLVXBVb0p3ekJjMUxrZzYvUWkvdDg1aG5ZK3FqTTJFK2JVRlRkRW54WkNsbXExK2grVW81NXJ4WksxUXhzM3dpS3Iyei8zT0M3Y0M1Ti9sK1ptZitRKzRjZU02bHk5ZjVzYU42eUtTajRRTUlheklVZnBJMXNnSC9jSGFxZE9uMzk3cmRQODk3OXc3dlE5NW51ZGh1TFltTmpjM0dReUhoMDVOV1pZaEVCSEhGWHhrK1ltWUZVNmVPTUg3UC9BK1RteHYwelNHMld6T2VES0ZBSWxPUVVEZE5BVGdHMTk4akUvK3kvK0Z4ZDdWcUVmYmJyK2xYTUZFMnRJcWlVWXllWktRNnJnTkdWZVdTVzJabUlCWEdxOHlHbXVaTHcwOURjZjZQWnFxSVR1V3NHd2MxbHM2aVFidkNWV0ZxU3pMcXNIaFNGcWpvRVhkVUZ2SHNyYlVwYUZJVTI0L3RzWm8xRC9VemIwMkhpTlU1Sy9nbzVwSzNza0pDSFFRT0Y4UmxqVjJVWkozQklPaVIzZTk0SnM0bkF1WkxwTGUwYzlKRUwvUEg2VHo1enBBM3YydTkvRDhoZWZvZEFxRUVGeStmRW5NNTNQaG5CVWhzT28xVWlBWFFuUkNDUG1KRXlmUG50dysrZE1oaEI5MzFoOFhVb1RCY01EbTFwWllXMXVqNkhRaTdFTkswalJ5eFUxaktPdUswREw4NnFybXpKblQvTmlQL1NoYlcxdk01M01ta3lueitSSm5IYzQ3Y0pFRmFJemxzZC85Skk5OTRwZXBGL3NvRlRGaGNzWEtXd1dIaERScCt3dVZVRG5ZcXhybUpsQUZ3ZElHREFwckJIWGRZS3FHVk1EcGZrR1JLTHdSalBLQ1ZEdXlJbUd0M3lGSkZONFlaS2JZbjFzcTN5Q3lES1VqVE4wMWhqelJkSklVRlR6enNxTEkrbFJhTTBjeDZ2WndPa3FxYXFrSUlucWtKSGxDTUlIRjBvSng5RHFDWVNmbDJLakxwU1N3WXp4cmtrN1NUZFk1UW84UElQd1B3R2ozTDBTQXZQbk5qM0JpK3dUWHJsM2xsMy81WHdtdEU2YlRxUXpCaTdiWE9HekVnWTdTdW5QWCtic2U3blY3LzdGejlvZTlEMG1XNTJFNEhJbXRyVTBHZzJFRURPcTR6OGp6bk9GZ1NGbVdWSFgwT3ZjK0dzSzg2ZUdIZU90YkhtVmpmWjJ5TEJsUHBzeG44ME5IcHhBQ1VtcHUzTGpPNDcvL08zenREMzRIVTgyajdtMkl5b3BxRlNDQWJwdHpoK0NnRGxUV01HOENCNVduRHBBa21ya05HR3NwdkNjWE1SVjIwNFF6YXgycTJxS0VJc3NWd1VUcGxtVmpLRUxBV2xqV0JpVWsyK3ZycUFDTnNYUmtTcTZUeUkxdmhhdUY5MHlXUzlLaW9KT0FWd2xGb3FKTkFoemFaTS9uRGJPOUVsc1plamtVdVdhcjN5TVpabnlucVhCYTBUNEQ5TkVBRWExMzRVM1UxcTBBK1RNLy8rQWYvQ05lZU9FRit2MCszMzNtR2VienVaaE5wNjBFTmFvTmpxTzlScjY1dFhYeXhQRVRIOGl6N0tlc01lZUZFS0xmNzhlc3NiNUI1MGpXa0VKUzVBVnJhMnNzRmd0bXMybmtPVGhIbnVlOC8zM3Y1WUVIN3NON3ozZzhZYkZZVWxVMTg5bWNxcTd4M3RQcmo5QjJ6S1VuUDhIamYvQTdCRlBqV28yc3BBMEsxZjRZaEtBT2dya1IxRjVTQjZnY3pKckEzSUltTURVR0NmU0FUbXQyS1FPY1dlOXdZdGhsT2lreDF0SXAraFNwcG1xaWJaeFFraHBCYlN5NWxJVFNNbk54UXBVbW1tRy9nM1VSNFJ3RTBlVXF3R3l4b0hHZU5ORjBpcFRFV1JaVmd4ZUMyYVJpOS9vY2pLT1RRU2VYRERzNVcrc2R2bWxyOXEwajB4b0VVaVV5UFJJZ1NDbEZwakpoTU9GV2dQeGJPdi9ELy9EZjhiZisxay94KzcvL2FZeHB4R1F5RWY2bVVzblJDVlZXZERxRDg3ZmY4WTVFSjM5VEtmMURUV09LTEVzWmp0YlozTmhrTUJxUzV4bEs2Y00rbzl2ck1SZ01tRTJuek9hemR2dGUwKy8zZU45N2Y0UUhIN3dmWXd4bFdURWVUMm1hQmdLVVZRVkFyejlpdm4rWk0rTHptTWxUTE9zR1lXSjlrYVdnVmV1VklTVU5DaXMxSmdnV3hyTzBubGx0cUcyVUE4MmtJRVdnQ2ZHYkVuSENKWWprcUR0UHJLT2xaRkZWTEJxTHloSThVRllOdlU3R1RJRkdNTktTcFV0WWxEVk9lTklzUVJMd1RhdFVqU0JSa2tWdG1TMld6T3NhcVJTemVjblY2MU9LSWtXbml2R2tZbnl3Qk90Sk5IUXlRU2ROMkI1MDJWV2VyeDhzRUVWRzhEN2dnMG9MM2VHbWZaR0Fsdmw0cThUNnN6MXZmL3NQOC9MTEw3Szd1OHV4WThmNTVqZS9LZmIyZG9YM2ZpWGpzNXBReGVBUUl0L2EzTnErN2N4dGYwVUorZE5OMDV4MHVORHI5VVFjMzI3UjdYVkpWdEIwb2hWenQ5c2xUVklPRGc2b3FqTEN4a1Bndm52djRTMXZmWlJUSjA5UTF6V3oyWno1Zk5rNngzcE0wekFhclFId3pTOCt4czZyZjhDWkQvVDUwbE1UYk8zcGFFVXYwMmdWTThiTVEya0ZYaXJLeWxNYVMyVWNqYld2QVlpbEFaSVFEcWNNc3MwZVFrQS9VUXhUeFdKUmtXdk5vRnVnRTgxa0ViUEpLN3NMUnYwdXFkS3hYMUdLZmlmRmlqaUpValpnakVVbGlrUkU3L1Rsc29JQXZUUkRLc20xeVp6OS9STEVBbHJwSWRIcVlCVVo5QXZOMXFDTDdpWDgvczQrbFpSMFYvcGRMaEJXVHFjZ2ZsRHYxcCtMQVBuS1Y3N01iYmVkUlNuRjd1Nk91SEhqdXZUZXkrODFvZXAwdW9QYmI3L2pIWjI4K0VudjNGdU1ONzBrVGNOd09CUWJtMXNNaDBQeVZvTnE5VFJMVy90a1l4cktaUmx4VXRaQ2dFY2ZlWmozdlB0ZFpIbEdYVGZNWmd2bTh5V05hZG9sWUNETEM1SWs1WXUvODNFZSs0MWZZbXNEUHUzV2NSUExtZlUrYU1uU2VuWkx3N3h4TkNhYTduaDREZWFsNENZYlR3R0pqNU1HSmVKL2h4QUJpUUNOY0h6MnFVdjBNOFh4ZnNGeExWbkxFN1JXakZKTjFtZ3VIWlRNcW9ZN052dkkxdVlnVjVMS082UVFqTG9GUXNZU3JMYU90QldldHM0elh6VE01MUdLS0xJTDIvRzJpSml3WHFFWWRBdU9yWFg1d3NHTWk4dWEvakRpczFyNnJtOUtVL0Y5MUx6NmN4MGc3M3puTzluYjIrUENoUXNNQmtObXM2bHd6b2tRZ2d3M3QrR0h2WVlRb25QbTlKbXpHeHViZjFNci9kZWF1dDVRU29taTAyVmpjME5zYm03UjZhNnlSbHhkSzZYb2Rqcm9KS0ZjTGx2cnNvQjFsclgxTmQ3K3RyZHl6OTEzeDNKak5tYzJXN0JZTE9JbTNUZ0lrT2NkbkxWOCtqYyt3aDk4L0pjSTFqQmVLSjUrWmNIY09nNHF3N0p4VkkzRGlRQlNJaE9KN2lXa0lhQk1lL0Y4SUxFZTZVSUxEbXUzNjhUbG9TUUd4NnBDS1d0UFdWVWNMT0hWY1VsNjVZQ3RYa2FSS2paN0hhYVY0Y0wxTWJVTGFLVzRmYTJncVJ0c2lJTFczU3dsQ05CQjRxeW5MaHYyNWlYVGVVVlZSejkxYjhPaDhTaHRCa3MxZEhKQlA5T01pcFRIeHpNZTM1dVNkUFZyeHJsQ29MSk8wdVVJWURZT0wyUzRGU0QvaG1kclk0djE5WFVta3dtQUdJOFBWbnVObzl2d3d5YThLSXIrL2ZjOThNT3BUdjUrMHpTUEdHTlVuaGNNaGtQV056Y1lEVWV0WGJKcXZRTUZXc1dTQ2lHWXoyZHh1aUlFcHFtNTdiWXpmUENESDJCcmM1UEpkSXF4bHVXaVpENWZSR0tUdFhFL0loVlhYbjJKTDN6OEYvbk8xNy9JdktxWVZwNkRDbWF1WlNNV0NmbXhndUZhVHJaUmtLM2xpRTZLS2xKQ2JXbkdGYzVCcUF4dXY4VHNMTENUSmRuY3h2UW80NjZFOW5JS0dkMTBwYURWMDRtT1RjNTdMaDlFbTRjTDEyZUhKaHROZ0svZm1QTFN2R0lqVlNRaDBGV0NqVUVleVdERzBqU1daVlhUTk5FQnlyZXRpUThjTGhOWE5uWGRGQWFaWXF1YmMwTjZ2clkzeDh1b0I3enlZQWt4S3dxZDZhemxjOTNLSUg4V0owMHpmdTduZm9GLzhsLytRNzc4K0plRmRYYjFFRjJWVkFtUUNTSHlFRUpIS1pYZGMvZTk5NHlHbzcvc25QdFFYZGVuaFpSaE9CeUt0ZlYxMXRjM2IwNm9WRFNUcEhXWkZVSzJMTDRvNStsY2hJL2NjKzg5dk8rOTcySFFIN0IvY01EQmVCS2RhbjNBV3RPaWR6MWxWWFAxNVF0ODgvYyt3bzJYbjJhOWx5S2xaVkhWZ0dTd1hiQjIvd1pyOTIwd3VLMkw2bVU0SWJGQlVEY0JYM3RzNWFqbmxtYmVVTTFxYktHcE1xaVNHbVV0dW9UY1Flb2hiOFVUVlB1RUR1S0kyb2lJMGo4dURzcG9WaThpalEvcktlY1Y0d0NiQWlvdHFKbzYyc1laRzZkcC90Q3htcGE1ZXppTVhTMHhPeG4wQzhsV1ArZGFMdmxpdVdTWkNWSjArNENKRmdveXVtd0ZVN3M2Qk1JUDhwMTdRd1RJai8vNFgrTDY5ZXRjdVBBQ1AvZHoveHRwbG9tZDNSMFJRaEFoQkJWQ1NJNU9xRUlJK2ZiMmliVjc3cjduUTk3NWYzKzVXTndESkZtV2gvNXdLRFkzNGpZOHk3SjJ6aTl2NW40ZkNFUU5hOVA2RFZwcldGOWY0NGQvNk8yY1AzOEhJTmpkMjJkbmR4ZnZBbHJydVBtV0Nwd1BhWkx5N0xlL0xKNzgzSzlUNzErbGt4ZlV0VUVGU1dlN3h3TnZQOG5HVzQrVEhpc0lXbUY5b0tvQ3R2YlJDOTNIWnNMN3FFZ2lHNGVZMWJCb2NNc0szNWlvS3hXaVBxY01rUGtXSCtNakpFVnk4eWx2UTd6UW9SWEJYVkgzMG5ZMFhJaUlEbFlPK2tLZ2RaUVh5clNrYk9MZnN5dExoRGFEK0hCejgzMHpPQVREZnM2bFFjNVhuYUhPTXpwWndOY0cyWXBrSHpwQitpQklpTkwxdHpMSW4vNDg5TkJEL083dmZwTDN2LytEVk5XQ3h4Ly9vckRXQ3VmY1VVaDYzcjZ5ZnIvZlAzUDZ0anVQSDkvK0tXZmRqeTNtODRGU21tNnZ4OXI2dWxoYlg2ZmI5aHBDQ0pSVUxkdk8zeFIzSmtyOXUxYTkvTVQyY1Q3ODR4L2k1SWtUSEJ5TVdTNlgwU0RIdVFnVk53WXBWWlR5RWJMNTFtT2ZkazkrOWxjN3dTNEFpYmVPYkMzbitOdTJPUFdPWTZUYlhSb0hWZU9wYTBkbGFCWGdpZnBWTG1wVzJjcmhTMHRvTE5LSEtKelFOSkZ2M3RJbGdnQ25ZQm1nZFBHU3ArM2xkOXkwSmZWRVg4SHNTTE4vOU5VRVFTb0NvbFU5OGExUGlKY1NhNklLNHlvd2pvSW5Fd1Y1QnNOYzBsL3Y4dUphajFlVVFKSFFhWFcwN0NxcUVLK0YvNjgyakVlbVdMZkd2UDhIajFLSzdlMXRubnJxU2VHY0U5WmEyWlpWUjhHRkhRVFpndzg4ZE9mVzV0YVBXMk0vTUovTzduVE95VTZ2eDJnNFpHMTlrLzRna3Bsa1N5V05TaUdDeHJRMlpXMG1FVUxnbktQYjdYRC8vZmZ4OEp2ZVJML2ZaMy8vZ0xJc3FldUdnRUNwaEdvNlJ3akJjTFRHWWpHLzhmblBmLzZ6di9lcnZ6QmZWL1dIUnAzc3RxSlFZdmoyNCtpM2JXS1BGUmdmYUV6QWVIQkJSR1ZHRjNBdUJvbHBQSzUyQk9QeGxjWE1HOHlzcHA1WG1Qa3lSdENxZ1ZCdHpzemI1bndCdG9xL3ZUeHk2OFNSSlpBODhzRW5SNXI4bFZlSUQyQ2JhQkZYMlJBMytDS0tVNndDUThpYmJNYXVobDZ1NkI3cjgvS0pFVmRTUlZLN1ZvdXI1Y1BVOGpYZHVWUVNLVVR3WGdRaFJRaXRGcWtRQXUvOVRhdmhXd0h5SjUrLzkzZCtobWVlZVpwWExyNGlsc3NsZFYwZkhkMG1SUHhVRVVJb2VyMSs3eDN2ZU9mN2k3ejRxZjNkdlRkVmRaVnFyUm10cjdHMnRzNXdPS1FvNGpSS0N0RWljQ1ZLcVFoTlgwbHpCZzlDWW94bE5CcnlveDk4UCtmdlBFOWQxVXdtVStxNnh2bW83T0djWjdrczBVa1N0TkxpNnRYTEwzM3Fkei81U3gvOWxWOSt3aGlqTjd2SnhidHVWMy9qM2crZGVqaDl4N1pjQ0JBdVlOdUh2L01CYjJKZ0JCOXdUYUJaMVVKTndDMHNmbUdnY2ZqYTRxb0d1Nnl4MHlZMkRqSStIa1FCTWhmb1JFSlgwT3c2d3ZLbTlpMUU5ZWNnQldIbHV0dmVWZDJPWldNR2plb1VkZnNsdUdqTWlHa0NpUlpJTFFndUNqOGtLV1FLaWtUUVhlOVNuUnh4ZWF2SE5OVjBmTUJsRG1jZHRySjRZOXZJdXlsL3VzS1ZxRVNzN2w4NE9zbTZsVUgraEhQbm5YZXh0N2ZIaWUxdFhuN2xKZkg4Qzg4em44K1BjalZXTzQzRHZjYjU4M2VldlBlZSsvNldiY3pmMk52ZDNiVEcwdTEwdzNCdFRheXRyZEhycjdLR0pORkpxM3RidDBEQkprSXUyc2tWUVdDdDVkaXhMVDcwb3gvZytQSHR1QlFzNnhaRHhlR1V5amxQcDlQQk8rOWZlUEhDTTcvNmE3Lzh2MzdtTTcvL2JKdlZrdEZEYTR0Ny8vN2R5ZkRzUUpRZW5GbXh6YU9wWjNEUjRpdzRrRDdhRUdBQ3B2YTRPaW9lc3VwSG5NZlZCdHUwS29XQnd6cEs1UUtkYWJSV1pHbENuVG9XMXlyQ3d0K2NBK2VTa0NqY3dxSk1PSlQrZEcwZkl4MUlKYWhkVzE0UnM1bHEreHRDYTMydDQ2U3NTS0hUVDZuT2JYTDF0blhtZVlvWE1aVUw1d21OeE5RU2IwTTdWanVTUUloSUFhR1VNOFl0Z2orVW5mdUI3RVIrb0FKa2JXMmR5V1RNOHhlZUYwUjhrM3dkZm1wVlFtZW5UNS9aUG4zcTlBK05obXQvWlRhZHZhMWNMdk1zeTFqYldHZHRiVjBNUnlPeUxJK1pRbXZTSkNWTkUrcTZvV21hdHRZVkxkY2lFcHVTSk9YUnR6ekMyOTc2Vm9RUUhCd2MwRFFHWXlMcnp4aURzeDRoRkVtaXFjcHE4c3gzdi9PNWYvN1AvOWxIdi9YRXR5NGlTQWo0ZTk1NS9QVDcvcFA3L2s3M1JQZitzdkZDU1VHbVlxWXdQcjdwemdlc0VDUWlFdUIxaUJUZHhucUVjZEh0eVFkY2JhSkxiR1B4dHIxTDdaWkhacEFraWl4TjBXblU5dFZKYkV3V04wcEM3U01NdUJOdEZPaEt4TnlnV2wrT1ZhQUVZc2F3b1YwNDBrSnIyeDVqeFVmSlVoajFOY2xHaCtXRHA1aHVENmlKZFZuV1pramhQRUZHSjF3cUVkMmsydklwdEg3d1BpQ0VFaUhVd1J6NUVnZ2hoQ3pMd213MnV4VWdSMCtTSkJoamVPYVpwNFZ6Rm12dGlzUjBGRDlWQUVXMzIrMzkwQSsvNHkxNVd2ek5wcTUvYUQ2YmpwejNETmRHakVackRFZWpkblNiSEtKdWU3MHVCQmhQSnRSTmhXekYyMlNiT1pyR01CajBlTmM3MzhGOTk5MUhWVlhNWm5PVVVvZGI4K0JodVN3cGlrNFFRb2k5dmQxcm4vLzg1LzdGUC8vRlgvamt3Y0hCUWdpaFFnamgvRnMyejN6d1A3bnY3M1ZQZGgrcGJSQko2MGlsbGNBU2JaVnRTNUFTclZGTjBnYU1jcEMwZ1JGY3pCN0JPRnh0Y1kySkdVWEVkMFNuQXAycjFnbzZSYlNiY0tVazNVR09jNEZ5MG9EUzhRVUVMZkJDRVl4enVqS045aUh6SUwySUtOeFNRRmZHWmw0Qm1ZUlV4WkpLWnBLa2x5SlBqTmc3ZjR6eVpCOFZQRWtBNFFWYWdBOGU1Nk5CajVEaVVBdnM2QWtodEo3cm9US2wzVDhTSUI0SUsyZmd2OUFCOGgvK1IvOEIrL3NIdlBmZGovRGYvNzkvanV2WHJ5T0VFSXZGWVRuMXh6YmhRTGE5ZmVMWWd3Kys2YS9uYWZxVFpWbmRWcGJMa0tZWkc2T1JHSTNXNlBhNlpLMmlTSkttRFBvRHBKUTBUYzFpc2JpWk9WYTdqamF4bnp0N0cyOTcrMXZaM05oZ01wbFNWZFZoWGI1Y0xOdkNDQUtFNVhMcExsMjY5STNISHZ2Y1J6NzZLNy84NWJxdXk5YTZMUXcyOHY2UC9aL3YvZXZidHcvZVVUZE9KSWtVZUU4VElyWUtBb2tTV0N0Uk1tQ0RJN2pvek9TYmdHMUJyRUtJUStpSWF4eW1ickF0QWhjWlRUZXpQQ0ZKVm5DWUVKZURPb3BoeTBReUdIWVJNcU9zM2MzaVJRaHNUMVBDYnBpVVh5bDZveDhxNityWWVEeEd0Q1BqUkVMZU51dWxnbTVIa3F4bHlLMEI2c3c2MDBHQjZhV29FRURKYU1iakF0SUhoSmF4dDJvRFJFcHhPR3NPN2ZjVlpWY2hDTEZzU25Od05EaHVsVmp0ZWZLSnAzbm80UWY0Yi8vNy80M0paQ0tjYzVFd2N6TXdrcHZ6R2ZMQllEQTRkKzcyQjArZE9QWHZXZXQrOUdEL29LTzBabTE5WFF5SEkvcjlQbmxldEZ3TlJWN2s5TG85NnFabVBwNWhXdGJlU3Rsd05hWEtpb0pISDMyRWh4OStDTk1ZRGc3R2JVQ1o2TDNSVHJXc2N4aGpHZStQbStlZS8rN3YvZlluUC9GelgvM3FWMTV1MXdraGhLQjFLdk8vK1E4ZS9DdTNQN0QrRXo0RUZhVEFBM1dRN1lJdFVOcUFkVkZvUWZ2NGhEYkJzelFlMTNpRTh4U3BwSzZndEI1Zlc3eHhtRG9PQlNDcXA2ZTVKczBTbElyY2xCVzdTcmhBOEJhWnBoUzlES0VEN3FERXRJNjZLN05QNmYxTFJpWGYyYjduN2g4TyszdmNtTTJnaWVYYlR0dFRod3lTVWNMZzVJais5cEI4VUpBT01uUlhJM1RFdHFTWndnVVEzb0VTU0JrUTltYmpIMXpNaEQ3RTV2NW0veUVSc0pqZFdPNi9Qa0Qrd21lUU5FMDVkdndZenozM25KZ3ZGcFJsS1kvZ3B4SWdiYWRUZVo3bjNYUG43amkvZlh6N3g0czgveXZ6K2Z3WUNOWHQ5eGtPQnd3R1E0cE9oelJKby9wZm5rZjE5RFJsUEQ1Z1BwL2pXN2VsK0FDTlAzb2YyTnpZNEozdmZBZTNuenZIYkRhTFhJMFFNSFZEVlZVc0ZzdW9jWlZsR0ZOeTdlcVZuVC82bzhjLzl0dS8vWWxmdm5UNTBvMTJDZTFYNytHUC9wMDdIN3I3N2NkK3NuWmgyRmlQZFZBUmhaNVNKU2hyejZ5SkhiQjFsbVVWa0o3NDVQVWdiVURXRHVNZHRuYUVaWVBaWDBUcmFPY2grS2lGcFZYclJoVTFnRUpybnlDbFJMWjJ0RW9wWkpxZ3ZVTkxzTVFuT2tLZ3BGaFMyVzlMb2VpdnJmV3NNK3htQ2I0TmtCVjhST1NDWktNZ0czWEp1amxKcXFLRlcyd2sydkswWFJZbUV1SGpvbE1FVUVSbGxCQkNhL2Jqa0RvR2NsUndrWUNZejY3TlZ5V1dGMEswbkt1L2dGT3NEMzNveHpnWUgvRDAwMC9qck9YYjMzNUM3T3pjRU1hWTE1UlRRb2ljcUVHVmJtOXZiOTUvL3dNL0xwRi8wemwvOTN3K2wybWEwdXYzR1F5R2RIdTlRMEZvclRTajBZaTEwWWltYWRqZDM2TmNMdU1UdHdVZXRqTjJ0Rlk4K09BRFBQTG1oK2tVM1lpbGFneDEwN0MvdDQ4UThoQXoxRmdiZHZmMjJObTU4ZTNISC8vaXYvaVh2L1NMZndETWhCQjFDTUd0c3QxZGoyd2NlL2pIVHYya1RlU1pSZTJwS29jTUFwRkpsSXg3RGx4c1pFM3JxNUhaZ0hTQzJrUWJBaHRDdk1pdERsVm9PMk5oUFZnWEZSQzFJazJqV21OUUVxbFVXL2ZINzB0TGpTZ1VXaVVSQmhJQ0F0OW1UVW1JRy9aTDFPNUMwdXVmbDBJb0pTV3ExY202T1JlR1VBZE1aYkcxd1JwSFVrUk9qSGR4d3krOHdIQnpOeElnOWxmR0kzMDdOcTROenJxVzZORmFWYmRFTFE4elc3c28reVB3U3FsZ3JRMS9vVXFzZSsrN2o4bDR6S2MvL1h1ODVhMXZBeERHR0s1Y3VTejU0ekk3UlFnaDcvZjcvZnZ1dmY4dC9YNy9yeEY0ZDFYWFE2MDF3OUZhR0E2SG90UHRVT1J4cDZHVXBOUHBzTGEyVHBabFRDZFR4cE9vR0hKemRCc3hFZDRIK3IwZTczNzNPN252dm51Wnp5SlBQQWd3N2RpMjF4dkVHajV5RzBKVDErN1paNS81L08vOHptLy9yNDkvK1V2UENGZ2lSTlc2VHlrQldWcW83TDEvNjQ0UGJaenB2WHRaZTZGRUlFOGtTU0x3TGRHcGJsV2ZaUHZLaGNCSWdUR3g3M0EyWGl4alBNckhmaUs0MEVxV1JqU2Zrb0pVcXlpUTBBYUlrQUl0TkJCSDFTaUpTdVA2ejFVT2F3STZUWEhlNFFKQlFxT2MrM281cjY2dW54NytxTkphNnlRSlVzalh3ajBFVUVNenJsaDJGeVJGZ3RCUmYxWG1VZk0wU0lsdFBLcXlpRlRobElpREJSZmF2c2xpVjVNM1FWd09SbzJ3b0hQdGhlS3FxMjJFdTRlYkpWWUxRUDN6SHlDRHdaQi8rRS8rTWYrdi84ZC9neENDN3p6MXBMRFdIbTNDVjV2d0FzaVZWcDJISG56VG5jZTNqdjgxYTkyUG1ibzVJWlVTL1VFLzlQdDkwUjhNUktmVGpmS1lLazV2dXQwZXcrRUlwU1RUeVlUSmRISzRCaFB0Q05lM2RlM1c1aWJ2ZmU5N09IM3FGTlBwak9XeWJQV3I0bE14MVFsb2dYVXVTQ0ZGV1ZVSDMvNzJ0ejc1ci83VnYvakZaNzc3ekt0QUZhQWtPaUJKUk9RcVBmcStVN2MvK1BaamYxMHIwVUdMSUVHa21jWUVPQ2lqWXFGekFlc0N4a0ZqSTZURXVyaVEwenJTWG9PUFQzeG5QZDQ0WEdrUVRVQWpvbmU1MWxGL1M2c1lIRnJGd0EreFFTWVI3YS9GaGFDMThkK1NRaUZWd0ZvblpPQmxNeW4veVB2Z09zUEJ3QWN2cXVVaWptTEZrUTFpTzNqeUM4OWliOUY2bWlnSWdzUUhaQjUxUW9NUUpDNGduWTlJZ01waUt4Y05QeHNIeHFGQ1FDaUZiR203UWdoVW9hdkoxZmxUM29YeWRkUG1QLzlOK3MvOHZiL1A4eGVlNTQvKzZISCs3Ly80djhKN0o0UVFvcXFxRlVUazZIUnFoWjhhL2ZBUHZlTkhlcjMrZnpDZnplNjExcXBPcnhkNnZSNzlmbDhVbmM0aFJDVDZidlJaWDk5QVNVbFYxU3lYRFkxcDBGcmpuTU03RjRQRGV6cmRMdmZkZXc4UFBIQWZXWmF6dDdlUDg1Nm1hZUlGYXJGWUlRUzg5eXlYUzcrM3UvdjBZNDk5L2w5OTlGYys4cG05L2IyeEVHSVpRaWpidmdNZ0paQ2t1Y3JmODVkdisvSGhNTHVqYkZ5UVNnZ1pGRWlGdHk3V0R1Mm4zMFpxMjczR21zUzdnS2tkMW5oRUVDZ0V0ckxVa3lyK3VLd3hpeks2MzJaUk1FS3M4TzB5TmdDdU1kaTZKaTB5ZEtJSlBnSUtuZk9INkZzUmxkYkhZVmIrcTJaYXZhano5SGpXNjQ2OGM4STBWUWl1blhUSjF3WUlEdHpNc0VobmJXUGVscWsrOWgxSkluRlMwTXhNKzM2dlBBd2RwbW93amNFSFNMT0V2TWphMFRwQ3Azbyt1N1o0bVdpMTV0b2V4Syt0clhGd2NQRG5NMERlLzRFUDhPWEhIeWRKNHRaYWF5Mm0wNGxvc1RXdjBicHRtL0JNS2RWOTRJRUg3ejUxOHZSUEpFbnlsMmZUMmFaVWlvM05JYjFlVHhSRmh6d3YwSW1LVExXOFlEUmFwOVBKOGM0emJadndMTXRaTGoxTjNVUU1neFJZNHhtTmh2ekllOTdGSGVmdllMRlljbkF3amppcXNQSVdoNEJGQ0JIU0pCR05NZFhMTDczNCtmL2ZQLy81bi8zUzQxOTZWZ2l4Qkk0R1J5QWF4U1lob043NTRUUDMzUFBtalI4aitDUklBVmJRVFJRbXhQTEtCMEZ0bzNKSThBTG5WU3o1UWpna05obmpDVDdFVWFrRFd6bk1vc0ZVQmxNM05NYkdxVmVpRVRxV1ZVckpRNG9yV3NjU3JCV3VzemFXVnNIRkMrdENDRUxpdFBlZnFTYmxOME1JZGRvdE9ubXZPN1Ntd1pwR3ZHWnlKRjhMNGdvRzZsbU55aGZvRldnckJIU1dZQm9JaVlvTnZ2ZklWQk44d0Z2ZlRyRGlRd2NoMjcvbWd5NHk0WHk0MFN6TmpaZ3pnMVZTK1U2bkUzNzZwMzg2L00vLzgvLzg1eTlBN3JycmJvNGRQNFpTbWsvODFtK0lka3k2d2s2cDF3RUxDeWxsZnNmdDU4K2RQMy9uaDVNay9WRm43Zm1tYVpKZXZ4KzYzYTdvZHJ0a2VSN1pmU0xXcnAxdWg0MzFEZElzWjdHWXh5WmNDSW84SjJLMXFrTTZuWkNDKys2L2owY2ZmVE5yb3lINysyT3Fxc2JaNkF6cm5DTk5VeGJMa3JxcFE1N2xUQ2JqSzA4OTllVEhQdm9ySC9uNGswOSsreEpRaFJBV3NSby9uRmkxbTMyU3JORDlkLy9Wc3gvV3VUemxRd2dDSVpSVTVEckIxTkhlek5vUW5XU3RPQVFqRWlTU0FDS1FKUkFLamZSUmFNN1UvdEFUTUZpSENJRTBUZW5rR1VGRVp4blZMZ09WVmxnbmNGcWl1amxTcThoL056NzJOUzR1LzlxRjVKTitVdjY2TTI0R2hPN2FvQytsekUxVlllcUtRd25IbzhIQlRTaHdLQVAxZElsdXA0RytCU0pLTFNQL3hIdE1hUkZSb3oyT200M0RtemdaaTFZT0pnSkVpOFEzUzNOeHVWZnVJSENFU0ZOWlpmOC9OeVhXUC94SC94aXROZi9ULy9qL1pYdjdCSys4L0lxUVVyQzN0N2ZhYWVqdlVVN2x4NDRkVzN2NDRVZmVzNzYyOFhlV2k4Vzl6cmtzU2ROUWRBbzZuWTRvaXNqZjFsb2poQ0JKb2tqMGFEakUrOEI0ZkVDU0pIUTZIY3FxWkRLZDBEUW1RaGxDSU05ekhuM2tZZDcydHJmZ25PZnk1YXN0ZzAxRTNvWVExSFhOWWxuU05FMVFTdnRyMTY0KzhmSGYvTmcvL2RTbmZ2Y2J5K1Z5MW9KaFY1YkVLenR2Y1NRTEptZk9EN2FQbmU0K0lxUk1SSWhxaEM3QTNBUnFMN0JlRUcxcDRpV0x3ZWxSN1MyVWJlT3FwY2RuS2o1eDZ5aktFRXpzUXlTeHJ3Z2l4QXdpQlI2UFVMR2VUL0lFNFR3aTBRamtZYVB2ak1lMmRGaEN1TzRYOWIrcXhzdVhWemxpZUdKNHJPajNzL2w0SEt3eklxeE1ETDlYZ0xUTVJMdHdsTWt5dnMvZWcwdkpzb1RHK1ppOWxNQTNGdHVDSzVzeVl0WkVLd2tucFVRb0tWU20zV0svK25JOXJTdUJNSUZndmZlK0xNc2Z1Qkh2djFHQS9QZi8zWC9MZi8zZi9EL3BkcnM4OWRTVG9peVhvbW1hMWJKdmxUVldXL0EwVGRQKy9mYy9lTy90NTI3LzYxbWEvZGl5WEk2a1VxSFQ3VkowQ2xIa0JWbVdvNU9vSmFaMTVGZDB1MTN5cktBeGh1bGtnbFF5Q3FVdElrZmNPUmVGbzRWZ1kyUEUyOS8yRnU2OTUyNW04d1c3TzN2VVZVM1ROSFI3MFRYSldZZHBERFpDV3BhdnZ2RDhGejcyNjcvMjg0Lzk0UmVlSVM2VEYwZUN3eDVwSVBYUk12SERQMzNuV3dkcjJSMVNTQVJndmFCMjBXMkhPRnpGaGRoYlNCOWlxRGpBT1VqVW9WS0JsSUlrRlFTbmNKbWlUaVZLZ0dsOUVJV01HQ1pQaUVoa3FRNUxMWjFwY0tFVlRZaVRNTy9hN0JIM0VCYm4vckRhbVgwbEJHb0FvU2g2eDN2SEVTRTFUUzFzWFJLOCsrUDl4MUg1Rk9JN1llYVdTaTZqbjRpSXFkUTFFcWtqZ3N2WjZLbnV5b2FtclBET3RZRWROLzR5bG9iWDYxbnpZdkJoeGR0eVFPaTBmb3h2NkFCNTRJRUhHSS9IWkZuVWl2cVZYL21vMk52Ym8xMzBIWjFPWlNCeUNMbFVxdlBvSTQvZWUrZjV1ejRrbFhxdk1lYU9zcXBrWG5SQ1VSUWl6M095TENYUktiTGxoQjhHUnA2VHBpbnorWXpGWW9HVUVSdFZWZU5EV1BSS0F2U2VlKzdpVFc5NmtQVzFFZFBablAzOU1RZVRTV3Q3cHFpcW1ycXFhSm9tTk1hRTNkMmRsMTk0NGZuZitNUnYvZVludi92ZFp5NjNqZml5TGFtYVZmUFlQdGFPOWxIcHZROXZidDc1NFBxUDVFVXlNTWJqZ2lCNGhRaiswSXRjQm5GWXVialFUcHVVUUdwSkVCRTY3b1JBSlFyaHdDbFBraW1LUVU1ZHBOU3pFcVdqV255V1pZY1hXQ2NxS3BDc2xvTUVYT1BiVVhIQVdvOWQ3U3FFdU9LbjVTZHM0eWFyV2NId1pIZGpkTHh6dHR3ZjYrVjhpbW1hN3kyOHM4cVhra09GK1dBQ1ptbGkyU3NrNFRCN3FFT2NsYmV4UWJlTmlTUHFkcGdBaEtSSVJETnZ2cnIzd3Y2Rk5qaU1FTUszci9DelAvdXpiOXdBRVVMd25lOThoL1BuenhOQzRNYU42K0xGRjE4UTN2dlZQa090bG4waGhBNkU3T3paczhmZi92WjMvS1ZCZi9CWGxGTG5sOHRsSXFVS3c5RklaRmxHbnVXSCs0elYzcUxYNnpJY2p1S3lUc0JpTVdleFhKSmxHYzY1UXhqSUtrQzAxano2eUp0NTI5c2V4VG5IalJ0N2xHVkZWVlp4U2FXanExTmQxd2doT1RqWXQ5OTk1cG12ZlBYcmYvUnpuLzNzWjc0SnpJVVFaUnNjVGZ1aE9hV1VIdzNYbUMvbVZGVVpleWtoRWtKSTczdkxzZHU2YStsOVZXMFJTRHdDS1FKYUNtcm5xUTBZNTJPSjFJWlhBSVFTaENDZ2RzaEVvWldrc2c2Q1J5bUJUaFJwSnlGZjYxQWVMQWpXa2VRSm5WNkdDNTVBVkRsRXRQVFpGVjdMeGdCeE5tQ014MXNmaEpSR0dQdkphbS81ekpFeVVXK2ZYMXZ2YjZUcnkwbkpjanFtcWNyWE51ZnlqNWRYaDhIalc4eVlhcWhqSFUyYXBVZ2RTN1RnUE01NW5MSHRValpwVldJaUdWMG1lbEV2N0xlcmcycTJ5dEJDQ0Erd3M3UHp4czRnSVFRMk56ZVp6K2RpYjI5UGVPK0Y5LzRvZGlvSDhoQkNYaFJGLzVGSDNuTC92ZmZjOHpOU0p1K3F5bVhIaDRCT0VvYWRya2pTQ0QyUEhuNnFKZEFJdXIwZTYrdnJLS21ZTDJZc0Zrc0VnanlOSEk2NnFRL2Y5Q1JKV0J1TmVQQ2grN250dGpPVVpjbitmcHhTU1JFelVhSVN2QTlVVlkzV09sUlZkZTNwcDUvNm5WLzd0Vi81MklzdnZmaFNXMG90UXdqVjZnT1RVdnArZitEUDNuNG4xNis4R3BxbWxxMWlpaGFDVkNxWm5MeXovOWE4cjdmcnlnV2RDR0c5YnlFYWtYVzlHdTJhNEhFdFdFK0lDQ0VQSVdBUVpLSlZXVmp0UU5ycHI5U1N6cWhnMmN0cDVpVnBuaEJraU1HR1FNbG9heHYxcVFMT2VIeTdXNG0wM1JCblpNWTkxZXpOUCs2c1c3YWxvd1RVMnNuK3NiUW5Ock9SUU9VckdOU1JvRGo2bzMzZDZEZkVmdDVXSG1oYTgwOXdSaDdLc2p2VGtxUldja0NScW9sS0U0U1NsNWE3eXllUFpHa3JoUEQrQncyQTlhY3RzZmIyOW9TVVVuanYxWkV0K0FvN2xRR2RONy81a1R2UG5qMzNvZVBIVC95RVZ1ck1iRFlUU211S1ZjYlEraEFidFFLbnBVbENwOXRsT0JpZ2xhSnVHclJVYkt6SERYbTMxNlhYN2NTeXF5aklzcFRCb0UrdjI2VnBHc3F5NHVBZ051dGFLWUtNZXdDRXdEa1RoRUJjdlhMbHljOSs3dmQvOWpjKy9yRXYxWFU5V3dWSCsyRlpCRlpKNlpWVTRmeWQ1L2tmdnZiVjhNRlV0c0lRc2FjS1BpU256dzlIWis4ZVBDUUpza2dWallmU0Jtclg4cmlGSklRSUhRa3VaamtsQVM4T2pmaFFnaVplWnF5TFVKR29OQmd4VGtraVNiSUVYeldrYVd5QVYwTUkwY3E5Qng5d2JYZmtYYUNwWFpUbENVRklSRVZ0UGwxUHF5dEhwbkFKSUlwQk9rb3lPa2t2TURyZFl6WXBxS3Z5NXBwdU5hdVQzK01DeUJaVzRzSFhIa05GY0Q0dUV0dlB0S2tiZk5QRW5Zd1NlQkg5RTNXdWpUUCtLM3ZQNzcvVWZqMHhxd1Y4K0FIVy9mblhEWkRWWkVwNDcvV0t3TFNpdklZUTB2dnV1Ly9zbTkvOHlGL3VGTjMzSmtseWp6RTJqVk1pSlhRU3MwVm94NDVwbWtiMHJaSjB1MTFPYkcrenNiSEJjRGc0blBNUCtrT1NSSk1rQ1ZtZWtiWXlvQVF3MW1Dc1pkNDI0c1pZdkhPVVpZbTFqcUlvcU1veStJQXd4cFJQUGZudHh6L3ptVS8vd3VjZis0TW5nRklJc1doM0c2c3BsUi9rcVYvcjV0VG9VSlVWLzltcGRRcWRNTE5HUUpEdDdrUGY4K2FOMjdkUDl4NlNTSUdTV0JkNUVKNkFRR0phY0o3d0VjVWFXbVcxUk1ZbXZqVUlwYmFPWUVNcktSVFZUUEJ0MEZnZllSdmlKZ0k1aElCU0l2TG1WeEtqSVRia3hnYWF4cS9VRFlOdy9rdG1XdjErOEtGcXMwY0FraVJYMmVoWWNUcnBrSW5jMHp2UlpUZ2VzcmMwdUptOVdXcUYxMldTdGt4Y3lacXVOTGVzOFNETW9YNnZEMUhrSXZaYUtrb3B5ZGpFaTBSZm43dzYvWXdwemJSOXp5M2d2UWlCdlAwcTM0QUJjclI5YXgxZnc2SEdiUWdoSDYydHJiLzU0VWQrNU94dDUvNjZVdnBSMDVpc2FacVFaUm5IdHJiRTJscGs5bVZaUnA1bmpOWkdIRDkrbkkyTmRSS2RrT2M1ZVo2MkFncVNscjkvcUh6aGZjQlp4N3hwc0szV2JRaXhyM0RlazZRcHprWHJBV01NaThXeVJmRUdqR2xlZk9xcGIzLzBWMy8xbzU5KzZlVVhyNng2alJCQ2ZWZ0RnNWRTaENMVm5PZ2xJWkdDYjczd0xFdmpaQWdjMGZZVmFaTEo5Tkgzbm54UFZ1aTE0QWdtQ09IYkViSWlMcmlkNUtaY3FKU1VWVlFnVkFTOGo2V1JzWTZtOWl1SzBFcW5ObXI5K29DckxLNHlhSzFRN2NRcUJIOUlRb0oya1I1YTlaTjIyVWdReUJDdVV6WWZxNmZsNWZiYXJSanNZbkNzS0dTdXpnV0ZTQXNSMG40cSt0dER5a1hKL05LVVVJV2JRZks5YnNBS3lOajJQc0pGdm9yd0VlamxXZ0tZVEdOd3RIcGpRZVdKczAxNGZQZTd1MCszZ1ZISG5paDRoSWpLMjIvQUFCRkgyamI1dW5LcUFJb1AvOWlIejk5My93Ti9aMk5qODhOWm1nMlZGS0pwR200N2U1czRmLzRPTnJlMnlOSXNscThCZ29pWHliVnFMNElJWFZpV05jR1hKTW1xWjZqaWsvY0kyREMwVDhzVlE4MjJCalJwbXVKdDNLSTc1NE5PRXJGY0xPcUxyNzd5NVU5OStuZC83dkhILy9CSlkrd2NPTnFJcjhhTFBrQndQckF6TGRtWmxuTGxrUjRJb3RXRlRvU2dDQ0ZrSjgvMnQwNmRIendjRUxwMlBpeU5iek5JcTE3bzRtV3ZyY1BZK1BWSzBmSkNYQXY5YnFKUVZSb0VuZ0JleEFhNzVVNkV4bEdPSzJ4dDZmYlRsc2V5TWdNVmgyK0pYUUVjbTdoZmFmc1lMMFA0dXBrc3Y5MStuMjBqVEJvQ1l1djJ3U2pwNmhQT2UxUW1TWHNKdldQOTZIYnJITXU5QmI0S2g1SkNOMmZSTjRNbWNEUERlQitEMUFVZlI5RUJsSTVpR0tGZEFBa3RSZExKOWc1ZUd2K3VyZXdVUVUySTVWV0FvR3hMejMyRGxWaEhBME8xeTc1czVjTDB3QU1QYlAybi81Zi85QVAzM0hQdjN4Z01CZzlsYWFyU05NTmExL0l2SW1iS0dJczE4ZDBPTGxDM2VLbVZhbnFhSkZoam9tNlNBR3RkNjdIZHNMb1pVcTdVd0gwNzVuVjQ1OG55REswVFFpQUlwVWl5VEl4R2EySjNkK2Znd29YbmZ2T1hmdWtYLzhXRkZ5NWNPYkxiV0RYaWJqVjdQL3E5aGhBa0F1bkM0Ylo4TmRiTmFQWFZUdDdlUHpjY1pTZWREMVF1SEhIWTgrZzJFR2FOcFRTZXVtbUR4NEpySWovQ05BSGJlS1NMQ0YxUDFQRDFKc3JqK01yUkxLTE1qNHlzTzFac1FWU3IwZG1PWEkwTlZFMjdHSFF4MnlwNHhjL0tqMVdMNXFETkhNMVJDR0ozTGR0S2NyVldPVWNEaUZ5VERqeGQwOGVVRFFEVnZNUXRIYUU1c2dGcXBYNVdVN09WTWtsWThVZnNheCtuUW9DSU80K1E5bk5NWmY5Zy9OTEJrMEJEb0ZwaHNBNDNnOU0zVm9DSUk0Rnh0TmZvQ0NIeUQzemdBMmYvOC8vYmYvNzNUNTgrOCtOVldROU5ZME5WTm1JMnZZSktOSG1lMDVpb1JOaGlzbHBrclVDcUZtM2FYazNySFZYZHRJMnN4RFFXWTF1RXJYZXh2SElPWjEyUVV1SUpGRVVIcFpTUVFpSmtpRFY1YlpoTnA5T0xGMS85eHJlZitOYnZmZVNYZitsejEyOWMzeE1SbWw2dXBpWkhBaU84N2lHZ1c1NlBGdEV5UXg5WkRLWWgwQVU2YjNySGlZZDBJdGNiNDRJQWtTY0tJVHpPeE9iYkVaK2tzcFgzTjRZSU0vRUJWMGZGa3VEaXJzRGJWc0hSdGsySkIxdFp6TFRHTFp2b050V3k3NlNLVFRuRVNaWHpzVTh4amNNWVI0amJtanFVelNlWHU0dm4ycXZkM0J6U3hwRlpVdWdUTXBWYnpkTGhQQUlsWWpuVVNjalh1blRMcUlEWTZJcG1hZkQxVFhqbVlaUzFYNjZRYllsM05OSHJGdGJlNHNKVW5ncWgxSXZqbHc0KzNzeWE2WkdTendvcFFqN01LUGNyZnBDUC9oTktxdGRZbElVUWlydnV2SFB0cDM3NmI3L256UTgvOHBONTNuM3J6czVlSWhBaFNSSmhyU1hOTThxeXBOL3ZSMktNaS9ld2FjR0I3VEtGSkUwSUFjclN0Q0lEbWpSTlc5VjBGN09FZFJBRXhqUklxVllaeERkTkU2UlV2c2h6djFnc3pXdzJtMXk5ZXZuVjU1OS8vc2tYbm4vKzZhOSs3WSsrOWZRelQxOEg2alk0cXRlVlZPRjdQQUJXT0xFRVNFSTBiVktETEVuWHV1bXdTT1RJUVZIVnJudjJkUDlSSVNtUWdsd0lNaWxaR245b08rRGJYVVZ3VWRwSFFTUkMxWTVtWnFNZ25JM2FXTFJaVVlTQUVncmx3UzBzOWJqQ0dVZVNxd2phWFYxS0FZSFlyRnNiRytSWVdvWGdQR3pteVY1WTF0K2VPYitxZGc1RjE5dnNxRVdlREsxSE5aWlFtWmlmRWkxd2hjWjBVdEp1am5jdXd1NmRKL2hXWGFVVnFsdnAvY3JYOVNJcjVkYlZJbFRxQkpWcXNuNXU3TkorZXZ6aXdYUHQ1M0FUMXlZSStTZ1BiNVFBRVVlcVRSWHJicEhGaFIvWlQvMnR2M1hYWC8ycmYrUHZGVVhuTHhsamhrM1RpT0ZvUktjb1JGTTN6QmR6dE5MMGVqMlVqa0xGZFYxRmNvK0lXbE9KVGtLU2FoS2RpS3AxV3pMR2t1ZXIySW5jYmVjY3dYdmJHTk0walYyVTVXVHgvSFBQWDdwNjdlcmwyV3kyR0k4UEpzWTA0K1Y4c1hOamQvZlN6bzNyNDFkZWZYbHNyUzNiajdJQjZoRENhdWxudjhkR1BINlBrSWViU3AzRm5jZjdhN2R2ZEkrZldldThhUzFQN3Rqb3BDYzdpYm90SkVwVnRRdko1OGNuYmx3b1JYcGJCeTlndVpGU0ZZcGFSNWZOMHNQU2VieVVLTkVLMmRwQXNDSktpRTRxbXRwVHJXaXRQZ2FTVmhMcEJNMjRwSnBFQlhhVnhDVmpNQTdTdU5keFBzU0E4K0ZRVTh0N1JDOVY0YWZmY201TEcvZXUvL1VUMzN4dWYxSytYbGxVcDRYT2kxRzJhVnRlZkdqN0I5ckdQd2dSbFZHa2JPZlM3U1BGSGtHaXladEx6eFU4WHJUb2U5L2VucmhabDJTRERrbVd2TEQveXQ3blhPTm1SK0E3VGtnUk9odkZvYWZJR3lXRHJGWkNXZ2lSaEJBU3FhVDZMLy9SUC9uaHQ3NzFiZi9YTE04ZkxjdEtEUVlEUnFOUk96MXlsRlVWZEpJUWdrY0tTVjNWS0tXRTFwbzB6YUkxY0phanRCS2hmYTVOeGhPbmxHcnFwbWwyYmxUTDhXUjhZSXk5YXEyWnpXYXpaamFkVFBZUERzYlhybDE5NWZubm43LzJ5c3N2N2MzbTh3a0U0NzEzTGQxMXRlVnlnQk5DbUJESlRPYkk1dGdsU1JLeUxBdnorWnpXOWxtdUFKUUI4dTErdXZtT083YnV1bU9qOCtiMUluMjRTSk43MTNycENTbGw2a01RQ0NuSzJxQzFwSmxZN0w2RjU2b29oTkJSdUVSZ3VncXpsVkpuQWpuSUtaS0V2ZUNwdGNSNjBmWUpVRmVPZXRsUUcwOVRXN3oxcEZwSERWem5zV1ZEOEI2VktaU1M3Vmc4RXFaY2lLUXI1NlBnbkcvaEs4NEgzbnhtSk83ZkhxU0pWai94VSsrLzc4SS8vWTF2Zkx6Ti9pdUIwaVFmcEwxOGxKNDNrZlRYb29ZanNhcHVJb2JLR29kcEdxcHhoZGx6cnkxS2orS3k1YzBNRWt2bCtPdHBvcEJhbzdLRXJKY3Q2djN5RTd2UDdINjN6UngxL0p6d090Y0JSSmk4TW4xREJZaG9OOFpLS1NYZSt0YTNyZjJsdi9SWC92Sjk5OTcvSDlkMWZZOFBsVnRmV3d1ZGJsZWthUnFVMHFJMkZaMmlFRUdzY05XUzREMUprdmk2cnB1ZG5aMkZsTkpiWStxcXJxY0grL3MzeHBQeDdyVnIxL2FhcHRtcjYrcmc2dFdyKzYrKytzcitVOTk1Y3RkYVczRlRmTndlYWFocFNmMHJnbis3Y3d1SHo3Z1FnbHY5ZW91akNrbVNoTUZnZ0ZZNkxCYUxvelRmRE9qK3d4OTk2RDF2T3J2MWs2R3U3cytrT05OVUpqTzFvWjQyUVVpeFduNEY2WW5CN1h3VUszQVJHa0lkRUtWSEhqUWtsMHB5SlhIZGtnWkJFSUhwUnNaY1NHYWFDRUVKTVVqTW9zYVdjVGpobFVLMTJ6ZnZQQ3FKWUV5dEZDSVZyU0NEd0xzVytlRTkxc1JYWXoxM0hSL3gvcnRPWUkwaFQvWFdXKzdlL21zLy9NQ3BiMzc1TzVjdkhIbm9aZGtnRzZsT2VyNjIwV3BadFAyTXFUMjJzUkVtWWh6VnBLVFphZUx6L3VocGFjUEJIZTNjV2xuVEVFR1hLbEVrV1JxS1VWY29yWjY5K3V6ZTU0SVBpNk85UjRpWXJEQThPMlIrZmY2R0NSRFI3aDdFZTkvN1B2bDMvKzdmZTllSkU2ZitpeVJKSHlXRVlhL2ZjMXBwbHlTSjg4NkZ1cTRoMUJocnF1bDB1bmRqWjJjNkhoOVVUZE0wOC9sc3p4ajd5dTdPenFVYk42N1BFY0kxVmQzTTVyUDU5UnZYeHhjdnZicHcxcG5YQllFLzBqejcxd1dDYjB1a28zL09BMEVJNFVNSWh6OXZmd3hyYTJ1aDNUeUhjK2ZPOHJXdmZtMGxHNzZheUtWM0hSdHRQSHp1ek45ZTczZCtZalpka09vRTI4enhiaEVFUVNnaHdUaXNpYjJTYnl3WTMvNlBhUjFqSW1BdytIWTJiQU15ZURLbEdOUU9mWDFLM2hqU1JERFBOVHZPc0ZoVUdPZnd3VWNKMHNiZzVjMUZnNUN4S1VmRzBhNXNsVUJXT2wzZXRwdHNGOFVZSGp5N3diM25Ubkt3djAvZEdBYmQ5SUVQUEhydVI3NzhuY3RYMmtzcHRCUlpYaVFESTFVbTNLcEhpc1NtcHJLWWhjRldjZUpvWitaUDNrbUVJNDhzMFg1NkNZZzB5aEhwUkpNUE9pTHJaY3Y1NWRuSEZ6dkxpMGQ2RDl1aWNNSnliOG53M0pBM3d0RkhFVGo5ZmorODczM3Z2M2ZRSC96VnZkM2RNSjFPUHorYlRwdXFydnhpc2JoeDdkcTFuZmxpWnB4MUFZU3I2MnA4L2NiMTY1UEplRnpYdFhIT3VlVnlhY3V5TkVjdS9tc3U5WkczMmY4SnIzQWtLQUlRcEpTSHNqRHRyNi8ySWVISWl4QVBKMDZjb0NnS25udnVPZnJDazJrcEt1dVBpcHhuN3p4LzZ2NUVKRzlhTGh3MjZDQ0RFa0ducUtLbE1MUWpWcDE2aExPNFVKTUkxMjZSQXo0NG10SmlYSVB4SVhwd2VQQ3FKdVFwVmlvcVkrT09aKzdZU0RQNlBqQ3VMQWNxTU5kUWE0bVRnU0JEcXpvU1lyQzB6MzIxZ3M2THVJU0xmVWM0SEFwMFJ5bTJjQmhyMmRqYzRNYlZhNFRNRnljM3UrOS8yMzBudnZyVlo2NWVBdnhkdy96ZUJ4TDFINWtYcDZQNVZnY3ZKSTBOTkF1RG54dnNyS0daVjlUTEVsZTZmejEyZUxoWmZxMjQ1bGszRDhWYXg3dmFQYmIzN043bmd2TlYyM3NZaExBNlU3N1lLTUxzeW95clg3LzZoZ21RdzIrNTMrL3poY2UrY1BFWGZ1RVgvdXNiTjY0RmExM2l2VlBlZTBVSWpqaTdQdm9XSGVHZHhjdmJRcGZkaW5nV1RVM0QwY3dRam1TR2xSYlNZUWI0WHBmZSsraEtvWlVtTDNLa2lJdzZBSzEwMk5uZGVZM0U1WGc4Wmo2Zk01bE1xS2I3QkNFUitOVmdLZEZLNW1jMlJ2ZG5XcDh3MFZsR0NLVklpeHlkcDdqR1VsVU56dmtJa1JHeHBkZEpEQTZsTlNFNGZGVWhyRU5ZUXpBV0s5dGF2bHBnaGFCcUdoWlZUWkZsMk1hZ2xHUzd5TmtPTUtscXhrdkxUSGdXaFVJbG9GT05UeVJlU1lTU3VIWkw3ME9JZFBaRHZua2d5UlREelp4R1FOblU1RmxDcDlkbFdTNDROc3JmOVA1SGJ2dlFreS9zL0dyVldEZk1lR2hRTm04SmoxOUtKanB3WTlSSG5CcEduL1I1alNtYktJNWRtMFA4MkwvMjhURS9TS0VvQmgxQkVDOGZ2TGovTDh2OWNxOE5qaG93QW56U1MrbWZIakM3UE9PTmN2U1JpeDZ1WExrU3JseTVzbnRrL0huVFlWZ0lLZUlKUnk2MmoxckU0ZkRDcjBxZVZibHo5TWZWYnJaVjZneENpS08vRjBzS0lVTGROSzhQd244dHRQSHFYTHAwNmVZM21HWlJoN2xGNUFMcDJmWCs2T1JhL3lHRWxNWTJMVXpGb3JVaVZTa0dnNnNhSEpBcVJlTWNRVWhXekx1dzB0Wk5VcVR3SkNvQmFkQUV0SXBOdGZXZXFqRk1sMVdzMHhFME51NTJiSURjdzhoQ2JqemRwVU1ua3JWK3p0ZzBUSzJCazMzOGV0Rml1K0xFYXJYLzhDN1FYOWZrSFJVUnc5TFQxRFZGcDZCY3pFUFQyUFRPazhQM1BYajcxamUrOXV6VnF5NzQyNjh2eTI1V0M4U3N3ajI3aDkvc29XNGJSV3MyNzNFcmFkTS94VlpiSklMT1dwZXNXelROdFBxOThZc0gzMm1ESS9ZZWJXbGxGaWJ3Qmp2NmRVbHpoZVgwUnlaQnpWRnMxR3NDaFBhU0V5ODhyNUVlNDJnSlJGc3FrYVpwS0lvQzA1aERvV2xyYlpqUFp4QUNkOTkxRjMvNHBTOGRjbENPWG56ckxQUDUvN0hHN3NWcnV6am5aU0NvZGpxbkg3bHQrL2IxSW4ra3JtM3dQbUNkRmE2dFcrcW1SQ1ZwSE1NcTFZNUJpU2pkVmdXeGFScUNDTGdRWWVoS0NsU2VIcnBVYWEzSnBTUlBIY051RnlFRnBySFUxakNyRzJaVnc5SjdsbVdGYmVIdWRlM1lXeGdtMHlXcE5haEpTZmloTTFncENTMGcwYlM3ajd5bjZBeVNLS2p0SEtWMWRMRW9yY215VERSMUZRWkZkdmJkYnpyNTdtKzljUDFUalErOWVkV0l5N1ZuVWdlVUQ4aHJVOEwxQlVvSU1pbElBSVNuc3EwdEF2K2FXandLMHEyRS9sWS9pTUJUQnk4Y2ZNcVdFZHB6T05aRmVGVkVDdldWUDdyOGhnMFFYdGNMdko0ZEVGYWtwdGM5OVkrYW43ekdDTVc1MStacnBSUmxXVktXY1VUeWxyZStsZk8zMzg1SFB2ckxoOXYwNXk5YytKNVo0VTl6N2p0OW5POWV2bzRVUW9TQWxJSlVTcUUyOHZUKzZjRnNzeEdDd2FBbk1BSnJEUFY4aVZhS1hwNlJTQlUzL1ZWRGxpU0lFQjFwaFlRd2l6RDFQRW53M3FHRndIbkhZbG5GMmI1d0pGS2dFNDBQbnJ6SU1MVkJWVkVlZGRTemRLY3BCTUhWMlpMZ0RJbHpDR2NSeHJKMDRLNHY2VnlidzZsaDNKcTNaanRDQ3ZvYkdTcVJPT2VaTEd1dUhjdzVmbXdkWnkxSmxsSXRsOEphbTk1emV1MkhidDhlUGJPL1ArNHNaR0JuR1Jjd3VSUW9BZ0lYbmFXaUpuWTBYR2svZk5zR1NYM2tTUm0rQi94ZHJVbjZ4L3RrbmV4Z2RubjZhK05YSmk4Zmdia1lCQzdMMDZEekpNejM1N3hSTTBqNEhrTzkxNzRYVWpJYXJaRmxHWjJpUTExWGgvUllwVlM0OE1JRlZ2akNQK2x5ZSs4NWNlSUVnLzRBNXh4WHIxNWxPcG13V0N3Ty84ejB6OUFiUWdqUVVnblhPbFA1RU5UV2NOQTVlMnpqZkZsV01oME1naEJTaEhaU2hCQ29KSWxTb2EycVlkU0lpMUFTTFRYV05pcy9iNVJTZUdkcHZLZXFHK3JHa0tiNkVFNGpSSWhLalVLU2RYSlVua1V3WmxuUnp5MW5Ob1pNNW5PTU53UnJJd0xaQnVZdStuV0lTUTFiRG1kV1FuQXVCa2NtQ1M2S3pwWHpobWRmM09IQnpSRmdJejVOUkVtZ1VTL2R2di9jeHQyZnZyd3ZWM2lhTEdLSGNCNmtVb1FRcUowN3JMVlhFOXljbTRZc3BxMlZYak55RkNCNmtHMWtJZXZtd2RidWlmMFhEcjdaL2pPSHlBV0JDR3ZERWNQaGdPL3VQLytHQ3hENXVoTHJmK2NWdnNlSm5nN09SYUNpYzY3OStSL2ZrbHBydVhyMUtzOCs5eXdYWHJqQXM4OStsMjk4OHh2L1ZyNnh2Lzh6ZjRkTGV4T2M5OEpIcnhFTnFJMXV2bkg3OXVZRFdhY3JzeVFWODBXSk1aYXFiRUFwWktJUGJkbTBTdEE2aVV1NldJcGhqY1czaGp0MVZlRnM3Ri9LcXFJb1VuU2lzTTRSUXN2ek1CWmIxM1JHSS9wclF6eUIyWExKd2xvbVZVVmRWU2doOENJNlBMbHdjeWZueTNZRTJ6aWEycEhta21LZ295QURFVTJaWm9yTCszTVd5eG9oSWtSRTZ3UmpiRWlreU84N1BibzNhRFd3Ujl4dEsrK3BnU1JKeVpXS2phWTR3cm9WTi9VYVZtOWNwMzFsUjNhRm1SRDBSQ0xTTE4yZnZqcjl2V3BhVjBjZ1M0Y2Nvb1B4aEpkZXVTZ2s4TGYveGw5OVE1ZFlmL0t3d252MjkvZmZNTjlZbWhmVUxnZ2Z0K2VIc0l0N1QyNmR5bld5M1hTNklraHdqU2ZST3FLT0E5aXFKc2dvc214TmpkU2F0RlhsQ041aG5TV0VRSnBuU0NGWnpwZWtpYUpmRk9TZGxNWTZyUE9vTEFGcjhjNlNGSDJjOTF5L2ZKM3h3UUcxYzNnQkI1TTVkV1B4U21Dc1kxV1JKakw2bU1mUmNjQllVSWxrZEx3NDdNdVVpbjdqYVpGUWlnWFRhY1Zna0dPY0kwa1Rwb3U1c002cDQrdkYyVUV2RTlPREtPWnRXMnlYSk5JS0JDRlNEY1BSbm1NbHRIRFRodTJvcjZHU0VSNHpFQVdEcWt0M1dxaW1LTzU0Zm9ObnJ1L3R6YmdKMzdHQXI2b0tKV1hZV0Y5YnNmVC8vQVhJRyszc1g3dkN4dHFJcTlkdmlIQWtnN3pwOUxFN3MyNnZrOWxBdFhLM0JSSWxjWlZoWVMweVVTUkZSbFUxRkZJaTB4U0JvSzRhWnBNNTFuczZSV1JFR3U5UWFHUVM5V2NUQVVybkVXeHBIVHJOS1BvOWRuZDJ1WEh0Umx3ZlNKaldOVmNQWmtCZ1dYc2tnYVpkUVRRclNvYU1qbERPTzRhYkNUcVJrUlBUNnMvSDFhY2s3YWVVVmRWYUpFaThremdQZGQySTJhTGFjdTNVYlZYM3JOQ1pQbmdNTjIyaE9WeDNoOWZVM3JJRnJpVWgwbWZ6VkpGbUdmM1JrTUZvU0U0MmtqMzFNeWNmdm4vN3lWY3Uvck5uWG5pNUVrTFlJeE5OQXRqUmFNUWJiWXoxNXpaQUZsY3ZzcGhOaFZpcElZSmFIL1I2Sjd2RmZjR0hIS21pYkUwckplU1B5SUZxcGVoMk8yaVZnTE00WjBuVGhNclp5RlZCWU9xS3lqcENvaEVLRkJHU0xxVWkwWkttckVrNkJZT05FY2JVek1iVENJeFNDbzludW14WWxJWkNSZjZxMG9LcUNaU3R5NndRWUtYRTJVQi9xT24wZEJTMmJvMW9iaUo4UVJVSnhrYklpRXBTa2pSQlNNbGlhZmp1cXdleVhEWi9US1JFY2ROTnVscVZkRWQ2RU05clBkWlhwWjhMVU5tQXdjQjBHUmVXQXlkVW9vb3Uvc1AzYm05MVZPQ2ZQdlhTSzg4Y0hmcUVFUHoxM1YzMzFIUFAzd3FRSDRUejBzdVhLS3VHQUJJaEZDSEloMDV2SFQ5NTh2ZzlPa3RsNmgzbE11ck5MbHBJdmlZZ0F1U2RnalJKeUxzOXFzV0N1cXl3eGxMWHpXc29kVkpHMlo2ODJ5SE5rbWlzR1NjVUlBU0RyWFdrZ1BuZU5BYWppdEI5QkV6bUZjSTdYRnV5TkM1dzRHT2dxVmFQTTZTYVh2Q00rZ2xXQ2xiVXV4WVhSR2dWN012S3NFeWlXRFJTUmUwc0NTOWVtdkNGSnk2RDlZY1hYN3dXV29VNE1xVlNSNkFWUndQcXNJZHNoeS9LT29TTkU3N0p3WVJPbnFHeWxEeFBrOEd3Lzk0NzFnZWpjNmZmK2MrKzhNMG5mbjg2bTBkWVVRaCtzVmo2cDU1KzVsYUo5WU53bnQrYm9MUnFkWFdDQkRneDZtNElIMFkrQkV3VnJTbWNzUVRqc0NMU1k5TWlReWhGWFZXa0FYU1c0S3hoT1oyeEtDdWNjK1N0YkpFbnhML3ZER2xla09WNUs0M2o2RzUyOFFnVys3dlV0Y0cyK0hKckxEVWhCbStJcUZ3cEJkY00wUTJxOWZPVGVVS3FKTnZ6a25vN3gvcWJ3SVVWR3pHVlVXYkkxQTVYT0V4alNiS0E5eEhQL3V5bE1mc0hTekwrT0JuRzhsckhnOVZtZVBWcituVzRvTlhmVDlyWGFrRVdRbUJXVnZpeVFra2hKbnNUbmFYNkxhUDFqV052MmpvMit2Smk4VXZXaHhvaERLOFJFSHJqVGJIK1hKMXdPT2lOanNhQXV2ZTJrOGVhcHU1VXkyZ3BvRVIwVjdMTzRZMGw2K1FrcVdhNVdGQ1dOVlZaWXVzR3FTVGUyVWlWVUJKakxaNllFVllaeGRxR1pybWtXU3pRU2xQMGVsVExKU3BKMFoyQ3RNaEpzaFNaS0NiTGlyS0syVWhyY0ZyU0JJR1drWDBhQUpWcDF2ZG1aTUVUa2xZMEdvRU1BUlY4cSswYk9mM1NleElWbGQyajV3bFVqZWZaaStORDR0WXFPNmdqQzY5VmNDUkhmbDBjQ1k0VmNEZndXdTFWZVhOSGlCUUNyVFM2Vlp4eHpqRmJsRnk5Zk9YTTNzV0w3OHlWTEZiSlM3emU4dlpXQnZuK25pT2ZSd0RrVnBiY0VZd2RWSTBMMWpuaGd3Zm5DTTZUcGdtcDBzekxKZVBwbkNSUHlKcUdmcTlBRURBK3lubXU1RzJjaDdKY1JqZW9QTUZaeUhzcG9UR29OT1g2eFZlWjdCMlFKd2xWYmRBaTh2eWE0TGt4WFZJM2ppS0JQRlBNZ3FBZ01JbUwrRWhXS1JzNnRxRzhZNGpYaXREWVZscElST25QMWdMQlZvWThDSXBVNGIybnJpTHYvOG1YOXJpNE16OE1oS1BHTEJ4WkJNb2o0OXlqQmk2cnY2ZU9sRnJaa1ordnlqTVpZY1lBRkVsRzhJN0dCM3p3empxL3N3aUgxWnQ0STk2aFA5Y0JjaVE0L0IzYld5cHQ2aTJYS0dtOEVMNFZmekNOSWRPYUlrdnh6ckpjUnRNajJZSUZoQTgwVlVYVGdoZWR0UWdwV1M0cnZQZmtlWWJTT2o1cEcwUFNLWERlc3B6UFVFclF0QXZFbFdpMmN4NVRHeklGZVNyUlNqSmZSQisvS2tBWDZBbm9Cb2ZxNU5RYm5XamlLU0pSWHJRMnkxcEhiRmhUV2RZQ2RJc2swbjZ0NDhhTkE3N3kzV3VVTmw3YzVzamxUM2t0aFB0b1k3N0tHdnBJdG5GSEFrdStibUcyU2ptSjFtUnBnU1N3S09kSUFnS21Ub3FuZ2czMnNHMjZGU0EvWUpGeEJFVzhLRXZ6cVc4Ky9mbjFMRnMvTmh6Y3Q3N1dXOHUwekJLZEVGUlVIVkE2NnVVcW1aS2xDU3FOeGoxYUt3U1JReEdFd0RpTEZwb3NTMGdTSFYxZHF6STY3Q1FKczJzM3dIbXlMS1dSQWJPc2FKb0dhd05WWlZvRnlBaHhyNTFuYmx2TnJCQVlDc2hsSEtuNnRRTFh5K09PaEdocmhRc0lyVkZLUktXVXBhSHJJR21KNGNGN2J1d3YyWjlXcjRGWnIvb0l3K3ZVS3RwQVdGbG5kWWdPUWJRY09IT2tGTFB0bncxSCtoZ3JKQ2xRTmN0WTZrVmNwcENDMlkwUVh1R1BVeDF1QmNnUFVJbDFpQ0srUHBuWHZ6NmQvNEZHWERpL05YcnJUOXkxOVI5WHM4bloyaXR5cVZnZkRKRkpBdDR6N0hVUkJEcDVocGFLMnZ2WWV4eTZ1WHAwUjlQdGRVaFRqZk1PcFhOMHA4Tms3NENtcXVua0dVVzNnNS9OMFZJUUVzM1NWT3pNRnN5cWhod3d3bE01Y0JZV0lhQURkQ1JvRlRWNjNZbCsvUEo5RzV3K0lMUWswVEx5UTV4SExDM25CaDJFZ01aWXNrVHg0clVKaTBWejJKd2Z6UTcrZXdSTWRhUVhNVUFUQWprcnZOYk52dU43TWNoalNSWHhhRWtMWFpFSWtGenpzTi9HUklRVytCQ0dFQ2EzQXVRSDQ3U2FBSWRaeElQd1VwWnZPOUZiNzRWcVkrNU11RHJlRjh2U29yaU9EWUlpVFZqdmQ5Z2E5VGkrdFU2dnlPT0hMd1NWaTdUWVRsSFE3VVJYcDJYZGtCYzVTVjR3M1o5UTF4VTZWY2hVMHpTUjFCMEVCQ2t4SVRCZVZQR3l0ZE9yZWVOcGZDUW9ubERRVmUySDBzOW8raG5CT0ZUcmJTaUVpQnYwZHRwVlY0NjhkcXh0eEEwK3dQVkZ3MWVmMzhFYkY1ZUIzNk4zV1BVZlhrYk95Y3FKYWtVY254T2xYWklqVTZ1VTF5cVIrdmJYVXFsSVpPeXZWaGxMQ3VIS0VGNWQrckMzV3FNZ0NEb0VOb0ZiQWZJRGNKU0tPbHF2TGJsdzl4M3JiZDR6MGo4eG5pNTYxcmhRU0luWGtpRGlzbkJTMWt5cU9aZkhlNFFYcjVBa0NadmRuRXlyS0dHZnBQUkVJSGNhS2hkZG80b2NVeTZweXlWQnR2cTV3VkdYOWFyVW8zR09SZFd3TEUzc0JWSkJrZ2dteTZqYmUxc09tVi90T1FUbWVBK1RLRVRqNHVKUXh1QklFb1VQVWZhbktnMW52R1RZU2FrYlM2b1YzN3l3dzhWcjB3aGZQOUtFcjA3UlRwNE1VU081Y1k2Rk1ZZEI0NDY4YWw3cm83T1MxOHphbnpjSUtnSjlCQ25oVU85TUNweFM0cUoxaDk2T2pvQVhTZ2IzQmxBeStRc1JJQStkUDhkenIxNmhyTjNxeVNheUxGZC85NGZ1KzNDL21kMHhYOVk0dXhTOU5HV1FaNkFWczdwbUtocHNLeGticE1IYWhpdVRKZGEzbkJndmNGNHk2T1YwT3ptWjFxejM5aU84WFFyeWJrWlA1VWp2WWlOdFk4bGhuV05hTmpTTm81TkVxWno1MGxON09KbkNRTFV3RHdPaG4xSWU2MFlPZXNzOUY2dXhidXNIVWxzUE95VjNydzF3UUZVNzVwWGxHeGQyRUcyZ2hTTVhlOVYzRkVrU0E5QWFrdGFRay9iaUJ5S0pZNlU4dW9LN2h5TTlTazJVcVd3OWNSQStVSG5QU0xiNnBvSGdDWTBUOGhWdUNnZDVJR2d0RVk1YkFmS0RjRWFqRWZMUzFmYUJMQlFoaUx1M0JxUHRQTGxmRmh2SmliUWZrdDVVSUFKTlhURmZMaWpybWw2aHlKS2N5cmhvbnhBOGpiVnhJZWM5amZFSTY3bThQNk84TVk5eWpFcmdwQ1RYa2xFdkk4OVNUZ3dMdGtZZFZCQW9EMDFqbVN3cmxQRHhxZXdEU3g5aDdZVzZTYWtWVWxLZTZ0TVVDYUd4c1o0WE4xWGRyZlVSK1R0dnVGTW1uTnJvc3F3TldncXU3Q3pZbjFTSE05VVZKWFIxSnhNUkE2enlFWERabUlZbWhNTkdmR1h5Y25RWFVuTElwYVpleVErdFpGUGJmM2NLekgyZ1VDcXM1Y2tyb1RGZkhCdjNuUmIvYUVWVW12R1oxcnhVTjdjQzVBZmhwTlVpcWdSR2txd0M1RWl4VnM2bW00M3hMSm9ndHRaR2pMWTJxVjNEWXJGZ2NIMlh2ZjE5bEdoOU8wSmcwUmlNZGZnUWZRYmpsQ3V3UVd5dXZZK1BhUnNjeGpyMng0Ykd3NnZYWkN5SHBHU1FLRUtBL1dWTjVrRlo2T1NTSk1Dd0xRUHRxb1lmcE5ULy8vYmVMTmpTOUNyUGZOYjMvY09lenBSelZtWFdsRktwSnRXZ0VRbHJRQlN0bG0zQWdEdWdqZDFob3NNZEFVUVFCQkcrc2kvY2dkdDM3YjRnMmgxdGR3ZHlnMFE0RUxJeE5rWXlRb0FrYkZrRG1tcWVzbkxPazJmYzB6OTh3K3FMNzk4blR4VzRveTFWWWFseXI0aGRlU3J6WkdWRzdmL2RhM3JYK3g0WjROdmtHaXRaVWpiSkZyWnRtcFRVQjlzMUQ1NDRTdU1EM2tlS1hzNkwxOGJwa092UXJsb09OK3FxMU40ZGpKUGFoVXNYTjQ4NEZxUGN0Z05NZi9HZ0pLLzFsQklFbkVMTUM0SUlUZkRNdmFkV2xUWXZuQ25MejB4Mzk3Y09WV3NSMER6RzVSVHJ1eVdlZStvNVl1Z3FpMDZRZWlpNldzK2JnWXZLYkZJVG1wcjVaTXBvZGNqRzBTTWNXVHRDTloxeTQ4WW0rOU1KODdvaHhvajBlM2pWNU1zbjBJU0Fhd0tOYTJuZHpYMkFONmxYa0V3SVVXaGFoNCt3UDAxTk9jQmVUR3pkUVlDaEtwTEJiakNNTWtGTVpISnlTRzJGekNzbVM3cFkxZ2doUnJ3bXdNUzlob2VISTlaSEpUdnpDaU5RdFo3dC9lWmc4clJvcEIydlBPckpEcFZjaHpkNGgva2ZpeC90b1JySnhYZ2dDWk5MNG93TnJhWElTeFRZcVdiTVhjdWdhZTR1QnIyM2JHWDJTODZIQTYyQ3hTQmdDWkR2a3JqZ0lpYkxoQkFPMkJhclJUWnFHbGNnUWxIa0tFcDBEZlVjV3UrWXoydjZaUS8xTUNxR0RNb0J4OWFGcUo3ZDZSeVZkSjg2blRmTXFSSHZHUFR6enRFcTBFaWs4VXFSR1d4dUdQWU5NVVNhT25aTVgySFNLRlVEemtjeUkreDVLREpETHhQMlYzS21HNzBrTFc5VHRzcU1wQVZsMS8zT2R5dnVHQXR2ZmRNR005Y2tzMDZiU3AvU3BnY1l2Zm5BTDBBUUQwMnlEdmNrbGxlS0VaaERlNDl3cUk4SmgzNE8waTFLM1RTRUVNanpjckZNVk5PMmR1WmNIbUwwdkZMS1NhOVg5UklnM3pValhsN05iWkRzN05yZ0xLcWprQnhnazdlM1JxSkdpSkhKWkVZMW5sRzdnR1NXb3BlQk1mVExndFBIK29tM0ZWdjI5MmRzZWNoSlhLN2FlMXJ2RUJQSkZZYWp0SmRvbkdNK3Jja0V5cjRsb3JSZU1YYnhzQW1Wd3ZIY0VncllPemJBR3RQSnlORHA4U2F4dWl5M3pDcEhiOXZ4Nk8wbmlFVG1qY1BIaUJqTGFwa3hHaFpVU0ZMZmZoVUk3Q3NlOEZkdXhUbTA0N0FIRGJzYy9OUHpTazVXVUtVMFNjZlhSMFdEVDhvdklFRzFWV0V2S3FIakgzOVBMZ2h2aFQzSWdod24zZVRVR3ZSWUNGck9YU0Fhb2QvTGFkcUlMWVdWNFlEOXJiMERxMldiV3pRcTg3cW1hUjI5TWtlck5HcnRsVDJPSGNsUzM2Qks0eDNqNll6R09mSWlveWh6R3U5eGJVdVJHVXFiNk9kVm15UkQrcGxnTlMzbytrWEdXbUhZV2JIRVVaa1dndDNqRkh5eVU3Q1paVFp1MEtzVlAzRG5iUnhmNjdFN25kTzRwRWRhNUpiTnZUbFBYdHJEcWI2Q1dySzQrMWljeVI1bThSNWUvdVd2QUUzblMzTG92eEY1cGFBaVVTbEZLWXloOVo0bUJqVWdYdGx1b2w3c1ZqMkwvb05NMG9Ya0VpRGZSZEVKUnh6c3Q1eEs0MVZqak5IVUxrcmpBcmsxMk1KUlRXWVlJd1NmbUxKNW5sRjFFeGVSNUFibEc4ZXNjUlNqTXVsa29Za1JIQTBicTZ0RVlHVTBCQUpiK3hQVUJUVFBxWDN5UVdsYnhhaFFacExPYTBWWnpTME1NclpIQnRQVitVWU5TT3pVMGczei9acHNzK1dEWjA5eTV0aUF2Vm5GckVtU3FFV1dnUHpGWnpiWm1qU3Z5QWlMcGVCaHdKaERaVk54Q0NUKzBMNGtIQUpIOGFxTUV3OUFweEFEMlVJM3JCT0xkM0NoVWw0NmhDa1YwQk1aY3NVdHFTYmZWZmc0TEU4RWtHY2l2ZzBTT3hIL0dBTjFDRENaRTlvV1kwemFQUWlKTmk0a3pwTkdySnJrZmVHVEgySGpIYW93bmMybzIwQnZwVWZaS3hDZ2tJd3lXckxla0VZajFkNFlvcUFtdzVKR3JOaGsrbG1LY3FOVTJ0d3dpTWxuT1VDUytBbVI4WldLNFZoNS9JR3ozSDU4eU02NG9uS3B0REpHNkpjWkY2N3VjdUhLUGozOTh5VjZEbE5MT0FTWXc4WW9oeHZ6UlVaNU5hSHg4RU9UeHNpSmJ1ODBMaXlmdlFwLzZwVGR6bWJOQTlISTkyNlpkU3Rra05qVkN5R0kzUmRqbXRENkxBbENKL3E0RDVHcWRoMmRQRTJpVExUSjlTb0VvdEhrd3dlWVhwWXloOEo4WGpNZXoxQnI4TFVoaWlFemp1bThZbWM4eHVUcFZsMVJuSS9zVjRFVlNTTFVXWjY4Q1QyUlhYVkVaMmhKNVJRaHd0ekRUc3NaMitkZDk1MW1ZN1hreHY2TXhpWGFlMVJsYlZCaUpiQzVOU1Z2QXh2Y3RKWlNJeWw3eEp0N0R2aXo1TVdhUCt1MWx4MEN6dUhMUTN1NHhDTFJZM3dNZE1mbkFyd2M0WTlhWmNwTjg0Um9nZVo3dEF0NXd3SmtZUng2YzBpajd2SzR1WEpYRnVjK2hrRWJvZ1FmRUpPMHZVS0UyamtLYThtTXdXWVIzMFkwQkdKdWFKMG56NUp2QjVvZVFLY3g3VCtjb3g5eStubk9aRFpQcmxwZDZlUGJnRWhpM3RadFpMVVVva2xtT0M0S1YyS2dxU05yV2Nhd0tJa1REL3VlbzdiazNKblRuRDZ4aXNsZ1p6ckhHaUV2TEM1RTFvY2xSaUpYTmlmczcxYVVVWW1kTGRvcTZZeDNzUW1mNk0xNlp5SCtxWWQ2aXNVT1pHRS9hdzR0R2c5YmNmVVBaUnREVWx4cHU5d2hNQlA0MTJQbFc5eTAxL1pkTDZKK0NaRHZybmowNUJwUGJVOWprNWJBWHBYMjJxeTZldnQ2TWEwYWY5eUZRSlpadkk4RVd2cjlIc1lhZkVnOUNOMjIyR1NHUUNTcVNTZXVtaktBRHdIVENlZEpqQXlMZ3ZsMHhyUnhaSVZOQnFWMWl6WGdXMGZicG5iWVdpSFBCQjhVaCtGOWo3NkZqZlVCcy9HYytiaWhDUTBiSnd0T0hCMVNscFpBb0tvQzFocUt3cUJBdjVmRXM2OXVUNWhNYTR4Nk5vWUc3OUpHWGpweHE4SWFwSTJJaTJRR2NpdW9NVFFSNnFpMG1uU0MyMjVIOFdyL2lmclFodzJramZtQjRRaVFvZk1JVnhYNnVmQ2xDbjdMS3hNT1c2MkJ0bnB6NGJnRXlIZEpyUGNzbmUzR1lsL205MHg1SlMrTFo4cXF1VHRxeEJxVG5KeFEydFpoTXBNK1YyMnF4SHRsamc4T3ZCS00wb1pJSm9iZ1BDNm16SkJuV2RvbCtNQzhhWEdhUE5zUmNHMDZzbXA5b0k3U2ZXSXJtYlhVTGpBUHl2VEtIdFcxTVQ0azd0YkdhbzkrTDhQRmdLczlJU2k5TXBWMUN6WnZWVGVNcHhYenhuTjVjMDVmTEwxUndYeWVURGl6M05MNGlJdENKZ0dUd2JBdzVCMlJNdS8xY0ZHcFhhQ0o0RlNvbXBZbVJwb1FiOXAySGRxSjZLRm1udTdIUVdZMmpaai9jK3I4eTFhNTV1QmFoNnVhVHRGOWtUajJ3L2ZtYzJUZnFBQzU4K1FSdHFhMU5ENklkbWNObTN0aloyTGNMSVFpeHJpZWlRd3hJdHI1S0lLa01hMjFaRm1TS0ttYU5sSEpjOU5KQTZVczRud2srQVNTekJnaWtXbGI0MExFSWpqbjB1OXRIYWl3MnlSSDIxRXVhZlB0SWhPVFlVUnB2YU1OanRDUkpHTUhCdWNUVlQ0dkxHVXZ3MXBsZnpwbmJ6cEhGWjY0UEthWmUrNWVINUZuR1VVbURQc2xlV2FKVWRtZHVhUWtud3VqMGxMMnk2VGRsV1VFMXhLZFk5VEwyUmowV0NreTFubzllbG5Ha2VHUWZwYVRpZEN6RnVsT2FnODd2QnJBR0RNZDlZclBUbHIvUklSZEVvOXg0VVVmcmFBckZtMzBlL2M1ZXNNQzVOeXhkUzd2enhaM0VnY21wUzlQNnQxbjkrcy92Zi9zU2J2Ums3Zk42c1oyMmc1WVl4QWxQZVNaVUxXZUVCWEpUV2RTbWJ3NmdsZEM2enZBSkpjcDZhNFNRNGlFR1BDSkI1WjhCVldaMUVxdTBMZlNqWWVGbFZHSktYSlVBNkd6WFV3TmVBUWo1SG5HeXFpa0tBd3V0T3hONWt5ckJsVjQ0ZnFVcHkrUHVlL29DcmV2OUlpYTlMeDZaWTQxaGlJekRITkxQNGRCWVNtTG5NektnUzUvMUFSdzUwSnlKOUNBYUxvaFdTbHlWakxMUnIvSEhVZVBzdGJyMDh0elZzb0NEUjRibFJLd3h1U2xOVTlQbmY5YUI0NkYzVm93RUVjV0hRaE00L2Z1Yy9TR0xiRVVtTHQ0ZUdqalNPUlVXNnZlbURYTlV6UHJybFMrUGlQQldDT1dHSE9pU1NURG5aMHgySXhzVUZCa0Z1OUNzbUMyZ01aTzJVUVJqUlRXWWpORGtlVWdsdFk1Z25Oa0pvUFNVcnVJaXpXRERCcXZTQkJXQjRhc1g3Qm5ETkdsY2crUnptclprT1dHc21md29XWGVwUEpOT2tmY0t6dHp2bmxobjdrR25yV09ZVy9Bc2F6SEtvTDZRQnNpMDZwQ1E2QmY5QklUMktRcnhObThRakQwaXp4dCsxdVBjdzdYUkRESjZXVTJxY2h6SWNzc21jQ0p0U01jWDFsaGQ3eFA0UncxRFVhaGliR01yVnZCU0V2VUF5SDRoUTExbHB3ZHZxZmpEWnRCem0rUEtiS00wc3BDZitwZzBpbGd6dS9QcjEyYit5K2VHSmJyL2R6Y2lSRzdONWxwQUd5ZUVWWEZXRU92TEJCcjhERjVjNFNvaEJoeElkSTJMbGs1RzBOZEpSRUhIeU5WM1NZQXhWU0tqZXZJWmgwWlN0ci81VFp0djR1ajZ3UmowdDE3bmllRnhrSW9Td3NTbU5jTjQzbUQ2OHhEWFVoVStZdmJGZGVqNS9oYmpyTCtsaFBVdDY4d3YyMUVIQlZrM2FkN29SQmRRQ0prV1ViWks3RWkzWFJQeWEzRkdBTXhaUkpkS0V0Mmw0NUMrcnNEOVBvbHJXdTVjdTA2M25rMGF1ZkF5OVZHOVRkbWtlZTQ2U2JsUzlBK3FEV3c1WmNBK2E0Tll3eG5WdE50aDFlVlE3d2c5VkhqWGh2MllsWThkYVRmYXlBYmlKZ05KZHJHdDlqQ3lzTFVOVWFWdW5iRWtNYSs4N3FoYlYzS0t0M3V3cGlrNVZHN2xycHVhTnJrUWx0WGdkMHFVbldLSlpta0djQm9yVTl4ZElYR083eDYydGppUWtOUVQrc2N0Zk9wYk1vdDJua1VHb1FiTzNNdXg4RFJ0NTNtdHZ0UHNYWnl4R0N0aDEzdjBaN29NNzk5aERzeG9EMCtvTWd0dGdsRUY4aVMwMXlTUWxKRlE2STZGM21XMk1LK08rdTFZTE4wMWd2Q2FEaWlMUE1rdWwwblprRUE5UkNEOExrOStFUklBNjU2c2ZzSWdxNEFPL0Y3L3hsNlF3TWt4TWphb0VpbW15U3ZhSDNscmt5MzUrM2toWEh6RFJmMG13RnpmdXJqZFNOMnd4aFRJa2pUTnFacUcyMjgxN3AxVE9ldFZGV0xDNkVqRk41c2NUUXFUZDJpSXJRdTRqelVEbTZrMnl0V0phV3Z3c0pEYnp2SDI5NTFIK3RyUTRvOFdScllic3k4T0VpcWcyZmVlcXFtWlRLcnViWTU1Znptbk41OVJ6bjdqck9NanZUb2ozSjZ3NXhlTDhPV2xqak1pVWY2MUtlR3VMTnJoRHZXOEJzbDBRQ3pGait0aWNHbmJCY0NXWkV4R1BTVFpVTlViSmF5aDdGUUZEbkRRUi92VzNiM0ovalFzYlFFYVdCckR2OTBCczkwNEtnQTF5dHRQSEYwd09iTXZTR2VvVGU4TGxZWkl5L05XKzVaSCtqbXJHSHVRenkwWEk2QWIzeHdUK3pPdmdvODBiTm1kS3lYblN1Tm5ENCtLTjZ4V3RqN2g3bmM1VncxOENHVTgzbHEzRjFJc3AvV0dvMnhZZFN6a29uZ25NZFl3U3U0b0RUZDNmWlFZRXRoWGFBb2MvcHJJMFlyQTBaVncrMzJHS2RPSFdGbmI4TDE3VEUzOXFiTTZwYW9NT29YaEJpUzBWOFI2YThweCs1WVozQzBwTXdOZzl5Q3lNRk10U0J4eDNJVjRvb1FWbGJnN0Fyek9oQXY3eEZlM2tldVQrRENIdFlMVGRYZ0drOXVCWG9XNXdKcU9tRUk3OWphMnFIeTBIckZDdW1rTnBtVGZIa2ErU1kzVlVnRFFzeEdCY00zYjhEMTJSSWczd3Z4OU82Y002dEQzbmV5NUxOWG85cEc0clFOMmxudkh1YnpGUWhOSFdKMWFkYnVBdm41YWZ2WnZqVWJ4MHI3eUVqMHpSTDh2Vlk0SlNLblk5U05URlRhTm9vUFVMZUIwQ2tqTG9aRlFhSFMxQk0wM1kxR0R6aHo1amkzbnozSzNzNGViVjNUVkEyWk5hd1BlL1NMbkxNbk5oQnJEaHlucnUyT0VSSG1UY3ZtZk03d1pKLytJQ00zUXBuYlpCUGR5UVl0Q013aXN0QlZKd3JZZ2REZWZRUjMyeXB1N2dpWHg4aWtSYStPYWJibW1MMkt2QTZZM0NBeG9pcTRPdEw0Wk5OV21MU2Rqd3A1UC9lelRMNFk5dHNwZXRQdlhrUndUVkJaSzk4d3o4K3RvS3pJcGZHTWZ6NmVjZmRhanlPOVhOZkxqS3V6TnJvUUQzWmlDZzZsNXViUlhCWlY4NmtQMDZrUGwwaDZibXNGckEzRTNGc0tkK2RDVCtGMFZEMWp3V1NGSGE3ZVBycWpYNW84TkpGNnYwR2JRSyt3VEwxaWZDUWI1Tno1amp1NDc4SGIwU2JRK2tEVkpOdnB0ZzFNcXhyVFRiTW1zNFpaN1JnTUNseU1qQ2NWOXRpQTdQU0lMRXU5UXA0bGhaTGtNNWdPbVRyM0VMS3NzNDRPaVR1VzVzNEd6UzN4ekJxK0RzanBWWmkxdUJ0ejJxMHA4KzBaTXA1VEFDRlhUQjNwaVlMelJLZEVSWHAzcit1Z3RIUDU2dlVXY0tvYUVLSXhFb2RySmMvKzJ4ZVdBUGxlakpmMkUzbmk4YnVPNkxqMXVoK2pXSkVRMHdsRzUweW9UdFB6ZE9CSzFZR21qakN1NFVxdDhkbE9OcW9RR0ZoWUEzcWpZWDc4MGI5MTM4K2R2R1BsNGZuTTBldzFNcDA2YkdscG1zaDg3Q2l5aktkTzloaFBybkdNSE50RWprckdZR2pKQnNMUnRSV01OY3ptTFVWaFdIRUZVV0JTTzBhRGttazlTWDlpYnNpdHdXVEpLeVRUNUxZcmlhaWNIQmhVaUpKdTJMMVB5cEcyVkRJZjBPUmxnQmlRd3RJT0Mrb3dvQXFlMWdRS2ErajNTd3BNOGt0MEVkdEc4dHd3ZXVoNG5EMi8wNnFxRXlRZ3ljazIrRy9UUjNvSmtPK2UrTEY3ajNOajdnZ1JjbXQwdmN3NDBzdmo5Vm5MYnUwV1IzY0xxejZqcnp6S2UvWExLT3g3dUFIMDkvZWFLNWVmM2Z2b2tUdFhmbjUwY25CdTlYUlB5NGpNR3NYdnRLemVab2x0Wk45Rjl1b3B2b2w0RHoxcnNKMnR3UkJEVUpqTkd6YThZUlNnRE1xcVdNWlZUVjBLZ3lJZFlCa3JxQWpXcEhuTHdxbzdONEpxVWpBeEpNY29NY2xHcjdDQ3p3eWFSU1NYSkhrYTAwZEQxR1FSbll0Sms3bk1FRTIzRHpsZUl0Wm8wY3VJeGx5cngrMmxqZzd0UlNRdVRGdDNMay9mVU0rTHZkVUE4dlQybkF2am1xYmJLVXphd0UrODVTUTNLc2RXNVJSajFGaUxHQk1WaWNiWWFLMEpJaEpVMVhYTE1DY2lyWWkwWGYrUzZuQWxYUG5XemhXYjIydWpFLzJIVVZaTlZOMjhQTmZKalFhYlpSSkNjcXcxeVM0RWE0VmFoQjBYY0VhWUV0bHBQVk1YdU9JREw5WTFMODVxWGhqUGVPTFNKdG14Z2xOdjJTRFBvSmRaK29WQlRIb2JFeVZkc0owOHo4S0UyeC9vWDJtbmdLakVvSVNnZUJkUnI2aUwrTG5EelZza1JvdzFHR3V4SkRVVHNXbVJtUmVXK2JqNXl1VW50bjdiemQwVXFBVDV6enBGTHdIeVBSd0xKdDFYcm8zWnJycXhwRTNNaytnOVJsV2pSbzB4YXBabDBSZ1RZN0x2RGNZWUx5S0xEZjFCb3dybzllZjNydytPRHVxVkUvMjNWQk0zdVBqMTdhdTlFNk9ZRjFrL2RzcUNZcURWNUc0YmZLU2RPMnh1c1VhSWJTUjIvbXJkV0pYdHZUblQvU2wzdmUwRXgrOFlVVmdZRkFiVFVlbU5BVVFYUmh6NHFJU09TT0E3QXFXaEU0QUlpdmN4YVd4NVJYMEVIL0MxdzgwZDZnTTJNOWpNa0pVRnRzakFDR0tOaURWeHZOLzg5dVl6MjEvV3FIT2dGaEhYNy9mQ20rNDd4OWJtOWh0cmw4WXlYaG5lRTkzTjllL0M5djJSUng3UmZyOGZSU1NjTzNjdXZQV3RidzNIang5M1pWa3V6aTRxRWhkcEV0cXc5NVhmZlBhVEwzNTkremVlK1B6MVA0cVJyeFdEZkVCTUZtK0xrc1lZU1Y3czNTTHZvSzZ6Z3JGQ2tSdXl6QkliQitPWjMxanBiWjQ4TTZ6S1Fsa3JoWDZ1R0t1VWhhSE1EZFlLTmhPeVRKQnU2aFEwYmZlbG8vQUxpZjhoY0tEWWVKT3BKbWlNZU9mUzN6SGM5TDFWUUt5Z1JtWnUycjRVWFdnaGxWY2lFbzhmUDhGUC9lUlBzc3dndDFDODRteFZsYXFxY002eHU3dkx6Lzdzei9Md3d3OXo4ZUpGQmJScG1sZWNWQVFYNCthemU4KzErL1hYVHoxMC9EMWk3SDNxTmZYT1NDZnluQjdTYXR3UzIwamVzK0FqY1ZHcytFaTFNMk4yZVcrdnZqcjdneE1uKzA4Kyt2anBCd2E1WktQQ1lpUXBpd1M1NlkxWUdJUHYrb0VZbGJicm16VXFJWFRmRnlFR2lDRjVUY2MyRXR0QVBXMXA1NG56VlpZNUdwVzh5RERXb01hUTkzUEVtaGUzTDQ3LzlYUnpkaFdvUktRV2tiQzJ2cWJWck9hRkYxNTRRejBEMlJJRy8vL2k2dFdyQjEvLzBpLzlFbC85NmxlNWVQRWl2L0FMdjhCWHZ2SVZmdS8zZmk5dWJXMzVWSUVsYkxXVFZxdE0vTTdGNlpmTFBYY3U3MmQzWjRNOE41bGdpd3c3eURTem9MVUhheVZHSVZaZTIza3JibHd4MzVsWHM2MzVNL1YyL2RucVd2WDFVeDg0OVlHakt5WVRGUzJOU08zVE5WalJYWVI1NzhtekhDdUNHc2d5d1lTYjJycHRqQlNhUnNqR3B1bFhqSnJ1a2J0MGFhekJKQzRhTnJlSU5lbGx1aXZLMmorMzgvTGVWUTZkaktpcVhyNTBXYytjUGZPR2U5K1hBUGsyNGgvLzQzOTg4UFhmK0J0L2cwY2ZmVlMvOHBXdnlNN09UdnJjdnlteHFkVmVFMS82M01YZlhEazErc2J3V1AvOS9mWHljYU42ZDNBdWx3SWpSb2lTaC9MWXl0WFoxdVJJdXpjZitGazdic2JOTit0eCt5ZlZkdk5WUC9XVG9tZFh6ajI4ZnVjZ0YyTTBOZUtSbEFWRWhFd01NYVQrU1RYbEtJMnBKNGtCMHU5Snk4Zk9hUGRtWXkvcHYyY1cvVmVNK0lOanNnN3R4cWhSNm5iZVB0T00yd2xwTVJpNkNaWjY3L25DNTc2d0JNZ3lYaGwvOSsvK1hmN2hQL3lIUFBIRUUvcTJ0NzJOcDU5K1dxdXFRbFZiT3JFSU4yNzh6cmlaN0R6SDAydG4xejVkOU13NTM5WVBSL3o5M29VOEd3NTJlcGVtditObnMvdGQwTnUxNVhQTlh2dTFkdUwydS9lb3YzYTh0M2JIM2FNN2MyT01LRmhSQ3B0S3RTb0VFRXVSbTBTbkY0Z29Lb0FJMFNnYUVsWEVHS0VOU3RzR1FuY2hxWGtHcFZKTE4yN3UvQTlGSkUyOFlpVExNakdHY2JWVm5lZW1JRU13eG1nNk5udGp4aElncjBIOC9iLy85N0hXOHVpamorcnU3aTdqOFRqdTd1NXlxTnlLM1JqWTdWL1lud0xQU0NhZk1ibU1WS1BseHN6dnQ5TTZMOHdmUnlHRUppNGswRE1SK3FydzZBZE8zYkcyVmg1ZFhQVUZCV3VFRXFFeGlvYUlHaUczSFlYZHBQMklTRVFNcWRUcTlMMFdqRTNUN1ZDaUNHMW54cG5uR1NwQzZHeXhOVVJzYnNtc0lNS2tucmtiaDZaMlVVUml2OS9YcXFyZWtPL3Rjb3IxR2tVSWdjdVhML05Mdi9STFBQNzQ0NmhxTk1aNFk0d1RrWnAwaWpydFhoUDF1aGVxZURuV1hJeXRYaFZoeDdWeEp6UnhyL3VlT1ZDcjR2S2V6UjU3NzhsSEJyMWlKUWJVbXJTYk1FQm1oQ0l6U1pCQmt3KzdvQ1R4RlUxS0tCM05YUklHVUYyQUk1VlJJU3JSSlhFZmtTVHVZeVg5bWhoRGxsczFpUnQyYWJ3NXZRWTNGNFNEd1VCLzlFZC85QTM3dmk0QjhockdwejcxS1VJNnRWVlYxZnZ2djErSHcyRVFFUzhpalloVUlqSVRrWW1JN0l2SWVQRlNaVXk2cTVoMEkrTjJrWDN1ZnN2UlkyZnVPbkovWm5PYkd5TWdaRWgzdkpVbzZGVkl2aDNxQWdURlNPb3RjdWxHeVdsVm5vN0h1dXdoQ25YajhUNTBsN2lLOHg0ZjB3R1ZzWWE4ekRBaVlxMzR0dll2VFc5VSszU09VVUFzaWtLbjAra2I5ajFkbGxpdmNmemlMLzdpd2RmdmZ2ZTd0YW9xblV3bVl0SUYwbUx5YzNqN2NPQThvS3FMbjE4NE1ac3pKMDRPZi9wdnZ1dng5ZFgrbTZMR3RDTWg3Vk9zZEFjcG9SUEpVeWdHT1JyQXgxU0NoYzRaRjFWOFFnWkdrdHlQRDVvdUpUdEQwT0NTMTZZZzZjNmV0SFEwMWlDWm1jMzI2aWM1NU5TbXFuRThIbFBYOVJJZ3kvZ3ZqKzN0YmFxcTR1elpzM3J4NGtXR3d5RnJhMnR4T0J3U1FsSkVpVEdpcWx5L2ZwMnFxZzVNWlVVa0Z6SDV6L3owNDQ4OTl1akdUMHlLN1dFYmsrRm56M1MzNnlLSUdESURQUXZ6N21HUENCRkJOZUtpNGtMcU80d1JZdUJBMjh1RnBDVzV5Q2E2NEJvZStFVExnU0NGR0tuM3Iwd3ZId0o1VkZXYXB0RU8vRXVBTE9PL0xINzd0My83NEdzUllUYWJNWnZOL2d4ZjZXZCs1bWY0M2QvOVhla0EwaW5yYU8rZWUrNGNmZUFENy9sUVByeHljaWR1cWhnaytNUVF0Q0xrUm1nanVLaFlWVW9SMm81aHVWQ1dEQkZzcHpuY1J1M0d2TjNWMDhMTDhCQ3RoYzR3MUpBeWtHVGR6a1RZbSsvVnV3dUFkT1BkQ1BEcFQzOTYyWU1zNHp1TEJkdjF6NHZOemMzRWxVck5RaVlpcFNyNXU5OXgvejN2Zk5mYnZ1L1V5cHRFS3NSSFQybFNhWlVaU3k3Mm9QRVdFbUR5anFqWWRtZkdxb0xUSkQyRXBwRXRzYnY5N1VBVVE4UzVsRnJTWDBFUDlIZ1JVYXlKcnZZWFFodkdRRVFJeHBqWWlZTy9vV01Ka08rQytPeG5QOHYyOXJaUjFZVU1idG52OTNvZmVmeTlieCt1REU3ZGMrWXh2WGZ0blRTTmcwVkoxTFV2b3BhZXNRenpuTkptRk1aaWpTV3FIbWh5K1pqRXJyc25uc09YK1lzdkYxWTMwbTNUTTV2VTdLMDFtaFZXNS92TmhXYm1KcVFWeXh1U3Vic0V5SGRaZk9BREh3Qlk5QjZpcWwzMjBPenhENzc3bnNjLzlIMC9Za0lvTW12a3dkdS9uNGVHYjBOaTk0VHFUVFp5YVUyaWx5aUlkc3UrbUN5WEpTalNPZWd1NWdMZUo0RTZZMHlTVFkxSlNFNUR5akRTMGR2Rkd0U0lpQkZYVGRyenZnM3U4UFo4WTJOakNaQmx2TDV4NzczM0lpSVNZMXlvZWhaQStkZis4dnNmRzYwT3o2cEdDSjZWc3M5Nzd2aHZlV2psbmVBTVFWTVJGR0tTTVFYQlI2aDlvR3FUcW1OSXY1VWM2VUNUSExFT3pIQmlJaXRTZWRRRnZQZkV6a3RSVERyR01rWkVZeHkzOC9aU2x6T0NpRVJycmI3OTdXOWZBbVFacnk4NDV2TzVxT29DSExtcTV2ZTkrYTdqNzM3dlc3Ky9iMlZnRnA1UTBkSExlN3pqN0lkNTk0bS9UTDhaRVVJZ3FoQXgrRUJTY0F6YUthb2tzVGxqT3M1V1ZLS1BFTkx5VURUWi8ycU1xRWFJSUpxVTdWV1ZMTE1ZSTJveVVlL0N0TnB2dGxJcmxUUlNiNFgrWXpuRitxOGM2K3Zyc3J1N2UxZ1R1Z1RLLy9GLytOR0hianR4NUVHeitBQ0xybHQvUTJGTDdqditHS2NHWjNobSswOTVidklVSVRaVXFoVFdFZ0pZMGpoWUZBcEpza09wZHpFb2tSZ0RNY1NiWHVxWlFXTUVsUVU5Sm1rTmQ0MU9ETHJWenYyTWhhVno5ejN6K1h6WnBDL2o5WW5UcDAvejY3Lys2OVIxdlRCdnlvRGlMVysrYS8wRDczL3NoOVpYK2lkWk9DbXJUeWVJSm9mb01OcHlaSGlVZDUzOUlYN3c3Ri9uWkRoTmZXTkcyN2xQNVViSUpFMjMwbVZpbHpHa2EvQ2pwbDhNTVczWFhVeFhoYXBrV1liTmJOZkRxMWhyeUtKY0QzVlkrSDNFUlFiNSt0ZS92aXl4bHZIYXg4Lys3TThDQitOZG82cFdSSHBBOFpNLzhaSDczbnozSGU4aUlpcFo0cXBqSUN0U3FSV1NuUUxCWXpWdzIvcWRmT0N1RDNObSt3N2FKNmNVVlVSRjhOMm52REdkUDNyVXBFRFI5U0NtV3d6R21KcnowSGIwa3F6ell1eXVIY1VLWjlmWFQ5eDU3TWhoSzBOVlZVNmNPTEVzc1pieHVwUldpNUhTb3J6S1ZiVVlEUWY5Ung2NTl4MXJHK3ZIOFY1Rk80bXJyQTlpMEhhS2FBVEpPbDBmQTY3aTlNWlJmdktILzN1ZWZlSnJ2SGp4Vy9oVnVONXJlY2J2NG1MaVZva2hYUTc2UVBSSkdBN1NaajFaTnNRRDRXcHJra0tjQ0pxSjRWUmVibHpwRlpiT3NmWjczZnQ4Q1pEdjhyaHk1UXBGVVFBWVZWMU1yb3Azdit2UjI3Ny9YWTk4aU9BeU1UbVlMb09vZ3E4T3lGc0xVd0VOYlVjUFVVWmx4bU9QdnAyN3o1emxtVzk4bmRQdGpFZU9uT1ZxblBQODdqVXVqUGZZOG5WM1FaakVzSk9sUTFvVUpoS2pwdEd1UU96UWVXODJrbnV5L3ZRL2VkOXlhRzBDOE9LTEx5NEJzb3pYTm80Y09jSW5QL2xKcXFvNkdPMTJ1NC9pSi83NlgzM3Z4dkZqZDlHT08wdFpteHIwNENINnBNb2VBeG9EeG1SbzhGMlpsT2duaW1FNFd1SCtSeDdsMG9VTHZQak1DeHd0TFErZmZZajVVY2V6VzllNU50M253djRlZTBYTHZMVnNWek5FTERiUGtTeWpLSEo2V2NaYWtYR3VOK0xSd1NwMUNPTnhWWHQ0aFpVaDczakhPL2p5bDcrOEJNZ3lYcHY0dVovN09UNys4WTh6bjgrbDZ6MHlFU2xVTlh2b0xYZmQ5cUh2Zit3am1jMUt4R2k2V25MZ0QxdHBCbUpJRXkzRkpDT2Z0a1lrV1M4RTUxRk5Va0MzM1g0RzFQRGNjeS95amErL3hLa1RHenk0Y3BUN2kzVzJ6UWFUcHFZWmVXNzBwL2cxaHp0YTAxWU56anNLZ2JYY01ySkdySGRjdWpGNTlxV3JlOVZoY0NRcnVqZCtsYlZzMHY4Q295eEwzdi8rOTRza2hlazAybFV0Z09Ldi81WDNQSEx5MlBvOUpxcUlLUVN4b0JFTkRnMSs0Yk9BU0RxRjFlanhyaVdHMEVuMU5MaTJJZmlXMWpWVTh6bHJHMnU4OVpFSE9YWGJHUzVmM2VXUC84T1RQUHZDWlh6aldjOTdITWw3M0Y0T09FcEJQZy9rTThlb1ZVWVJKRVFhNzRuQXJIYTc0MW5USHA1Z3JhK3Y4L2YrM3Q5YmxsakxlTzNpNnRXclhMOStmWkVPTEpBckZNZVByYTIvODYxM3ZEZjZkazJOU1ZkOUhibFFiQy9aK0VRUEpIQUU3L0J0aTNjT01SYm5QSzVKRHVjeGVyeFh2SFA0RUFodDRNVEpEVlpXKzl5NHRzWHpMMXpndWVldnNiRTJZRFFzSVVhbXM0cXFUb2FqL2NJUU5WMFpGbUl4eHRRdTZwaU80bTZNVVJIUitYeXVQL1pqUDdZRXlESmVtL2piZi90djg5R1BmcFR1ZGlJMTUwS0pVdjdDLy9Tajk5MStZdlRZNWZNdnljcXhFMlJwdnBTYWNURnBEMEphYkVSWEo0ZGFEY1FZME9BSlBtbjd4Tmg1bDdoQU5aOG5ycFlLcnFtSnZtVnRmY2k1YzJlNE51aHgrZklXbDY3c1lrVXBEZVRTcVROQ3AvRXJSQldxWU1ZelozYTV1UU9KSXFLVHlZUkxseTR0UzZ4bHZIWngrKzIzaTZxYUdHTUc1Q2psNmVQcm8zZSsrNEVmdlBQZU84NXN2dnlNTnZOWm1sYkZ6bFU5TktuTTZzYTZxa0lNQVZIQm1PNStQTXVSanNIcjJwYTZxbWliaHJhcWFKcUtHRHh0MjFCVkZkNjFiS3dQT1hmM0tlNDRlNHBlcjA4SWlSWmZsQVdTV2FMSmNHcG9vNldOWmpLcDIzME9qWGdYdmNmWnMyZVhBRm5HYXhNWExseVEvZjM5Zzk1RFJFcWcvUENIM243SGczZWVlTWZhK3JwZEhRZ1hudm9HYW16YWRaZzg3VDI2VjF5TWQ1T0I1b0hBQXBwRUk3eHJhZHVXdG0wSTN1Tzl3N1VOUHZnMHhnMGVjL1BBbDZLd0RJZDlJb2E2Q1RnUFVTMUdMR1ZSTU9vWDVFYnJ5YnlhazhqREVWVVZFYXk5TlVRNWx3RDVDNHJQZi83enpPZnpnOTRENkJWRjN2dkxIMzdQKzA2ZlhIOFR3ZkRtUng2U2IzM3hQM0wxeWlYSVRIcDdiSWxrSlppQzJOYkVtSmk2TVhoVVU0TWVRa2hmQThGN2drKy9GcnZsbjNjdHdUbWM4emVQcHJyeXk3ZStVM3puWnQ4amloQXhvc3dhdC8vODVaMXhWMXBGRWRFalI0N294ei8rOFNWQWx2R2R4dy8vOEE4RDRMMlhSZS9SN1QzeXYvbmZmZWlCOS8rbFIvNktVYkZJem1qakdFZU85UGlUVC84K1RUMU5mYkVkZ3VTb3IxSVdDU0haSFJpYmdCQWp4dGh1dXBXc0VEUkdOQ28rZEZuRU9WemI0bHVIOTRGRXhBMW9kTjMxZWhLcHRrWVcrbGNzNUJkYjcyOWMzWjdNdTd3VGpURjY3Tmd4dmZmZWU1Y0FXY1ozRmxldVhHRTRISExiYmJlSnFrcU0wWksyNXIzUmNERDRxUi8vMEE4ZVBiSnlOK1NJV0xJWWVlenRiMkg3MG5uKzlFKytTTFNLU25wNHhWZ2tLeFlWRmRFSFF2RGRXanZSUm96WTVNM3VRcnFvVmNVNVJ3aWhvNU1FbXJxaGJWcXFxcVZ0UFRHRU5FNG1IVTFsbWRBckxJTitybGxtWXV2RHVHcjlncWlvZ09aNWZrdHMwWmNBZVoyanFpcmUrOTczdnFyM29GRFY3Q2QvL0ljZWVQalJlOTl2ZlpPSnpaT0dhSEFjMlZqalBlOTVNMy93Yno3TnQ3Nzhwd2dPRFltd0tOYW1SajBxTVFhc3piRlpqaTU2RTBrcUpNWVl2UE40NTNITzBkUXR6aVdmOXhCakFrWlU2c1l4bVZhMHp1TjhvR2s5ODdxbGRTa3pCUTJ1YXQxMjIvcjIwQlJMTnpjM2x6M0lNcjd6bU0vbmZPbExYNkpwbXB0N0Q2VWNEbnFEdi9WVEgzNy9rWlhoblpLTU54S2x4TTFBRFE4KzlHYnV2bXVOZi9IL2ZKSWIxMjhnZVprbVdwM3dkSkx3eWNqeUhsbGVZbXhHQ0pHbXJxbXJLZ2tDKzlDZHp4cEFpRkdUUUZ4TTRuQXhScHE2SmNhUVRIZEltcjQrUkJvWGFGMFFqWGluY2FxcUJ6UVRWZVgrKys4L3VCdFpBbVFaMzNZOC9QRERmT3hqSHlQR3VCQlJMNERpYi83VWYzUHZQZWZPdkQ4M051K0lHeEJhb2tzUHJHckdEMzd3VVc0L0JyL3ppWC9EZURaTm0zU1ZCSXlzSUM5S3hONzBKUVJEY0NreldKT1I1VGsyc3dTZlRtbWQ4NTBRWE9jVjRzS0JLMjZNRVdzTjFpU3BIMnM2QjkzQ3V2MVpVbkpmQU1RWW81Y3ZYOVpiNVQxY0F1UjFqS0lvVUZWUlZhT3FtU3BGbVpuZUQzMzRQWC9wK1BIVmN6RjBhbFNoVFNSRWxPaGJndmNNaGl2ODFZKzhuZDByTC9BN3YvRXZxZW9LaytYWXJDQXIrNWlzUk1TbWpibHppZkRyQThGSGZKYzl2QXNnY3ZEdmduUzZ2S2JMUmhIblUzOGlRSllsR2FITUp2LzFQTGVFdUJDcDdsU0VWTFhYNi9IalAvN2pTNEFzNDl1UFgvM1ZYMlZsWldYQnUxcU1kdk8vOUgwUG5YemczSm52SzhRVTNaRUdoQnBpSUlaQWNDM2UxWUJsZFcyZEgzai9XL2phbDc3RUgvMytGOUNGN0tFS3h1YUl6VEUyVDlraktvakZCMGRkVjdnMmpYVTFLcGsxWkZraVRhaHE2akZRMnRaMW9scXB2TXB0RXF6T3MyU2xNRy84N3FXdHljSTU2SUNvNkp5N1pkN0hKVUJleCt4Umx1VWlnMWdSeWF3MStZY2ZmOWQ5NSs0NC9ZQUdUMXBPZCtXVlQrVlY3SUNTdUltVzA2ZVA4S0gzdlpuZi85Um4rUEovK21xUzR1MjI3REZFdEx1Y2JkdTJFODQyblVPdHdYdFAwN1RFcUlRWTAvUXJScXdScXFvbGhKanF2c3gyd0RDVUN5UFJxTFErenJmRzFaaWJGZzRxSXRvSmROOFNzZVJpdlU3eDBrc3ZFVUlRRVZtYzFCWWJheXZGQXcrKzZiMVp2emVJVmF1aG1VZ3VGbUtEeGpTdDBzNEZOM2IzSDlZV1BQeld1OWpkbS9JYkgvMEVQV3Q1NE9FSENDSGRoa1JOeE1RRWxxUjFsVTdPVTRNZU5TUzkzdENKVW92Qis0QjNQbzJLWXlDektVRTRIN0UyT2VIR3FCaWJ0ZE9xYlE1bEQxM29DUzh6eURLK1k0RE01M05FeEFoa3FwcWZQcjYyY3ZiMDBic1FFV09FME13NnhVTkw5RDRkUUhXV3pZbU42OUo0MXhTODQ3RTNjZHVKakgveVR6N0dFMTk3c3BPRVQ5djJHQ0ZHUWRVY2JNbURUd0p3UnRMUEZVV2VCS3VkVDJOZDUzR3RQN2o3RFNFNTRZYWdWSzJuRFVxSXNkM2VtN2l1TWxNUndYdFAyN1pMZ0N6ak80dFBmT0lUTXB2TkpNWm94RWltL1lnbXdRQUFFL2RKUkVGVXF2TFdCKzQ0ZTlmWkkyZWtiY1FrVlFTbSs5dEVreEZqSUxpYXRwa1JYSTBZa0E0QVlPa05CenorQTI5bFl5WHlQLzh2L3dkLzhQdGZRTHRQZXNVUVZZbEV4QWlaelJDeEI1NkRlWmFsNyt1WXZzRWx6U3k2MFc2aWwwaDNUNnVFb0drcmp4SVRBVXhGNUNCN2lNZ1NJTXY0OW1NMEdyRy92OCtpdk9vYWRIUGl4TVlwMisrdGFlZURWZzdYQ0w1aFB0a2w2dzNBbU82aE5wMnVxR0t0b1NoN1pGbVAxZFZWZnV5dnZKMTNQM0tTLyt1ZmZaemYrSTNmWVRhYms1Y2wxdWFBUlNRNTFCcHJzRGJER0V2VW00ZFdhQ3FoNmpyUlR0S1dmcUdaeFFJMGFrU1l6T2JOcEdvZHNKZ2xLOEQ1OCtlWFBjZ3l2c05QSG1NSUlRaGdZMVFyUXUvN3YrK1JlN0pzVUthaGxtS3lrdFhqdHpQZHZrWlRRMjkwOU9BcU1IcVBjM05DVkV6M0xoa3hySzJ2OFVNZmZKRFZsUUdmK3RSbmVmNzVsL25nQjcrUGU5OThCLzErbnhBQ3huaVFDQ0xZVHN6YUJZOFBFUjhpTVNpK2t5ZTF4aVpwb003Z1V4V0t6TEk3bWVMdzBjZWtwS2l2dWtkZlpwQmxmRnZ4OHovLzg0c3ZSVldOQ0JZd2Q5OTVhdjN0NzNqb25ZWFlJa2xWSmZaSjFsdG5lT1FVZFZNeDZ4YUNOaXVSeFE1UnRUdXQ5Y2xCcWhoUWxFTWVlL2h1L3RxSDM4cnUxaFgrOTMveWEvenFSei9KazA4K1Q5YU5hbE9qMzRrNXFIUjlTbW9tNnNyaGZEZ1FrclBHSkMrUkVDbnluRm5qR005bXJuTGhmT3VDT3pUbXZlVmltVUZlNC9EZXM3S3l3bXcyNi9oWGtvR2FILzNJZSs5Y1hkODRJeGhCRDdrSFNFYmVXMlh0OURtbTI1ZHBXb2MxRnU5OVJ5R3AweFdpR2t4ZUpMdm5za2ZSUnM2ZU9jNkhmNkRrOHRVOXZ2bjBKZjdaUjUvbGdmdnU1dHhkdDNISG1aTmt4bUtNeGRvTVNCSS8za1ZhbDRRZmNtc3hKbzE1UTR6TTZvYnQ4UmpuV3M2ZVhQSFhhNzlKY3JPOUpiUEhFaUN2VS8reHZyNHVtNXViQzFrZkM5aUg3Ny9uenJ3bzFoZGFjR21sYlJNUHk1UmtaY25hcVpKcS93WnVQc2FXQTdKeVNHQ1hwcHAzM0tya2I5NDBqaEFpeHVhc3JxMnhzcjdCbSsrOW01MjlLZHM3Kzh5bXUzempXenYwZWdPS0xFK2F1eUV3bTFUczc4L1luMVJJOExnbUVEUVFvbWM4bjlMNmh2VmhqL1ZSU2ErWEsyMVkrQkhHV3hVa1M0Qzh4dkhnZ3cveVc3LzFXd3YycmxWVnV6cnFEKzY1NTh6ZC9Ud2ZvQ2dhNWFZWllNYytCRVF5Qmh1M0UxYU80NnNKb1o2eGtwZmt4WlRRTnBpc1NFMTUwNkpxR0hvSW5TVm9OWnN5SEJhY09EcGtaM3ZNOWMxZDluZHVzTE0vby9YS2ZONXc1ZG91ZTN0ejFJZTA3OUJFZGUvbGh0Vmh4dTNIMWxnZGxBektqRjZaKzgzZG5XMGdDRVJFMUJqRHVYUG5lUGJaWjVjQVdjYTNGNWN2WDJZK255OGNheTFnN3pwN2NtWDk1TkUzNVptMTJsYWRHTFZOZCtleXNIcGFWUG9SbXhYWTBUb2hMd24xbEZJRFdwYmtSWStpTEduYWhtcnVvSGFJOTlSVnpYdytvNXJQYVJ1SHNiQ3hQaUMzUXIrMHRLM254bmFrV2lsUjc2Z3FqMmhnclZld01pZ29Nc3VvbHpQc0ZlU1pvVi9tVXVRMjdreWJkTFVsUkdOTWpESHFBdzg4c0FUSU1yNzkrT1ZmL3VVRk9CWWpYblBuMmRPanZCeXM2VUtobmZ3UUtQVGcxUFhnNjg1NDBBcEkwVXNqcHFqcDRLbHRtVS9uTkkxbk5xOEl6bEhYRGZQWm5MWnBpREhpV2svYmVvd3g5TXVjR0NMRFhzbjZhRUIwQWF1QlhtNHBpeXlSRWpPaHlHMmlucGljb3JRWWErcnh2TjJuY3c0aDJSNW8welRMSG1RWjMzNjBiYnM0SmpvUXAzN3ptKy9hV0IyTlZwQU1rYTRtMHE0SWk3N0xLS1RkaC9vRDlmWkZNeThpWU1CWEZmVjhrcjVOQTAxZDRWMmdtbGZNcDlPT1JDaTByZXVrZ0JZM0lPbnZGbnc2b2pKaWt2T3RSbFFOZzZKSWhFWXJGSm5WWVM5bmY5WmUyQjdYbTZRZHlLSlI1OS85dTMrM0JNZ3l2clBvWkRrWERicDU3Tkg3MzNUcTZOSGJVUU8ybjZSRE5TQ3h1MlR0ekRYVHNZYnBRSk1NYlE0MGVVTWdCaytXRmFqNkpONmdFZThkVFYwbjRZYW9pYkRZdWQ2RzdqWmRPNkNFcE5pT0VTR3poaUpQcFZXL3lEQld5RE5MbGhuS0l0UHptNU52bnIrK2Y4T0l4SmhjcGVLdE9NVmE3a0ZlWjZ3QWt1Vmx6MlpGamtpblBoSlEwVlM1YUx5cDRIN284Vk9OQk4vaVhVUHdEVzFUSVVZb3loNGlhU3AxYzdrZEtjc01hK3lCSzRMTnVvMjhTT0prV1VOWlpQVEtnclZSbjlHZ3gvcW96K3F3cEN4eWVrVk9ubVVZWTZSdVEzVjVlL0tOdWcxZXdVbEtlL0cyMjI2NzVkN0FaUVo1ZmNFQllDVFBpcWFabVoyWG5pS1RHaDhDM2puNmd4SEc1aFJsajd3L3d1UTlEQkZ0SzRnZTM5Wm9CR1BUM2JreEdhaERFTEtzSUxPV3Vyc2c5S3BrZVZvTU91Y3hJbmdmeVhPTGlOQTJIbDNwVTFwRDlBRmlaRlJhK3IzMDY4Wkl5aDY1WmRhNDg4OWQyWHMycHRMS0wrUitqaDA3eHVYTGw1Y0FXY1pyRzlYMWwrTHpYOWpYWm5wTlR0OStKR2xYaGNEK3ZqS3ZXakFaZVo2dUJLMHQ4RDZRNXptajBZZzh6OG1MRXB0bEJKOGFkVVhKOGdKck0vSThwekVPeVFMOXNvL1VMZDRIc3N3U1FwWUd5ZEdUNTRaQkw4ZUswRlFOL1V6b1pkS0owS1VzazJlaXczN21ucjY2OTdrbkwrNWVCMXozQ3NZWWZkT2IzblJMMks0dEFmSVhHenE5L3B3Tzczc0xkOTUvanJMZng3ZE51dFB3SGxWd3ZxV2VWYmgyU3JWZk1aM1h6T1lPc1gxQ01LeHRySEwwMkhIVzFvK1JGME9pV2x5bzZRMkh0QzVnYmN0Z1lERldjSzBqenl3Mnl6cWRyRVJPN1BkeWNtdlJXRU53RkFaY1NEZUt2ZElpb21UV2lBdng4aE9YZGo4L3FkeXNBNGNIb25OT1AvR0pUOXhTVE40bFFGNHZSS1F4NzBHRFlBeCs5Y2hHTEFjclZvTURFVFFvMFFmYU5qS3ZIYlVIWndVL0toZ04rcXkwTGVPZE1XMzA3TjNZNStyRkN4UzlJVVU1WkxTNndlcmFDdFlXNUZsQmx1Y1lNWVRnc1ZsR1Z1aEJReDU5SlBoSXJ5eHc0cEZCVHFPT3liUkJGUWE5akR3VEpFMjI0dlZ4OVpVdlBIUHQrUTRjclloNEVZbmFTWTR1ZTVCbHZDWVk0ZWFaYXR3ZU45ZThGTHMyczhlaVFGMVZiTjNZNDhaOHdzeTIxSDBJbzR6V2trUVdLbysxa2NHUmpLTU1XUE5LTzZ1cDZ4cm5haTYvdk1rTGpaQVZpUUp2QklvOHc1b01STWp5bkhaYUk2SVlLNWlzNDF3Vmx0Q0M4Mm1MbjJXZFVTZENrUmtFZHArN3R2OG4wOHJ0QVczM0NubWU2OXJhR3B1Ym0wdUFMT00xaXlpUzdwaWV2akMrdU4vcTVyRXNQNFpZTG03ZTRMeHVVWjJJU045UTJCNnFCaHNGRnlKdEdXbHM0SW8wUEZWTldZK1dZMFhHa2F6SHNiTFBjRkN6czFzeHEyZGN2ckJENDRYQllNamF5b2pNSnRtZW9zeUp3WlBuR2JhNWVldnV2WkpsbHJLSUIwSU54b0F4NkxUMXovL2hFMWUrdnNnZVFCQVJ2ZTIyMi9TOTczMHZIL3ZZeDVZQVdjWjNGaXNySzlSMXJkNzdxRW9Bd3BlK2VmSEdmTzR1aWNnRCsxdDdYSmh2TTc4ekVOV1F4NHhBc2xDekdHSjN0NUZPWUlVMlY2NWF6L1hnc1ZYTnluek9zY2F5WGxwV2pTVkRtRldPemEwdGJteHUwKy8zV1ZrWk11Z1ZTWG5SZ3BpVzRCWHZrdjVWa1djWVRUc1Nhd1FSMGN5YTV2bnJlNS9iM0s5dWlPQlZFMEJVTlpabGVjdHQwQmV4M0lPOHh2R0x2L2lMbkQ1OWVuR2k2b0h3NG9XdHZjM04vV2NhSDkzMi9wN3U5aXJtSVduak5oSDJKeTExRlFrS1RRek12R1BxUFBPUWRLMHNCcS9LT1BNOG04MzVYREhtTTR4NU9sUk1MWXhHUGM2Y1dHVjlsT0hhT2VjdlhPYUpaeTV3Yld1ZldaVTIrMFZSa0JkSlRDNWRHeVlsRXpHaTFnanoxbDM0OGt0Ym53dFJteTU3ZUdOTVVGVjkrdW1udVJYN2oyVUdlUjFpZDNlWHdXQkExMzhFRVh5SVdqLzcwdVlMYjN1NEdsK3RkbzY2bzRIS1JYSXJaQ0pvQ0hoUm91YjRXS1d4cXhVMnQrZHNESHZFa09nbXg0ZERmSmd4TTU0YnVlZHliREZST2U0c1ovT0NVOE1lL1Y1T1dXVHM3TTY1Y1BrYVdaYXpNaHF5T2lncGlvemcwcEJBakVIUzhsNnNSUzlzemYvVDgxZkhsd0NuU2lzaXdSaWpKMDZjNFByMTYvem1iLzdtTW9NczR6dVA3ZTF0enA4L3IxMUVOSTFLUC92Rlo1NTU0Ym56TCs4VVk2Sk50S3U1ZHlqUVh4bEFiZ2d4a3RtTVhsNVFWVjNmb0VuVHlzZklwRTNmbjF0RGFaS2JiVVhrYVdxK3dKU25CcDR3eUZsZjZYSDZ4QXAzMzdiT3FHZTVjV09iNTErK3hzdlhkM0dCZEVHNDBJVlBwN2JUeS92ei96aXAycmxBUTdjOTM5alkwQTkvK01PM2hKdnRmeTdzOHBGK2JlTmIzL29XL1g0Zjc3MHNXTDFBL3VLRkc3NC9VdGUvdjNqWUZReGRVSFZSUlZYb1ozMkNScHJnT29FRjRmS05NU3FSTENzSVBoSWlWQzUwUEs3a0graUQwcnBJamhBVnJ2aVdMUTJjSEEwNDFpc284b3dpTitTZGlOelc3b1N0M1JuVHFpVXpsakl6T2lpTlRKMzc2aDg5ZGZVVFYzZm0yOEI4VVdJTmgwTjkzL3ZlcDEvNHdoZHUyZmR6bVVGZWgwaCtIRUdOTVpHMGFHdWJ4dGYvOTcvODhoKzlkR252aTJKRVhWUjhGTVp0eGR4VkZMWThFRkR3SWJBM3JyRFc0cngyb0FHellBRURwUlZzbG9wa05ZSVZRVDFjYkd2K1lMYkhYaTlqZGRUaitMRVJHeXNsRzZNZXB6YUdqSHFHNnp1Ny9JZHZ2c0R1ZENaNWJxWXYzWmo4KzIrYzM3NjZBRWJIdmRLdHJhMWJTa1Z4bVVIK2dxSW9DbFpXVnZESlppQmxFY0UyODhEUk02UHluZ2VQdmk5QzdsVndRYWxjUXo4dkdHUjlyRlUydDhZODg4SU5OazcwaWRGZzVDYVIwWFNOUXdoS3lDS05WNklUYkJUYXlpR1paZHc2cnJjTmQ0eUc5SHhFUXpoUWNUY2lxZkZVejNUZVVCVDVrMTk4Y2ZQWFg3dzJ2dFpsajlvWTQxWldWdUtwVTZmNDNkLzkzVnY2dlZ4bWtOY2hack1aZitmdi9CMU9uRGlSdk03QW9UUkE4L3pYdHI2MWZXMytkRzRGMGFnaHd0d0hMbzYzdVRHZmtObVNpeGYzbVV3YnN0d20zNDZEcTF4QlNRb2xMaXF6SnVCVmlWN3hQb25HcVlJRzVmeGt4dWZHdTh5dHhTdU1Wa3FHdll5NmF2SE9jL3JJa0xLWFY5KzZ0UE1IbjMvcTJzdGQ5ampZblAvSWovd0kvK0FmL0lOYi9yMWNBdVIxaW5lKzg1MnNyNjhqSWdkbEZ0QTg5OVd0UytlZjIvL2oxc2ZtWUhBcXdxVDFYSnJzc0QzWjQvejVYVDEyWWtpV0d4cGltbW9oV0FFMGVRaEdvUFpLYm9VUU5jbGc1d1pRb2tCaERTOU5KbnhwUG1hd1BzSjdaVEt1Y0hWREpxcTlJdVBZMnZDWkp5N3QvbEVJY1U3WG5LdHFLSXBDejU0OXF3ODk5TkFTSU10SCtmV0pwbW00ZXZXcXhoalZHQk1XQUhHMW4vL3h2M3J4VXp0WDVsOHVyRWhwd0VneXJ1bVg4TXpsSzgyTEwyenZIRG5XaTRxUXg2UVNKTWJRZXZBeFlra0k4U0ZTWm9iQ21PNG90bE5pdElLUjlMM2YzTnJtQm9ISmZzMzIxZ1FyU3IvTVpEQW85NSs1TnY3MUp5L3RQaTgzYVNWZVJQVDA2ZE04Kyt5enQ1VE53UklnZjhIeDB6LzkwM3o5NjEvbkl4LzVpSklzbEVQM0tkMjg4TVhyNTUvOTJ0YnZ6ZXV3MTZyU0JpVVR4ZWFxRjg1UGR2TENidlVHR2RPOVFKZ3JFaUtaTWZnQUdoT3hNQ2k0TmlLaVNVK1hCS0pNaE1KYUNpUDRjY09ORjdkNDh0a3JYTi9jUjVLVXFRNzZ1ZCtmdTg5OC9wbXJuNCtxdFVMVmxWZEJST0sxYTlmMG9ZY2U0ajN2ZWM4U0lNdEgrZldMNTU5L25zY2VlNHpSYUtTYXpsWWRVQVBOdi8rMVp6NTc4Zm45enlEcVZhTVdoVkExMFgzejg5ZWVPSDZxMytaNVp1b3FNQXVSaVlQOW1hZXRJMFJEakVsYkt6aGw1cFUycHR2MUxEY1FsTm5tbUswWHR0aDZmcE5tWExGemJaL3BaRTZXRysyWGx0cUhMLzdCRTVkLzlmcmVmS2RyekJ2QVcydGpVUlRVZGMzT3pzN3lEVndDNVBXUGYvU1AvaEZsV2I1aTVDdEN2WDlsZHVQenYvM1N4Nlo3elZQRFhMQVdibXpXODUyWHgwK3ZuK2dYeGxqeUxMazl0VUhaMzZ1Wjd0WE1LcyswOWt5YUpOK2pkWURkaG5hdlllZnltSmUvZEo0TFgzeUp2WmUyOExValJtVTJhYkFDUldhWTF2NUxYM2oyK3E5ODZZVWJ6eTJtVm9EcnlrRHQ5L3NhWStSWGZ1VlhsbS9lRWlDdmIzendneC9rNFljZjV0NTc3K1hvMGFNTGtEaFZLb1RxaWM5Y2ZPcTVMMjMrYWc0N1Znd1hudGg3ZW5XOW1KeTZZN1JCU0lyckN6cTZXQXRGeHR3RnBrMWdiOWJpS285dkF2c1g5cm4rNUNZWHYzeVJ5OSs2UkQxckVDdW9FVXhFalF0WUk3Rng0VS8vOE9sci8rc2ZQbm50YTZTeWFyNllYRmxyNDF2Zit0WmJ5aHhuQ1pEdmd2akdONzdCOGVQSGFacUc3clk3VGJTVU9VRm5mL2hyei96N2k4L3MvZHJ1VHJ0MTVhbWRMeHcvMWZPRGxkNmdhb05pOUVEMzAxaURGNUpGc3c5TU5pdWlRdDFFbWpiUXpCcmNwS0xzRlpUREhvaW9FVUZCb3d1N3U3UDYwLy8yNjVkKytZc3YzUGhHQjQ3Wm9qRUhZcFpsVEtkVDNkL2ZYNzVwaDJLNUtQd0xpS2VmZnBxelo4OHltVXdXbjlBSE9vck54TFdYTDAyZjM1djZhMWUrdGZYbGV4NDZjdmZ4YzBmZlA1MUZvNGc0YjJoRFRLUGNoVE90YzJ4ZEhHTldDb3FnVEsvT21lM044TE9hc2l6bzlRdk55Z3dmOUZLOVcvL2IyWTM1SjcveTB2YkhuNzh4ZVVGdWdxUHBza2ZzSmxjNkhBNXZ5YU9vLzY5WXNubi9na0pWYWR0MmNXVkkxN0FyRUs1OFkvdmFsVzlzZnhJbzMvbjRtWWVzU0p0WkdUU3Rhb2hSUXFkdGxWc0RNZEs2Nkh3YkpyMWV2dHJjcUxMWjFwUjJYS2tnWW5KRE5QaHE3cjQwdVZGOWJPZmw4VmRpMUwzRmNFRFRqMjMzNTBkVmpSMng4cFltSlM0enlIL2wyTjNkWFh5NTJBOGVQc3M5VUU1dkEvdjlqWDVaOW9zVFltUVl2Sm9ZWWtkWWpFU1VhdDd1WFg5NjZ3dkgzbkwwOVB6eXVMZnp3ZzJpZDVLWFdTMlpmWG15My95THJaY24vM1I4YmZZdFZjWmRyN0ZveUJkbFZUajA1ekllajdseDQ4YnlqVm9DNUxzcTRxdUFFdmV1VE9mUC84Y3JYNTNPM0ZNbXM5TVFWVUxVdk5YWWQ1a2lHZFRielpWTFg3NzZyNCtjMjdoci80V2RFOU9yNDAyTVBPbWIrSzkycjFYL2RPL3kvUGQ5NVRlN1VtckdUWWJ1Z1VvSnQ2amZ4MzlweVBKL3dYLzEvLzhIVmdra1Zlc1M2QU1GTURyMTRJbTdqci81eUp2eTQvMzc4clhpcmxHZUhaOWZtVzgvK2Vubi83ZVRqNXg0cE42Y25Oczl2L3VWdHRHbm1wbS8zdlVXZmxGU2NWUGJLdkpLK2RBbE9KWUErWjRKY3dna3RnTkgyUUdtSTdWVERFNE9WMWVQRFFmNGFHKzh1SE1OUldOVXIxR3JRd0J3aDhxb1A4OEFaeGxMZ0h6UGdrUmVCWlRzRUVqa1ZmMkxIQUpGN0lDd2VMMjZ4MWlDWXdtUU45UjdzUUNMUFpSZHpLdEE4bWY2bDBNL0YxODFDRmpHRWlCdnlQZEYvcHdYZjg3RHI0ZEF3N0xIV0FMa1ZtN29YLzN3TDRId09zYi9DNnlQUlNER3ZNWTdBQUFBUm5SRldIUmpiMjF0Wlc1MEFFWnBiR1VnYzI5MWNtTmxPaUJvZEhSd09pOHZaVzR1ZDJscmFYQmxaR2xoTG05eVp5OTNhV3RwTDBacGJHVTZWRTFPVkV4bGJ6SXdNVEl1Y0c1bkpYSEdGZ0FBQUNWMFJWaDBaR0YwWlRwamNtVmhkR1VBTWpBeE15MHdPUzB4TmxReU16b3lOem8wTVNzd01Eb3dNSTFjd21BQUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNVE10TURrdE1UWlVNak02TWpjNk5ERXJNREE2TUREOEFYcmNBQUFBUm5SRldIUnpiMlowZDJGeVpRQkpiV0ZuWlUxaFoybGpheUEyTGpZdU9TMDNJREl3TVRJdE1EZ3RNVGNnVVRFMklHaDBkSEE2THk5M2QzY3VhVzFoWjJWdFlXZHBZMnN1YjNKbm5MMjVTQUFBQUJoMFJWaDBWR2gxYldJNk9rUnZZM1Z0Wlc1ME9qcFFZV2RsY3dBeHAvKzdMd0FBQUJoMFJWaDBWR2gxYldJNk9rbHRZV2RsT2pwb1pXbG5hSFFBTXpremU0T1dmUUFBQUJkMFJWaDBWR2gxYldJNk9rbHRZV2RsT2pwWGFXUjBhQUF5TlRKOVg5QmRBQUFBR1hSRldIUlVhSFZ0WWpvNlRXbHRaWFI1Y0dVQWFXMWhaMlV2Y0c1blA3SldUZ0FBQUJkMFJWaDBWR2gxYldJNk9rMVVhVzFsQURFek56a3pOelF3TmpGTlR0Z2ZBQUFBRW5SRldIUlVhSFZ0WWpvNlUybDZaUUF4TXpKTFFrSmtKL3luQUFBQU0zUkZXSFJVYUhWdFlqbzZWVkpKQUdacGJHVTZMeTh2ZEcxd0wyeHZZMkZzWTI5d2VWODJZV0l6WVdNeE1UaGhZekF0TVM1d2JtZitjdWJqQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nXG4gKiogbW9kdWxlIGlkID0gMzAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQb0FBQUZmQ0FZQUFBQm5TdEhVQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFCSUFBQUFTQUJHeVdzK0FBQ0FBRWxFUVZSNDJ1ejlWNVNsVjNZZUNINzduUE83YThPYjlBbGtKcEFBRWxVQXFncFZLTy9KWWhWTlVTUWxVcVJJaWFUWVRXbWt0ZFRUUFEvek1QTXc4OUF6YTdWbVRTOU5zOVdha2RoU3k1QXRpaUlwMnFwaWVROXZFa2p2d2tkYy83dGo5anljLzBiZURDUktwTWdxQXFpNzEvb1JpTWdiY1NQdS9iK3ozYmUvVGZqZUd2MFpIOGVZMnRTbTlwZG02bnNJY1BvT24wOENuS2VnbjlyVTNqaEFwN3Q4RkJNWHZRYklYWFZOZ240SzlxbE43WFVJOUlQZVd3Q1E0NDlFa05YbkJJQUlZQVlzTXl4d3grV20zbjFxVTN0OWUzUnhBT1FCQUVWQXdIem44NDdSU3dUTGpCS0FtYmpzNU1OaUpaQWJOMzNucGphMVA0Zko3MkkrUHZiYUNrQkUvb29aaUFDRWgrYUMyWGZkWDErNWR5V2FxMGV5dHRrejQxQmQwZTJJWURKMFp5VUlwV1g4OEZzVzhQSm1PbjMzcGphMXZ5S1BUZ2R5Y1FVZ0pFSU1Sc3hBY09ad1BQZmZmSHJwM0wxSDRyZUhpYmlIQ1FJR3U2T3Vmdll6end5ZS9YLytoNjJYQUVnQ2lDZENkZUdoNzk1K29zV2hFdE4zYm1wVCt5c08zV2tTNUFBU1ppUUFnaDkvOTh3OS80Y2ZXZnJrQThmaWo4ODI1VEVSQ2NYd0FYbzVzaDg5ZmpnK3Y5QUsvOFgvNmRkdmZwYnV6UE9aQVhZTTNobHFCSkttdWZyVXB2WlhGTHBQaHV6N0lBY1FBMmo4di8vdWtYZi9uUjlhK1BtSFR5U2ZxTWR5QlE1a0NtYVhPWVpsU0taNHJxR09MTldpbzJsZlhubnF4bUNyT2pEdXFNSjNVb01iblFJQThKR3o4N2k4azAzZnhhbE43WHNNOVAzQ0d4RmlBTkdoMlhEdTEvNyswWS8vOEx0bWZ2SElZdkM0QkJKbndMQWdZaENFb0VGZjBtQW9tVXRBajhKNWFhUHd5UnU5NTN1WlNha0syVEZ1dlJHWUNQenVVelAwbGVzRC9OSTdWL0h0NjRQcE96bTFxWDJQZ2E2SUVJSVJDVUx0Zi83N3h6LzY4YmUzZm5HbUtjK3lobVJMQUJNUkEwSUMyVUJpYjF0aW1DbnFqUVJ0N1pJVXBKWlgybUgzVDEvZXV6amgwZmM5dXhURWhYYjRhdzh2VXFnRXZubXRQMzBucHphMTd5SFFKUUFsQ0JFRHdZUEhrdFZmL2ZUU3p4MWVDQjUzQmdJV0pLUUhlSkVUZHJjVnV0c1NrZ2hwQnR6WVpIUkh6S0VVU1R0V3MwbElsNTY1T2RpbzhuVXpCanFCa0dybm1JRmhibEE2WUpDYjZiczV0YW05aHFtL1pLQVRBSExzeVREdmZiQzVWQS9FRVhLUWtwbEpFYXdoN0hZSVY2OUxqRVlDa2dIdEhEWjdGcVBjSVF3bE1ZTm5vdUMrZHgyZi9kRnZYTzJ0bmQ4WTNTUkN3dXlCN3BnZE1jUnphME5lYUlZUU5DM09UVzFxMy9QUUhiNFFGLzdDUnhZZnZtKysvdUdBNWF3dWdkRkEwcVhMRWxldkNYUUhoS3hrYlBRTnJ1MW9kSVoybndlbkpFRVN5Wms0V0Zsb0JGdGZ1TlM1N0JpT0RvVHdET0pDVzR3S0N6ZUYrdFNtOWowRmVqQUcrOCs4Ky9BVERWWC9RSDhnazUwOVJaczdFcjArb1VpQlVXNngxZFhZR3BoOXBwc2cvd01nQklHSVEwRkpNMUpMY1VpWG4xOGJibFo5ZFhzN2hBYzdCb2dJUEFYNjFLYjJQUU02VlNBUEFJalp1TFo4ZEs3K1dETUo1ekpOdkR0MHREYzAyT3hxck8vazJPdVhzTmJCVlNnVlFvQ0ZaNzRMSXBJRXpOYkMyU1FROW1ZdmUyR3pYK1owQU94U0VMdnFCMFJLd2s1ZCs5U205ajN4Nk9NV203eXdNZXJwMUM1ZXVqRzQvNlZyZy9DRmF3Tyt1cDdSN2tDanNJd1NETXNFZ0VFZ2tBQkFCQ2tJUkFRUW1BQXhVdytPaGtwc1AzdHJjTGt3em1CaXlvMTVYTU1IbEJDNGQ3R0ozVkV4Zldlbk5yWHZFdEFudmJvQUVKVE9tUXZibzh1WHIvV1hyOS9xM3R2dHAxSmI3M0ZKRUZnSUVQbHhObEdoVjRCQWdqei9sWWtjNEFJbG9wbG11TVRnOHkrdEQzY09odkNvR25aS0VzMGs0UlRvVTV2YTl5QjAzNzhJQ0RWelNRSTM1aFZPUy9BcU00TklrQkFDU2doSVFWQkNRRlNlWElKQUZZTEJBQWtpeTh4UkVpd0lKYkRUejEvWTZwZFo5WkF4MkIwUk9KUVN6VmpSM3FpY3ZyTlRtOXAzRWVnSFFROEFRZUV3RElBc0pENE5kbTBpSWlVVktTa2doWUNTb21xK0U2UUFIQU9HL0VtaEFJU0JCQk93TkJ2ZlN3TGI1MjhOWGk2Tkd3UGRBbURoZVhab0p5R21RSi9hMUw2N29mc2s0Q2VCTC9zTzF5TkNrVWkrajlrMUhJTklDa1JTUWdtQlVQcWVPaHpBQW1EbDgzVEo4R1YxSWxhaGtPMGtXTkRHUFhWcGE5U3BoQ3I4ekRxUkUwUzgySXl3TTV5RzdsT2IybmM3UjYrQzdsZDVkOW16dUZhWFJESHhXY3MySVpLc3BLQlFTYWdxVDNjRVgzbkg3ZmsxY29BZ1VNbkFYRDFjbUswSHlhMU85dTN0UVpIaXRqaUZBOENGZGx4TWhTbW1Oclh2dWtjL2FHUFFDd0RVTjdqU2xsaFN4R2NZRUVJSUVrTDYvRndJaU9yUjR5b2JpRURqNFhSQnBBbFlhRVpIalhVM0xteU1YaTZ0MjFlaVlZQUxNKzJ2VFcxcWY1VkFCd0hDQVRhM3VGa2pIQlp3Snh3QUlTUUpKUkNROEcwMTRUMjdvNnJOTnY1dThsOFhrbFJhT25WaGZmREgvVXpyQ2EvdVIyYVVoSXdDc0xIVGQzaHFVOE4zWCs1NUhFTnJBSUtyTUw3dmNIbXR4UDk4UkxoWklZcUhoMUk2SVVrSUVCcGhnRmdJRUFBbUI4Y0FDd0hEREJZTVJSWW1FQmhtMWhYR2pmWG45dFZsR1hCZWYyYktmNS9hMUw1WEhwMWY0LzlWenVnb1lEc2gzTS9PenRyS3MwczU5dXErN0U1VitPN2ROU01VRXJ2RGN2dmJWenIvNGNMbTRJSjFYRlFIeWRpcjc4dEVDMFZnTzhYNzFLYW12c3NncHdtdlRtUFBYbmxlc2FIeGpZRDQxK2RoL2g0b1g1QkNNQWlrQ2FoTGhZQUJab0VDRGhFSjFFRHU2dllRMzd6ZWVmYjVXNzJuQzIxRDlnTTBDcmZscElrZEU1RURGSEVZaHloejMyNDcrL0JESUFETnBJNG9ETytzR0JMQkdJUG5uMzhlL1g2LzRzL2ZlVWlNMDRoNnJZYUhIejRIcFFMc2RidDQvcm5ucG5mUzFMN3ZjM1I2RGE5T0RDQjFXSXNJSWdBL2Fxd1Jqb2hrb0VCU2dJVFlCNWh6akF1YkEvUFo4NXZpcGMwK01tT2ZCbUVidDRreisvUHE0NmVTUWtJSUFXc3NRSVNkelMwc3JpeFRISVFVaENGSktja1hBd1VwcFlpSWFITnprNHFpbUNUKzNGNDI0ZEZQWVJUUzZxRkRwSUtBOGp5bm5aMGR6TTIwOFk3SEhzYTFHN2VtZDlYVXZ1OXk5RW1BVCticiswQXFHYlNoOGI4cjR1VVptSjhZWlRuTE1BQkpBUkNCbGFCMG1QUGxuV0h2L1Bad2MzZFVMalBqSkFUOVExTDBiMWk3L3dSR0NDOGp2Uis2TXdOR1c0ZUpncHdRQXRjdVhZSHczcHVzdGZ1SFVPVzlpWWdvREVNd00xWC9jTHZONTBkalVaYWF2L1d0Ynp2blh0M0drMEx3ZXg1L0ZHOTk4RDc4di82WGZ6Vzl3NmIyZmVQUi83TWVYek1LeDdnU0Vab0tmTWJBa1FOenBnMnU3dzdwMlZ2ZDNZdTc2ZWNIaFZrQ2FCbUFCR09SZ1BzZ2lPSHdNZzV3M3cvRUVBU0FtSm1NMWtKckxaeHp3amtubUZsV2wzTE9LV3V0Y3M1SjU1ei95RTd0Lzc5enlqbVc0Kzl6enBGempwaVo4cUxFcmZVTllqQ09yQ3pUM0V3YnpJeHo5OTJMUzllblhuNXEzMzlBdjJNcHcvZ3FHQU1XOUlvVXBDM3pxRmVZcjE3Y1NYZXU3T1hMbmN4SWJWR0hvRU1BUnhOUlFRdEVKMG1LRFRpK2NwZS81MkFJTGdCSVpsYk1IRXg4REpnNVpPWUFmc1EyQkNnRU9LdytyNzYyLy8rU21jWDRxZzRSZ0pta2tMUzJ1WVVYWHJtRWRyTkJSTURheGphVUpEUWJNWTZzdExFd1Y4ZGVkN3FBWW1wdnZ0RDlvSTN6YWozK25BRzdvL25LeU9KL0ZMbHRHYlpVV0Q3RUFCSGp2U1J4VWdhQnNLVW1KakNZTllGQ2RtaEM4aEVBOVNwOG53UjFlY0RUVDI2UWtVS0lNZWdGaUlUdjFETUJFRlhvZnJkRmtOWlgrbUFBdHN5M1YwYzVadXVNY1ZJS1o1M2pGMTY1NUh6a3ozRE9hOTBSRVdaYUNlSW9SRjVNT2ZsVGUzTUNmZEtiandVZngvbTdaWVpOTFd0WVpBQnFBRklBdjhaQVFveTNPMk9wK2draGdicEpzeVZVR0pIT3NxaHdhWU1JaHFTQTFZWXFUeXVydzJTY3FGY3F0YVRHb1hxejBaUXJTNGVDcTlldlFadDh2M0ovNXZROTBlbFRweE91QW9MK1lLQjd2WDdaNmV6cXRiWDEwam5uaEJDR2lEVXpERFByNnJtTXRjNENjUDVBWU1zQWcwSFdPZGJhNHRyTkx1ZEZpVmF6QVFMUUd3eW5kK0xVM25RZS9XRGJiYkpZTi9ieTQ1NTRIY0FGQVArTUhjK3lzMmVxaUp3Z3FOV2VXNlRUYjNsWFlyVCsyQXZmL0t6VlpXcWtDbHllcG45aTh2SVNNOThWNk13Y0xpMHRoUi83eUVlVzd6dDkrdXppUW5Mc3E5Lzg3TFZYTHI5OGJaVHZjU2htMVgvN0QvN1A3MzNiMjk3NVljZ3dKRUd5UHhqY3ZIbmo1czNybDg1dlBmL00wNjg4K2V3THIxeTd1ZGJ2OVBvbXk3SXh5SFVWUldnQWhwbHQ5WnlPQ0c0NEtseWFsaXlsSUNrbFN5TDBSeU1zTDg1aWM3c3p2UnVuOXQwcmhQMFZQL2VZNExyZlc2Kzg4TGlLWGdQUXFQTGlYNEhFVDhNaFJ1Vm1neWpDeXBGN3pkTFJrM1RqMm90dWIrdUdKU2dpZ2E4S29YNWRwOFhUVnV1ODhxNm92THo2eUljK05QdFRQL0VUNy9uUWh6NzhDVUc5aHkvZS9MZDFSSjMrK3ZhTkYwZjVzRGc2ODdIbzhZZC80Wjc1NVNQTHFQcnArU2pGenZWTExoRWFVU2c3WC9qSzE3LzY3UG1YWHlySzh1cnpMNzc4OGg5OS9xdDd3MUZhM0EzdzQ0T0xpQ3dBeDh5T2lEaUpJeGhqZUg2dURXc010blo3MHp0eWFtK2FZdHdkVmhIZ2dEc3I1anp4dVFCUUFKZ2xRVzhoUWMwSzZIRE9jcit6MDkyOGNhbE0rLzI2STZ0SXNoSktuVkJSOUZhaFpHWkx2UUh2MlpNZ0RKTC83ci85N3g3NjVWLzZwWi81b1UvODRNOGtjWGptMlJmL2ZiaVpmNDVrczVzMEZ2aklBL2QrNU1TakQvemMwWm5Ha1FaYkF5S0IvbDRIYXhkZlFtQkhOTk5xVVdjd3FBLzZPMmVjeTk4eDE2NC9rVVRCYVJKQXMxSFgvY0hJYUdQRzJubVQ5Tnc3Y240aUltTXNCQkdVa3FTVWhISWhjak1kc1ozYW13em9OVVdRZ3FnZXlDcEp2d1BvazRVN0NXQVhEQWJqT0JqdE1XaElDS0VDWlFIRWJCMVVKRFViVHEyekN5QjNtQTFmZytOK0VBVEozL3Q3djNydUgvNkRmL2lyWisrNzc0T0NVYnQ1OVR4Zld2czljcW9naWdRM2s5TjhadUZ2b1IyZkJzTVNFVlBhSDlET3phdlVqb2thalRwOTladmZvTi82NDkvZ1AvbjI3L0RWamZQeXd0V1g2anVkalh0YXplUmR6VnA4b2hiWG9uYXpZWXVpNEtJMDQ5QmRZWko0YzBDa295d05DeUdJbk1BRFoydDQzNFB6ZU9IcWRNM1UxTjRrUUpmVkNLb1VCT01ZVEhmTjU4YzVmUW5nV1FBREFIVVF1aUJjSU1LOGlxSVpFTEV0RFZuTkcwN2JwK0c0Ym8xcE8yTXZBRmovcFYvNjVmdi9tMy8wai83bTBhTkgzOEpsS1lhZExsNjU5RVhSYzk4bUVoWngzS0t6S3o5SnE2MTNFYk1ta2tSWm1tTG41bVhVbFFNRCtOSTN2b0RQUGZWYlNJNXQwOE1mV0tEN3pzM2dubk5OSERvZElXcm95TGp5WkJRR2o0UkNuSTBDY1N5VVFqQWhMMHBqY0RzdEdYY0YvQi9JbmlHb3RXRVpDbHBkRG5GOFBzR0xWd1pveEFxNW5zN1dUKzBORG5URGdIRkFZUm5qMlJPK1RYQjVyWUdZQ3hYZ253UHdSUUN4cy9hc00yWUV4Z3NRR0ZCSWZPVGsyZmJ4MCtmbWE4MlpmaEpGMlgvMXk3LzRrYUxNM25YcjFvMXdmbmFPUm50YjlQTG03eUZYMjdBc2NYem1YVGl6OEVrd000UWtsTlppZC8wR0VpclI2KzNoYzkvK0Exd2FmQTczUHc2Y1BsZEhheFpvMUpqcWlhRDJqS0xWb3pHT240NjV0Y0JSWEpkSEdvM3dMVXJLY3dIa0lTbUZNZFlOamEvR3F3bWdUekx6eUxBRkdOamVLNmc3MEdqR0FRYTVRUzJTZU9MZVdUeDZySW56RzZQcFhUdTFOMTZPL21lMFNRb3RBZWdDMkFHUWdhQ0o2TU1nS2dCK0FRSnpCSHJIN01KcTg1NnpqNHJaaGRXVnZPamN1N085ZHZvLy92WnZORC83MlQra1FhZURRdmVRTjE0RTRod3hyZUwrOXNjd2s2ekFPUVBJQUx1YjYrQlJCOTNPRGo3L3pPOWowUGcyN251SHhNS3Nnb0tGSW9lQUdTSjNZTTBJQTRkMmsybjFjSXdqcDJwWVBsSkRleTZhVllvZVlrUDNOV3UxeFlYNW1iSTN5THJXT3BwNDdXL3o2UmswR0Jsc2RnczRCbzBLQTJaUXFBUk9MZFh3Z3c4dG9KTlpuRjVxNE1yT2xIQXp0VGN2ME1mWDVLQkpqWWgrRUlyYUFLL0FZZ0VXNGFDM1J6dnJOOHBSdnlOM2QyNnV2SFRwcGRwdVo1ZlcxemZ3OVc5L0V5OWZlUm05WVErekN3MmNubjhiVnFJSEVRUVJnbG9EZzhFQWc1MmI2TzV0NFdzWC93UnU4VVhjOTdCQXV5WkEyZ0hXeTFWSEFTT01HVElDL1B3Tnd6cW1RRGxxdENRV0RpVTRkTEpHUzZ2eHZDRDVvTTF4MzB5ckZXakxHMm1XNjhxNzA0RkNuUUJETUh0aEhTa0lETkRlU09OenIzUm9wUlhqZi9pcEIvQnJuNzgrdlh1bjlxWUFPazJFOEhlN3hxQXYvZWQ4QW93Rk9JUWdnSjFETmh4d2QyZWp0R1VoSExPd0FtaTNaaENKR0JjdVhzV3Rxd01rWWdIdmYrdkhJVjBkU2JNQkpzTFc1blhjdW5FWkw2eDlGZUdSOHpoOW4wTXRKTUF4U0JBVU1jTFFRY3BxTHhSVnMvUENiNXh3UkNEQkZJU08ydk1TUisrTmVmbG9MRlZNSzJYS1owM083YkowMTBwak5CaEJKWmMzenVIRmhKY1hESkJ6VExteEtJMURwaDMrOFo5Y29TaThMWkU5M1U0enRUZUxSNThzekFGM2pLT2lBUEF5SERiQVdBQ3dDa0NEY0FzZ2hLRnF0bWJhUXVlV3ltR0J0ejM4Q1A3UnIvelgyQjZzNDlxMWRVZ1g0N0g3SDhYeTRqS1NlaFA5M2hCWExwN0h4Yld2SVQ1eUhpZE9HeWdpYUVOd0xDQUVRMGpBV2NKb0pHQ1pJQ1FnaFg5U1F3SWtDVUlCckFBcEhLTEEwZXlpd3JIVE1jK3VoSFVRblFvUXoyMXRaUmUwTlRuOFR2bElDbExWSmlySnQwRy9IOVk3QU1QQ0VBZ3dsaUVGVVNRRmxsb1IrdE8xMFZON2s0VHVCd0UvZVpVQXJnSjRwY3JmbndQd242SllYb25pY0JWU3pqcnRjT2JFdmZpcEgvNVJuRHAxQXM5Y2ZoNDdYUTBXTlVSUmdOV2xWUWdLMFVzdllLZjhHc1RDeTVnL2JtQklRZHRxWkJhQUE2RTBoRHduV1BpTk1nSUVFVEFZQkNFWlNyQmZHRmtKMllwcXUxU1FDRnBjVW54aU5RNk9MOWVPSHpsVW4rc05zN1ZpWUlXMlhEZ0dLbW1zVUJBRm9BTmdueWplQ1VGZ1pncWtRRDFTNkdYNmpoZE1DQWtoRmRoOXI2djJkeHNScUV3RjhLZmt0Sk13QmZwM3ZvTmV5OHVQcjEwQTU0bHdBY0RHdldmbitOaTk4dzkzZDRiTDJqajg2aS84SWo3NTBZL2oxMzc5bitPem4vMHlWRnlINFFEblg3bUl6YzRyV0Q2MUN5eCtBNjV4RldHYlFZR3NZbWUvdGxVN1FtNUV0VFlLVUNGQWtzQ0c5b0d0d0lpVVF5SWRBbUk0RUxRVEVCSkF3Y0MzTlRXdVdNeU5vSTRsd2ZGUG5sdDg1QWZ2VzN6b3hIeXlVbzlWWTZFWlJBRGNJTGVHR1FFUkJVUjN0T1dxYVRuL1VWdEdQelA3ZW56ajE0cElFQkc5RnREcE8xeC9Ya1FmdU9pMWY0YVFBSmpnM0YvRzgwL3RUUXAwZkljYlliTGZibEdOdnJ6amd5Y2VQbm4vNG50dlhSODBPNk1VTnpkdTRPVkxsL0RWYjN3VDZ4dGJ5SE1EUlVNODhzNEFIL2wwaE5hUlhZeXlGUG1RQUNNZ0E0OHFhd0RucDFGOTZDNEFJUmkzTjdZejJCRUNWUjBLRUpBQ2tPUi9KUWVDMHdSNlVzTTlaMUIySEhIbXlJMmdPTU5DTE9XeEIxWWJENy9uMU96ajd6c3ovOFFUOTg2OTY5NmwrbXloM2FDVDZzSTRsb0lvd0oxTExPOFl2eVVpVVlGc1BIc1BmbTFBaWU5dzBWMGlpSU5mKzg5OS85MHY1d2pPL1htZSt6djkzblNYMzNGNldMeUdxVGZZNzhzVEJUbzM4VFdMeVRGVXJ6Z2ptRldOaEVyYWN6RnZiZ2xjdkhpVnJsNjlDVnRhMUZzeEhuaHNGcC8rNjhzNCs5WW1CSVZJTzRDelFDQVlOZ1N5M0krVkVnQ2xmRWhPKzA5RElHSTRKbkFGc1ZJVFhQV3ZoZ25rR0pBRUtSajhpa0grZ2dhWC9qWXROVkJhUmorMVlHWlpDMlVqVW1nbW9UaTgwa3pzM09uNDdVL2NNL3ZKcjEvcC9NSHZQcnYxMll0YjZXWmhiQUJHd1Q1VktlRzE3UDB3a0pmSWNRY0tsUXdpbmxnZVR5QVN1RDJDTzFud3ZIMWcrakZjcm40bTM1YmN2ZzFFdnZObnZDckNxamJjSGd3bnhsT0YzK2w3M2NUMysrOTVMUURmK1RjZlRQRytVL28zOWVodkZNOU9SUEQ3MXU1NC8wVVY1Z1lBMU1xUjJiZTA1aHVQSFQ4MUZ4ODdQb1A1WklFNnZTSG1Wa0o4NnFkTzRHZC8rU2hPbm0xQU80bDBBTEQxYWFTTUFDY0kxdnBDV3lEOVBjaVc0SEpDdGdzVVE4QmFBVllFWndtV3laTisySDg5THdWeUxWQTRBYnJtWUw2bDRZWU9JSWJXUUQ5enlEVWprQUtoSWdxVm9FRDZZOFVDNUpoakNiRjBacW54MkR2dWFaK3RSVExiNkpmYm85SktnTVk4K3JFbzV1VG40b0RuSCtmNWs0OEpEbngvY09DeGsxNVRIcmlDdS95TWc3L1AzWDZIZzg4ZmZJZnZPL2ljZC90YjVYOG1vaEFIRGdmeG40a0tweDc5OVZxY2M4d2tpTnpFY3BkSm9VZ1FRWlc1RmtxRldEMDZnd2RPTE9BOUh6cUs1dkVCN2p2YlJCaFo5UHNNa3hKZ2ZEWGRnbUMxZndJVk1FSTRCRVF3MWpzK3g0UXlFeUFCa0dLNGdhOHRzU0JmSVBOWktJaTlOMWU3RHZycEVyWm5ZZG1Yem9lRlExWTRLRWtJQTRLU2hFZ1JBamtlNkdOU2tsQm9wa0hoNGxZWXZ1T25IajE4OXZoODdUZC81OW5OLy9qdHE3MHR5L3RUY3Z2VGNSUFg1Sm9xZDVmUTFvUEVqL1NOUFQwVE0vT0JMYlVIUE9FNFRaQUhQUFBrKytJT2ZPK3J2bjhpOVJCVk9NSGY0WHRmQzdoM2UveHJEVWI5V2IzK0ZPaXZPNlF6bzkxcXNITk1nK0ZvVXA2WnFxcTBZTU5Cbm1vQitQQjU1ZlFlamh5S0FkbEVmK0FnaDRCSkJWQXlsUE92aHF3REpBRjIvbzR3a3VBSFhjZDVPaERQTUFRWXhoSk00UlZxYlZYMHBoQmc1NzA4d0tpL1hLSmNOM0RzWlhUU3dpRXZISlFpeEVGVnlXZEFTRUlZK2kzeERJSVNnRkpFVVFpTU1rZTI1UGJianMzOTNISXpPalhmMlBxTnI5NDBtNFhqUEJEb0tSVWFaMTNoMk5veXozU2VqdlFFNkE4Q2hrQWt3VXlWOENVUkNiQnpEa0lBYm45TExlUFZqTVJKOVIxWlJWQVFRcEsxbG9VVTdLeWJQRndtQVVZSG9nUkJKSWozUlh2NXRZQXU3bExPUDFpRXRYY0J2RDN3ZFl0WGF5Qk1nZjVHc0R3djRad2I2NjFQbnZ3U2hNQ1VMRWtMdEZvQ3g4N0VtRjBJWUt5RDcxd0RMZ1ZzeWZzeU5FR045Z3RzempLY0Jrd2h3RG1ERkNBVkVDZ0dTVWF1QlVydHVmbk9DWWlLVEZNT1BYK2ZCQ0ZlTDJHdkZiRGF3VEpoVkRoWTU5Q0lKVWo0U0tBd0RsRWdZQUNVamxHUEpjS0tMK2QxNklpU1JNQm94NlBjQmZmTTE5Lzc4MDhjdmFkOVJldzlzeXRMQjVIRllVVEdtTUphNC9Kc2RHbno1cFUveVBxOUszZUNnZ2hnMjVwZlBERzdkUGd4RURXSWVTaWtaQWdLNEZ3bWhJaExZenFEM2Eybk81dHJXN2lUc0NRQWNCZ0d5VVBuSGp2WGJMWG50R1BGMWdobXhDREt3ekJzZ04xZzdlYTE1eTVlT0gvOWJvWFV4U01uNzV0ZFhEbnJuSlZoV0lzQVNPdE1DSEJxaTd5N2MrdmFON3FkbmUySnROSkJVSzAxdjNncUNHTUVVa0hyc3EvTDNGbHJzMUd2dXd2bWNnTFE0d2puNE9lRU95WEI2ZnNKN0c5b29CZGxDVUVFSVlpc2RWVklTQXBnRllkUitMRjMvMEJ5OHI2YVNKT1hZWUlTeGhFQ1loQVRobHNXemhLQ0FMQ3V1b3NWVUdhQVpVSlVaWUJHRThDQXNJQ3RQcWNTU0hOQ2FYeVlMb2dnbFQ4d0xBQXJDZUhBUUYwdllETHI5YktjTHljMEUrVjN3RHRmWmhLQ29CUkJrSUJ4UUdrSlRNTFg2Z1hCdXFvYXBRUTE2Z0xXc2pnVWg4ZCsrUkU2OXJzM1lueHRLemFEVVY3R3RUcUVrZ2lTMm9jYzg3azljZk9mRHJ1N0w5LzJZb3pHN055aEkvZWMvY1c1NWNNZkQ1SWFtVHdUemxvZnhBT1dIUk9wd0psanAvNzAya3RQL2RQMWE1Y3VUWUloVURKKzlMRjNmdmlSdDcvM2w2VlVxMWxlc05ZRkhMTlNLbkNCQ2tVOVNmamt5VE9mWitmKzZhVkxyMXlZOU1ZTGg0L2Y5K0RiM3YrcjdkbUZ4OUpoRDBHVVNDR2xjTTdDT2VOTW5nN0RJUGhudzBIM040d3hYZ0NVSU51TFM1OW96aTc4VFJYR2MzRVFvU2pTVVo2TmpMSG1ockgybnhXRC9wTUFoSlFJR3MxNld3ZzVHUFJIdThiWTlFRHVEdHlXTC91K0FydDZvLzhCREFoMisvcHc0MEtQL0p1Zi91RjdmL3pqUC9hV05Ud1p2N3o5SEpzQ3BBVERLcUJJR1VYS0VJTGhiQVZVQXN5SVlSMVZwUzVDQ2IvU3lZMmp4OElUMGEwQnlveEJvUUJKVDF1VHhwTmxJQWdvR2VGNkNScG9aSnJoZUx6aUhYQ08vZjhMcjU2aHBJQmpRRHVIUUNsMFVrSW5OYkJHSXdtRjc4OExJQzhkNHNDemNMVmxuaytBSHp4a09CamQ2di9ycDYrOXNEWnczYmlXSEo1ZFhEMjlkUGllOTdabTVwUGV6dVp2NlRKZkZ6SVExbWlhV3puMFkrMzVwWS91Yk44c3lORjZQaHBrUmhjbGdFQUlhZkowSkZhUG4xazhjdS85SDFWQ05JSXcvdlYwTk53aG9zQTU0eGJtRjg2ZWV1Q1JYOWJPTHI3d3dwTzNCdDErYnRsYUthVmtaaDROK3NIeGsyZG1IMzdrblI5OC9IMC9FTWxhNnpmVExPMHBGVW9obFdvdkx2OThjM2JoYmRjdnZkRGZXYnQrVlFWaHhvUzJNem9RU2lhenk0ZFhHdk9MUDNiczlBTzlZWC93aW5PR3MySjB1cjJ3OVBPbUtCZUg2ZTUyTHFVaWNHQ2NiVUNwMVhwclpsUU0raHRCSUZ5ckhYKzRWaytlSUpLRHBKRThwVXYzOVg2M2Y2WElpejI4bWs3OWZiV0I4dzBOZFBJeE8xWGFjSklJQVRPTCsrNDVOdmNUbi96RXh4Wm41KzUvNlZvZlZqdFM3RmN5R3d2b3ZvRXozbU02QUU0d1dCS2NGRENXSUN6QmxOVXhVdm9ZZ1VSVkEzQyszY2FpY2hFR3Q0dHd6bFBoYWxzYTRtYU80Y2lpdEl3azhLRTZ3MmNHcXVMRXN3V0NnTHcwUFF0ME1vSE5ib0VzTDlCT0JPQ0FyUFJSWjFvNEJGS2dOQTV4SUdpckN6UmpRWThlYWlRTEh6N0ovK0lyYTFkZjNra1BkM2JXb3FUZTRFWnovbTB6ODB2M0Z2bHdFTVIxTW1YaEdzMlo1ZTd1aHJwMjZYeW04MnpkakVhL0ErQldkVWpXSWZHT1htL3I3Y1lWaTdOTGh4OWZQSHJ5VU5ydjdja2dKT2VNYURTYTh6YzJOMWR1WEg0eDMxaS9jVFhyOWY2RUhWOGJWOUJGS040OUtJWWZiQzRmYlRlYWM0K3ZIRDl6dk4vdlpFb3BuNU5MZWZTNWIzMk9PanNiMldCMysydXVMTDhDUUtsYS9YUmpkdVlIb2xwdGZuWis1Y1RNOHVGZmltcURQV05LdU4zMVpwYU9Wb2FkdmQyczEvdGRJcVROMmJsSFpSaWVVSktPeTBDZVRScXR0OVVpT3hzRTRtL3BVczlDV0Z0cnR0N1hhRVMzNFBoZjdtbjlHOVlQQlBCZGN2bHBlKzMxYXU5NXh5TzRmbXVqYXFlUlYzWUZJaEJpSWlULzlkLzZ5USs4NzUzdi9xbW8xbXBmMlg2YWgvazZrUk13TEdCU0J6MHdYbCtTcTZYcThLMnhVZ2hvSmhTcFE1NDdPQWhmaFhkQVdUSjB5VERXZDNWWmlQMEsrMzRtTEFCbEhKS2JHZHhXZ1Z4UGJJOFFGVlZXZVJhZHJ4c3lna0FDTXNSRzEyQzlrNEpOaWFXR1FxQUltLzBTM2FFSHVoQytCQkVxUHdGanJDOEc5ak1YMU1KZ3RWMExUbDdlSEt6dWRZYzFyWE1NK251VXA2UEVzV3M3YTlyV2xETzl2VzNaMlY3SHNOdUpwWlNSa09JTGJOMFZFS1VrUlV5Q1B1bWNmZFFZSS9OMFFNUnVscGxYZ3pCY2xVcXREUHZkMXNhdGE3aDU3VklnQlZiRElMNnN5L0tiUkRRUWdReFVwRDVpdEhsNGxLYTB1N3NsakM3YjdOdzhDVEdicDRPWjNZMmJ0THQ1azNTUnQwaUl5R3I5RlNIVldqelR2b2VBVCtvMHJlWHB5RmxyMnRvVXk4NmE1WFRZbnhsMDk2UzFUb0tocFZMUFIvWDZCNlNVeDdVdWhXVVRObWZuRDhkeDhKWnNsSzkyT3NOWHNyVDRrM3E5RnJZYXJiTmxYcTROQjRPdk1iK3FTdSsrbjRweWIwaWdueng2QkkxYVFqdDczWEgrRlJCUnpJemcvWTgvY3VLSFAvcWhuejF6NnI2SE5RdSt2UDBzN1E0M1lJeUFZWUJUQTFkWUVBRzZaT2lxdXE1emh5SjNLQXlRNTg1UGhCSEJXVUNYRGxvN3NQTjNpMmJBT005NVpkQStINFVFSWVnWmlDc2ptTnhCQmdTcVFDb0ZRUWhVbi9zMlhoUXJHRlpZMnl1eDI4c1FTOFpjRWtCS3d2WGRISVBNWWI0Wm9Sa3JCSklRS0lJaWdsUUM5VWlpWFZPb1JRb0V5T1ZtMUd4SEt1cUpHdVRzSWJLbTVHelE2MXBqUjNrNkxJbzh5MGlxT0VwcWxBLzdRMTNrTDRIb2FiWjJBQ0FDczRQaitUQktqczB1ckNaZ2piVGZLZkkwemNzaUg2U0Ryclk2ajQ2Y3VJK3lZYjhZN0d4ZmRleXVPR2V2QWxEc1dOclNya29aSGxzNmZDeGhWNkM3dHpXeXhnN0EzTS9USVpKNlBXbzBXcng5ODlvT3M3dkExcjdJN0VpUFJtRXhIQzZwTUp4WGlvSzAzOUZGbmpsZGxpQkJaRXVOTWgxS0FPU3NlYWJNODVyTzgxWHJUR1RLTWlCQlN5VGtESVV4S0lqV25UVXZSZ0dXU2FnVko0TlNSbkZmNS9tR2MwN2oxZTNEYWVqK2VyV043VjNrUlRGWnpaWGo4UDNzcVh1WEd2WEdpYUkwS0IweFhFakdDakF6RlBuQ20zR0FTUzIwQVNEOXY1V2xneEVFRi9vOE80Z0VVREFFSEFUN29wa1QvdnVkWXhBc21BWEN5TGVqblFDa2M2Q3RBbVpnSUlTWHlDSUpoRXI0SlE2ViszY01DQ1d4TlhEWTZZMVFGZ1ZtYWdwSklDR2t3RjZxMFIxcDFFTUZiUnhHamlFRjBLb3J4RklnREFSa3RYalNNU05TRW9FaWZPRCtCUncrVFBqTUxkYlBkTzJ6WlpaL284eUtqQURCakVJRzRRZVhqNTU0Ykc3cGtBV0xPSWlpVDVteVNJTWdWR1dlWlZxWFMxRmNLK0o2Z3IzMUs3ZDYyNXVmTXdaclJKUWJvMVZycHYxQUdFYy85Tmo3ZjRoMk4yNXhHQ1gzU1NubWd5QU1oNk5lcWN0eW9kbWV6Nk1reG8wTFQ2MTN0OVovbjBSNFN3cFJNbmhtNmRqSlR6M3c5ZytlWGpwOHlrSlFTNm5nUjBFaU1yclVnODRXeWlLbFlXZWprNCtHbjJHU3QwaklWdEp1Zlh6NStNblZuVnMzOXB5ekYxVVFMaFhGY051d1RVRXVNWU5pMDVaRldOYVR4YkRaUm10KzduNVRTNDVtdzkwNDczVkVlLzdRWXpGVGtFYURaNDNXSTE5cHVZTllNeTNHdlY1dHQ5T0RNZnRqbVlLSXhxdVJnc1g1K2FVZ2lGcWpMSWNNRkRrSCtIVXAzdk02S2FDbFFOWTNNTVo1S1N2RE1FcUFsSUJ3RmlvUWZxNDhBRUp4ZXdyTnNlK3ZreUFvQ1NoSkNBUWdpRUdTb0RJSDFTa0JaZ2dwSmdxR1hpb3JMeTBDSXBBa0RFY2FHOTBjb1dETU5RS0V5cytYRjlaaXUxOUFrZis4bjJrd2dQbEdDSFlNUjR4QysvS2djN3lmQWhTbHovMVBOd1NTMVJMTkFXLyt5VmJ4ZEZyYWJ1WEIwdDFiMXk2RlVhU09uWHJva1ZxOS9kaG8xQ01JQVNFa1lxa1FFNEhBdHJlemZuSHo1clYvMWQvcmZSNWVvdzhBa0EzN1gxRFIwOE9IM3Y3Qm4xdzlmdTlaZ002cUlJQWdnVFpXd2N4c2RJbHJGNS9idkhiNXdyL0t1cjNmQnpEV3ZpSnI3WlhWbzJmK3dhRmpaODcwZXpzclJUNkNjeFlFaDZUUlJEYnNydTl0YlB4R09rci9FRUFQQUVrbE1iKzAramNXang2UEFYclFtT0pjbnNVMDZ2ZWFlWC8wTWh4K1R3WHFYQkFFUDVqMytqQlpGclJuNW1ZZ1F3Z1pNMEVLWTIzTE90c0NzSVlESzdhbkh2MzFYWVViSDhOM2NMYUZFTUhjM01KeW96SFRLalVqa296U1dKVGFJUkFDMmpya0k0dkNPT1FHS0RLSFZEdFlBREpnS09zZ25RSUpCclQzNWxiNkVOMHdJS1VIZUtBOHlFTUp6Mzhmejdic2FhQ240UVR0NStVWTUvakdWL2lOQkc3dVpzaHloL2xHZ0RnZ0NDS3dZMEFSZGdjRmlzSWlEaVMwY1RETXFFY0twWGJZN2xqTTFKU1BFQ1JEUVBpVVlPSmwwS1hEWXFMVUR6MjQvUGhpTFJqOSt5ZHYvVUVuTFR0RUZEanJMbTVldmZSUGJLay9GTVcxT005RzVNQncxamFDSUJ5eFl3VjJuVHdiZnFHLzEzc1NRSDRBRExmV3JsejRud2hpTFFpais0SW82YXNnaUt3eGNWSnZaTlpvVGtmOWRIZHI3YVdzMi9zcWdHNzFLaEFSZUxDNy9ZVVh2djY1Y243NXlCUFphQkFiVTQ2czFTSEFoa2k0VWI5ek9SMmxmK29QQndvQkxrZmQ3bTl2Mzd6ZVpzTERCSkxHNm5sVEZxRkp5OHV1Tkw4SjREd0lSMTAxWnBnT2U3QmxpdmJNSWc2ZE9FZUQzZzRYblkzRnNGSDdDYXZOLzJoMW1lSFZpcnc4QmZycnQ2MVdyVFMrVFpZUlJFS0lJSllxVk1ZWWNGRVFyQUJyd01EQ2xJelIwR0NZV1pTcFFaNWJhT3Y4eUtrVjRFQ0FEUU5XZ21NSk9BR3JmQXROU1NBRVF6TGdISUVqNGVWYm1hQkI0TXhCcnVjb1VnTVpTa2l2RmVGcEtuNlJNMVFvc05rcjBPbVhtSzJIU0VJSk1NTmFobFFDL2JURXpxQkVwUHpiWXB4REdFaUVpbERrRm9FVW5tNUxRQkpFQ0VPRlNEbUVTa0tBb0NURFdJdGNneUx0NXQ5OWF2NEg0a0JHdi9QTTJuKzh2cGV1QTVCRzZ4YzNybDI2c0U5RzhWZFFoYlJVZmV4TnRKL3VZTmF4YzZPYmwxNzY1d0JhRmM5b3pLOGZzK25LNm9DbzhtQWV2MVVFZ0xiWHJuMTJlKzNhMStHWGRPanFleWZKTGRYWUQyY0FTSmZGeTd2ck4vOHhTVGtQaGlLaUJqdE9uTE01Z0QwQTBwVG1hZ0s1MlZ5WVg4NnpFYkpSSDNPTHg5RnNMV0x0Mm5uU1dWWlhLdnFFVU9wejF1Z2JZQlozSWZQd0ZPaHZvSFliUTBocm1SeHJKS29PZ29UVmpMeXdHQTROT3JzNTBtRUpXMW9ZNjlsc1Vnb1lKUkRFRWtZUVZHRVJjQURySkFKbWhMUVBXMURnUjlVYythSmNXUUpPRXNLZUJ1MFdJUEs4OVRBUSt5MDFYL1VVV092azZJNDBGaG9SNnJIRW1PV3RCS0cwRHB2OUVsSktSS0ZFVnZqVUpKQUNSV0c5d0FVQm1YVllxTmV3MUU0Z1NVTktmOVlKdndRR2dnaFJ4Z2dJU0pScWZ1anMvRWNQejBXdGYvdU5XLy9pbVJ2ZDY0SklPT1krN3R3a00xbWd1bHNiYWhJUXFnSnlEM2Y4aFhjY0N2d2F4YTVxem8vSFJKYTdmUzhtRGhZdnArVjR4TTdjbU9CSjdHL3hrVXExR3MxMnMxR2Z0VUtHS05NOXNDVTBaaGE0czdOR25jME5wNHNjUkpsMnp1VVRrM3pmVjZiZTRNaSs0eVl4MXRwUzh6QXJ5Z0xNdFhvTlREYWdZYzloZDJ1QWpWczk5SFpIWUdOaG5RT2tnRklTS2d3UVJDSENXb0E0Q1JFa0NpcXppQ3AvUkNDZnJDc3ZVUzBjUXhxQmdQMU1yRFFPZGlPSEhXaEVpZkk2OWRhQkhFRXFRaGhJYlBSRzJPamtXRzBucU1jU3hCVmJEZ1RIak02b1JLNGRacExRaCt5V1VZOFZYRFdJS2dYQk1LTVZCWWdVZ1YwR0ZyNm5KeVdxbjBOZ1FaQWhJM0Nld2h1QW9yTXJqWGY5M0x1T3lYOGw2Sjg4ZGIxenM1S3FBdTZraU42TkYzNVhydnZ0aThVQmozajNVZG5iajZrWUNIZk0wMk1pdXVBRGp4L3o0dFdCZzhaVEdhUjBjOHZMYjJtMDI1OTJqQ1ZuTGFLb2htS1U0cVZ2ZmhFeVVWQzFxR08wL2wxVGxpOEFlS242ZWZrVTZHOGM3ejNoQzhiaElldWR6dDZ0d1hEWWJkYnJ0VFRQMEF3WHNYVTl3d3ZQWGtUYVMrR3MxNlZnQmxnS0NDa2hsSUlLQXFna1J0S3FvZEd1bzlhb1pxcmdKYU5DQWhRTGlJQWhJUkNBWVEwamxBTE9HRVNkRXBFU0VFS2cwSDRaQllPUkNJbTlZWUViMnhuYVNZZ3dFTDZJQmtDU3Ivam5wVVZuV0VJSmlWSmJaS1hQMFpVUU1NWWlrZ1ROak5sR2pFWXNrUllsUWlYUmlNVStUUmFPSVNWQmtvQVJCQkVRRkJocDRRUklCS2VXRzQ5Lyt0RkRuVUxiWDN0eHZaK1RENmZIazI3alNUaUxWdytXVEhyWWc1TmtrN251UVcrTzE0Z0k3cGhIcjRhUjdqWlpOajVRSm9GL1J6dTRzYmg4dExHNC9DbVlZalVkRGlGbGlMaFd4N0RiNVg1bnA0eDBJdWRYajdRREZTZjluZTJ2V2EzVHUwUXVQTTNSWDYvTmZ5SGd4dnJLdmhqdWlNZ3ljN201dmIwN1N2TlJ1em1EeTFkZnhzMWJsN0FVcmVBOFgwWnBCbERDMzBQTXpyZlZpaEpjRklBUVVGa0dyVFhZT29BYUVGVWh6bFczcHJWQXlGNkxXUnVDa3dTV0ZsRnFFT1VXUVNCZ3EvdkdPU0JRQXRwYVhOa1lvUllxdE9zQkpGV0hWSlczTzJiME1vMUNPOVFqaVZGcEVDcUpJSlJnNXhBS3J5N2JTZ0xNTndOWWJUMkxUeEFLQnFUejVKbFJwckc1bCtOV0o4TmFKMFdhYXpqcmxXL0FKTzQ3UGhPY1B0TDY2STgrY2lndGpQc25sN2RIQmNERWQzcDFNNUZyNHk0ZTlsVUYwTmNvbjN3bkFJazdVcTF4MitEVnMrTUhuMDhTa1FRUU1LREFIQlRwVUJSNUtwTlFFUW5pTEIwaTYvV2dzM3dncFB4U3N6MTdmeENFSjBjME9nNGgzTVJoWnU5eUNMMnA3UTFKbUdrMkd1Z1BCckJlS2tsVU40RUNRSE16N2ZyUnc0ZmVtYVc5STEvODRoL2dhMS85RENWSzRjSDd6NkZXUzdEWEdTSXZTMGhGRTlWNy8xOW5MV3had21vTDRzcmJTd2tXdEQ5bUNpSTRCMWpMZnViY01LTGRBbzF1QVNIOTQ4WkJocFFDdC9ZeURFWUdjL1VJb1JUN2ZIZXZWZU83QXV2ZEZFcjZkRmNJUWlNT01PYjBTaUhRcklkWWFJY0lCWU1Fb0sxWG5RMlVSRm82UEhWcEQ1OS9aUnVYYklsMEpRWXYxeUZXbTlEdEVLTklvT01jWHJ6UnBXZGYyYVVqcmVqZTFkbWF2THFYUGpVcWJUbmh6ZmZEZHlHSTQxckFST1JUaHpzMnhZRWh3SDczTzkyTmJmYnFPWFM2KzBFZ3BIUkNTbGZwMmgyY1BSK0g3T1BOdXFFUUlwUktCY3djZ3ptczE1cU5lclA1aURibThLZy81SHpRSTZzMVJLQmVuRnRlSHJWbkYwNlhaYW1IM2U0L0tkUDBPUURaUkczQ1lrcVllZjFiVVphWWtDc2E3MVZYRjY1ZTNYcjIrYWVlSC9VMjNuYmo2aXN5Q0FKMzdlb2wydDdlb3VYVkkzajhyVy9EdGZXYjJPMXVZekFjd0s4d3I0Z3N6c0U1QjlzZndHb0RyVFcwYWFOdTY0Z1NoZ3NGMkRLVUpFZ0JXT0hwclBGT2hqSzNFRXFBMmZmVlEwbm9qVFIyK3lVYWNRQ2x2S0NrZGV4emMrRXBlVHY5SEhscDBVb1VqSFZvUmdHU29DTERPS0JlRDdFNEcwRlVCV3dsQkdTVllhL3ZadmpheFIyTVZrTWMvNUVUV0xsM0J2V2FnaTBZWnF4NFF3UlRhUFIyTWx4OVlVOTkvb3MzNUxJVlAzNjhGVCs5T3l3L3c4eGhKVTFGNDdKSEVFb0VTbkJaZktlNWp5cjQvd3RZa05SaHlnSWdPdzZ6eHQ1OHN1Z1dFVkVZMTJxdFdyUDVHSVI0cUN5eVBWM284cTFQZk96aCtlWERqMzM5czcrTll0QVhVYUpBcmRpUkRJOGxqZWE5WlpFSC9kMmRmNVVQQjE4RWMzNlhGSVV4cGNDK2ZtMDRHazFHZjVOZVFBMkdnL0xXemN0NW5uYVBOcHJ4YktNV2gxRVVrbldXZTcwZHhOTFJZcnVOWTRlUElZbGpwTmtJanNjVFpjVEVST3dZdXRUSVJpbnlZUTVUV2pqakpkU0kvVENLY3d4akhHeGhVZXZrU0l3REtRRUdRd3J2OWEvdkRDRklZS1lSSVpRRWRyZnJDNUlJcFdGYzJlb0RFQWlEQUdFZ01Oc0lFVlNSUmowSnNUZ1RRd25uSitTRUI2OFN3REN6K05yRlhhU3pNYzU5L0NRTzNkZUNIbG9NTjB2WWFyYlZhZ2VqTFFTQTVteUFvdy9NWS83a0xGNTRjVmVsTzZuZExzeVhxbkxCZm01ZTZYZHdvQ1FXRnh1WW1VblE2K1YzQ2M3L2ZQaW9OZHNJb2hncWpoR0dFYlF1RVRmYllPZkk2bkxTaXdlVkY0OEJKRVNVekMydG5HM096ZjVrVUV2K25nalVleUhFNDRlT24zN2kzS01mT0h2ejZ2bG9aL2NXbXEwNTE5M2F6SnhoWThzeXl0TVVvMzcvai9QUjhIOXgxcTVWYmNQaVFLZmgrOGJrRy9tWG53RDVIZGNvTnpzYWVGSEZRUlkzb2tna2lvSTRLcHZ0cHBBQktlWVNna3MwYWpIbVdnMG9xYUFkckhVMGtGSVpJcUdJZk1CUTVpVkd2U0hTM2hERnFJUXp2bmRmV2taUkdKaVJ4c3hJbzZrRWhQSXZweVNCN1o1dnBiVnFGY2l0TDlDTko5MEt5OWpxWjFqdmpOQklZaWdsMEk0RDFFT0owdnFEWjJFbVJoSUJSanNQY2dDU1BEdnZtMWM3S0E4bE9IMXUyU3ZhU0VJdHJ1WXZpUkFuQWpJZ2hBS3dmWTFFTWpnM1VFR0ErU010dDlQSkwxeTdOZmg2OVZKT2lqVXdNN01mb2dIRmNZQnVOL3NMdlU5Um80VjgyRWNZMTBEU00vN0tJb2ZPMHRjQ2VRSWdqdUs0UGJleStxNWFxL2tQUU9LVHcwRy8zdC9aeVYyaG8zTnYrMURTNjJ3SFgvL1NmK1E4NjVNcHl1dW1OSCtraS94cFUrb0xPaSsvWmNyeTM3RGppeFhBOHdNZzkzSyszeWZ0TnZsRy93T0lpSVFRcU9TTjlvUEtMRGM3Vzd1ako5YzdvNmY3aGI3WXo4c1hNbU0zU3BBZVdWZU9yTkY3bzZISmpBbURVSkZVNnVLd1YvNjJMdkd5TVU2QmVWWUlJWlVVTEFYQkdrMUZWbURVSDJFMEtsRG1CcU5oQVJvVU9DNGwxeU5WQ1M0VGpHRnM5WElJRW9oRENWVjVhQkszYy9SaFliRGVUY0VNdEJvUjZxRkVPd244VkJvejRraWlIby9uMGYzRUd2dU9JSjY1MnNHTk92RFFEeDVEM0FvQk1DaVNDR05DSEJNMEpKd0FoT1NxeHo1dTh3bVVRNFBXY29MWmUyZXp6VnZEVjNZM1J6dFZCMk5TbFlXTmNiNkZKUWpXT1JqelgrNEFneWl1VWlTUTBacXMxc1RXaWdPNStCMGdiOC9OSDJzdkxQMW9VSXYvcmk2TEIzdmRqazI3L1l1MktMN09qcGNHM1ozYTlhc3ZzZ3dGQVNMTHV2M2Z0OGI4Y3dCZkJ2Q25JUG95d09zVndJc3FONy9qYjd6Tlpwb0MvWFZ0UW9qOU50dnREczJkV21PbXNOdURUdmJLN3Zid3BiVmIzVy9mMnVoK1BTdkxGM3FEOVBsaFhqNlhXN3RsQ091bDVkKzlmbW4zOXdhRDRqbG43YVV3QUtSQWs4QU5TUkNCVXBCS0Fjd29oaG55UVlwOGtDTEtEZTZiYVpBS0JETkFTaEpHaFVGdldDQUkvS0JLS0FsQ2VxNjlzUXh0R2FXMjJPbG5pRUtGWmh4aXRoNGlWQUxHT2tSS29GVlRQaDhaVTB6QU1CYTRlSE9BNS9JVUQvL3dQWmhkVGdCRmlKc1NVUWlVaGlxYUdrTXorYmwzRURKTmdDS0lVS0RXRWtTbHBhUVdMalliVWVQV3JlR3pnMjQrWHMxNlIrNXFqT09pTUJCU0lLNEYrTTQ1KzRGUXZkRUVRSERXYjZSMHhwQXhKVGxqQkR1N3J5R0EyNnF1TVlocUFPSzRQVHUvY3ZMVXowa2gvazZlajVhVlVuRGE5b3MwL1MzSGRzODUrK2lvMzQyZE5ZZ2JEUXJDYUtCTitSbFg2bWVyOXoydkNtLzVBVTkrVzEzR04vZjQrd1hvYjJqQ3pMRWpSNUhsR1RhM3RrQkVqcG5OQk5ndEFFMUVJVE9QVC9GY1o2YXpkclZ6Y1Z4OENrT1Z0T2RxcmQzdDRjQjVjUUpWRlBpMlk3clVhTXEzeHhGOUNCS1BXV2ZuMkZwSUNDZ1EyQmdvU1M3VDV0WmFMMU1ubzhacUlBUks2OUJOU3dSU29CVXJoRVF3MXRlbkhYc2lqR1BHcVBEREt2VTRSQlFJaEZYVlBRb2xhckdmUnBOVmpLS05nM1BBeGs2S3A3WjdPUG1wRTFnOFZJY3VyUmVuY0lSNnhJZ0RobVVDQll5QXZhQ0ZrQXczc2hBa2dOQXZrN0M1STVlV3dYMW41OTczOFI4NmRlUGYvYS9QL2ZOMFVGcnk3ZnJiWUNld1kzYnNheGgvWmtRb0phdm94WWYvcHNqdTZNRlhBMGdISmFoakFob01zSXByeDJVY3Z4dXViTlJxRFVjUWxJc3NCdmdrQUN1a1ZFRVlJV2sxSVZTQU1pK0lMUnY0QVJwWGZjd1BWTmp0SGNVM3FucWcweHo5OVc4UFAzZ09Ta3JxOWJxd3poMWN3RGdwL1h4UUZubmNPM2JXdWl3ZEZudnNCUWJMS3N5enp2SW96K3hGYStWelFhQTJCSkdXUXVZTzZKR1NRNm5VelRCSnZyNDNOTCs3dnRHNzBFN0M0d3Z0cERYSU5lLzBDbXJIQVpxaGdyWU9wZk9pa0xsMk1NWXZXTnZ1WnlBaE1OT0kwYTZIaUtweDJTUlVuajdMREVFRTQxRGx0QTVQM3RoRDhPZ0N6ajZ4Q21mZGZyMjR0QUtLZ0hySUtKbFFPb0ZRVlNrb0FBaENHQkdrQWpUN253a0NxMWlFalZwMHhKWFl2blJ4NzVWcXErc0JSVlhpc1ZDbC9UT0U3MHBKTDBCbkhUbHJpZG5kTFVUM0ZYV2l1Q3E2MVFEVVBkaXBsalNTdDhaeC9CN0IzQzZ6QW50Ym0ranY3WkN6OXJvSzFMUE51Ym5qcmJuNXVTQ0txVXp6SXV2MXYyenk0cmNCM3BqdzVwUGh1bjFWai8vN1NocnlEZTdScmJWNDlvWG5lYWFSRUtCUkdPR3FOVVMzMXpQZDJaY2wzRW0vbk5nWHh2bmRlcmhaV2w3TzB2SjZlN2IyaFZxaVZraFNKSlNLamVOUmR5UGQ3TzZNc2kyZ2xsemVGdlZZL1Z4aDdQemVJT2ZsWmt5RDBxTFFYci9kZ1RISURBTGhkZHpUVXFOZHI2RVdTc1JLd0RnUGJML3h4YmZTaFBBUzBFb1NudC9vSXo5Y3g0T1BINGF6dnZydjB4ZXZQNWNiSUNyOVBLM1cvZytJcW1XUHRSQ1FFVmVyb1FDT0ZZSTZrMkRtWkZZdFB2alc1Wi9hWEIvZGVPYnB0VzhSVU9PSkVKN0JiQXlzMFlZQThNbzlzOWk0M0huVmU5R2VtNFBSQm1VK2duTk16cFdUMjF3T0xsOElBY2hxWTh5NGpSYVR3T3JTNFdQdmordjFENXNzWDh4R0l3ejdIZVFtSlJGSkhYRFFiUzhzbks3Vkc3UGFXTXBIdzI3VzYveUJ6dkxmQVBCeUJlN0pYcm5HSlBtSHhPMTJ3ZmZacXVrM3RFZS9jZXNtNWxwTlJHb0VFaEtGQVdLdjBNTFdPaWFpOGVXSXlGWnIwQ3pkdmd6b0RtOC8rZitUbFdoYjVMb3pIQlRYQi8zaVdtOHZ1OUx2WkxmeVZBK3JmeS83dWJuaHJMTzlZWEZLU1pITU4ySXVMWk90MkcvR0FkcFlQM091RFhKdE1kdEkwSW9ET1BaaUdIRWdmSVcrOHVZa0NJMmF3bzJ0SVY2eUdzYy9lQXl0dVFqUURLNHE4d1NndEZWK0x2eFdHU2F2Z0tQQWlKV241c2hxRnQ5VlNZM0pMSUtJS0lnSktsQnpzUXFiVyt1amwvcURmRkRSQ3ZiQlBuNGRGdzYzU0FZU3cwNkdqOTgvajlra3dNYWdRS0FFb3FRRzZ4eVZaVW5PdW9NODlmMldHZms4UEpCSzFkdXpzdy9GamVaWkNNd0pLWTg5L000UGY2bzl2L1FUZXp0YkozdmRQVDNzZGFqZWJNcXdVV01WaGdqcjlVV2x3bk5sWHJTSG5kMTFuYWIvVXVmNS84WitpMjV4SUZ5ZmJLRXh3cVFTNjNmZmNRL2tGT2l2VTh1S0VuRWtxcGx2WVBsUUMwWmI2TkppYnFrQklZakhGM3NGQ3VjWkd2NGpnZTRJNVhIM2pTY0hoejdHbit2cXhyTFdjYkU3TEs2VzJnYUhaK3RuWnV0UmFDdGhDR1BkZnE5ZUNzSXdLd0Vpek5RaVB6QkRoRm9rMFV5VUg1bFZBa0Vva05RVXV2MGNUKzhNTWZmNENwYnZtWUV4RHE1a0NIdTdWZWVYUzhEdlpCajNIWVF2NUlseEc4TDVtNXNxSVEwOTlGUmFWWk5FU3NnNERsYWlJREF2UExmNXdrVFJhcjh3UjBSc2pZUFJEbVZ1OFBpeE5qcVpvYlYrUVZJUVpYbEJWaHM0djdsQ0hBalQ5L3ZpQUZTdDNsaGRPbnprcnpYbTUvOXVHTWNmRHFQbzNTZnVlK3Q3VDU1OTIyTTdHemRiTjY2YzN5M0xVU2FsU0dCWnVOS1N5UXRwaTdKWlppbE1ubjJsVEVmL1A2djFmM0tNRGR3ZWpTMFB2RmZBYmRxakJ6Z0o3Qk1hcGtCL1kxbGFNSXJTRTFyaUpJQXVQTkJYajh4NDd5Z0ZHczJJczVGbTUvamdsTlhFWXI4N3A2LzJJd0c4YXZoajh0cm5oeHZIUmE3ZDJrSWpXcHl0aDZlVWxGUVlDK2ZZejcxWG1PdG5KWnExRUxVb1FHa2RvbEJpdmgwaWlnU1VGRkNLSUFNQnF4MmVYZXZCM2plRG93OHVJQkFlME5Zd0F1bFhOby8zR1lIOVlrZnRDS1VGUWdJa1Y4TTdURERXejdKSHF1b3FCUXFtYjFDbURySWhPYXpKc05hS2xxSkd2SDc1eGUzckUvV08vWEZUVzRFY0FMMjBPYUplYnBBYlI0NlpuSE9DbWNWRU5UMnNRQjZES0FFUUtpbnFNd3V6ajg2dUhQN2xLRWwrVk92eTVMRGZtNXRiUHJwMDdtMGZXbGkvOWtyMHlyTmZIVVZKV0xMZ3BpbDFYT2JGZVowWGYySzF2bXlLOG5tMitqK3hNLy9hV1h6RE1Yb0hRUDZkV1cvK3hjRDNvOGszMng4MEdoWW9TMTk4YjdZVEZJV0dOVjdzc2N6TlpCdnVEcHViUzFBVWxqRmUzcmhQOFNRM0dmNFRrYVZYN3p2YjMvNWhHYU5CWWZacVN0NVRDK1NLbjBabHNwWHVHd0hvNXdVVzIzVW9QNWlEbVlaQ3N4NzQwOFY1MmFsSUVpN2M3R0ZqSWNicTIxY1J4Z3JzS3RWYTZkMnlOa0JtQ01iNWlFYUlha3NNQTRsa0tPSEZMYTMxTER4TEFvRUFGREVzQkdBQUdsbFFKTWdTY2EwWk5wTjIxT3pzRmhkMjFnYTdFM1dPL1lrMEltSWhpQUNJd3J5cTBEWVpwbzk3NGdtSW9scWpmbVQ1NlBHZm5GdVkvOFZBeWJlUDBxTFYyZHdjc2VQODdDUHZpZGhhUFBYbC80UW9kS3FXUkVrK0tvVFc1bG13KzNWMjd2Y0FmQkhBNXduMExXdDVuVy8zeHcrMno4WU12Ky9IQ1AzN0IraVQxdXVreUVZbGl0d2d6L1JyZ2h3QWlzSjZXRXNmRXNkSmlDUU9PQWdrRzJNcnRUaTRBN0xCZDF2c0p6TnRkL3RwdVY0THhMM05PRndjcStCRVN2cjlEc1podmhtRG1SRXFnVVlTN05OaWpmVWJWcmQyVXB5M0ZndFBIRVp6SmdackJ5Ymh3dzRMRkxsRE9kNjlEbjhBRUc3bjdaR3Mxa1hCOCtiTDBoODBTcUtTbmdMUzFFRVhqS2dtVVZvaUZUQmFzK0ZLdlIzaC9ETzc1M1d1czJwUDlPUkVHNm9CdmxlUlhZaGVGYWJYaUtnK3Q3VDhqa05Iai8rREpJay9VVnAzcUwrN1M3dGJHeS9rYWZvZmpDN04zdGF0azljdlBvOHk3V04rZmtiQWNYYzB6UDY5S2NwL0NlWVg0SFhyQmdDR2ZMdWlQcjRPZGxOWWpHbU5VL3YrQVBxZngvWWxteXRXYmFNVkl3Z2tna0FpeTNTVjMrTzFMdHlSRHdJaTFYWnptSlhkZGh5Y2FTVGhqSlFDVVNCSkcxK0Zqd01mdHRlVEFMVkkrbDBSeGtGS0FaMGJQTE05aEh4a0dZc25aeUNjOC8yZ3FvSllGZzVhTTFoVWtPV3FKY3krcFNZcVpZblNBb1VqU0FrRVZiSXVoSmVjUXNYK0hQWXNSQ1RCa3FBTFIwRWdaTDBScmlUdGVPM0NNOXZYbk9XRGYrY2tYVFVBRUFwQ1RFVGpBWlNFUE1qckFLTG0vT3pqczB2TC80aEp2VlZybmZRNnU3YmIyZnR5bWVYL2dSaldzZjJCUEIwMnlqemxack9PWnJOQnh0cXJXWmI5ZXBtWDV5dVBuZUpPQXN4a1ZkMEJzSFM3Y0ZqSjdvdnZlTEJQZ1Q0RlBOZ3hRcStYRG1jWmVmSHFrRC8wZHp5NVY2L2o1ZXJBa0NOdGIybHI5YUdaMm4yMVNOVkZwUllaU0xuLzRHYk5NK0pjbFQ0cUtmREtSZys3cXpXc1BMUUVlRTRNaFBRQ0UzNnBJNERTUVpMMzRNNTVHV3BaZGNHdDlYeDNVVlhma3dCbzFSa29IVXpCSUNsUWFvRXdJZ1JOQlVnQm9Tb1JUTXNjMTRLYUROVnltcmtyRzlkNk94TkgyYjZPL240VkhVZ1lpSlpiVWYzc2FuTXhDV1hjejAzSXZqYyswMXlhKzF0U0JtOHI4bFRsUllZaXowbVhoWGFXWHdTekk2SnpVWkxNekMwczBNeE1pd0ZRTmhxdFpXbjJlYTN0clFyZ1k2QlA5c1pOVldLMDVPbXNUSjZmdjgrRmRsT2dUNEgrbjdNaTA4aFNqZXcxUW41VjNXbTRVeUJoMHJNVEVVUy9zRGVOY2NGc0xUd1ZLWmxZTUpYR3l6VkhnVVF0VnI3OVpvRXdFTmphRytGbHF6SC82Q3FhelJEbFVFTVhEaGdyMHpnZk03dWhnY2tNWk9RM3hoak52bnRrdlZjdnJkOGpGNFdFSkFTU2tESG9PQXozTEdRaUlRSi9RQWdCeU5CTFVKTWtCQXBFN0xnNW15eUtRTkt0cS8yWFJ0MjhQQUR5YUJ5ZWgwb2tEeDF1emYzVTJ3OTk2RWZldXZJcjU0NjF6aFdPQjl2OXNuUWtEc2YxNUZORVlrbHJTOWxnUU5sZ0FGdVdJWml2QkdGNHNiVXdOemU3dEh3cXJyZXB5QXViOWp1N28rSG9kN0swL0FJRC9RbFBYaHdvdHUybkUxSUlydGNUMUdzMXp2UENqOTlOUVQ0RitsL1dDMmZ2UlBqZDVKQ0lHVzR2S3kremRjM0ZWbkp2YVcwdzl1cTFXS0FXS1ZpL0Z3cEZZZkRjVmgvdTNua3NIVzJETGZ2bGo5ckJPb0sxZmdrRmx4WmxadUJBRUtGRUlBbFVoZXJzcW1VVDdEZXpocFdDTGJQZjBpcERRaEFSWUgxeHJ0cWo2dFZ2SzcxS0dFYWdXRFFiMFJFaTJyMzY4dDROb3gxTmVQSUlRTExVaXRxZmZHVDUzRTg4ZnVodm56M2MrdXYxV3ZEQWlTTzFCMCtzMU01dURibXhaNlAza2dvZkt2TWlTUHM5NkR4allnY0NyUVZSOU8zV3dzSzc2KzJaOXdFaUhBMEc2YWpmL1VZK0d2M1RvakMvWngzdkhBQzVnUTlVUE1COTNjTUxXQWhDR0FSUVNpTE44dW5OT1FYNlg1Nk5RUjU1b0pON05kZ25jbHJTMjZQeVdnUjNKRlIwUEFrRG9hU2dWaTN3b28rRzRSemoydTRRTitzS3l3K3VRRXJoODIwbGZPVlBPM0JxUUlFRVc0YVZBb2dVd3FBQ05ST0lDRlVFN2hsNGZuQURTdm9DblJTQWpQeldHQkNoTEwxU0RwY00zYkZnQzBSMWdpUWlPSEN0SnFKNkxUb3lHSmhyYTlkNm5YRmUzb3BWL1lGRHJjVy85dmpoRDM3aXJVdS9mSGdoZVRkTHFxbUVxTENPTHUvYStSZTIzVnMyaCs2ZWZKZ0d4YUNQUnJOSk0vTXROT29oNnMyYWFjek1Ib3NhelhjNzQ4SjBNTmpxOS9aK0p4K05mczFxKzNYSFBEemd4ZmVMYlVHZ1FJSjQwbU16TTRwU1QwSCtIVXhOWDRLL21OR3J2Zmo0RERBWWE2VXpDd2ZjZkhxdDkvOTV5TnBtTFFqZm9ZUVFVbnFSWmlFSW5WNk9pM21KeG9PSEVRUVNWbHRZRWlCaWlFREFXUXUyRG9WMkNFTUJHZmduVlpYS1RXNHFVUXpoaWR4alZjV3NxOEVad1RVODh6Y08yUGZqSmNDVmpIVFFsTENaZzBzdHFPbW4zQXlEeXNMeDBuSjgvT0hIVjM5a2EzMjRGM1Z5YzJTKzFqeXoxRGg3Y3JGMjlzaFM3ZHpBcXBXTHR4emJra21ncEU2d2pNOWQwZnp0eXpkbGFGTTZQaE80NjlveEFCbUFTRnNnak9JbEdhaWxVWnFYYVRwNkllMzFmdHNaL1Vkd3ZNUCtkVHRZZE5zUDA3VTJIQVFLZGhxYVQ0SCt2YlQ4VHREekFSbmw4U2xBQkRSenl4ZGYyaHI5NHlTSy9vOW5EclVlY3d4bTV6V2ZydlF5bUpVV1d2TU5XRzBoRk1GV3Vid3p2dUpFZFUrWGRRVkRCWjd5YXF3WGtJekFNTlh1ZFdkOWpxNEV3UTROc3BUQklvS1Vmb01zUlFKZVFjdVRjaHdEWVV2Q0RDMXN3WkFLa01SZ1JXUVpPSE82OVk3MkUwZE1iYnVJV3JYZ3hHbzdYbklrd21jM2dLZTZncTkwTE5reVJhM2V4S21ISGdiaUc5UWlqYm1aRUhHaWhIUGd2ZTN0ckw4bnQ1aGRTVVNKVW9GaHBaNTNsdit0S2ZJbmNadGxlTkNUTy9MeWV2dTZObHFiNlkwM0RkMy82a3pjZHZKM3k5ZVpDS3AwdkxlWEZyY1c2dEY5TS9Wb1VRbkJXOTBVRjB0Tk0vY3ZJWXJWN1I5U1RkV1B4U2lkODEwQTR3RExYcHJLNzJBRGpHRXYrd3dDR1FlZEdVK2lpYVdYcFJHZWNlY1lzS1h6R25hS1FFcjRRaHo1dzBNcWdnUkRjUFgzYkJkb3JoWHFsRkQzek5mQ1kzRWdXemVHTFAvNHV1R3ZiRXJjNk9TMHMza0xrQUZPdi9YOUtMTVV6M3oxRHdET1VBUVJMcS8xMFJLZzFWWjBhYmtlZk5sYTk2VlJZYjVwalBtaTFmcjNuUzR2VjZDZW5EcDdsVnFyR0k4ZVRXK3pLZEJmSjJIOHdRbzhEb0pkTzk0WlpHYTdIc3Bqa1JKTGx6b3BzdVVHV3F0dEdvTlhDUGhrR3g3UTFucnFxNms0ODh6ZU80K3JBU0dobW5YM3pEaVRXcjlzSWhCUW9haW9zbjdIRzVlTU1CTDdZSGNNdU56SEhTTDJCSGxWT01ncktlaENpcmhqS0dKR3llQW5OdzIrdEVaNGZ0ZlJjTmluWUxpTlEyS0lxTFdFcERtUEY3LzFPWFI2VytBa3diQ2Y0OHlNd0UrL2ZSVS84ZGFWL01QM3o4Ky81ZGhNc3Q0cnZyazFLRjRpUHpkZUhDaTZsUk1nWnhKaXZOS0pwMENmQXYxMVlZdy8wM3BPQjRDR3BWa2ZwT1hOb2pDcm05b2NicDVlcHFRV01Ea21xbnJnM3F2VGJSVUlCZ3g4MFUyQ0ljRVZUYzBMUnFMU2pCZlNMM1p3OEJHQVVsN2hSc0J2ZkpHQm40d1RreHhSU1dCSk1FU2dIUTE1SVFYZEtpQkxSaFFRTmpMR2x6YVlQbi9EMGVhZ3BITFV4K0ZnZ0IrNko4SHgyUnFldkw2RGl4Zk9ZOURkUk5KdUlheTE4ZEJTZ2w5NDF5SStkUDg4RnV0aGE2RVZMcTIyNDFObmxwUEdpK3ZEbDNkSHVrdjBLcTU2VlYwbko2UUVTUWtSUk14R1QwRStCZm9iNml6WS96Z296TVpHTjd0RWtzSjRKcDZQbTNFOWtNSVJQTHFwRXFud3duRzNCVkY4RVE0UUREanQvOTJPZGVmQlhoTmUrZ09CeUxQaC9IVmJpTUpWaVlZZzN3TXN0ZS9SUjdzbDRrc3BlS1B3NGhjQUx2VVlmM2lEOGRTbWdYRUVrdzF3YnFIQXJ6eXhoSE9IMnZpamwzYnc3U3M3TUVXR3FOYkF6TUlpZ3FDQkQ1NnM0OTBuYW5BT0dJd2NySEVzQVhGMExqN2NqaVA3aFF0N1R6dm1sRHpJN3lUQ0VFRW81Umx1em9HZG5kNDlVNkMvSWNMNXUxRm55UUs3T3RjdjJkSnVVaUFQeFZHd29QeElMVG50a1MyVUI2eXBmb3FvUm01RUZjSTdBaHhUUllPdFFuL3l4VHFwQkJpZUJpdklUMnN5MFQ0RlZoQ0JpYUF6aDNpalFPTkdCam5RQ0FKQ3FBUVlEcCs5Q2J6U2wyQ25RWERRdXNEUnBzUUhUczJna1FUb2FZTUxXeWxzVk1meTRhTXdGQ0ZCaGc4ZERiRVFDYVNtbXBTMUlIYkV6Q3hqR1J4S3BPbytkYXYzQXQycEJiQS9PeUNxb1IrbnkrbU5OQVg2R3dib0I3MzY1TVJiT3V6bDEvSlJzU3NJSjJ2TmVGN0ZJVHNDa1JRUWt2YTNRL3NjM09mcHFNSnp0djdjWUhoMkcwQnd4b0dyZld6N3krUkZWU2VzUW53aXdGakFhcUM1VzJCK1d5TXlGdVJKNkFpSVVGaUxMNjFyRkJRaGtBTDlUZ2VEdlYxczdZNncwZ3p4dHBNTjlKM0NqU3hCRWRaUkdrWTU3T0J0cTRUM24yNGhDUWg1NldCTk5hUXVRSUtJbkVZU1FJYWZ1N3p6ZWVNNEhVOEUwZ1J2blowRDI2a25ud0w5RFFKMEFSd2NwWnBjUXVpcWgzRStMRytsdzJJYlNweEttdkZjR0VwSDR2YVM5VEVYVEdCY2tQTk1PR2J2cVNFSVFucmcyOUpWNjVSOEpaMEF6NWdSQkxCZnRlUUtDMjJCZUxmQTNFYUcyRG0vWTg3NVdYYkp3RXRkaWZNOWhkSUJuYTB0OUhhMlVXWXBWbWNrZnVpUkpieXdKL0R2enVlNE9aTElzaEpoMGNFbjdxL2h2YWRtMFVvVW9wZ0FEU2hMcUNsQ25qcWttbUV0VTY1WnY3S1RmV3RuVkd6NEZVOFYwSDFYaitYK3lxeXBUWUgrQnZMcUU2dEJENGJ3KzhBdk03Mlc5dk5OWm5kUHJSSFBoNUZpZHBWQzQzNUZuaW9SQzY0VVpEem9SVldZUTZXWXhCVkxqZ0xoU1RlTzRhd2ZrQ0VBcFdISW5zYnNyUkhFb0lSaGh6QVFXS29KaElydzlSMkJMMjRwck84TnNMTnhFMWsyZ0JVR0ZBUllXWndGMVpyNHJmTUYxdnRBZjI4UHA5b1dQL3V1Qlh6czRUbVE4SjY4SG5uQmkyYm9UN3RoenNpTWd3Z2toQlRZSGhUWHoyOE5ucTZXY1pUd202bjlhc2dwMEtkQWY2TUJuVjhOZEx3RzJGbm5aaTN0WmRjYzhXclNTSlpsSUtsYW8wYkVET0g0dHE0Y0NLejl3a2RaeVZDUklGanJ3RXhRU2tBcUgvN0w2bmRRa3FCTFJ0blRtTjFJMGVpWElBWVdtd0dPendnTU5QQTcxeFErY3hPNHNiNk5vcnVPTWgwZ2FjMmlPYitBT0tsRDFoWndhZGRndTlORFdBend2cU1CZnV6Y1BCNVlhYUJkVjVET1Q3M01Kb1FrRWlpZGhIYUFCU08zd09aSTgvV3R2bmpwZXZmVzlVSHh0ZXJ2Lzc3Y2l6WUYrcHZFR0xlbFo1bUFhcWtxODkwQjc2bWVwZDBjOWZLWGlxS3N4ZlhvY0JRSFhvTEdNcG1SaG1Ydm1WR1JhRWhVbmxyNjF0eCtFVTlXSkJqeUxUWWxDWWFCUERWbzMwclI2SlI0ZnMvaW1UMk5xOTBDTDNjZG5zUnBQTGNYNGRiVmkwQzZqYmxaaWJRd1NJYzVYS21SOVVjWTlub1k3dTVnTlhINDZVZm04S09QTENNSkZCUjdmVHlSTTFwQ0FKWVFTTWJBU1FoMkdBNE1zZ0o0NnZJdWZ1K3BXM1p0V0x4Y09IekRlWUFmMUh6anBXYU1VVGxsd3YxRmJVcUIvUjZablVCOUdJQ2xJQnJsN0tGN2Q3QnpQaXhmV2J1dys5OFh3K0xLOGJPclA3VXczMWlTZ1lUTERaRjJZTzBRS0FFb2doc0xRd3JQZEJQS3Q5UllFTFQxRzE2SmdMSjB5RXVIOWxERDdHVDQwMDJINTN1TVFtczRCZzRmUDRQRHdWRjB0djRVWE93aHFzZFk2K2NvQ291NmtuamtVSWg2SXBGSXdremN3cm1WRnQ1NnVBVURoekFXMk82VzJOdklFQkJRbEJaWllaR0VDbElxdE9zU1FuaHh4a2VQektFZEJmVGk1cUQrOVZ1ZCtsNnFVeUxJcXFOWGxSU21XbEJUai81R1BWa0YwSzc1dkxVd2R6aDk0RTVwS2dlQW5YRXVIUlF2OVhhSHR5QndOSXJDV1RDVGI3RXhzV1ZZSWVDTWc4MHNTSGx3VC81a2dtZkJPZ2VrT2FQc2xOaDhyb3N2WGtseGFRZ1VXWVpCWnhlSERwM0MyWWZmaVV2UGZ3TVhudjhHYkNDZ25ZTExjcHg1b0lWUGZlSUVIancwaDN0bkc3aDNxWWx6aDF0WWJrVStZckdBY2tCRUFyTzFBSWxTZU9YYUVGbmhzTkpPMEJiU0Uzc0lTSE4vMkJ5WlMrUjlLNjM2WHE0dlhkNGRYYWprbjBwVWxmZFFTWTZWbkhyMEtkRGZlT1lZQ0dVbEJtL3dXbFM2U2JBN0FDZ3pjNlBYSGIyWUQ3T1pVTXJGZUNZSktaQmsvU29YMzdkUzFUTEhpa1ZYRmRIQmZ1UWMxakd5ek9EcWN3T2N2Mkd3TjlJb2h3TzA2eW5tV2c0cVdrU1phMXg0L2h2UTBJQUtFVURqWXorNGdyL3p5MmZ3MEdPemFKNnVZUkJJWE4vTWNPSDZDRGU3SlRhSEdvVmpxRUFpQ2dWQ0FtQWRzaEpJd2dCenRRQ0I5RkxYbzl3aHl5eXkwbUdZR293S2EzY3kvY3I1cmNFTG1BamZDWENCRkM0S0ZFYkZGT2hUb0w4QkxkY1Z5QUdROGtXMmliTFRaSi85TnVBSmNDWHZETHI1azcxQmxvdFFycWdnYU1LeGNFVE00MFZuOE9RWmE5enRrOEw2cisxdUZYamw2VDV1M01pUkZ5VmMyY1BiSHhQNCsvL3dKS0pZNFRPLzl3S3VYendQbzNNa3pTWVlFVDc0d1VYODdDOGNRNnNlb2N3WnRaWkFhejdDN0xFNlpDMUFkNi9BM202QnphSEdkbVpRc08vWEUvbGFnTGFNWmlEQURzaHpoNnowZStUSWdhUVVZRUhCMExqTzAydmRid0lZMG5obkhtQ2xGQndyd1ZPUFBnWDZHOTVJVE1CNzNETjdkYzQrSG5zbEJvb2lOYzkzdGdlWHk3SnNrK05aSW9wSkNDOWdaNXdYazZqWXM3cXdzSWJSMnl2d3lwTjk3RzJYMEdXT1ViK0RKeDRQOFgvOXY1M0M0YU1SZnVzMzFuRCtoVjZGUUlXd1ZvZDFBaC82d0J6T1BsZ0hTUWRiZXRFS0lSa3lJRFNXWTZBWkllMGJJSGNZYVl0YnV6bld1aVU2cWZIS3RBYW9LUUVoQmJMQ1laQmE1TXllNVNjWlFTRGwwTmp0Yjk3WSt3S0FYa1VBOUVBWHd0VWl4Y09wUjU4Qy9ZMGZ5OS8yNFRMMHBEVyswN3RQaHZCVk5acklhcmZXMjB1Zkh2WkhtVEYyanFSc0tDVVZyRmVyWVZRU1VjN0JPY2JWbHdmWVhjOWdXY05ZQzNhTXBRWENXeDl0WVdiR2U5d3JWd3lHV1lpNFhRYzRRS2lBOTd5M2haTW5Fb2pBVi9EWkVxd2Q1d01Pc2hFaEMwTnNycVVvZWdWQVFLNE5Ob2NGdGtjYTdQdzIyS0cxNk9ZR1JXa1IxTlIrTDE4cFFabXhHOSsrMGZsVDY3aFRTVVZwQW93VXdpV2huQUo5Q3ZRM2w0bnhRRHZkRWNJZkxOTFpLcFFYWUVyTHpMN1kyeHRkS3JJQ3hybzJFeG9rSlJFUnd6a1NrbENVQnBzM1M4QUpzRFV3eHNLV0JkYXZkN0c4R3VOZDc1MkQ1UUFYcndUWTdTYUFjd2dveDN1ZWlQSEpUODlpZmxHQnJHZm1XVTJ3aFQ5SWpDTmtCVUVFQ2pzamk4dVhkdUd5RWtZN2FHT2hyVU0vTDNHek84TDF2U0hXT2tQczVDVUdScU5mYUtTRkpwSUNWdERXVXpkN255dU4zYTJBWGhKZ3BCU3VGa29lNUZPZy80V0x3Tk9YNFBWalZnTkNBVElBV3cwQ2c5bTlhbldVLzV6aEFLNEJrTTdncVoyYmc3WGVYdnI4N0hMamc2MjV4cm4yWEwzZGJOZVFjQUNkV3dobm9WUU1VNVpJdTEyVWFZcGp4eEtjT2RQQ1Y3NmM0ZGQvdlkvbm5pbFFaQmtXNWcxKytGUHplUCs3RnpFYlI3Q2xReWdBaEFLT0dCWUVyWDNlRDgxZ3paaWRyMEV1TlhEdHhRMHNSaEtoRkFpVmdCRUN4bHFVMW5wbFZ1dXdtUmUraDhhTTlpQkJISVdxSG9wNGtIc0JWMVRGQmdJd0hteVoydFNqdjZtTUhUeGZ2ZnBZTVd2dXhoSWJyM0lUOE1xczdEUnZqTHJGNVVGL05FeUhlWnlQc3BiUlR1WERFTVVJNlBlN3lQb0RhSjJEQW9tWitSWlkxUEI3djlQSDg4L2x5SVlwamgzSjhiTy91SW9mL3JGRFNJSUFneDVBaW9EQXI1NTFJT2pTWHdUQURCaWprVU9lT1dRRjQ5TFZEa2I5RkZGQUZVbkl6ODhLSWVDWUlZbEExWllKRW9JdGc3TFNibThQaTg4T0M3dFIxU0xLY1k0ZUI0cUh1WjdlR0ZPUC91WXpVMVNuTUFFcVZEQ0ZYOVQ0bW5rN3dZTDMyV1JiZXVUK2VHODB2SndQelErWFdmS0lWRVdnQzRQKzlqYVlIZHJMaTRBZ0RIS0IzL3J0YmJBVEVDN0hXOThTNG1kKy9pVGU5czQyYk1uUWtoRTJQZnR1TkJJdzdOM3NtRU52R1VCQWtOSkxVWWRLSUs2SDJOd2UrSlZRTlFPcVJtR2pJQVE3NTdYdnBJQjFYQ25UaWlJcnpTdTd3M0o5b21veDNzMk93a3pEOWluUTMrUVd4dzNrUlRicHlpZTkrSGcxa2dURE50cnRoVVo3OXQzTWFHUnB2eWlLSWpwODhsd3RpbXUwZWVNaWVwMXRHR0VBeHhqdTl2MHlSMnRoclVHekVlRTk3NXZIMy9pWnd6aHpmeDJzTGF3Rk9DZndFTkNtVW0yc2ROdWNJamdCV0VmZ2lDQnJCQkVKUkVtQTlreUNOU0owVW9NQUJtQkFTZWxGTGNJUVFrci9NNXhoZG81S290MnRmdjRWN2JnL1B1Y21Eak4yVTdiN0ZPamZGNkc4WmJCandxdTNsbzRYS2FqR1RQdmV4ZFVqZnlPdU5UK1lGYWx3MHBtWjVTTnFidmxJYS92bVpUVWM3Q0dvaGJDYUlQSUM3M3AzRGFmT05sQVVGcUVrSkZHSXg5KytoT01uRWppaC9aU2NJSVFSZ3pPZ3pBbEZBV1RPYTlBakJGakNWL1dyS1ZwRmdKUUNTUzJFVkFLR0xaU1VYby9lT1JUR1FBWUJwSE9BYzM0SWg4Z09zL0xsdFg3NUZPN2NPNysvTE5IWktkS25RSCtUVzU1bHhId0h5TWQ3eDJNQWlWUXFubDFhZm50alp1WnZxeWg1WkpRTzYzczdHMGpxTFN5dG5zQmdkeFByMXk1QUpDRnM2WkNBOGFtZk9ZcS84YmVQWVhFNWhuR3VZckV4akNiWTBrdkJDTUd3bGlCaWdCTUNWem0xMGd5ckNLVVIwTVlyejFicjVKRFUvS1pZSlFYQ1VJRktSaGlGa0NIZlpnQlpDNmQ5dmgyR0lUbm1Ycjl3WDg0TWI1SW5EWTZYSmpxR1Y1QmlNUVg2Rk9odlppT0NjMjY4UTR4d2U0TnBWSUc4TnJlODlNSG0zUHl2QkNvNW5SZVoybG0vT2N6NnZUUlU4VXh2ZHpQWVhiOUdVUktDd2doSk04ZFAvc3hKL01DUHJxRGRGb0N6a0NDWW92cmgwa0lFQkdPOG5wd2p3QnJDTUJQSUhjR0dCQllBYWNCb0wxcHBEYU0wRG5DRUlKR1lXWXlRWEF1Z2xBQUtEM0NTQWdJRUpmeG1XaVVGZ2tEQkdJdE9iN2k1bTdtbi9WRnp4K1FhQTBCcExhSmdXbldmQXYzTkhyWjdrRS9tNHlHQUtBakMydHpLNmtmck0rMWZCWWtUUlQ0U25hMk5yYXpmL3lOMlhPdHRiMzU4c0xjZEVnSHRsUVZvbStBRFA3Q01IL25wZWI5NldUdUUwc0U1RCt3eUl4QWtKQmlhQ0xhU29DMXlRbFlTQm9YWG5RUDhNa2huQVdjY2lBamx5QS9TeUpBd3V4QmhmcmtHcFJRS3h6RGFJSXdDUklFQ1FBaERoWG85Z2JPVzAxR2VwNlY3cXB1Ykd4VzRKelhqL0Fwa0FJTnB4WDBLOURlRHpTd3N3QmdEVlkyYjk3YTNEeGJlSnIxNXJJSWdtbDFlK1hoamJ2WlhsUXlQRlVVdU9qdWJONGZkem0reWM1Y0JmTUlhblZnRENDV2haQURITVlxY1VPWitmRlVwZ2lUMks1WTFvU3lxMGowTDVGcjRIcmRrWkNNZ0d3Qk9BR1Z1WVRLR0VRUVZDVGpOb0FDb053U3M4ZHRkNHByRTRaTk50R1lqZEx2OS9ieWRDRkJLb2w2UEVRU0NPNE1SWlhteHM1dTd6em5tQVY2OTYzeTZjR2tLOURkYmhPNzcwZGEza2NaaU5GN2V0UktFMlEvWmlXVFVhSnlaV1Z6NmVXWjNkRGpvd1ZtTFJxc3RkRkZTMnU4QndBREFVSVZoYzJacGhXcU5XUXczZXloR0piUmVRRDFrQk5MNXdSZExLRXVCdERvRWxBQkVDR2hMMEJsaG1BT3A5cFJYYWZ5YXA2d0VXakVnUXA5Vk4yY0VoUFBpajFZeWp0MVR4d052WGNTem0xMElJUkNISVVnUXBCQW9zeEp3Q21XaHk3U3dUM1Z6K3dwdVQ2eHBWRk5yU2hLSFNuQmFUSVVocDBCL2s1aXpGczQ1eWtjak9DL2NMb2lJbUhteXloNVdWMkMxT2E2SWp4dG1Ja0dpVm12QVdyZENVdncxZ0g2TENGK0s2elhSWGx6NldHTm1ycG1OTW9UY3hZT25qaUptUUxLRGRJRFdBaXlBb01aSW1DQVVJeTBFcENlditVMnJKY0dVUUpZN1NBRWtGVWRkS2lDT0NJSVlsZ20xbWw4T29iV0RGUkp2Zi9jcVJ0ZjJNTG8xQklSQVdSU3d4Z0lNRGdKRlJhbjNka3YrNDl5NEhmSWFjWGRJU0RWQ2lVWW9NWm9DZlFyME43cEZ0UnFLTkVWdmI2K2FVL1ZoZWdYeXNiemJlQjk1REtCR3pLRXBjenNhOVcxU2F5Sks2akJGanUyMVd5THRkUjJCOGxxck5idDQ2TWlKcUZaUGVuczlTTm5ERC8vMVZiejkvU3ZJTGNHVkFMR0ZZWUhTRUd6cGkyN2xFQmhsQklRK3lzZ05JU3NaNWNoNHdjbElvSEJBUGZMNzFuWEpDQ1FqYVFBcUFLUmxDQUVZWjdGeU9NSEpjMHQ0NXRZQVJWNVcrUWRCaFFwZ0ZDTkxYOXBKemJkODhvQWNFMEFYUkNndE0yR3FMak1GK2h2Y2tsb05sZ2dxQ0dDMEpqQVRIeVRCM0FaNUJDQUJVR01nbGxJVjF0aGRKdEVxMHBIcmJLNkxMQjA0R1FiYlVaS0U4eXNybndqajVDMmp3VWpWYWlOOC9NY080MzBmV1lGS0hDejh0cGZNQ0RnV0dQVUY4c3hEVEFhTUpHQ1VtcENtWHEyMTFBd2pnRGdneEUxUlZlZlpVM09GWC9RWUNJWWdoZ2lBZ0JqYU1HUWdjTSs1UlZ4OWNnT0RXMzFFWVFCakRBT0FCVjFkRzVTL1VWb2U0UGF1dGR0QUY4Umc0SHB2dXV0OEN2UTNOTWhqWkdtS3BGWkRKUlpCZHdGNE1KR2J4OVVWQmtFNHM3QjY2SjFSdmRrYURnYm83MnlURUE2dHhUbHlKTytQNCtSa1dLdTNzMUhxU1BiekQveklrZkF0NzF3VXRyQVFnVU1VVjE3WGVxNTZuZ05wVG41SHV2Sy9oVFYrb2FNUWhDUUNrQVIrK2FKa1JJb1JCSld1ZkVnZ3dUQWdzQ01vd2JEYUh3Q1NEWTZlcU9IWWd3dDRjV01BV01kU0NHaGpPcHVaK3pkN3FibFFoZXVUbTFPZG45cGp4dFNiVDRIK1ppaSt4VWtNclRVWnJlOUdoZ2tyVU5lVGVuM0JXbE5qZGcyckM3Rjg5TlM3V2d0em4rN3ViYy90YmE2UjBTWGF6U2FpSUtTMDFEVXVkSzIzdmMyamZ2K2wreCtkN3g4Nk1YdU9ITGNFTVl4R3RjeWhBcnFHNzR0WDRIWWxvU2g5YnU0cUVReWlhczJ5WWE4c3F6emdyZkJWZTFYdGV5TmlRREowNFFkeFpBQW82YkI2YWc2WHZyNEdTaTBMSVd3bjA3Ky9OaXoveURyV09MQWltZnpDQm02RUNwMXMybEtiQXYwTmJFSkpFRE9zTVdTME9jaFpIK2ZpWVJoRmphVWpSeitpd3ZBSEhITmtkVkZUeEhiMTVIM0g4M3c0Mjl2ZEFTUWdnOUR1N2V6dUJFcmxBTFMxempubVBlZmNId0lMczFiYk0xSkpHUFlETEJFek9DV3c5aEpXcGlRNHpTaEs4aUg3eUNITEhaUWsxT29TdFlTUmhQNjNDd0pHUW93Z1liQWlPRWNneDdDMldpUWhBVm4zRWpnc0NEWm56Qjl1WW1hbGljN0Zqc2ljZTNKdG9IK3IwRzUwQU9TdUN0bWRsR0xhVnBzQy9jMWhXYW5oakFWdTk4alZCTWhqSXBITXJSeDZiOXhvL2dvSk9xdkxFa0ltV0Z3NmdqQ3A0ZW9yenlLSUFrZ0szYWpUdWNhTTN5cEt2VEVCbkJHQVBXZjQvUUxNN0lCQ0ExRUNHRTBZN1JGQ3dSQjFJTXVBWWdpVUZoaWxGa1h1NEJpSVFrS3J6cGh0T3pSYkRtRlk1ZkZnUkxFRE9hQXdBZ1VKSHdWb3Y4MVZLT3h2ZzNGZ3hBMkZ4ZE1MdVBYeTN0VzFRZkd2ZTdtNUNVK0tHZit1KzB5NFNCSmFzYVNOUVRuRitoVG9iMnhqdjdMaElCRm1ja0FsWEQ2MDlFaXIzZndGU0hsbTJPOXhkM3VMbzFxRFZvOCtnSjIxNjFSa1Bjek10Yml6dmJlcDAveC9CL0FaSWd5WTkvUGNnQmxoa2VzQkc1UzY5S3ZQQllGYzRlbG1IQk1LQitSV29FQ2x2OTR0UVlYRDdPRUlTMGNKQ3pNV3pacUZVb3hRQW15OERsMFErNFVSTW1JazVKQXJRcjh2TVNvbFdEQmNKVFZsSFJBR2pNV2pEYTFieVdlMzFrZlB1d005ODRuY25JbUFHbGtXZ2laSGNxYzJCZm9iTFc0SFdEaC9lKzkvNVE3K3VwcVptei9abUpuLzJTZ01IMHZUVkE3MmRsOU8rLzFyWlpZL2V2WDgwd3VqWGdlMXV1SklFamNiOFY2L0k3N2luRXNya0plNFBkNXBzMkhaTFFzdUhBQ2xBSzBKTW1Db0dsQWFnaE1FR1FCa0NLSWtORUtCUmdTc0huSllPdUtReEJhUjhyK3ZGRUJZYzM3WWhmeFFTNjRKeEl4YXlPQWFVR2FFd3ZnYWdOaGY0K3g0YnJXTzlyRjJob3Q3SlRsMlBzYlluM1BacjdxVklGelA5MlcwOWxmWkFNQ0pFM01RUXFCZUR3QUF6ejIzUHIyZnBrQi9IWnZkMTNpbEEwQlg3Zm41UTR1cnF6K2QxR3J2Sy9OQzlYWjJMcWE5M20rQ3VXYks0aTNyVnk4d0VaR1FMVklMczFTcjAzeTlNVmdZOUVjM2NMdE54VlYwb1BhMmhsdWp6STBLUTVBQmdaMS9XbDBDSm1NZ0lpanAyMlh0R1VKelRtRytiYkYweUNLTUhJUUFBdUVBNWFNQVl3bXNLMEZINGRlcGFPY1hVUWdGek00WWRQc1NtWkZ3OEY4ck5GaEdLbWpPSnF0eExWU2pRVDU1d08zWEo1aEJ1clE4cWFaVGdad0JUNTg5ZkxpTlhpK2xILy94dC9MNTgxc0FBSzJuaEpvcDBGOUhGaVVKZEZIQVo4RDdOL2lZM3FxQ09KNkptNjBmUVJEOVNLRk4zTzkyc2x5WEd6SU1CamEzcDhGb0FpQVp5RHhPNGdBZ0tZU29DeUZXQVh5aEttaFZ1alRFQUx0MFVBelRrZFpwNWlWZXBQS1BNcnFTcDhrQkkzMTRQZHR5bUcwd1p1Y2Nnb0RoRElGVTViMExRanFTZ0FTS0FZRXRFTTh3Uk9EWnVvNEZ0UGJWK0dhRFlic093MEo0dlhvQmFBczBXc254ZWpOYUdBM3lBVzUzRm14MTRObHhuczRNSm9Mem5LSGIwNjNYcisvaDh1VWRicmNUL1BmLy9XZklyNWF5SEFRUzdWYUVuZDEwZXBOTmdmNVhaKzI1ZWFURDRlMFExYjNLbXlzQVVoQWRJK0FISExnOTdIVnk2MXcrczdUeVFEcnNMZmEydDgvYjBueGRTSFZmYzM2eG1iVG5WV2tkRHpxOWpTekxYNjd5M1hIZXU1Ly9XMk9MYkZCbVJlYWdBZ2xoMkFPOVpEaS9ueHhKWGFBOTZ6QS9hOUdzVzBTQlA0cEkrdFphNFFSR1JxRFhGNGhydmgyWGpRakZDSWdUQmptM3Z4SEdNVUVwUnFQT0VNSkJXMEFMU1pZWmNUMDRHc1ZxR2NBYUVWbXZpQWRpaHNMdFBqb0RjTXh3N1AzNS92SUtyWjBEd0oxT3luNXRFKy9IK0VURVJJUzV1UVN0Vm93clYvYW1OOTRVNk44N20xMWFocXNHVmNvOHA0bTU4c2xCbFJCQXBMV2V5Yk5zcGRadUk2azNnMkFtbEhtV0JmbGcxSFRHUGduZ3M2MkZoVSsxNXhiZTR4aGl0OVBiRyt4MmY3TXM5SG5jdVlXVUt1MlhnSm16ZnJmc0ZMbXpxaTRGdEYrZFVvNGNZQmxDRVpLWU1iZmcwR281SklIemE1MnJGYSs1RWVqdENUaEppR1o4RFpGQ1JoVDYzbm1oQ1hCK254b3orMzNzbGdEQmtCRkJXa1pXT2dwa2dEaUpabFFnMjBRSUFiYk1jQUNrWDlaQTQ2S2NxZkwzc1ljZmo2czZaaDRmQlBiMkljRE9hTXU3ZStsNEVBak00Q2hTY0k2bllmMEJtNnJBZnBjc3FUZVFwU015WllrSmxaaEprTWNZVTFzZEoxS0llNXYxK29sR3MwWFdzdXpzYkdMWTdkd0U0M096UzB0TE00c0xIeFJTdFlzMDFkM3RyZisxelBQL0RjQVF2aWRkVG9UQzQ1NjhtRjFwM3J0MHFQVkFFS2xRRzBaWk1MbkNRVHRHR0FnY1BzUllXTFNReEhCRHdQYXFhbDVRVGJabFlqL2Z0b1pRNUlUaHJ1K2hReENLa3BDWGhNS0lhaHJPRi8xMEtXQ1pRQUpZVGhieDRLSEQ0aDBQMWc4dHpJV0oxdVNpU05hY2hXUkdDV1lHUVFFY1ZVWEppSWhDb2pzWWduTGlFaE1ISm9GQkpBaEZZVEFjbGlBaWNzNGZXRUxRZE41MUN2VHZudm1pa2lOVGFqaHJKMEYreDVES3hDVkJXSkZoOUVoY2IxSnZiNGV6d1I2MTJyR1luV3ZPTm1abTN4SEZyVU5GbnJtOXpmVS9LZFAwZndLd0J6OFFNa2s4Z2ZlVUZBR3dqWFp5WlBYWTdHTmhLT3B3Z0MwY1djTmdadFJyaE5YVktnUm5BcGNFWndsR0NaRDBERGNSQUU0UW5BVjBKVkJSZEgzZ3pZcGdOV0FNSWRPZVFTY0FPQ3VROWhucGdNRUc2QTlHZU9hYnQxQ1A1TnhIUC9pV0I0OGZhNzk3cGtYdmVzdkRLMitKaytCb0dBVW4ycTE0T1Fna0NTRklTaUVBS0dZL3JRY2dJRUxvbzRGWGdaNEFDSzVhbHM0Qnh2ak5ORVJFUWhEdU9kSEdrVU5OYk85azA5QjlhbitKbnJ6ZFJONGJvTWp5OGNiaWd6ejI2TUFWRWxIWW5sL1VNd3RMV1pGbHRWR3Z4NDFHblJ2MXFBR0lSNFV6S0VaZDlIWTd6NVJwK3Y5bDVxMEs0TVdCSEpjbVFsNmJEY3JoY0toTlhGY1VLbUtYKzhHV0pKR28xd1VBUnBGS0lIQ1FEYytVSXdkd1dlMkVZOThxMCt3RklHVkVhSzB3bEhRd2pwQVhYbFRDTXNIUDVqaFF6aENDSUVMQU9JTFdqQTRYOUlmLzVpTHVXYjFldTc2K1YxdTcyVjljWHE3Zis4QURpMC84K0NmdmRUZlhoNk1yTjdLMVhqL3ZEWWRsMXUzbFR3MEh4Y1ZTbTJHYWxqdHBxbmV0ZFdYbDdTM0Ftbmxmck1MNHNCOFc0SEZmM2pJelN5bGdqRU52VU96NzlXWWpBaEhRSHhSVG9FL3RMK0xPdlU2YXMrNWc0UzBFRUFraGs2UlJueWVpUXc1dTFoZzlLMlF3MzV4ZmVreElsZXpkdW9GUnY4dkZVSnJCSHNFNXRneG01M2pUV3ZmUHJMVXZWZ0FmMDBqSE9TNnE1eG9EWGZRN2FXL1F5Yk5hSTRTUklKRVpVQ1FoV3dIQ3dQUGFwV1ZZQTRRTEJNc0V3UXpydkJmbjZ1aGdSekE1ZytIRklZa0VwR0NFQ2FNc2dRaU1YQk0wQ0VFMStFSWtQRS9lTWM0OHRJRHV5TkFmL2JzWGtBNExidFJqTk9xeGVOL2Jsb01INzVzUlNZUWtVTUg4SUsyek5vNkhtWGxmcjEvbzBiRE1CdjNzeXZiTzhJdWpWRjh6cGJzMkdoWHJSV25MQTBYSWc2QVhBS3pXenQyNE5XQWwvYWxGbGM1bHIxOWdaYm1CamMzaEZPaFQreTh6ZGd5aEZEbGJIdXlWUndCRnpabVpJM01ySzMvYnNYMjhORVU5ejdPNkNtcXkzbXpIZTF0cjFPdnVNSU92bG1YNVpPR0xVUDBxRno4UDRLdndGTmZKa0gwUzZKVkhad01nSEhaRzY3MU90dDZlVCs0UmtTUUlJZ2tnakFtdVlMaVV2ZEpyenRCRGdtZmZleUlOdzdmU21BQXpBbHdYb0pEQkxRSTB3QmxnSW9JVkFEbDQvVGtRUkFRSVlwQmpDQ0lFZFFrRmh3Y2VYY0xGbDNhd2M2bER2L2czMzROUGZ1eCs2bmV2WW5ldmc0VVp3Y09oeENoekZBYUNXaktJdzBBa1VhaWFVYWdXNjgzNGJYbGg4bnhVbnMvUzhndEcyNi8yaCtWMmI1QVBpOXlrQURRUmFXWXVKd3FUaHBrTlFLN1Vsb25nQUlMV0RtRWdXWWp2cndtNUtkRC9razFueGJqYWZsQWhKcFpLSkhHai9va2dqSDZpMEhtOXpBdHlCcGhkWG9IVkpYZDNOMEFDR294dk9lWi9XNEY4VUYxalVzemtEUGNkcXFtNDNhS3lBTWc2YkthRC9FWTIwSm9LRjhwSUlBa2xvdEI3T0VjQVJ3UVZrT2VoT2srb29SSUlCTU14d1REQkdOOWFVN0txa1djTTlCMUtBM0NOVUNZQ21TVTRBa3dwRUFsR1FBeG1RbDR3eXA1RkZDZzg4YkY3OGRRZlhjRkgzLzhBbGhabUFiZUpOTitEc1VSeExLaWVDR2pqSUMwQUsyQWlpYktVbEJzcmhCVDFJRmFQTlp2UnVXWXQvTFIyN3VYaHNIeHFaMmY0clpzM3U5ZlR6S1RWNnpKNTZhcGliNW5oaU9EeXdqZ2hDSVZYcjJFQW1KdXJZV21oanZPdmJFK0xjVlA3YzNqMU95dnM0K0tiaW11MSsxUVMvMWZHNnNOWk9ySzlyWjIrTFVyRVNWMlZlWWF5SEZEWXFET0lydGxTUHdkR3Z3SnpPUkd1NzN1c0NaRGYzcTVlUFc5VmtFT3RFVDdZYkNjUEV4QXlpQnJ0QUN2TEFlSWFRVWFFSUdLSUJEQWdHSi9oK2hhMUE0d1JzSzQ2UFlqQTBtOW9NWUxnREdBS0JoUlFCaEo1VlpCakJ6ampmNDR4UUdFSlpCZ0VSdEtLY2YxNkg4Z016ajB3ZytId0JvWWpqZEpJdjVMWkFhT1JRMWs2a0NCWUI3TFdrV01RZzhITWJMUlRLcEF6cTZ1dFUzT3p5YnNXbHhvUHpjM1hva1k5TEhxOVBMZVdKMmNJSk80VTJSeEhQY2l5MjF6a1JqM0ViRHZCNXRad0N2U3AvVmxSenBOVGFmdFZkaElpcWJYYmYxMG85UkZqZEREc2RDL29MUDhqYTIwN0hmUVgwa0VYUWtpS0cyM0I0S1p6N3FMVDVtVUFhWFhsRTk3Y0hnRDVSSVdndXNtcGFrMnhtNTFiYUw0ZFJDMGhKVllPeFppYlZTREJVQUVRUlo1OFlpeUJRWEN1NmhwSTMxb2JMMmpnYXNFaXdWZmlPUlJBUXFEazltRUFJaWpuSUF3ampJRXdBS1FDd3ByWGxYTk02STRZejMvakpqNzQ3a2NSaGcwVStSN1NUUHNwT090M3VHbkR2b292L0Y0MzZkdGt4TXhFUkREYUlwQVM3WmxRSkVtd05EOVhlL3ZDYkh6ZjZsSWpxaVdxMk5wT3gzUmdXYlhwYnJmalBGRm5IL2hFUkNTQXNyUTBHcFdvSlFyYXVHbm8vbnF5WDNyblVhU2x4Y1dkREtFU3NNeWVPTzBUc2pHTkFsKzYydmtyS01uZFFZN2h1RkYvUUlicUk4d3VLZE44NElyeVQ1dk5lamZMOGtRWE9RTVlnS2dJaloxWFlYd29UTnpEZXBSOWJzS0wzNkhHTWdIeXlRR1JNYVBNZ3YwT3MzUlFYQ29LM1pkS0hJcHJDdldHZ3FnR1J2YkxoZkJhN2RiNmRwa2dncFMrWitBMHdNUitCTTZPbjRpaEpCRFZISlJpeUdwZUhmQWlGaENFSUdRSVptZ25vRFVnR0dpbEF0WW1lR1pFdUhEek9oNTc2Q0hZY2dkRVBaVGJCdFlNRUlZQ2picENVVHBJUlRCR29sYVRzSTVocllPU2puUmhrWmNha2lRNnZaTGpJRkt0V3Z4STYxaDQ1dWpoMW5NUDNMZjBweGV2N0gzenVSZTNidWE1NlZYdndXUklieVpmeTlHb2RLTlJ5VklTRVlqYnJSak9NUWJETjA5bC9nM2wwVTh2MXNFTUpJRkVIRWg4K2QvOWRYem1UeTZobTFva2dZUVNoRWdTUWtVSXBJQWdRcXdFZGxPTlJxUlFqeVRTMG42dlFENzI2QUdBdUxXdzhGTkNxUTg0YTFYVzczKzkxYWhmUFhSNCtjY0lkRHpMYzgzZ3I0YTE1SmFLNG5zSUlGdVd6K3NzK3dxQTNtVE9PVkY0ZTYxVnl2c2NlZ0NCdFV6TmR2VE9xQjRkYmM4bDR0ZzlkWVNCOTlBaUlJU1JQeHJLMUpOa0hNUG41TmFIOE1aNGVpc0pnSnpQdmVzSk1EOXJNRGRqMFV3Y0dyRkRMV2JFRVNOT2dGckNDUGNQQUtDZU9NUXhvOTVnSERzaThQQ2pkZFJtQmhCSkh5eExOT3JMVURKR3I3dUh2QUJrUUdnMUpKUWlsSnFobEk4MEJBU1lDWTRkaXNKZ01Deng3UE9iZFBOR0g1MWVnVTQzQzdXMlI0SkFQcnkwV0Q5ejdvSEYxV1l6MURkdURVYlZhMVVKWnQzeGVxRUtSZ0FRaENRS0Era0ZNb3MzenliWDE3VkgvOEdQZkF6UHYvUWlidHk2Q1NKQ1BaVG9DdUdydW9KdzhnZitPU0lsYUc5a0lNWHRSSFdNZ2xENG9wTVN4SUtBK0h1MzNtZVNKQU1BODhMeVl6Tno3YVRUNzFnR3J0VGJjMmZDV3YzZXBKWjFDUGg2R01jdkphM20rMGdLV2FicHpYSTQraHFBRHU2eWZQQXVBTWZoNHpQWTNScWh5TFdyS0tiangyYWRuZUczNTViYWo5UnFzaWtFa1dPL0EwbFkzLy9XQmFDSGpLRHBnVms2Z3E0QXpnNElZa2E5em9pRlJReEcwblpRWWRWK1kwWTZGQmdNSllSZ3pNMWJ5SkNSR2ovSkpnVWpsdjVzSXVkL3NWcFRRWkpGcXErREdnSElhcWhRWVpFQzJLc092VjJMTkhNd2xwRVZQbWVYZ2hBR0FtbkZlM0dPa1JlRVJxT0dMTXRJeFFSSERrOC92OEZGNlZySERyZmZlZkxFekdObnp5dzljZXFlK2M5OStldlhQM2ZoNHQ0VmVEbnRnSm5IN1VuaGkzYXd6T3lNY1p4bGVoeSs4eFRvZjRuMnZpZmVBeUVFaEJDNGNmTW1MbHkrQ0FDNDUvZ0pYTGgwc1VwOW1WN2FISkoxNHpsR1VEWFdLTzZxSlZnOWpBaE1BQ2twZUMvVkFNQ0habUk4Zkd3R2dSTDRuU2ZYL2tLLysvSEhQNGk4dDRmTjg4OGNETmtucSs3UnNOdU5abWRucUY2dnlhTGRlRXhHY1RQTlN0M3ZEcjVwcmZzUHpWYnp2V0VVbnpPNnpGMVpmazRYeGRjbVBMaDlMWUNQN2NnOXM4aHp3MFhoNVJyWkQ1OHhNNHBSdjNpWndGbHJKbXdDbnF2dWdHcFJJcUJzbGR3VElDV2dRaS82S0FSUXF6dlUydzdObWtNb25OK0xMb0JNUzYvK1Nvek1TYVM1UUJJN01CRUs1M3Z5Z1hSZ0FJWkZwV1h0Sy9IRG5DQkpRWkNzMWlsMklXSmc1cmhDT0N1d3R5Nndka1dqdjJIQkZyRGFweEZSRmRhWDJxREtxN0d5WE1QOXA1Y3hOOXRFdDZ1eHN0Q2duYjJjODhMaXdyV09tcDlKSG03V3czdWZlUHpZSTZmdVdmemNONzUxNDB1N2UrbDFBUFhxL1JtRDNRQXcxcksxMWpxK2t6djdoZ2Y4WDJuby9yTS84ZE00ZHVRSUdvMEd0TllVUlJFTmhrUGEzdDBoQVBUY1N5K0kzcUJQWUJZRUNPdFlWR200aEo5am51UkNxLzJMSVVHZUYrMkxPQ0M3cjNnSXRCSkZoMlpyRkVpQjgydjl2OURmTUh2MFhwZ2lvOUhPQnQwbGRJN2dLYTVzakluS29uaXJsQ0tPNDlwQ1VxczNiWkZTTngwTUc3TnpDN1ZXNndrbDFid3Bpb3VqYnU5Zk9tdlA0N2JzMHJqSy9wcGdQM3h5Qm9OT1JxTkJPUzdJalVrNmdYUGNPSHlpL2E1Nzc1OWZpR3NTVWdseThEeHdLWUZRK3JGVERxcGlIQU5Sd0dnMEdVbVRFU1ZWNjlBSlFBREd5V281R2lFM0Fwb0U0bnIxT1BMQURpUWpsQTZTL00relROQXNZTmhQeFVueUs1ZEw5dExUU3ZnM0xnaUJ4aXhoWmxraWJsWFNNNXF3TUJOQVNFS1dPMlNaZ2RFTzFyRlh4OGsxQWlFUXFnQzFKTVN4d3kyYW42dFRMUW1SWmhyckc0T3cxeStPTHk3VUhqaDJlT1pVdlI2WnRZMytMbTR2eXJtaldJYzdaV2pwUUVvMkJmcWZ4NFNRK01rZitUVFdOemJvRHo3eng5VHI5WEQ1Nm1YYTNkc2pFaVNVVk5JNks0MHhrcGtsVHdMNWR1NGJURlMyUTVxUVN1YmJBeERqRm9zUDdZbGdIS016S3RGTE5jNnV0bkZpb1lGcnU2UC9zaGV3VmtNeDdGTXg2SGs2Mkt2bG9jWjg5dTJ5TEpzNkw0KzM1eGFpTUFwbGtROEZsRnFJNC9vWjUzaE9sMFZSWnRrZlpvUGg3OEtUWkY0bHUvVGFIbjBHMnhzaktnc3pYZ0NoNE9tMWlYT000MmZtejk1N2R1R2tESVZ3SklnQjZOSTNDU2dnUk1MaDBDaEhNek53aVVEUUlpUjFQNTh1NmJZSXN5TkM2UWhFNDBvOElJbFI3VkdzZW50Y2phOFNTaVBCRGhDVkRyd2dJQlMrZmVhcWFWTVN2cjNudUtyK0V5R0t2UmpHekxMRS9DRXZPYjI5cmozUG5nQmpmZW5jT3NiYStoQjdleU1jUGR5QWxBcGxZWkVFQXZVa29JWFpHczIwWW1TNXdjN2VxTjd0RmZlc0hHbysrT2hiVm1hZWYzSHJKUi9LNzBkZ2RDQXFvd09GVHJ4UndmNWREOTJYR3lGcWdVUW9CYVFRMk82UHNGYzRrQkQ0di93Ly91L1VialpSbEFYdDdwWGpKUWFUNjRnbXQ1WUlYOCtGSUUvdzhoNGJFTlhqVVUxWVZ0MWdFSG5Od2pFdldzQ3pwV3hlT3BjV3Vlc0VtcGFiQ1dydCtMODROQnY4LzhuN3J5QmJzeXUvRS90dDg1bmowbDliZGNzWHlzSVVYQU5vaDBZM3lTYWJGTm1rbXBSRURzMXdLREVVbWhseFl2U2cwTnZvUWM4S1BVaWhHTVZJTTR4UWNJYWlxS0U0YkE0NVpIZXpIUnNOb0FBVUNrQjVkMjNldE1kOGJ1Kzk5TEQyeWN5NnFPYXdLYlNoVkJFWjExVGV6SlBuMjJhdC8vcWJlemRKWFovQjZBc3hTc1lVaUJRWFByVUIvbTQ1R3JYanV2aUZvV3Zxdy8wakUxTXNWMlpKNkFkRTB2c2srZStBL1F2SThIL3ZKZ2V3Q2xMSUE2V21HR1cxcmdydjdqcG5Rd2ppQndTYlJDT1VqS1h5OEdTNzRvWDdDNDVtSmE4OFhCQ211dm1kMDBwb2JlTVdrdFZ5UE9rbXR5andsb0lpOU5ZbmRaY0pDayswd1dBd1RGM0VHcldsOGdqOTJVRmdjQzV6ZDQzNlBzZGs4SGtHVm8wZDA2bTY0REFhOGU2ckhjMzdpWEVkMVZFM0pTYVRrcE5seTgwN0p6ei8xR1VPKzhRUUVuWGxFR01ZMVJOMmRtcU9UenU1ZjdDaTc0Wkg3ODJiUHc2OERQekxkWVdZRDhaT1JDNnlEdGNmUE1CWitMZXFwUDg5MitqR2FBelAyanBwN1ErVTN4a1R3b0J6emh3Y0hSb1JNZkY4azF3VWdUaVUvT0dOemtTOUNGYk9QZjR0WUoweHJuREdqd3RYWGQyb1JzYVkrTmJCNm40YllndW1ORWlYYi9nZUdKS3lwUmhpU3QrN2M4b0wzcHAvMDRmV241eGNCTi9jV2NVaFV2aXkzS3JyK3JGeVBQcFVJcjdZdGF1d2Mybm5zcE5vVDQ4UDlsZno1Y3RKVW1uZ25pZzU1dHZBdC9nd2ovdGZDY0t0LzZ2cWducFNtS1A3SzlaellwVnNTaHBQeThuMWh6Y3VDZUtIUWM4RENZa3dDRWtTejdRcm5sOHRxVUppWjlIejFQdEw3ancxZ2cyRFRmcHRJMVpGS2ptc1FiTExwVFg2ckZNd0xPOGJ1c3BTYmVuenllbkxZR0JJNnptOTBHSHBzK2RjU29hUURMVkxxcGpMZzI0SmhyQ2V6MXVvU3VHcFowdTJMM3UrOTNYTDI5OVcwd3V4aGhnVE1TWmVlMmVPZFNYWDltWTYyemRxaW9FVDZ0cHpwWEptYTJzazg5Tk9idDQ4dmZyU0o2NzhqU1JzbnA3Mjc2MVcvY245dzlVSEtZa3pobExrTENxcXY5RERwd2VlaFhIT1NJenkveDhiL1gvMmxSdWNOSUYvL3AwRDdwNzJGM29iWVgvVlkxYkd5RmxKWkl4ekJRWXhNY2IxYlh3R1hobGpQTWg1VW9uZ0xSaHJjZFlZSnFVdjl5YkYxa1pkWEhMV2pyWW5mdnF4eTVQclZ6ZnFLNWMzcW9mR3RiOVNWZGE4ZVcveEczL3Z0Mi8vNDFkdno5K2FkOEdqYmlZZktydVN3TkdxVDIvY20vUHc5cGdQam42WGxrUmxxY3FRSHh4dEZjWVlmL1d4eC8rVTkrNHZ4UlQybW00NThuVXBWVldaRUhxM2Fwc0RRZjRGOEpZSWMrQTRvK3dMenZQQ0x5clQvcFgvblI0MTlHM0lIQkM0UUFxSmU1Y21WN2EyeDg5MGJTendGaVNwSzB5Q2wxWXJ2cERtbElVUUM0TUx3aU4zVit6MEF6ZWZIZEhzT0ZJRVQ2THdCZ2xaYTg3NVRkOE11dUdLSFVOTU1PODAvYVgwQXFMZ1hEOFlCZnVzbkJrL1JyR0kwVmduWTFWNzVoQVNoaUNpdDBNbThmUkdOZSt6VGNjbmYzektaSy9ndGQrYUkzY2F3cWdneHNTaTdYajFqUU1LNjlqY0dISGFKa2FGSlFXaEM1R3l0TGpDbXZHczRvbkh0LzJsdmNuSFhXRWY4dGEyTWFYbDdidUxmL0sxbDIvOU53ZUhxMXNocE5JWXVyemhQOFNodnpEaUJHQlVlNWxOSys3ZFgvNy8za2JmbVphSVFFakM3ZU9ld3VuWTV1d2kxK2Rrak1ZTzVYNUhyQ0JtQ09raU12MGhRd1lCN3pET1dWT09DbHZPNm1MNjVPNzR5czY0MkoxV3hmVnJPL1dUais2TUg1OVcvb292M0doVW1ySXN6Q2dKTGlaOEx6aGZHdk81cDdZLzl2U1Y2VS85eHV0SGYrKy8rdnJOZi9qdS9lWXduYlBXMWtpK3hDVGNPVzdrOHF4bVVudFp0citMMmFtaVdUcUFYdC9vV3JLNzhkNlZoMnhSZkNtRTdxbG11V0J4Y29welZyYXFFWWtrMGRzbnlzM3h2NVBhNFQ4Ym12NWZQREFySHg2NFFmNTdxVm94ZmloVTNGNXNleDU2ZE9zUlo4M09NR0FrSnZBV0k4S3pzZU9uNDRMS0pZTG81aVF6NFdiM0IyNjhuSGp2eFFtbk93WEdLRnV0c0VxRUNja1MwdHJ0VmZ2cmlLRUpCdE1KWlNuRXZCQkVZQkNkZnhZMlFUS1VYckJlZ3hyWGxGc2w4V2hMRUVYNTk0Z285OTNEZ0NIa24vR1I1MFpVbXdXdi9Nb1JpOWNDeGhrSzd6ZzhXUEgydTBkODZzVUtpeVhFbEhzK1E5OGxpdEpRMTVia0M1dzF0aHZTcGFLMFdPUGxxZkgySTNzNzR4OTc5ZnY3ZitkN3IrMy95cW9aNWtBcElxdjFHTzVDRDU5Z0hZQUxLWWxjdnpybDB0NlliNzV5Nzk5K01PNnYvZlF6aE5Eejd2MkdjZVZvKzhnNys0MTUvZTZTUlIrTnRjYm1udWNNRFJmZHdLVndaaVpRY1c0U3VBNFJISTNyZXZ6MDFhMUx6MThaUGYzQ3RZMW4vK2l6bDMvcTUxNjQ4cGUvK05UdUw3ejB5TllmLy9pTnpaOTg1Tkw0RTk3WlI2clM3VmFsM2FoS015azhSUkxqdTRSTlNZd1ZvWFQ0cXJTN2x6YnFseTdOUnJPRFpmLzIvWG5mWHVpdHprb3dRV1RWQjd5enZ6djY0eHB4K3ZCTlhnRjJZM3ZyODNWZC91a3c5RHVMNDZORnQyZ080aENMK2VuY241N01wWjVzK28zdG5XMWp6ZFcrYTc4dlNkN1BHNzE5b0d3WG8rWHg3M2lyVDY1dE1TNHRoL3RMTy9UUlBnQUcxaTk5L3VFZjI3dzgrVnl3dG93WU13ZzhuWHIrZUZod2hVZ3dxa00zSmo4ZG85KzBYa1Q4WEZoZDlRUnZXUVZIeEdBUll0SzZQV0hPU3ZvVU5JNjVpNGFZdE5TMzZNM3VySDU5ajk3ZU9MQk9UNVk0R0xXaDBzaDFsY2tLOUZGZFpsTTB4S1JHRjlZcWdwZVNvWnA1UnBkcW10UEk2amlRb2hCVDVQYitrcjNkRVp1emltRklWTFVsaFVSTUVDSjRhL0JlZDc4MUVFUENPV044WVgzaDNlVzkzZkhucjF5WlhSZVIrOHRsZnhLakZCYzRFZllCb28wa0VkbzJNQjRWcHE0OGhYYzhmSDN6RDVWcDVlOXFvLy9GbjN5R1VXbTVkVERuWU5GanJUSE5FRTFNWXBQaU95NGxjUmVROGNyb1I3MytGZjJvT0xkU1duL1VuMzdpNmlQLzdoY2YvWnMvOSt6VzMvek1ZOXQvOHZITGt5OXRqb3RIZmVHMnJUZVRBRVVYeFNVeFdHL05xQUtqZkdoakxXWlVXYk5SR1ZONVkxSVNNd1JZZEttOHZGVS92enNyeTN2ejdudjNGOTJhMTNqeHBoUnJqSGhuemVWWndiejlYYkhuMWh2OTRoUmd1ckd6ODdPRjl6L1o5VzNaTEZiL1hERC95RmYxTXpHRVVSakMyMFBYalNlYlc0VVk5b3kzMDE3cHJ2T1B1TkhYZklBZitPOS84dVhMN0cwVTNFbWVlMjhmTW5UQklPTHoyTEVDNnJKMFc1Lys0cU0vWDgzcVozcHdnOEFUMHZObjBvb2JKaEpFWmFacmRNUklGcmtPaXNpWDg4UXd0c3gzUzBKUThDd2FneGhMRkMzak8xR0pxdGdzYlFVS0w5RGxFN0NDeWdzbVpjOTNvd0JjWE0vWDBWNTlmZnltcE5uckp2L1pab1JlMXVVaTZuNmpaQjdQenZXYWJpbWMzdStRbUZnMkFTUng0OXFNR0tEck5VVTJSc0VYRm12QTU5UFRPNnNlY3lIaHZUWFdZSnkzNWNaRy9iRXJseWFmMnRxc1E5ZkhlL041bHg1QTVzK2V2MEpHUmxiTndQNUJZelptRlpOUndhWGRNZnQvU0RiNzc2cDByd3JIL2tsam1qNGlnc2xscmhXd0tZbmx3eU13Yi9RbUx5NkNhNXUxTDY5TXEycFd1OHBaVXgydVFpaXRxWUlrODhnNGZHeks2dk9UMGZUS2FoQ0dZVTN4RXB4RFNtOU1IQVJqVk0wVWtzVm4wVU9WaE5nTHhpbGRjOWtsUWhSak1USmZodUxHenVUbnYvemNsZU9qUmYrZjN6bHA0NFZlU3pFYkVUSHliNHlpcnZFSEM0SjFidXA5OGJEQUtBeERsMUo2ejQrbmowL0g5VVpWWFpLVCsvc3Z0NnZtN2JaWi9MUXZTbE1WSll0ejBDMStlSU1ia2QvQitLd3FESVV6ZEFkTGNOYWtQaGprckZMMUlwaTlhN1BkMGF4Nk5MU3hpTjd5cVNyeUorT1NxMlZVMGNyRkFpWmxmOVo4emttaFJJUzkxMXNPZGlybUc1Wm1NSVRlYVY5dGhDRVoybWdwckNpamJpRlVJVkZNbGZjZUJKYXRvN1dDRngzRDlXSlZ0NStFWU1EbnV6S0czRDVrSjlyU0M0TXhwS2hNU0dlRWhBV3JObFV1UW0wRDVZN25VeisxaDVqRWExOE43R3hXdlBuT0NaZDNSenoxNkM1OUFPc01mWi9vdTBqWEFXUFB4dFRURDhKNDVPbTZTT2tNVWxoREgyMU13bXhhUHZXcFQxejlqL2QyeDU5OTYrM0R2LzJ0Nzl4N3MrM0NJcWZock1rMnZlSTlnc25QcmVzalhSZmwycFhKdjMwOSt0UFhadHcrWEpyZmV2MHV4OHN1bS9DSmxRdm8rSVdaZHBINzdXSmMydXJwcTVQSkN3OVByMitVeGNNN2RYSHQ4cVM2akpoZEVUYU9WK0ZlN2N4a1NDbFlaM2V0OWRPbVMrYTRTWFNEcG5pT1JycWhRNmN6M1kyUldoZ05nN0pudk0va09LZnoxVERvLzFzMmlVRmxpeEtpMUE5dlQzN2hrNC9zZlBmZzFUdS9QS1MwRm41RWdXaUVOTVFrL3diZHpJVVRYcjlYVWRXWFhWRThacDExRXROQkN2RllhQjYxRytOaU1wdTViclhjR29iaHpiS3FmOG9hK200SWIrYngyOFVSamxqbnhIbkgwUFZuL2ZkLzlPOC94Nm9KL0tOL2NwdWpSZUI0R2N3d2I3Si95a1Z2T2xPQUZMdFhwcGVTdGRPWWhFL2JqbCtnNWRhN0M5NFY0YmtiTmR0alM0eEdkZVlYZ3FLTXk0Q1pNNHlQSWx0dmQ3ei9mTTFLTEgweUZFbW9uZEFsMWF3WENKWFZuSFJubGRGZzE4QmFncVoxVE90STVSSWptd2lEQ21ra0srZldUOEtJTW16VThOMW80dXZaUWFSSXZhVGNKSXVPWW9pSmpTM0haMzdtQ3NiQWQzL3pEb1V6ZlBNNys3end6RFoyOEt6YXlMaTJMQnRsNnpWOW9vb2FEZ25ndktWcEkxaHdoVE9qd3RCMVFkb20xSS9lMlB4ak42NVBQM1pwYi9SZmZ1czcrLy90K3pkUEQvbkJJSXBCaEdBTThmN0JFbWZnNktRUmdLMk5pdVBUN3QrT2plNnM1Yjk5K2IwMVdtMGxwUWZ6dk5jOVlRR1VuMzlpOC9JbmJtdzhmSG16ZXV5Unk2TlBQbmFwZm5iREY0K2F3VXpFWWQ2N08zQzZETXlxaXBpZ0dTTEh5NEhUVmFSeWtXVXY5RkVvbldHVWcvdXNOUlJlWlpFaENZVXhqR3REV2VrdFhobERHSVRGVXBWUDNobENTSlNGTWM2WjFPSDJIcjgwL1V1UDdVM2ZmT1B1NmRzWk05RHhpY0YySWFXN0ovM3Y5ajM4QWFsbzF5eXZyRTVPOS9hdVhXZTJzN1BSaCs3RmJ0VzZtRkxxK3BZazRueFpQbHg0NzJPTXgwUGZ2NTdMOVl2WXdVZHlzY1lqWFpuT0dmN0JieDJTb2hxNjVlbUZmd0Q3S0YxZDdFbVM2ck5WNE0rVUxkc3BjakxiNHQxSC9pU24xeXpiZC84eHpJOFFDb3lYc3cxK2x2dUNVbDR2dmRsU1hwOGlVMHVSUjJzaVVOdEV2ZFlaQ0JRVldsV1Y0Q3ExbVlxRDBCbDFua25SWVBOUDJRZkxrQXd1QTN6ZWFCbVBoUUdyQUtOUnZuMXFoS0kyMmZoZEQ0QmdORGpTVzRHUXFHdkhKMzc4Q2wwVGFicWV0OTg2NXR2ZjNlZWxGNi9SZGVwUzZ4ME1VZkRXTUhTUm9sRHd3QmZLRVloRFFvWkVad3pPV1NNcHNWb09US2ZGVTUvNTVMWC81ZFZMazZkZmYrdm92LzZWMzNqL08veWdNKzFhQWh2djNsOGxFV0ZVZTFrdWVoNit2c2tIdDA3KzhHLzBSVE1ZYXcxRFNCK1Y1MTJ2Rjlmbm43cDA1VWVmM0huaHNaM2lKNi9NcWsvdGJKYVhkN2VLR1VaTTF5WDZtR1Rrall3TFdJalE5Z0lpSEM5NjdpOEhuTUhzVFVxMkowN0JHMnZ3L3NOSWxERXdyaTJ6aWFFcXlJb3JRNGhDMjhtWlB0cDV3MWdzZlJTOE45WlprYjNOK25PUFg1bis5TTNqMVgreDZrS2ZENloxR1c5QytwME5nbi91RjU1Z1BiLzZmLy9kdHk3UVVqNzBUeXpDL3NHZFcrL0VZYml4ZS8xcU5kdmEvb3FZbzRReHRZQlk3eDZ1cDZNQkF5RU04NzVwMzMyQTRxcGx1NXp2ODcvNTExOGt4TVIwNnZuYXk0ZG11Und5b2ZlTU1IVDJQSXloQmhrQnhZM044dUUvVW5TanI5UURPMWJvdThnam4vMFNIL3NMZjR1VUV1R1hDc3kvL0w5QmxxVktIaUNsbElNY3JQNSt0QWpjZUwvaDlQa0NJM0kySnF1Y01BVERxck9ZTnBGYW9CUXFtL3ZvcUNNMVp4TDlZQWpCVURqUk1WbzJxaEFMdGxMRVBRUTlNSkxWdVR1aWgwK3pVRzUrTVRVTXdaeWRMSDJBWUMyVkVXU0lWTFhqMmM5ZjV1RHVrdE9UbGwvNzZsM0c0ekZYOW1iWldWcDNvMFZmVzdMblJwamVxcmxHMHdhR1FTMnh5OUthR01XY25QWXluUlNqSngvYi9uT1g5c1l2Ym01VS84VnYvdmJOWDlzL2FQYU53ZVV2ZVhHaWd6SGFHTzFkbXNwUC8rUWovTk5mZW8rYnQvOWdOdnUvYnAxcVRwdUIzSWMvU1BFY0FmVVRWell2L2RuUDNQajBWNTdlK1F1ZmZtVHpMMjNYNWVlOXNidmVVc1VoaVF4SlRGRFNzL1JpNXFmUm5DeWpNY2FZdGsvbWFObWJKaVF6clIzWGQycXF5bEtYaHFxMGF4ZC9STUFYaHVuVU1wMVpuRFVaSU5LM09FWm9laUVrdmZFMDVrUFRQMU1TOElZdUpyTm80OWJkay9ZM0Z1MXdmSkY1bG5zc0NtZjQ2My9yaGZ6dllMWXpZbXU3NU5XWDcvUFNGNjd3Ly9qUFg4dDlwSVVrOWdGK2U2MmdtaHgyYmZQdzBBMVhZOStYS2NhaUhJK014WmhoNkRhdGtkMjI3VXpmdEsvMXkrYS9GcEdUQ3dTTmFJeUp4aGl4emhKRDVFcy9jaFZqRFArSC85TjNlZlY3SjZacG9rbWlTdkVMejZNMmhqSENXS0QrSXgrYlBmWWZ2TFQ1Sjc2eVk1NmNPbHdVQ0tGaytNSmZ4ZDk0RG1NcTNuTUFBSUFBU1VSQlZGZlVtSTBycEhkK0d4YjN3QlpJejFscHZFWUxURElZRDVORjVQQnF5VEJ4bEM3ci9zVXdSSjJmRDYyaEc1VENXaFE2V3hmQVJJMXVrbnd5U1RKbk0vaVExREhXRm9ZK1dsYU5wVDhGRThHVjUyR0x4cXRocFNrNFMybEp5ZEF0b0Z1cTh5eldNdlJDTlNtWjdZeFlIblFjSDdVc2xvR0hybTJvQWlvemZJWkIyWmthQjZHWFRicFFteDJmZENRUnlzS3JYTFpQWmdnSlFaaE95c3RYTGswK3RiYzdxZHN1M3IxLzJDejRzUHgxRGZaS2pNcFplUC9tZ3NKYlR1YnRIN3FOYmg3NHVGaXFYL1FtSC8yeGoxOS81czkrL0tGZmVQN3krQzlkblJaZnJLMXN4aWpHV2FRdUREWmhKUm5UdGNrc2p4TjlBMjJiT0cwaVlvUm1FTnBzSm1nTXpLWUYxbG02ZUg1aHhxU2wrR1JzS1N1RGlIcWNoUWdoWk5CdW5Vb3NhejY5WWVpRW9kZUhhcHd4ZlJKemY5Nk43ODZibDA5V3d6dW92MXJRelVXeTFvaXo4Ty8vYno3SksxOC9ZSDRTcUNZRm83R2pLQ3dmdkxNd3pUS1lHTVVZblRUWkM2UEU5ZUUzd1pnVnlIN2ZOT08rNnk0Ylk0dk4zY3ZHWUZpZUhOdm1kT25heFdyUk4rMS9sMUw2SlQ1c0xoSHltRitlZW1hSGcvMFZseStOT1RycXpGdnZuaHExU3hLYkk0MSs0SGtBbzg4K3UvbjRmL0pIcnY2Rkg3MWMvM2hwelNoRWkrbDZ3c2JqRkQvNVY2aW5XNEJneWpGZ1NlLzlOaEx6RlRlSTlzUHJZVkpXRXRSRElsakR6WjBhSDNWTTF2V1drUE5oWEFuMUNPcEtlOTlFdG9sV25oNDIzM2tHem42ZmpFNU9VaklNQS9TZElTelZtY1k1WVRpRklWaDhxUlpWTVJpSzRweExINEptdktjRXdSa0dZNGxSbUd6V1dPTTR2cmZrZ3c5T21VNEtkcmZIZEgyaUtDeE5FMVRLWERoU1drdjlGSm0zVnIwTURvOGJuTE5VcFVORWFOcG9Rc0lNZzBoVnVmSFdadjNjN3Zib2tuUDIzcTA3ODRNTWduNklnZ3dhQm1tdG9SOGk0MUZKMHc1L2FEYTZlV0IwOUtHUjJYbzB0amVyTi8vbVR6NzFrei81K1BiZnVEb3RmbmJrdUZZVlZoVVRZTHd6UmlMR1dZTjFobmFSR0ZyQmVGMFlwMDBnUk9VM1N3THBJLzJRMk5zczJKdVZkRUd5dDdqMjJqYUNFOVZlMm54YmlFQS9DTU1BVFN1c21rVGhZRlJrb25zVVlxK0hRUVM2a0ZpMFFUNDRYTDUydE95L25jNVphR2R5MENUd0wvN0pMWFByL1pVOU9lN04vS2d6eHdlZFdad085dlNvc3pHcWlnNzVnY052WGVHc1BkdGJYNVhHamZ3emZsUnZiRzFlWXVpNzd2VCsvVmVHdHYrMnBQVFBST1NmQTdjZm9MMG1BM0xweW9Rbm45bmhuVGVPZU8yTlkrNGZ0R2JWRElqSVdzRjM4WG1NZ2ZFblA3SHp5TC83VngvL3lsLy8wdDZmKyt5MC9JbkNtbGtVdlpWSkF2V000cm12NERkMmMvTldZc2JieEx0dmt1NjlnYkdWUHJ3TGhhaFoyelVVaHFwTGZEQ3FtVHVIZGVvRjMrZDVlbVcxQTRpWjFtcHlINE5aejhMemlNeVM1OWk1akJMZFpDSmd4R0JMN2ZIN3p0QWVxUjExTW5wN2h3NThvUUVUSVJtUzE4OFhkTXczSlAwK01RaXo3VEg5TW5ELzFwejlvNGFYUG5rWjV4ekxKbENWbG1GSVp6b0I0eXpwREZNVnFzcHhmTkp4dW1qWjJScWRIUUp0bTFBUE84UVlXMHpHeFJQYlc2TkhObWIxNGR2dkhkKzkwSHBkSEkybXZvK01xb0lmKzhJTnF0TC92clBvM0wvaUpyL1lpNS9QeFEwamE4d0VHRCsyTzNuMDU1NjkrcmN1VC8wWHJUT2xOVWpoakJIUnFwYW82WjNPRzZwUkpwQVpvUjVyT1Q1ZlJseWVrYlpEcEdzRFFXQmpYTEExTFVBRWo1SXV5RVFIbTE5WlROQzJ3dkU4Y3JLSVZONHdMZ3pHQ0U3NXN2cHdncUswVVJSdDdXS1NMaVRldmorL2ZiQWNmajBMano4VWdtREFycGJCZGwxeUtZcE5VVnlLNGxQQzZ5MHEvaU0yK05rQk9ObmNmclNlamI0NG1vNS9halFiZmNIWStGQlIxdVZrdkVXM1dnekwwK04vTEVuK0FmRGJ3TUdGVGY0aGc0a1loWGZmUENJbFpmUzFiVmduazV4OWIyTTAxZ2tZL2Z5ZnV2SGlYL3Nyai8zbEwzNXk5ajk4d1pvWHBpZXhUQkV4YTlHQjlaam1DRC9ad3ozMjBsa0pMT1VJRXNTM1hvWmhoU25jaDIwenNuU1ZFcW9oNFFWdVhoc1JjczQ2WHArTEVTVytyUFBiak0wazhhRElmbGd6Nkt6VndpRWF3cUIvSDNPRkZxTWFDSUFodEZwbXhVTGJnWURCV0pYSVJUa242a1JqaVVabHRERkJqSVlZZE9idUM4L3FvT0g0dUtPb0RKOTdhWS9GSWhBR3dUdEwyMFdjMDJyUjV6WmhTUG9BUm9Ybi91R1M3ZTBLWXgwSXJKcWdiTHQ4MDRoZ3ZMTVB6NmJWb3h1emV2KzlEMDV1WitNUGVWQ2o0SnpOUGdybUQzeWovNDZsdWpHbXRzWk1SUHUvS1ZCZEdsZVBmdTZoelYrb1Nqdnl6bEFXK1lkSHk2eCtVT0hFRU9YQ3cxZXJwNWhnM2tRa1FkY25sbTJnVFFuckxOUEtzelAyVklYRmVUVUlyQXREUFhJWUQwMkVaU3QwZzdEcUVpa0toVE5NYXN0a1lpbktYSGJtdHprTTJtdUhKTFFpMGc3Qy9YbDdmT2UwL2RVaHJ1RW5IU3Z6ZzBHSUQ4cGl5d2MzdURIYUd4dkRDTVBXOXRXclB6ZWV6djZTOCs2bEpQTHcwSFNsOXhXVDZTWjl2M0pSaGcxRVlncnBGdXJUdnE0cTBrVUVQK3ExYUt5MWFtWW1QMmdoRFl5cXlzLys0bDk0NG5OLy9zOWUvK3RQUHpQK3FZMUNOamZ1OXZpNUtPYzlYWndQSkRpOWk3M3hjY3pXTlgzb3p1TTI5dkJINzVNK2VCV3hwVzVzazRWYTYxNWRtVVZNbThqSnJPQ2dLaUJsUlZvbXVEaW5mM1o1UkNiSnFPbGozb1RKS3VHbUM4cC9YMzhNVWJQY3VrRTNxYXlmaU5OS0lxR0hpaSswSlZpMmxxRlRBRGEweXFrWWxvbDJrZFRYT1VMWEpveDF0S3VCNVdIRDIrK2M4TmdqRXg2Nk11RzltdzNlMmJWRHBCcFI1aHM5b0JXZ05kQjFrZjNESlE5ZjMyQVlFbUZJTk0yUXhZcTYwZnMraVRYbTBtamtyMHJpOWJ2N2k3c1hhTEp4elljWVFtSjNaeXhGNGJqeisrdzQ2MzRIbHRmNUxXNU1aV0FrVUlrU2lpWWI0M0wyeU83NDJtY2Z1ZjdGeHlidUM2UFNGUVl4S1lJcm9LNE16VEloU2VmYU1RcGhVRnVUbUhURzNmZkMva0hQcW9tMElkR3RuV01Nakp6bDBxU2txaDFtamI0YVZUNDFBWnBCUDdmMGhzTHJIRmZRVTltY2xWL25Cb2h0bzNaRWZaOElCZ2JCdEVOTTd4MHV2OUVPNmNCOE5NdE5Kd3JHVk1hYXlocFRaM3BycmFqMkQzeU04ci9aY25YeHg0cXkrSXd4dU9YcHFXbFBWNFErTUhRTktTVXptbTNzNHR5VHhySXRLYjJQeUVuV0JLUUhEbHNyWUJHeEg3SEpLMkJpc1pQLzBaOS80b3MvLytjZStwOWZ1VnArZGhXa0tvWWtPMGZCdU5NRVVjZFRDbXBsSmtwN2dwemN4ZDc0RkdhOHdkRkp5ei83N3BKWDNqN204dkYzbWRDUmtvVUlKbWErZWpKSXJ5YVJSU21NaDhqK1RzWGdIU1lJVnNoKzdPdjVxejZMSVRQZGt1anRyQUdPMEExcVdSV1RHbEdFcUQ1MVo1bXpHUDFTS1FjbENvUm9tSGVXUHFwaFJUZm8xMG1EMG5Gakw3VEx4SkJ2K3hDRTBFVkNNSnplTzJXMUdMaXp2K0xqeisyeW1FZFdUYUQwbHBSYlFlT1VueEdpS0xraUtpLy8zdjVDM1cybUZhczIwcmJoVEV1ZmNteDBQeVJqTUplcTBsVnRHMTQ3bVhmekM3ZDZXbS8yL1lQbDcvc21mM0NqWDd6SkwvYmo0MUZkajMvOCtjY2UrVlBQYlB6NEgzdGk5MmUrOHZpbFAvcUZoN2YreUc3aGYyeFcyODFKNVV3SWltN3ZiRHRLRDAyclpBWURTbWl4SnBNVHRNeExHTzRkOWZReEtXc3BKa1JFZjAyd3UxRlMxc3AxbHFRTXE1RFU0cWd1TEtQQ1lORkYzSVdFRWJCaUdIcGg2SVV3cEd5VW9QKytheFBEa0ZSc1k1RStTZkh1d2ZLMVJSZmV4RkFZQTlZYWI2d3BqVFhWMlEwTmxRaUZ5Rm53WC9rQStEV2RiVmZiVjI5TXJ6ejEvTzdqRHowNmUyelY4c21ZN0NPU0VnbGp4RmlHcG1IbzI5UjNuVWdDNTIzdENuOWRoSG5vaGxmeWE3RFdHdmVBME9lakNFa0srTUhvai8vc2pXZi9CMy82NGYvRnc0K1ZuKzZpK09QanhMZ1dzN05LK0tOME5vN000NTRNc0JuazZEM29XKzd0dmNUZi92VjkvdDdMQjN6cnFPWjZ1TXVUNlgyaWM4cVVXL3ZickpOSm5jRnNHV1pPLzN4eldtR0NVRVR0SjJUSWJEdWptN3k1VU1wYkExMHdMSHRMbTBNZGpkRlMzTmhzOVdLMXFWVndUUDl0Q0FZN2lDYTZZbkI1L0phc21tQUVkRFp2dlNFNVE5K3JaWFNNaWFGUGhDQzA4NTZ3YW5qdjFwS3FjRnplblRCZkRMb1dSWlJqdkpaWWluclN4YWpsL2JJSjNMbTNZSGQ3ckZoVEZ4bEMxRkljZzRpWW1LRHZveXNLZndOajdyeC84K1NOQjFxeHBObnVmekFhZHY4QStQYmdyVEV5eHRSLzVZOTg5ak9mbnRtLzR0djVKeGVyWVJLR1ZFbkV0MzF2WlRvaUdMMG9LbStwUjdDeFllbDZvVzFnNVBVbkc5SmFCSktaYkI1R1UwK1ZIRU5JcklhSWlNV1FpSkpnUFR2UEMzUU52cmtJS1FnRGN1WjZNbktaT3BtcmdpaTZZTmFlNU91RlJHWlIrY0pRT1ZkT1MvZUlNV1lUTmFSd2FqaGdlbDFucXJyYjJDcW5vN0dmbG9YYm1FeDlkZm5hZUxhNVZjd2VmV0x6K3ZhbCt1SFJ1THBpQ2p1cUptNjdLRnpWOTZuNGYvMlhOMmV2ZkgySkw0ekJxV2toUURHZW1tcFVrMEpyckhGaWJERWU3L0pTc2VlL3VuOW4rWGJmUlMzZmpTbXNYbWlEaUFTUkQ3VVdhM1IvL09pTjJkWm5QblBwVDk5NGJQUnBWd1pUbDRacWJDbEgwSjFZNnVKY2IyWFd3OE8xaUJ5THZQWlBlZXQwZzMvNjJuVzZPeTh6dUNtL2RlbGpmSmJYMll3SERGSmlURG9INWRCeVNKYUFUenkxWExFNHRMdytIYXNQZXhKc0Zyc01BelJpR01UZ3NwREZpRzVTMHRvaFJEZXZzeWpwQlQzUUpiZGRQbHVSeEtTaGFkYkExR3FMc0VqS25QTldxOFY0WmlLb294Q0p1c0dUZ1BHVzBjWUk1eDJUMnZIci8vSVdsLzdFak5tMFlOVmtNVk1YaVRGUkYxN2RjNUplUERFbHRqWnE5ZzhXSEowMjdPNU04SVdsNzROT2N6TEgzNmozcFNBeW1VMnFQL0g0SXp0ZmUvdTl3MWZ6NGR3RFRrU2lNWWF5Y0ticmcveEJiUFFIeS9ZaWwrdmxuL3F4VHovOStiM3h2OWZ2Ny8vNC9xSXRsaUdKSktHdzZxTmVWSWFpc0RpZ0tnMitNdmlSeFJVUjArbERiM3YxOTZxOHlZd3F3UldXb2pKMHZhaTFjQWJhTEE3eHlwUXJXNHUxMmJCUXg2VDZPVGFETTFtUlpJeXlxMXloL2Y4dzVFTWdsMTlkcjV2YkQ0YXVBMGxpNnNJVkQyM1duMzNuY1BWTGVIdHZZN01jWDc0K3FuZXZqSGUzZHVwTE96dkZydk9VVHp3eDI3dThPN282S29xSHhGRzZrU21kTlg3b1RKRzhLVU95aGJWaWhvU05XQ2lGeWFiSFdvdnpsalR2U2FzV1JPaVhTek1hMTFTVGlWWVdDWGZqOGUxUC9ORS9mZU4vZGJ6ZnZITG41dnpXL0xpOStmcDNEcjV4NStiaVhvcFNoaEJEakpKTUZ2eUtWc2xWNFV6MXVVOWYvdUluUHJYOXM2SEVIN1ZXVW9Bck8xQldzTnh6akdlVzhqanFyWk92S2pFR1c2aHRST29XZk95ZHY4dVgzaTc1di96cTkxbFZ1K3g5NWMvendiVW4yR2oyTVZhNUJ6aGxySzFMYUZxSU5sR1NlT25lS2FNbThyM3RLY0ZhYXFzMDBwUUVHNjFXWFFCUlc2OWsxZkxHUkJoczdwR0Q0SDAyckJROWtLMFIrckIydGxGcXJFK1NBZDBNSDJTR1hpSEtuQlMzZGd2VkF5TkdJUVI5M2VXb29KNk0yT2dqOXc4YXZ2dmFQcDk0OWdyenhkcTBVbDF5aG15QUtibVNIQVpoT2k2b0tzZDgwYk81TVdKVU9ickdFR0xFSjZONnZ2eDZRaFRLd2oyL3RWRi8yanY3Ym9qcDRqVEZxalE2cFQrb0d4MCs3RnhhQ3ZqTmpjbjJqOStZL1JtWkgzK3hhZHBpRUNUa3RJeUljcHFyVW8zOW5EVzRVdWVoelVwb1cySFZDUzRvMkdhc29Tb3N2clo0QjY2MEZKWGpaQlVKb25HK1lpQ2tSTnNrdWk0eTJxeDBjMXVqTGtuR0lFWkJFdWYwaG9naU5FRlg0SmlrdG0zV1VEaW9DbVZUTFZyRGtFUVhsSUZHTUVYcHpNYW9mT1FUbjc3MHBjLzl6TFhxb1ljbVQreGVIbDJaYmZxTm9qRGowaHRmZWlGMDRsSXZMZ291V2FVNlJZeVlFcGFkTlYxQWpOT2liQWlHVllDbWk5bGl4K0dkNC9LTkxZNFA1alFuSFRFT2xMYWc3em9LVnhLQ3IxenRuMzcyMDVjZSs5Z25kbU9NMG4zMnp2S2RXKytjZm4xNTJyMzcvcHNuNzc3NTJ1RzdweWZkSWdReGtxUkVwTHA4YWJMNTNJczdYNTVlY3J1SkpIZHZKaE83eUkxTGhsR1JXRzE3anZkS0xuVXQwbVVnelJpbHVKNlZwekFOSy82OWh4ZXNiaVQrajk4LzRLMm01dVhoS1o1T0wrTjlPbE9ZaVRObnhta1N3WFJLVVBJKzhmeHF5VFJFdnI4ejRiVHl1b2hFS0dQT2QvRVFFSUt4WnhaVXpxcmsxQmdoV2tOblZDT1AxWFlzclBKaFhXV05iZzZUR0VUREpXSTBXS3VCYW5pcmJhRkEwUWJTSWpBVURvd2hEa21UYloyanFncjZxbUJqVTNqdHpXTXViVStaVFVjMDNYQUd5amtNWldsek5vMCt4cTVQWE42WmNldnVLVmN2emRTUnRuSTBUV0J3Q2ZGbVBjQXdnaVRyVERXWlZEOTFhVy82eTdmdm5pNDVwMXFmV1lMdGJvODVPRnI5Z2Q3b0hpaWM5K1ZmK1lsbnZ6Qk55NTlaekp0UkwwYU1GV090T1V0QXNWWjc0bGdKbTV1VzdVdVc4Y1N4T0lvczVnbXhDcENsd3VMemJSNnp3VUNmRWltSXVuOE1pV2FJR0NERVJCOGliUisxRC9kYTlndUdjUTF0YnhoVitxNFdZcUJKeEVHcmd0Z0owUWgxcmNHQnhrUGhEVlVyckpiS3ZySEc0bzI2Vkd6TTZ0bWpQN2IzRjUvNzRoV1BpUGNHbTFJMHNSUGFSdEpnUll3VGszUEFHQUxTaXpYV1lieEpqRjNDaWpGdGIwbEdzQWplT3phM0tyckZUU1Jzc3JHOVI1UUYyQVhHR2ZxbVlUUlN1OVJ1NkZndUJ0TjAwQ2NLR1ZMaHJSbGR2ajc5NUtWcjArZUpLYWJQaC9iMmUvT3ZmZnVWZTc5NmROTGUzNys3dW5mN2cwVno1YUhwbzVjZTIvamthV1BNeUZxNWZsMlllT0grZlRnMGx1MUxzTGhSc0hFNFVFZWRiaGpSMjVtMU1DVEhJMjg2ejMvNGhUMjJINy9PTDE1N212cFJLRzlmSnA3ZTBvTlRKTS9TbGZRaUVhUVhwRGVJMTVMOThhT0d2UlI1WXpyaWc3S2tLWjBhUGFaenV5bkp4bk4yVUM2RWNXcFdFZGNJZHNyaFR3S3BWNFdJTGMvbFFxWlFnb3pOOC9rUTFCYkxaQW1yQUlTRTdTTTRpeFZsT1lxMVo4aDY2VDI3VzU1M0Y4ZTg4ZTRoTDcxNG5SQVR6aWlQZnMwaDhGNnJTY1UyWURUeUZONXlaMy9PN3M0VWExWGUyblZCU1VIV0lpSjRhMHdRR0kvOXgyYVQ4b1hiY0RjVG9UeWErbXJ5dUpUZnozN2RYYmpOMThZSk5WQTk5Y1NqZXovNTJPN1AxMTMzbzMwVHJIWFdZS0VKQ3BZVkdhRzg4ZENJUng2cmtSUnBXNkV1SWZSQzAyZ1p2VVpoS3EvejhKVE9COWFyVlZRQ0FxSlNWTyt3empCRVlYdFNjSDJ2eHVVWmFwMHJnWEhsc1JiYVRrL3pFSFVCT1ErVGljTlhhazlVMW9haXRneVovOTUyNmF5WFN3YVNGVlo5TkVkOUtMZHViUHV1RlNQNXhpOEtRelhDMmdJYm96WFdHbU9jTVRFWU03UUc2NFErV0ZhZHBUQXdMaEpWb2NrazNodTJkZ3FPN3k5NDcvVzdtT1F4dGlKbEpVZnNBdVZvaEJHaFhhMkljZUNwbHk2YjhWWnRZbEJqdFl3eHVPUnQ2V28zMnR5c0hudnl1ZDBmK2ZqbnJuenhxZWUzUDFuUDZvMG5IdHQ4OXBubk5qOXJETFoyWXFaanRXeit4dGNpWC8yTmdka1V0aC9UWkpQNk9HTDY4NG11eVI5cmlwQllHTldXajAwanoxM2Y1aE9mK3hTek85OG4zbmtmQ3E5QVdaR3JnWHl0UzJlUWZxMzlVMnlrVG9uclhjZVZlY2Q0U014U3dFVmhLWTVPVktTQ3FNa0ZFYldYamxCNFpjK2xxT3ZEV2tYVEd6SEV3bVplZlo3NUcwUEk4dHFtaHo0cXNZQzR0cWZTbGlCaE1GbWcwdmVKZmpYUUxUcFNIMGhKcWF6M0R4b2VmbWpLYkZwcjZHSitmN3kzMnFldm1aYTVlaFhnNUxUbDB1NlVKQW5CblBYcHptVmdFV05TU3NrNU8xbXVoZzlPVHR1WGMvaytBRUdwemFTNktuNWZHWEx1Z2JLOXlLTWovL2xIZHA1K2JHVCtYREdFaDJJU29vRm1TTFQ1NWkwS2pjeTVjYlhDSlBqZ1pxRHJZR05tT0QzUkIrcWQ5dDVGbm9VYnlUUFcvUGNoNkN3OFlQVEljMnYrdWpBYmVhN3ZWR0ExbHFldXpwR29rNU5JbnhselE4Zzl1dGZGcU9XcG5CRnJYS0VQb0drVDdaQklVZGx5T0VNN0pBNldMVmVmMmtVR01SYk1xTWFNSjJLTVV5dWtHQTF4MEFNbFNhNUtldFZhTzZjZzBwcXBGWVA2bTQxbkJVODhmNG5KUnNXdGQrNXhjUHVJYnQ0U2U3MVpmVm1wS2l2MlBQSGlOaC8vOFlmUG5DVzhCY0dZSU1aWUM4WWgwVnZFbXRJNE01bHRqNjgrOHRUMmkxZjNKay92ekNoOUlSemZDNXd1SWx0N0ZsL0IvWDFoRU12T0ZVKzNXOEFLWm91WVk1VVVHU2RxbUlMUjcwR0toaXAyUE5xK3dTd2VFK2Qza2RVUnhpdnJ4ZVNLekpqencyS2RCR0ZRbVdrYUlIVXdYa1V1cndhdTlEMlB0aTJQenhzZWJqdTJRMkMwU215RXlMalFNbjJ0V0V0QXNqWURhaHJ5S001bVJ4dk9qQ1JUeUlCcnNxU296alhPRzZSUENoUmFtNlhLUXVvUzhiZ2w5SW11ai9TTGpyNFpXSE9YaDZCbC9iWExVNW8yWXAwNTAxUmtkODB6Z1VyS0FPSmkyYk14SzZucmduWVY2SHUxSHZQZTRleWFEV2hFQkp1aUhNMFgzVGRXemJEZ0FVZmZwaDErWDhFNDkwREpYZ0tWdFdiMEU0OXNmT2xxWGZ5Y3g0NGlTQmZGdERFUlJLZ3F2M1oyWVZwNW1sWEt6bzdRRDlBMjJSbmZRbEZtQVVJVXl0cmluSklSeXNyZ0NzUFJhYVEzc09paUlwMFl1cEFvakdGU0Z3d1IrcUNFbUxKeUZPT0NaUk5Kb21hRGtPZjBVUmVmTlRwOGxqeUQxZm1yMFBhdzZoTGRFSlVPbTRTUWhNTnVnSEhKWkZiakMwTlptcHhBb29LWk5JQkVZZGtabXNFcTJ5dC9qQW9kS1NuZlhrZUJoYzJieUZnZWYzNlg2NDl0Y3ZPZEUwNE9WK3BwWGhmZ1MwSk0zSGg2ZzUvN3F5OVNqQ3JhTG1HdE9YUHNPT2NnaTdFWWs2eHUvSkNFb1JOdmd4UWJZOEU3NGUzM0J0NStLL0RZRTQ2SEhqRmN2ZUhZdSs0UTYraVNaVkY3WnN1QkVVbURFdU1GN3ZtRjJ4THJkT0l4Znh2Q01hYnk1ODFkdXZEQ2NpOXRqTkc0NHlqUUdXajExNWdNYVRCd0tyaVZNTzRqdTR2QXcwY2RqNTIyUEhteTRzbDV3eU5OeDZPaDU3SkVwaExaSGdKbFN2U2ljakxqVEo1Vkc0Yjh1bE9qZjY5K2hkbDZ4NjZuTW9ZNENIRkl4S0JDSm1ranNkZlpkNy9vYUZjZHhsaFNTcVFrSEozMGJHNVUxR1dScXdrRmM2MWJQMnNWd0t5aldSZUxIZ3hjdWpSUkptZEk5SVBhNnJoc2FaNlNtcDQ0YXlmelJmL1Y0NVBtRmhlTUpiT3E3UThPZGM5N3hJeEtOOXFveWh1bGRaTXdwRFBGVHpKZ3JhcVFZcjRWVTFRRVhVOUlPRDNWcE0zU2FOa1RPa1UweTlKZ015Tk9yRkJXbHVUQUY1WlNoTkpxWks0bVpocjZLSndzQXJ0ZSszdUpRb3I1YXhXR2JwbWdNSXhLVGYwWVFqNTFnK1R4bWlhQ08yc292YVd1QlY5YXBOSFplZ2dKaThFSE9MeDV5clVibTZRdTRvSWxkSVpWMWkrUENsR2xWanp2STFrdnRGNUwyVGpvdkJnSHRSTnFyNUI2aUpIckQwL1l1VFRsN3EwVlZXM1l1alRsL29HUU9oWExqRGNyK2lHcVJESWtCcmV1WFBRUVNjbGtEemZvb2pGVmdTRkVhWHBoT1ZpMlJvbEhueTY1L21oQk9ZVmVFb3VGTUQ4VnRpOWJTZ2Q5YVhuaitwU24zMXV3RlFhaXo4NTA2NUZaNUd3RHV4SVllZTNCTzlXV3kvcm5IOVRwUlhvOXhGbjNzRlo3ZFRyOUhQTGhLRU11cDBmNWdGZ3IwaW90ODZkTmcxbDRaQklZSkpDczBHSzVSY2xSNVRtb1BMZkxpdHV1b00rTzNMRlcycXVONTcxNWlPQ1NZRUlrZFZxMXNVYmRhMC9YUm9aVklJUkkxL1pVVlVFU0tFdEwwMGZlZVB1SUZ6NTJtYTVQakNwSDRiSVF4WG1zcUVlOE1jckMyOTRlYyt2T01kZXVUUm1OQzA1UFdsS01taGhyUUFwL0poWHczbDZaak11bmlzSjljeGhpKzRCMm5UK3dHOTFrTXNqSXU0MlBYOTc0aWEyNmVDa0VNZFliTStRZk9PVlN4aHFvdldOYU9hcmFVbzJjRWhaRUFiYys2R2hqeU9OQzV4UnQxZEpWYi9NVVlibUtTQkNhUG1uL0w3b0pZMHhzandvMko1N0NHa3FyL2w2RjA2Y3JTVERvNFZBV09VTjdyWUE3Vng1bWcybGxhYlY5WXRYRy9QVlY1TktreUZCWjlxN09LSTFRV2wzOFJhWjdSbXZVYjFyMEJsU2p3K3h4bHJTL3RQbm5zbDcvdjNxbTZSanBlOTlxK041M1ZqUnR6eEI2bHZNQll5dGlqSVIyd0ZJd21SU014enE5dU9oQTZLMEtONVIwa3N0c0ROMGlHUWNLU2xvb2FzZm10c1dYYXFodzkxYmlqZTlFWmh1VzZkUWlFVTZzb3kwY0crMUFsUzlsK1pEOFFyUTg5eGswNnpOM1hYS3NocGl6U0FucDF2ejN0VFJOTHR3VytyNUlWdGU3TEY0eGNiMjZjMm5ldzlBWmhrWUlpNGhaSk93SzZ0UElwWk9CaDVZZFR5NDZQalpmc1RWRWRsSmdGQklMNzFpS0ljd0Rwa3RRS0hIVmk5QzNpYjVOaXJSbnVtcm9oZVZ4UXpqdEdMcUJadGxpblZwWnBSaW9TczlpR2RqWXFCaVBTN3BlOVJjeFp4RDBRYkJPUWNVaDZNenRaSzVqakxLdzNMcDFuSHQ2VmMyZGFWUkZ4RnByUWt6TDAzbjdtMjBYbW55akQ4YWNzUnJrOS90Ry81QWtOWW5ZcUdJT2RmWXhocnEwaVBVc08rM1JwN1ZuclVvcks3M2xWNzF1SGszUTBINjh5QzcrUTZaSmxxWCtHeUVuZEJnTjBYTUNLYVMxclNaZFRBd2hZdEV4emtrclJDZjBLU3ZhcklKMnhrRlZhc3NBbHJET1dBc3FhSW1aczV4VWU0RzNoalpySjYyRllyRE1sejNkcW1kY2xFZ1F4aWJoSFhpcnFTU2xFZW9xcVdYeEdkTk9rQjU4SlRwZXlTUEVaUFgxbGhXOC9mcVMzL2lsQmNNd3BxeEhyRTdtaEw1WHB4U2dPUjN4elY4NTVzNmJQVSs4VVBQY3AzZndwZGRTMk9oaTAzNVk2S0tsUkFHcnZoVTJLblZVRGQyNXliak41b3pYSHJMTVpoWmZXTFZzU3VCdDRrNVJZbmVudkhnMHA4d3piYnBzbE9jTXhwL2xMbVdkdHQ3b2lxS1NwY0g1bEJnZ0RkbXEyWjdiYklyTm50OUdOL2VIVm5KY2U5S2Roeitzd2IyVUdYTFJxUTJWYWNBMHdzd0d2bmgwUXU4dEo2WGo5YXJtbTlNSmJ3NldlZW13R01yc05KSXlpU2FHU0FyYTBzVTJrTnFvQUZ5TXBCaEowZUd0SlZsTGpCRm5ZYjdzdWJRM3Bta0dnbEg1YW93NjhyV1lETDRKSVNaT1QxdnVINng0K3NrZGhuNGdoTUJrTXNaN1I5Y04rTUpyenBNWHF0STlYWlorZkpIbEtDTFdtak0zR3ZuOUx0M1BEdVUrcE5nT2NUbkVOSGhuQ21ORXZMZW1kbGFKQ0VPaVFnVW45Y1RTSjJIVkNnR2g4QlpubGIyR05SaXZ6S0V1YS91U0FkcVVNN2Qwc3laZzVCMGxocWJUdmllS2NOSUV1cFFvS3E4YnpFa21md2lEcUxobHZaalVFVkhPdGVpY0IyYXR1ZDRlc0VsZlc1QUVsYU1vSEl2RE9hZUhMZE5wcGFPNm9NaHVXU1Jza2IrSFFFa2lHa013QnA4UktldHlibGlXcGNTc1BuSFc4TTdieDl5NmRVeFJxRFlhUEpJaXczS0ZMeDNKV2ZxdTUrNzdqcFA3YzdaM1M1NTRkaHNUaFNJcjlNNFFVNVBMeDA2SVRVQUtUeGMxY01FYmFJMUJjQXd4TWF1RnJXMURHUFN3TTVrMkdnYmhkT2E1TjZ1NWRyZkZ6NU1lRW1jdUszclBtSHpreTRYa3VyVno1bnBqUzh5MzlncE1lZDc0bWJWZ3dlU0VxUENBY05QSm1RNUJKYkJyUW8yY2pXUFdGRnBLQ0ZZZFpVd1BXMDNnODJiQlUwY04zeXRydnJZejVYMnhOR2lyNEtKZ2NyeUw1SFVhdWtDS0NURXdoSWhrOWlRR25QY2tHWEF1Y1hDMDR0THVpS3AwWnlRYnljQmNVdmRRUklSaENCU0Y1YzY5SlNlbkhWZXZibkg3empGOU4yU2szaUFTY0M0N0pEbTdOYXI4dzlhWVcrazhYdXpNSkd5emRweTBrZi9keno0RXdQLzZGMi8rdnBUdUJWQkZrZXI1eTdPbjk4YlZwNzB4WlJhSG1ENm5WMWFGcGRUTUpjWWpSNStnVDNxNkYwNXZiSXpKOGovdDFTVlRVWnNtTVo5SFZzdklvazJjTElMMjVSYTZKdEozV3JhSFRHbThmblhNNVVzbFZhbmw4UG8yajBQbXZpZlZvOGVvdDNlOFVCQ3RzNzVjVHVjTlNWaTJpYWFQUkJIczJOT0V4TDJqQmFPdEVaczdZNnpUV0JqSmM5ZTFVMExYRzFhdFpUa29FdXk5aWp0Y3FSUk4xbHgrcHo5M1ZWaytlRy9PZDE0NW9Hc0h2TGNraEtGVk1HZHpiMHpLNE5oME5sTC84WEhKcFljbTZvR2VPUWREVWt2bHlpblExN1JDbUFmRkxUSXlUUTVSVVBzNGd6V0dOQWhGVXRGOFljRDBnaDFRQThlcmhsaFp5bFdpeXFXMW1QTmIrV3pqKzNPcDZub0RTelJuWTdsMTNOSVo4cjRHOVpJS1ZBaWNnMytjbTA2Y2U3SGtZdDdsNzcybUxNZWNCSlBiQUpOZlFFSTU4S011OFVnMzhNU3lZMmNZOE1BS3cycUF2bGVhdFc3eVNGZ05kUE9PSVFwSGg2ZjA3VUJkRlhvNXVMWERUS1FmaEs2TFRFZWw2akV5Q1N5bHpCY0pDV3NNYmRQaUM4L3R1d3ZhTm5MNThveU5hYzE4MGVZWnZEMVA4d1R4M3ZubHF2L2dkTjY5bkpLa2kzSmtZNUJaN1dYVkovNkRMMTJtZEpaM2ozcHFaeGw1eTZKUHZ5Y2IvYUtSUWZuaTFjMW45MGJWNXgxVU1VSFRSelB2UXA1cE96SXVtbm5yZXJzWFBpT3gzbEFVQm1lVXFEQUVRWUw2ZWpjcjdaTmpVc0dBTXNxMDVJOVo1Mk16MGRzNncyTVBUWGpvYWtYb2RWTTRaeWhLdFNxcWF4M0huWldBUnZ0cDUzVVd2ajV3VWxTRU5vZ0NOMTBRZ2tDYllORUhqdWNyektSaXRqWFdYdC9rMTU5dkcyT2dHU3p6d2RKSDNZVjFLVGl2aXo1bCthWE5oZ3BhamxvS1kvbmVLMGVjemlQZTYvL3ZWaTBwS3NDWkVsVDFoTkZrVE1qSTdkVWJZeWF6QXBkdms1ZzdFWlY5Q3pFa0ZpY0JhL1dHRHRGazR3Njl3ZGRLUDVQQUp3V3BLcU5lYnFFeDFHT2hxSVd1dGpRamo4ZFJTendiajVsNHdRbDJUVFZkYjl4MTBtTDZzRFdtRExra3p4cFB5WDE4NnZQWEdqSmR0VEFmVWxZWWMyRzJmN0VGeU5VZVNZazltcFNuZnpZaEMxb0V4azNpOG56Z3hySm5leG13TWJGQ1dQVHFLdFExUGN1am5uYlpJekh5Yk9IeEZ1NTJLdElYckhvaGRFb3lhTnRJVVhpcXVxQlBLcnpxbzlBbEJacGppSFJENFBpMDQraTRZVytuWm11cnB2UmVlUkZ0cit2ZnFFT05hSjl1Vjgyd2YzTGEvbm8veEhEQit5QVprQzd6OFgvMW5ZWDV6cjNHMU02eUdwS3h3R0pZRTNsK2VLVzdQT0JxbXJvK3RrTklZVlI3RW5JRzNzU2tCdmxETW94R2psNUVRYXJDWXBMZXFEN1RKVVB1cDJOR3pHUGV4TjRycGJFcUxXVmhXTGFSbE1CVkZoc3RQa0NselJISlFGR3F4anhaM2Z4cjNLQnZFMTJ2WmE3MzJsZGF1OGFPZERRVG8zSUFpa0xwazJWcG1ZMDg4ejdRdERyWEpobVdweDJMazU3YWxTcGFxTFgzeDBBL21Cd25KQmdyakp5Y09hRmFVRTU0Z05nTHlSbENZZWtIWVRvZThkUmpNL2IzanpHMndEaGhzbEV6Mi9EY2Z2Y2tNOEdXN0Z5NlRGMVpqdlpiYnIwOTUrcTFLdHRpclcyWTlCQU14bUNpMExTUlBGWENIdmNVMDRKeXBMeUdabEJCU2FndGVKallwSE4rQy9WTWlVVk90TVk2cWdwT3R6elhKWEZwM3VHTUVQMEZRc3NGVXMxYWkwN0tLTHZMcFhaL1ljTjNuUFhLUTY5NGdYZmF4cEQwejJzaUN1c0F4RHpKY0lWODZMYVhzeGw5YmgxaS9uUDJ4SWpKMEluYVROVk40dUhRTWlrc3o0d3Q3MkJZSURReXNLb1RzNUZuTFBDWVRQam12WUx2cjFiYzJDMnhwWHJmcFZoVE9qQmkyWnpWRkZYQmFraDBZdGpQbXZmVE5uRi9IcGlXanJmbVBVTVV0dmFtVExmR3ZQL2VNYVV6VktXbjcvb01WbXRGMkhjRHpwb05aODBzenpxcXRmZUFVaEVrZVdma3pqeWt1NHVBdDBhY1FkcWc3TGtoaWZ6c0kxdjg0bnZIUDlRZWZiM2g0N0pQZlRLa29yTEVrUERvR0d6WkRFUXYrTUlUZ043QXhDdE5zbStTbXZpbGpJQjJxaUt5em1DVjlJRXRvZkpPS3h1WFhUZmNPVW91Qm9Jb1cyNEkwRVh0cFl3ZE5Mbk42aHgrR0tEcjhvZ2xLakxxOGlFUWcyRHlNUmppZWJ4ajZRMVZZUmdLUStYMTUra3d4QlRwanBlczVqMzkxRE9Kb3J4ckxNWnFIejVDS0RQT1VPWE1NTWxEZXhNVVBVNHJvVXVRTmlCNFF6VnhQUDNjTnIvOTFic1ltYkMzZTQxbWZBeDJrVzh2b1Z1dW1CK2ZzSHY1TXZPVG5ydnZMZWxlMnFLc0hHMkEwcTFSZlNVVzlZUFE5WWtvVUpjR213eXBTelJCRDhKNlpWZ3VMUnRqQ0dORHFoeVNMWlZORnFlWXFCc2xuc0pRR2Q2L05PWjA4Tnc0V0RHU3hOQWFVc041bUlMTndpTjNabDJ2cXEya2lQeTZZbC9mN0VZVWFNV0NqWW5VZEpxYnRsUkgyR21wcjBkQ2d0Smh2U1AwT3I0MWJqMmMwdGVkY3QwcE1UOVhyMHk0T0p5VFdaYTlaZDVCYkJKN0szMU9CeUhTTHlQV0pxb1NsaXZodGNNRnoyMVcvSTgvTVdhMll6RWpyZjZNVWJhanlhWnZLUk55UW9KVnIydnpkRWpjbVN2UjY1VmQ0ZWJobU4zTFU1ckNNdDRxK2Y3ZEpaMTFGTVlRdWdGbkxZV3pKR05ONGUxVjcrd1Y0TVFZYXBIelprYUVFRk9HUG9VVXRMd1htOS85ejErZUd2TkRBT3o4QTBaMjY5OG5YNWkrckd5MDNxcXhnRldTaVZIN0VQQmFNcTdWUlhISU4zdHRHZnJFYWhsMUZwc0VYMW0xOTdXNklYMWh6dXMyWi9DbG8wdFJ4enRPRFFDOENHMkl6QmM5S1dtVXpucXNsL0pNZFR4V2RsUWNNZ2M3SStLc0ZWS2dmbUtaWGptdURTRW1WcTFoVWpuYUpBeFdrZVZtMVRGZjlNeWFpbEViV2EzMHRZeXRaVm9xQ2g4VEdrYm8xSTh1QlpQbGxxb0lzOW5pS0VwdVkyeml5WmQyZVBaYlczejkxKzhSbTU3TlN6czBUV1M4VVRHRVNOOEVUZzd1TTkzWW9DcExUS2svbnhHVlNzWk1iSEhaNWJaZFJaWk5wTElHRzQyV2RvUGdTSFNEenZTSEx0RXVvYWtNeTRsaFoyS1pWcnJSS1JSRXN5WDRRc3VHM2x2ZXZ6YmlwUEk4ZWJSaVIzcUdhSlJCbDlGMkhidmxaV0tOSXVmWm9rTnlqTk5hU1M5SmNGRVBvSVdkRUI1NWtYRGxFWlY4N3U3d20rK2Q4TXJORmJ1emlyM1R0ekZEdzVPendGN1pFOU9BRytaSTMySUdMYkZkYVRIUk1zUWE2UzFXb3VaYkZybXFpRUtaUy94K2dLRVR1a1hrZUJFNDZRY1ZUQWwwTVNFenc4d1Z6S3lHZ2ZoQ2lCbEhJdVNLSlZjVzRtSGJyNEZEeTNOVGRkNzUwYXZiZEpuS08yK0ZrNnN6Ymg1WGZQVmV6eXZIUFhmblBTZHRUN0xPVGtzdjNwbUh5c0krYm8xNWx3dWVQem1JMUdXRDBvdG9ScExzMVJSRVdJWDBRMFhkMTJDazZLUXJ0UkdKTVlqMmxONmNpUXVzTTFRalR4TWkwWERXeXhhRllUcXhOQTEwVGNyQW1RV1hQZHVDbHA3R0c4b2lsL0hPVUk4ZHpaRDBvWHFMRjVBWUVVbWN6bnY2THBCQ1lMV011RFd5R1ZWQ2FSSm5Fc09pTXRoQ2UxK2JhWTR4NkswK3FuVU11R2pXTGlaS3B5eThZVkpWSEo0dU9KcTNUQllWNDRsalBIRzVYRlJzUVdWSHFuODJlYjdkOTVyNDZUMjRLVkJaM0tCSkpoS3pmM2psK2NxZmZwcDZVdlAxMzd6RnpiZVBtYzFtak1zeHk3QlEwOE9tNGVUb2tMMUxWNURvYUJwaHRBR2xVNFVXa3MwdFJWT2FZMHIwZlNRTmlWSHR6bWIyUnJLclNpKzBSdWhXMEswczdkS3dNYkZzejhBYkN3bkdKSFZaalNybnEwemlhRnp5Y3VGNTlHakZJNm5GaTRLZGtqVlhXazZ2a3hEWE0zYkZLWXpOVTVaOFRTRVFTY2pHak0wdi9SamxzNThuYlYzblY5OEwvTDNoa0hmRFd6VDNQMkRqNm1lSnpIaGgwdkUzdm55Wng2L1VMRys5VHp5NGlUKytpem05eTNCMGsvWjRBZnQzR0JjQlU0eEp4aW1nbi9RUXR3SWpZK2l6WDBIb2hENGxtcFIwcG1VdE8xVkJGUnh2M1JaMkYrb3ZhQ2ZDbFV1T2VxclMyeVJLdWlJb2J5R2FkWHJNV3BnRGJqQ012UlllMDVIaFd1VjRkblBFRjIvVTNGOG03czBEWDkvditQcmh3UHZMeEdKSVZZaHBZb3hDSnNpWjdON3c0VGptYzhNdkVlT01rZThkTldmV3NqOE1ydnVEcEJsL2VWcGZ1NzVSZjJGczdFNElndkhXZENIU3A0UjNEbWNWM0JxTkhKc1REeHFTb0RkclVpNzRtaGViMWdza04yZldLaXVKckRFUEdKWnRVTnJwa0FnaGtRd01NVkZYbnVlZmVZU2RuVTJNc1JSMWlTOGNYUnZwbXBqN09FMzZjSmx5VzlYcUxXYWlRVEx5YTNML2Jvemg2RGh3c2hqb2hrUzBobmsvY085a2lha0twdE14VmUwcEswdGRPNnBTalJIYXFDbWhCaWp6Uk5UbWZERHZ0WCtQeHRBa28ybWltVWs0ZElJclN4NS9kcGNiVDIxVDE0NDN2M3VIMWJKbjZBSTJRK3dwQ3VWNHhtb1ptR3hhZHErTklFazJ6MVRYbENncTF6MDY3T2xYZ2RCRml0cG5qalpLOGtnR2lVa0pJWDFDb25vQmRLM2Fkem1ycmlpMkYzd1V4Rm1zQ0drdTJBaHBZcmxYVjl5M25xcFBURnhVNitab3puUGFzdmpLWkVmWE13Njh1MENYVGVCS3h5Z3RjTys4akxuNUxmekIyL3p5YTNOKzdiVTNLVy8rRXZkZi9SVysvODFmWmV2UnAxak5udVRoRzFkNS9xWG5LSzQvUWYzRWkxVFAvUWpGeDM4Yzg4eVBJaC8vTXVtWno5Qk05amcrUGlLZEhsSzdnbjVRUWxBZjRHUVFlbEdlKzdLUG5BeURybGRycWF6bCs2c2xPNVhqQ3pzMXZSWGFCUC9zNXBLLy8vb3hibW5ZN0FwTWI2bTlWVkRWUVhMclFZUTU4NlUvMjQ3bVhEVW5TVGtqbTZYajJ0VHhpV3NWWDN4b3hDZDNDejV6dWVTTDEycjcrS3hzZ3RCZDNTajhWdTFNNlV6Y0dYczJLaGV1VEgyb3ZVM3pQcTFIYjJLTnlxdjdId0lhOTFFOXVnQ3k2RUxUOW5FVkNzRTRZeVFuYThRa3JMcUFzeEN0WWVnakJFR2kwQVhCR0oyamo4ZVdwb1ZWRTVWWEs1TGZsSVExanBoN2Npc3dyUjFIVHNQelV1V1ZiSVBRREk3ajVjREIwVEdiMHluVFdhS3FhbHhoMmQycmFJNFhHR1BwZWtOSWxxSXNJZldJRzBneFlWeWtMSlRKRnFKYUY0M0hsckxVbTgva3VUcGlDQ0d5V2pZc2x4MWRVMlU3b25XbEtqaWpJcENzZU14eHdEcG5UMG5kYnJzV0ZuTzFuQjV0T3J4WG1teUlDZXZoK3VQYjFOT0tiMzExbjBVVDhDSTgvNW5yYk93YS91VS9lbDhQdVJpWW42d3dzcVhUcGFqakhlY01mU2NVbGNNV2htNmVHSHVkYUJpckRMMlFFd2g4ZHZKWmp4NnRVV3V0b1ZjamhjMnBKYzBjd2VodFhBemExL3FwRUdQRWl1RmtwK1Mzbk9mUmVjUGpmY2ZFUitMS0tHUE81eGlaM3VocHYwNVpPRVBvMTBFTlFnb1c0d1R6d1p2RWQ5L2d6NWwveWdzTmZPM29nRytaeUQrN2VaUDNmdVB2WWY3a0M3eDZPL0JUaTVhTlNZbllDbXRxU0ZQY2RCY2ZvSG4wRTV3Ky9WTTBMN3pOYi85WC8yY2VmdTFYZVdSV1lMMkhYUEVNZVIyZUVhZlVQZ2diSTE4N1B1R3I3VEY3R3pmNHlpTVQrZ0srWEl4WjNPejUzMzcxRnFWWWZueHZneCs1TnVHeHZZSXJVOGRrNXJDRkVFb0JuNnViOVliUDVwWGl6a3ZoZFU2bkVkZ3RERmN1bFVZU0xqMHkvcEgrMmEwWFRydDRPQ0FuZlN2SGJaSjdHRmtjTGVPYlEyRHh4a0gvL2Yvd0Y5LzlyU0RTcnIvRitxMzlQYnZSdCt0eSsyT1hwait5T1MxdlJIU21QU1FsdHhpYkxZV3NvYTRjdGJPMGJhSmJKSVltMGJiNjQzcW5wWHVmTmVlU0JGczRqTGRyVnltODFSSnF2a3drRWFYS1p0cVVXTU5pTWJBOWdiMHR4L0ZoeTJyUjBqWjlIajA1Zk9uWjJKMHltcFpzN215emZYbVg4V3lUeVd4R05SMVJqRHlqMlpoeTRrbG9iOWNGT0ZsRytwQVlrbkRVZE53NVh0Q2tSRFdxcUVjVjVjaFRqNTNLWFVzZHR4Vk9LSXUxV2sxSGVkNEpNUmtXdmVXa3RTdzdpM0VHWDJhcVo5Q3htQmhETDRibG91ZnJ2L3d1UVF5Yk81Y1oyb0xacnNVQ3l4TURUbmo0OFlxSEg5dFU1dGw2YXBVcHhja1o1dmRiVnN1Z1BJVnhvU3kvekZSVllrZmVaRW5GR1VYbHNraEg2RHQ5RHM0WTJrNE5GN1dOVVREUGxZb0gyQ1NJTXh6TktnNUhCY0VhTm1MVXR1bzh3emd6b0JScldWTmNUVHdYRkpIVGJjbWoxa0lDMTh2SVMzc1ZmL1RHaUo5K1pNYU5PdkxVQmp4N3RlYkpSeTlURm1zL1Z2V3RTekVTaGtEb28rSUZvMjE0L1BOOC9UaHk4TUc3YkthV292RDVjNkVOUWh2VWZ6Q0s0STFoRVNOZm44OTVMN1Y4cDIyWmxaNlA3MVhzMW9ZWFp4T2VuSTE1OVhqRjMzL3JnTC96eGdHL3VyL2t6ZnVSazBPWW53cmphS2tHcFc3YjB2d2dxclhlUVdzQU00OEdVd1lVVThTNWFFYmp3bTV2VE4zVjdZbDc5RkpWUExmbml4Y3ZwZkp6azJYMWhkV3BPWDdsWVBXMXU5M1FXUjNGcHgrV2FQM2lSczkwRDFXeGVXdkhMMTdmZkdtajlrK0hxQXZHV3NNZ1F0TnA4b1QxRnVNTk5ZWitsUmk2bERYTFNqR05tV0ZValhUT2JndExVYWxJcGE0Y1BrZml1dExTRFluVFpjaFoyTm1GVTRTMkMwenJna2V2MWpUTHlQdzBNajhON0I5MkhCNFAzRHZvdUhkM1FiTnNrTlNSWWsvb2UySWNzQzZwWlZYcEtLeWpubzV3VGpnNTdqbWFCNXBlSFdpUG01NzdpNFpWRkNiVG11bkdtTEwyV0dmeHBhV3FuQkoveE9oNHF0QjFXMlFOZWpzWTVvMWwwYXRSWVZrcUR0QU5laGhZWitqUitYelhKNzcxYXpkeDR5MDJ0M1pKWWNCWFBjNDZobWFrMGxvL2NPbjZGRmU0czBZdVJhMm1yTE1zanhybXh6MXVXcEdDZ2txdWRHZm92SVlONUVDRXJPenl6aENEQ2o3U0lIUTl6QnM5cEdJeWlvcUx1YUM0VVAyQVErZ0x5NzI2NWw1ZFlwSlFoMFNSRVhmV25tbnJIdjBDR2NabUhJWThnbFN3VG5HTjllanUyc2p6bVMzaHBmNzdQTHIvTDNFM3Z3Vkh0MGhITjRra0JsL1JSMUhuMStUb0FzeFhQZUh3QXpaSGlXcllKOTYveGRpcDExc1FvUjJFUlI5cG92YmNHTU5pQ0h5dm5XTnFaZEw5K21GREw1Ym5kaW8yUjhKRDA0SWZ2N1RGcGJMa3JaT08xNDhidmg4RDMwbnczN3g3eEcvZTYvak9PdzFIK3dQOXlpQUx0U1l6N3R5OVV3TnRPZlBITyt2dDVTelhYVWdtOVMxaGZtRDZ3OXN5Lys0Ny9mZituNitjL3IxLzlNN3BmL3AzM3RuL3hWZE9WeWRSRkEyeFptMlk5Y09kbzYrRFR4SWd4MDIvNmxNNkR1bWMrVmc0U3dxSnJnL1kwbU94V3VMYWhFbkM0RlNLT3AwNTZrS2pmWXcxK05vd1JJZkxtMy9WUkwyUjhvak5DOVNWVlF1aG9OcmhzQTROOEpiOWs1N2pvNVloR0JhNVd1Z0hJYVdVU3laMTVqeFpMQm1QVm16TUNxcXh3NXBFdHd6RVRxZ0tTd2dwbXc0cUdTWWx5YlRJcEVTWnFJS0lJU1Q2UVh0YloxUnpibzFXTTFHMFg1VmtHR0xDT1hMdnJJRUU2L0hUZWtNTkRnWmpXU1FOMVM1SEpTOSsrVW5lK0dhZ2NJNXVDTHp5YSs5anJlWFMxVWR3eHZHOWx3OXBWL0NUUC9zd3Uzc1ZKbHZRRGtsb2w0RnFWcEhDbkhaSVZOYXdtZ2NvckJMWnpoUmRPdHBVRzZhRWlNWG5wSlFXdzlBa0hlOTFRbE1hUmdXVUkwdmJXa2FWb2E2Z3JIVzBXSWhRT21nMlBLOU9OL2hnUHJCM3IyTTBSSGJiUUpYVUZ0bUVmTnNiOVdFajAwalBUU2t6aXk2ZUkvUkRwM01sNHcxMlBpZDg0OWNJMy80dFRPV3dreHE1OFVuaTdBcHBmSW0wOVNnbUpXWjMzK0x5NjcrRU83MkhhWHRXV3hWdG51ZVBDOE9xTUl3THA3NERvbm5HQ2FHdVBUTHlGTmJTeDhqLzlhMGpQbGdGL3NZeld6eTdWYkJuNEs5OWZKZlBYWjN4RDk0KzVwZnZuL0Q5OXc2WnJ3S3Z1amt5Sk1hRjQ2RnJFNTRhRi96SXpnYTc0NUlyWTgvVnlsQ1ZoczNTVWhYNlBpOVh3cklWVEVqU2lpeGp6LzNiSitIMjkvZTc5NC9hOE1IYlRmUEs5eGVyVis2MC9lMHV5YktKYWpEOVVmUHVIemJxZnFabDZtSmFuTFRoVGp1S1EyRW9VeFQ2a09qYmlJalFEUkhiVzVCQXFCejF5REgyaHVuTU1aazRISVlvT2tOUFNSSDVFSElPbXVoTjF3ZWxOWnFnQklQS3FlRmsxMnNaWHhTT0tzY2tMNVlxYlkxR054RldEeDQ0SC9GMVE2SVBzRndFeG1QUDVrWkJhb1YrbWVna2FzdVJCUmxyUzkraGl3cDZtZXd1RzFRQW9TWVF1Y2RMT2txMEZtS21hNllJUTNKNndBWExLaHFXUGZSUk1GbXlXR1FjbzRtb25qcTNQbHRYOWhoVnA2U1lHS0tLSWdqQy9kc2ZnRlh4MFBIaFFMc011SzJDSm1aekRtUHBob2h6anFFZm9BbVVXelVHcTRhWW1ZS2NCajJvUWtnTVVTaWlVeFplb1VZUEVZUE5ZTjB3Q0UxcEdaZUdjVWdNQWZwYUp3cGxNSXhHdVhJeENTdGFzU3gzQ3U1TVNtUUpzMlhnNFpPVzY2dU9jUmFJWEFUbTF0eUlpd3haRVlOME9ob3pwZmFMT0NHS1Izd0JKRklqdUc2SnZmZlBzSEdncE1TUE52UWs2MWRJTlBUaWljRmdrenJFNXRBWUpvVWxqTEpyVml1Y2hFZ1NZVHdkNFVjbGlGREVTTnYzL0lPYng3dzliL21mUHJYTGw2K05xY2VSNTY5NWJvd3Y4N01uMi96akR3NzRCMjhmOE9hOG80a0pQM05naFc4Y25mRGRmbUJ6Tm1GelZMRlZlbXdRTmxOaWFpM2VPazZYSFMzSS90MFRPUjdTRzZmTDRmLyt3YXA3YzVYU3ZTUnlMQ0p0VXRROW1mTlI5MFYxQUlYUm42MzkvOUpQMG4yRU9lUlpLc2tqbStQSHQ2dmlwUUk3RnAzc3MrZ0dtcUEzdGN2c3M3MVp5ZDVPeWRhR1p6UnlPR01vbkRrcjVZS29YTFcwaHFiUlJXaXNrbUdNSlV0UURWMFh6OEx0KzZCODk1aG45TFd4ekNhZUVQSnR2a1pDbFYxMHhxa01TUml5aTB6WHE5SCtrSVRUUVdoQ29vbkNjWnM0UHU1WnJnYTZJVElnSEt4YURydElOUzZZYlk2WlRDc05rSEJXOWZhRmVwdUZ2R3BUbmg0TTBYTGNXSTRheTJrakxIdDF6Vm1iRnFTa2xOdVl0QythenlQZithMkdzTkJwU3RNdDZkcUcyQStFWVNDbGlLL0hQUHpFTGs4OE02TW9IYXNlMmdHNkJNMHFFaGNEVFlpY25uUVVaWkZ4RHgxTjJ1eHYxM2VCWnQ2eE9HMFpJcGpDcWZ2S09xcllLSUsvanExS1dSaXdhaEpObzFkL3lCTUVnMVpCb0gyblIrV3c0ZzJMMm5HenJMaFRsOXozQll1VVMvbkNaTG1XbkxuVHJObDJhNGRleVRlOVpCL0JsT21BNjFaRnBia2x5WTVWQTl3UHBENlNwQ1FrcnlFTjJQTklwd3NUZ1RVYnJ3bkNLa2FPaHA3N3RhV1lWamhuc1U1eEN4c1RINnc2Zm5OL1NUOFlIcDlXYkU4TTFpVW0xdlBDNW93ZnVUekRBS3NZU2JWV0lOSkZTZ09WOXhTRmc5cXpjUEJCMi9QK0VMaVpJcmZpd0ozUThkMzdwMlkvcE9XZFZmY1BWME04U0NLRHlhNVhGNXhuaGdjODRKT0l5STFSelY1WmNyOGZmazl1OUFpRXcyVi9xOXVNKzJQamRvMGczaGpqdlVOQ29vdVJPcW5JWWJHTWpOd0Ftd1cxdFZST3k5WjJnR0FVa1crYXhHR1hhRHZkNUpYWDIzaFVPdW95QzJDOCttVlhoYVdPamlFbHJQZDBmZVRlMFVCWmF0K2M4b0xyNGN4QnBndUpFTk9aaDBMS2V1SWlPOVoyTVdtZ1kweHFLaEMwKzNYR1poVFNJa0V4Z1NFa2hxU2dUak5BSDdTUGpUa3RoQXcwT2kvS2dXOWgwWWlLYTRhRTl6cDM2b0t5dUZRK3FxeUlEOTVxV1J3T0ZNN1F0d1BONlNKVFEvWE5MMFlqeHRNWms4MEtZdzJMTnJGS0YxemR2YlpQTzdzVDd0NjZUYmVxMUViTGFaOHNSamRnT1M3b0ZoMzdIeHlRRWx4NmVJZnRLMU5HZFVrd2lTSnJDWXExNkdVUWpJMllLQ3l5VGZLc2R4U1ZJZmFPT0lhNnprcEJxK05FaHpEeDBFNE1KM1hCM2IwSytoRzdYV0M3aTR4UEF0dkxnZTArVUZ1bDNkYVM4Q2lvYUt0ek5sMjY0TThtU1IxaVNScnRaUWk2K2xQMiswNkpGSlRmSDdQL3dabTlsVkh4a3hqRmVMQ294TlFZZGZlcENnVmtoNkNIUVViS0Q3cWUvLzMzYi9IdHd5Vi83WmtkZnVTaE1aZHFZWCtlZUx3WThSK1BIK1pQbkt6NDVhTmpmdTNlS2JkRFl0NE51TDZuR2txbVVSaGo4RVdoVlNIZ3JTT2FaRXJyaUdLMmVtdnFRWjlrU0RBWVpUV2ZaZTFkeUd3N3E5Z3JaeGw3OTNzeVhsc3ZxL1QrOGVyT3h5L05EamRLd1J0anJGR0F4bHRsbUZtakMzalpSemFUMS95MHpyQk02dllTclhyQlNSU2FWY1FrS0NzZHZ4VkdSU2RyYnk3akxOYnJCazFaOE9LY3BVazZVMjlqNHVCME9Lc0g0N3FQenVWbXlIMVl6Q09tOWVqUk9VMkpFWk1uQjltb1B4ckJKVjBNVm1DajhOVFcwUGVSRU5WbUNHc29SaFpiR3Jwa3pqem1OUlZVNTlwdFVMWWNlUUVyRXEvcXF5U2FWaUpKTU5aeWVqSnc4OTJBU3dwV0RVTkxiQllRQmgzZE9VTlIxYmpDNHlzVkI0V1UzWHd1eEVwYmE2aXNZM09yWm42MHBKcFdPdFd3aG9oa0VwSm45NkVaY2VoNTc5VmJ2UFhOOTloK2VJY2JUMTVtTkM3b0VWemxLRERVUnYzSWg1Vmt6amNjcmhKZEVHWVRCUVREWUJtMW1hZVF5M2tSazVWOE1MV0p5Z2hzR0lJcnVSVU5pNW5RTDRYTlZlQlNESlFJZTIzUDNqSlE5WWxTRXFVVFhCWTh1ZXhDSXlHYmkrUktTTDNrc3FjN09XQlJkRFFZUklNZ05ITTl5MCt6TjU1U3JETzRXenRHMHdxcHZGbys5WmEyeVY4dkpvb2gwQTQ5Zi8vZGZiNTlaOGxmZm1hUFAvdmlKbzlkTGxpZUp2WVA0ZFBGakU5dFQvaks5Z2IvL040Slh6dHRPTzRIRnF1VzVDemp1dEJJcCt4UzY1eUJwT3ZZaUJSRzR3L1N4WSs4dWNPRmtNL3pEd1BqQ2lZRnZ6Y2JQWE9mNUlQVDVxZ0o4WFpFWW1tdHkvcGFpcndKQlMzTkI4bGE5T3lHZWJ5TXhLaXNNMWRZckZQakNwZVV2V1pZbXhLcUY1anJFcVV4RkY2Ti9ZeEE3ZlgwRGtIRkVzTVFtWi8yZUtkSVp1Z1RRMHkwWFNDS1VKV09xdklNU2Uyb1VsUTNIRDF4ZE5jUE1iRnFBdk91NTdUVHN0MnNHMG1FbmRKeWxQUldEeUVwUzYrMDRCVXB4bVFPdkRIMFFTMk4ra0hWYzRVemhLeDhzKzU4OWhsRXhUVFdHZDU2bytYZUIwc214cE9Na0ZMUGplY3VNOWtvdVB2ZU1RZDNHM3haNVJtMHV1MmFUUEpKb3JQaEpFRGxLYjNsVWhJK3VIdE12VE9sckR6OWFzQVhsbzN0R295bHFEMVB2bmlOeDI5czhQMlhiL0hxOXc2WUg2MjQ4YkVyYkYzZXdDZm9SUmhNOW1HLzZLaVRZRDVBdjByMEFtMGh6RmM2Wmh4UExGV2xFVWppeVNLWGZBMUZLSVpFYWNHWGNOekNmTnR6V3BZWVozQWliQ3dEc3piZ2cxQ0d4SFFacUxyRUNNRTNTZG1UQWRKY2NDTDRJRlJsamtlT1FwZDlCSDNJOG1PamdLSE41aHRwN1J2b1FFckRVV1hZSHhWczdvNXBRMUlqeDhLZTJVK1BSbXI3RlVKZzVCUGZQMW54bi96R1RYN2p6b0ovNTFNNy9OakRFeDY1NFRoWkJsSmorUExHakM5ZG5mREtTY3ZYanBic1I4TWREUGREWWpES3lteHpxT2NRaEVhZ0twM3ZrMVFDSzZBQkd0RmZMNFpycGdzTVZRQW10V1dqc2o5ME1DNWRzQUJJd09xb0hkNjhNcFBUQ3JhZE1US3FuSm4zQXpFcCtGTVc3a3prNE5icEtTTDRzZE5Nb1NDVVJnMEdZbFFmOTZJdytjVFd6ZGpNaGFyWEc5ZDdwZk43WnhFampBdEw0eTJwallRWUVXZlZ0VFR2SkovSFNzNWI3VE56cnR1UW9Hc0hGazJ2bFVZZk9XMEhWaUd4SEFMTm9ITjAxUCtmd2lubzRRcWhqNUV1Q3FzaHNWZ2xpdEpTbzU1M05ob0tyd3VzQzNwUURVSG4zQURKUWhzeTJ1eTB4QjE1clM4WDd4NFI3dDVpN2p3VVkvclFVOFNTaDY1ZFJhUml2dGpIRlNWVlhWS05QQ0ZwMVVINmNQNXVMSjF1bUM1aVQ1WWMzamxpOTZIZDdJa3VoSkFJVVIxVmV4RjI5cVo4NGN1UE05dmI0ZFZ2SFBEYVY5L2w4dU5iWEg3c0t0WFlFMXkyNHI3Z3RXNXNOaUtQaHFHQlVSdnhUbG1DNWNwcUFNZElxRWVXb2xqTGdzR1hXYXlDWVRJeFRLdEV3TEFRUXp0b3R2a3c4ZXhUNkcyY0RDNG1ZZyttRTF5anhvNDBFWnBFMlViYzNZWVloYzBrK0VtSnJ6MURuM0FSYkI4SkRzWlJaLy9PUUtnc3F5QzgyM29PREx4MUtCejJQVStPQzJ3ZmxlZFFHRktzOGlneU1SclZoREF3aEVqaGhhYVAvUDN2SGZLdE8wdCs1b2xOZnY3alcvem93Mk5HRzRaK1NMZ092akFiOGRMbG1rVXZIQS9DbTMzZ2RrZ013TzArY2pJa21nNzJoaEdqeXZydFM5VW5uOWdxMkI3NS90bkx0WHRzdHlwMlJxNHFLemUrdFF6di8rTEx4Ny80SC8yajkyNWZKT0NsbEZWK3Z3ZW91MmlBRGlMUTNGNTA3enk1bDA0RXRxMDNqTkNqTzFmSVo2ZGlISVEwNkN5OTlLcjhXYllCR1lTK1ZKRElaQmIva1B1cEZJViswTncxOG5ocjZKTnF6cjA5b3hnV0dKTFY4VnRDUzd0MmlDUUU2eFdwYi90QXV4eFlOQVBMUHJKb2UwNldQU2Z0UUpmUjV6N0oyUWwyNXFBdkNnb1NFeDRZVllrNFJQb1FhZHJJZkJreDNqS3pocW5Yb0lZMjY3NjdYdnZ5eFVybHNqNHpFVUxVelg2NWlueDVhOFVWSDJFcC9NaW5JL3MzSmh3dGhMdXQ1YzVxeFBjK1dQSGV5MGVjTEJzS1gxSTRIUTFPdGdwNkFSZlZFVGRrYlhyS3QzeUtCcWtMSmtQZzdnZjNxU2MxMDUwcHB2YUV5SmxYbnhqRGNaK1lHY3ZUTCt5d2Uva2FiNzB5NTQzWHY4ZkI3VGU1OXZRZU8xZTJLRXF2STYrb1NPeVpCdDRhZW10cG95YXZGQVo4RU95UXNCMlV5NlNlZ2RsQnQ2cVZveCtpM3JSMXJVRUtYcUIwT1JJMjVUbWdBU2tnRklZN3h3T0h4NUhaVG9IMWp0TVVXZldDM3ltdzI1N1Z5VUI3dDhVN21PMlV6UFpxckFkcE5aWkx1Z1FoVXF6REZrVmRmNWVENEtZTy85NEp6c0htUnFVWVRFakVXdWlIU05jUGVPOFlqMGNNSWRKMm5WWnZCdDQ2N3ZoUHY3N1ByNzgvNTQ4OXZja2ZmM0tUejE0ZE05dFNuM3F6RXNvQWw3M2xLVlBTaTdvZ3RTa1JnczcxVDgwRzFwdGlhdm1UUHZGSFk1TFlSZ21ucC9IMDV2NXdlMVQ3MVoxbTZOKzgzMVVmdG5ZelluNUlUcEsvVTQ4ZU1TWWlFZzdhZmo4a09aYXM2dkZPSlo1dEgxUittaDFpVDV0QmFYVmViWmlHUHBFR09ZczJWaU5IYVByQTBBWnk2cGFpNjFHZGF4YUxIa2twR3ppNE14VFpvdkxBQVMxbkJWaEpvZzJSWVJWcGg4RHhxdWRnM25MY0JicVFsQldWZ3dYa0kwaE01cHl1ekVYVGsyRVE0aEMxOXg4U2JTOFV2VkN2TjAvMm5iOFl4WHphSkhXQktTMXJtWGFJd290MXcwL01Wb3o2aEpTR1Q3MVFNUXdqVGhyTFlXTzUzOEFIeHh1OC9IN0hMMzZ6NGJ2SExTRjZKcHMrQzRYVStHRGt5WkhUYTA2L3ZubzdLZGtzSFBkUFZ4eTlmeC9uSGNhT2M1aUFFTVRsVFdzaENrVUlUTGZnRTErNHdaTlB2c0RYdnZwYnZQSGJyN0oxK1pBcmorNnhzVDFoR0JWbm1mVFdXMXhLbEpWaE1KWUJ3U2FoTUlJZndQZVIxUkN4aGFVY2VVWmpTN0hTREQ2SllBNFRvNmxWZ294VGJ6MVZINEx4T3JsSmVkbk5QQlFqalpNcUt0alljelJUaS9VV1czdGlHckY4ZkV6WEp0VUhqQ3kydERCVzk1eGhTTVRCa1lLK1JqTkV5dXdlM0ZlZVk2T21wSmQyS281T2VtaWhLaDExNmVoS2Y0YnRUTVlqdWo1a0srZnpKTnBYOWh2ZU9PMzRwKytjOHFYTFUzN2l4cFRyV3lYUDdsVHNlY2VRcytISG1SODlEWTRtcVlsb01IQnZNZkRPS3N4RGs5NVloWGgzRmVTTjQxVjQ3VnUzMnZlYVlJNi9zNzg2ZlhQUm5PUWpNQ3REdEZYN1lScFBQSWk2cjIzK3kzdno5dmFxajIrRlNsNlVKQzVacUFxSEh5SkQxTkI1c2NLaUZXcHI2VXJMV2x4ckMwdFI2SW5lOXBGVnAweTBFTlJJc2M4MWlRdzZsdytTTW5qQ21WOTJ6SkcyZ29KUlNZUmxIMWoyQTVWWGNIQmpVcklJVVJlamFKOWNGWmE1UkRXNytJaVN4ZkRodjA4WGFxV3VIMmo3U0RzSXRvdXcwbWlvcGxQbkVDUENjaFhQYUtsRDFMYWpOeXFrQ2NDV1RUdy83Umw1WVdpdFJnY0JRNXZvZWgxQjdwV0d6YjJhR3hzbHorOTQvdkVyKy96S202Y1VvNUt5Y21manB5NnVWV1J5N3ZwaURYNWFVWllGazFYTHlkMFREcHpEc2dkcFJBaU9JZ29oT1UwVUxaV0RJRTJQTXpmWnV6SGk1eDc2TTd6KzNSZjUydGQraWUvKzVsdk10aXQycm15eWZXMkhlbG9wMjg0YXFxZ2lwTUlaVEJKOGRyOHRuTUU0aDZ3Q3RrMjB3ZU1ML1R5ZlMvODJxZGhJTW4zTVc1VTZuM25GcWZnYTR3dkdtMG9TRDFHbkNNWFluSzBQWXkyVFNVbmhWZnAxOVA2U3hiMFYwOTBSazBzanZSQUdJZllLcEpxUUF4MkdCRU1rOUpvRk1CbFh6SmNCVEtRc0xYWHQ2WWFTRkZXbFdkY1ZHOVBBTUt5WXg2aXVPL2wxZGtQaSs4Y3Izamx1K0lkdkhMTlZPMTY4TXVLbHExTUs5SmxLSmxCNDZ6aEpjTm9NdkhhOGt0T3VqN2VPbXBkUGpzTi9kbnZWSDBXNEQ1emtmcjIvc0FRL2RDK05DL05ENzlFdi9wZEVDQVpZOWZINFlOVzlmV1ZTclp5MUd3QkZVckFtcEtqanNzcXFxMllpUjlSa24wRVRhWnRBUDBRdHRRVktyMUZPUTRoMHZmcVpyMFBsUzZkOXBTYWdhcjhVVTJMWkRUUnQwR2dnN3hoUFNqNyt5RFo3bXhYajBoTUZkdTR1dURvYmNiVHF1WDI4UkdMZ3RJYzd5MGdmenoyenpBUHZwbjJBZlJTVDBIUUR5NlpuMGdXSzRPbjdSTFBLVnNKcG5iMmRqUU5UVGc1MTVteVUxb25seW16Z3lpZzcyTVRzcGhxVlhCTjA3ZW1NUHdncFdtNWNtdkFYdmxEeXVTY2IzcHhOT0IwWFo4eS9MdVJ4WWRZQ3JJbXhMcWtSUitVc20xRzQrOTRoR01QT2pWM0tjVVVWTmJkYzAwMlVjdXlNeFErQjJ3ZmZZMk42ekF1ZitTUlBmdXc1dnZPdHIvTEc2OS9rOXV2NzNIenJnSzNMVXpZdWJ6TGVIRk9OSzhyU1VZOTBJenNSdkdnSjdveDZyM2tVeG5XOU1HUnpDR2NOOUJIcEk2NncrTnJoaXN3Y3ZPQWhsM0tMb2JlWEhwcml6TmtCbnlLSVVUd241VENGa0N3OW5zTjdIWjMxK01wREgwZ1p6Q1VJcGcyWVB0SXRldVluSzdwdWpQVWwzaldhQ1dnTlpXR3BTOGN3T0liQmtweWpybXRtMDBBSUxhdTVuTnRrWmVOSzhmREJvdWU5QmJ4MjJ2SmJ4eTNUY1lrVk5VbnhaVUZaZWx6aG1hODZWbjNFeE1FY3RIMTFwd25IUUx0V0FseUlLUS9uOXBqNlBoVFdjTnBIdVQ0dGZtL0hhK2kwSnR4YjlXODlhemwwaGQyd0JzYmU0VVJIWHJWWGlXck1lVlpLZGhHU0NNMFF6K2ZiYThsbDN0VXBKSHdVTGN0RkdOckEwQWU2RUZuMUExMC9zQm9peDIxZzNrY1dNYkU3S2ZtTFgzcUN5enNqdXBoWXRvSHYzVHpsN2YwNTl3NVdMTnBBbDRRbVJDeENaWVZObzhkbXlqL3NlcU83QzZFakY1U1Zpa1NHeE5BTnRLdUIwY2dUbldFQU9uc2UyV1BQeG53WkNSZURTWWJCR0x3VG5od1A3SlJST2VkWmJSeWpwcjFFeVJUYW9PK0hFVzFoS3U5NDRmS1U4alR5OHNHS1pudEVTam95bEpnbkxtbTkrQlBGWXFDMGltVk1Dc09rQyt5L2ZaOGtrYTFydXhCcmtBTEpYOE5sRUs4U2krMERSeWMzYVlZNVd4dlA4S1dmK2dvLyttTi9oTGZlL0I3ZmVmWHJ2UDNPOTduMzdudVVZMGUxV1RIYm5MQzVQV1c2TTlYUnB6ZVVrd0p2TGRZSXBiZDAzZHFNVXZEZTZvZ3dDbUVWa0Y0b053cUtrZXI4b3pGbmdac2ljdFptcmIzL2NlZGJRVG43OWtObWxHS2gzaHNoU1hHU1p0VXA1VGZxdUpTWXNNMUFtSGNjbjdRMGk0NXZmUE1XVHoyMlExVmJsbzErL2JKMFZGV2lIenpEb0xsc1JmS002cG93RFF6RFFOOXc1aXpiOVZxaUYzcXUwQWRoMFFicWNhRWdkSXI0WkluUlVqdk5XSzhLSzBWWmNPeGM3VXhVSmd3Zk1wdDRjTHlXMXFxN3I5NVo4c3hPL1h0eW81LzM2Y0lBbEcvZVg3ejFwY2QyN29uaE1XT2hyQjFWNDVpdkFyMGtpbVJvVStTa0NTcnk2T01aOWZHc1REWXFCUjN5NlUyT0wycTdnZFd5WTdIcVdQUURpejV3MUFhV2d6Q0k2b3V6ZlJoaE5mRFBYOStuc0hEbnVHWFJCbGE5anNLSWlUT0xzOXlBcjdLdDdUakhXY29GLzhIMVdsS0xqM01IZ0NnUVFxUnRPMWFManJwMlNoOGNzdmxHanBxS25HZG91MXpTcGlTMDBiQlZKaDRkQnlvZ3RHdTlzbUUxR0piSjBZZHNrQkQxdHZJR0txUDAyU0VJelhGSEh5QnQxamxhU29rNGhjc3BwSmx4RVlIYSs0dzNDSHRqeXpBUDNIL25rQmdpOGVvT0lZNHB4aVZlMUJyYVdrdG5oZEpaUmlLa3haeG05VFZPUis5emJlOVRQUCtKVC9Qa3g1N242UEFldDk1L20vZmVlNHNQYnIzSC91djN1Qlh1VTg4czQ0Mks4V3pDZEd0Q05hdnhsYWZPN1ViaExZVTMrQ0M0a0NnYytNcVRiS0lmb0RBcFR6enpkQ0RrVkYxWk0rLzBmVFM1dXJNV1hHRXhWcS9WWk5iY2l4eXhMSkRpT2xFM1Z5OGhZdnBJWFBTc1RsYTBxNTdRQjk2N05lZTNYMzZmRjU2OW90aFNFZ3BucVN0SDMzdTYzdWUwSUtFcVMrS29adEVsaGk1bWc4ck1vQTdxdmFmY2ZwVmloeUVxb1VzWk9xUVFTUG4xTFpxQldRN2J3Snh0Nm9zZlNaVnFJaUxuQmViNjkzLzcxWVBma3h2OWJMTm5WKzU0ZjlVZGRrbHVoNWlpTTlaaHpabVVzQXNSOFE2RFlkNE45RUZkWUNxblA1WGVKcG5PbWxFRnlhZjFzdWs1T21tNGQ5SncxQTJzWW81VHZxQ0R1QWlpRFNIeG0yOGZhSzJUdjFhQndYR2VLdVRQQVYwOTJTODRDY3VIZWhQZDFJWTF3ZUg4aDQ1OUlMUTlROU96bXV2UDF2ZktlTFBaU3N0cUdxTG1mT2YwRVJYRHdHT2JrVWMzZ2g1Mk9jb3BPYlZ1SG9KeUExSlVSMW9EbUtqVlRUS0dSUmM0N2lPeGRKa0ttbStwVEFRSlNja1lKczlkTnFjajdNRXhTWlFvYzNYcXVEbVAzSC8zaUw0UGJGN2Vackk5b3hTVUtpc0I1eTJ4MUxDTFdxQWNBaWVyOXprOXZzdk83dU5jMjMyUksxY2Y1dnExeC9qY2ozeVpvZSs0ZWZOZHZ2M3RyM052L3ozbTh5UHV2WEhFclhDRUxZVFJscU9lalJoTmFzYXpFV1ZWVUZiRjJlWXZ5NHpWT0tESkd6c3BoaE5FNmM0cEtLSEtybDBjYk1McG00dEwrdk9mUGI5TWdpSlhOakxvVkNVT0NicEFiQWRDTXpETUcvcVYybXUzcTRHMkNYejdsWDArOXZRbGlrTDEvY3FCc0ZTRnBmS080Q0xCV2dydnFPcWE2VFFRKzVaMklXZFUzVENBcTlRWEwwUlZjODRYUFZ1YjZvdm9WT05EVElrWU5QbkZXb3kzdG5iV21Camx3WnM4aWtqNkNKUFczOU1BQjNtQXZTTWlOTzhjcjc1MmRYUDB4U3JKWlpKUUdVTmRPSVloc3M1TkdHSTZBNHlVOHFNZTdURkJIeU9ycmxjRlZveWNyanJ1TFhVVTFxM2xoQitCREpvTEVSZWFDU2dmZWhkczd2ZmloYysvaUtvL2lESmVSTm5OaGI5TGEvOWRwd3ROaGlGSCtLaVJaVlVWZW1OVkJsL1liTytqTjFBUXRlVWRJa3g5NGpPWEExZkdRdW95VTZ1RTJHbk91eWNob295M2xGMVJBNFkrdjRkdG16aUtRcDkzdFEzNVBVV1JiRG16ZVRGUUYxU2x3emxMeWhpSWQ0YTlpV09ZUjA1dnpobTZnVzdWTW0wM0tHZGpmT1dJd1pLaXBjOUFYeTBKSDRUQ2ROeis0Rlh1SDczTDN2YWpYTjU2bG8zUk5jcXk0cm5uUDhVblAvVjVqbzhQZWYrRHQraWJCb1BuN2JlL3gxdHZ2MHBvZWs3dkw3amRIb0lKRkNWVTQ0S2ljRmh2bVc1dlV0V2FRbHI0N0FaYXVyT0RPQTVhNXE1YkZHY05SZUV3aGFjbzliQndUaE9CVEF5WW5FK3V0M2lla014YndrbWpyVUFmQ2F0T2RlR1NtQzg2VWtyY3VuWEt0MSs1dytjKy9SREhmVTh5eW90M1ZoV04zbHVWOUVhb2lvS05lb1RaaUJ5RmdhNlJNeCtGbUpRUEV2T0JQVzhpczZsT0JGSlNPMjlKUXBKMDdsRVBLU1VKRjJqbUtlUEw2UUVUN2QrWHBKYUwreUxrWktEK083ZE8zdnI4amUyNWVIYzU2VXN6THBlUE5qdHFwRDRoS1pHc3BTY3hTR1RWRFRUZCtmaHJQa1M2Q0YxT3Z2Z29SSndMUnZQbEE5bk95SWMzOWZyZk9ENU1Ldm1kM3JYMEFOcCtNZEVsV0IzOUVJWFlEd3h0cTJNbWM1NWdZcTJhRC9TSm5LbGpzS0lrb1NFWm50cUY1L1lTMWdpeHpYNWJoYUZOaGk1WkJtdTFSY2hlZDZwc1VPUnpDTUpoRXprMWxzV1FzQ2U5Z2ovWnNtbFl2OTVNSC9aT3gzbUY5OFNvU1M0WXc2UVNyZ0ozRjRuVnZZYlFCWWFtWTdhN1FiVTV4WmVlV0hxOFY4dXJrQmRDbGNCRzZBOVBXYzFmNGU3aE8xemRlNXFyVzg4UTRsV2Q4VmNqbnZuWUp4RkpqT3FhTDN6eHgraTduaEI2NXFlbnZQdnU2N3o1NXFzc215WE5hazZ6V2pMMGdmdHZIR05NeUZublVVdmZQRWtSemxOUmk3TEFGUTduQ3NwUnlYaDdBcFJZNDg5c29uWENITThPQnNWM0l1RzBwVGxlUWRaWFNFb1UxbkowMHJGWUtIMjZiUU5mLy9wdFh2cjROWFoyUnV6dkw1V3g1eTNPT1FvZkdiekRaZ0s5THdycXVtWnpDMDdjd05DcUQrRVF3RGloOUJDQ0h0Q3JKckRoM2RtQ1NxSU16V1V6NEkzRk9XdXR0VTZENGkrR1dQemVwekw5VHFqN2hWdmRSSkIwMHZSSDNSQlBKb1dUbUZWbk85T1NWYStlN0dtSWRNMUFteUxSQ1l0MjRIRFpjZElNblBZSmpWeitzRXh1TGRtNXVGbkxDeHN4WFpEelBEZ1NTeCsyN3ZySXR5eDl4SzErOFVhL2VCZ2tCOVFLc25nSEtRUkMxeE9jcDgvdGdTTGVXU1dYalFUcnMxUVZCUmFmMnhSdVRJVFVYa2dwUllqSktoODcrNktUOCttU2tXeTFCYUVYanR2SXFSaTZKbUNia0JlM0FuRHI5Njl3YXQ2Uk9xWGw5VUZ5Y0lDT3V6Q0dpUWs4V1JmY1d5VHVIZlljdHlmMFRjdGszbEJ1VEtobUk2VXpsdzVmYUR5VS9nemd4V0E3aVAyQ2R4ZmY0SEQ2TmxjdVBjMzF2UmVJc2szaGE1eHpyTm9PSkZLWEZiUFpGbGN1WGVlWmo3MkErYU0vVDRpQnhmeVVybXVKTWJKLzd4WWg5dlI5eCtIaFBwQm8rNFlZQTIzWDB2YzlmYjlnLytBbWQyN2ZvUndMNDUwWjlhaWtLTHdTcnZLaGw1SnVZaVBhay9lcm5tN2UwamU5ZWlZUEVSa0MzanVhdHVQTy9RVXhhb0NuTVhCeTJ2RzFsMi96c3ovekpNUGdPVDZPRklXbEtpMlMvRm5rOGtCZ1ZIbWNHeE1OakNYUjIwRFg2TFNscml5MWc2TjVvb3ZDZkRXb1dXZFo1QkJIeFNGaUVDU0pLUXMvcVVvMzZvZDR0SjZTL2tIRUp2OU84L1FBTU8vaS9xM2o1cFdwOTg4bVpOVEZyQWdxUEVPdkk3UW1EQncwSGZlV0xjZGR4SlllY1E1VFc2b0VvNVN3U2N2NWVWVFNyN21naS9YNTE3Tndqd2MyYW54Z3N6NzQrOS9weERJUDZITGxRayt2bUFHWUVaVDFoWkkrUmtMYjZvQXpCR1FJaEg2Z3IwcUtVWUV0TlE4dUdSWE9KR1BZS2VEcERTaU1NUFNLS3E5alpOSUFOZ291Q3pHc095ZkJHRkU1NjZwTEhLNEdUaUwwbVVrb29yMTdSRGU3OXhyRE5EaERYUFZjTFF2R3BlZDBOYWdPSUNWd2ppakNWdVY0K01ZbUw5ODY0Zlp4eTJuZjBEY0Q5V3BGdlp4UVZSVkZWZUxISmJZcUtMelYxRmlqSmhrdTg4bUgxU0hIaDcvQjNidXZjL1h5TTF6WmU1Wnh2VUhoeDFTK3BnK1JZYmxrc1pnekhvMnBxaHJ2UExQWkJwUEpERW5DbFNzUDVVeDFTd2lCZnVqMW8rL29oNEhqazBPKysrclgrTzUzMytiMjdUbFhudGlsM2h3ejJhcXpPYVZTYTFObWtNZ1F6MktYK2xWUHUreUkvYUNnYkZRd0w4YkluWHNyVnF0NE5sMFJnYTRMZk8wYk4zbnlpVTJlZVdvWGF6c09EbHY2M2hLRHBheTg4amRFY0VuTHFYbzhJc1pFYVZxY2lTd1dPVXNnNitrSG9Ha1RYUmNvQ2tmQ1FrcjBRVk4xckxWWVk2elZFRDVsa0FrL0xPTGJ2L0dOZmc3SUNVR3pvZFBKV3dlcnR4N2ZHcmREbE5FcUpPWk5SN05VUkxOUGlaTzI1ODZ5SnpuSHM0OXM4WW5IdDNHVm8rMFQ4OVhBM2YwNWh5ZHpEazg3UXFOQmllRkNUNTB1ZU42bUIyNW84eEdBbW4vZ3RwZVBLRWw0b0VqNmdUODdZQVMyVXFOSVovUElKd3BEcHlhVHJoL28yeGEvS3JCRm9YUFN1ampMWmpQZUVvempzZXVPeDdiTE15dW53ZGhzVEtraGlMMDM5SU9sRjhVeEtnODJxTTQ4aW5EYUJPNHVCazVpSlBSRHpoNWZxKytNWnNJVmxtRFZCYU0vYlhqamcwTmlWSGRYNDNRV0phSzMzYUxwdWJaaCtQeWpPM3lkSXo0NGJtZ09BOE5xUWJmb3FXYzE1YWlpYUd2OFpJU3JDNHgxU2xiSlVWYytKVXFCZXJBYzN0L244UDU5M3BwK25aM2RhMXpkZTRxZGpVZlluRnpCKzVxSW9SMENXUFVCR0ZVMUdPMm5ZNHlra0lncFpsY2dVVGZodWlhRW50dTMzdVpyWC8wMWJ0Kzl5YVhIOTNqbzZhdk1waVZsYWJQS0txMEh6SVJXZ3hPSE50QXZPcHJGaXFIcmMzeVU4djJ0c3h3dGVvN25tZ3Z3b2VkdTRPU2s0MnZmdU1lVFQxeGpjOE14REdxaFBRektQWkRLWjlWZW9EVENoQUl6SGhHc0pZWVdaM3BOQ2ZMS20zZVpQTFhxSXFOUlVtdXRmS2xoTERGRnJDKzlNYWI4OEZJVi9pQTN1bHk0K0tKYVFWS2V0c1BOcGsvekxxYWQxYUF6NzZQRmtxUFRodnU5NnBpdjdvejVtV2V2OGVUZWxJMk5ra1ZLSEN4NzVvdWVPeWNkUjZlQm9kZjlOY3Rqci9UQTVueVFxbW9lNk1mTkErWDZneVc2K1lpRFlmMzU4Y0xEcGdCVGc2c3lFZUpDT0tOa0JWa2NrcGJ4VHZ0cjR4eldPWXkxV090d2hVZXNwZktXVDM5OGs0YzNhbEtucFB3UUROMWdHSktseTBTWmhLaGhRaEFzYWx4b2pacGp6TnZJUWROeTBuWHF1WWlpL0NadmJKUHppRlI2YXpIZGdCOTBqS2YwVjJYZ1NZaFlZK25Ed01tcTVlRzlMVDc3eURhRmcvZU9HdnFsRUllZW9SM3c0eFYrVkZFMFkrclJDRk40eEJtS3d1Tzltak00b0pGRW5RUW5pYTZkYzN4NHlnZnZ2Y2wwdXMzVnZVZTV2UHNvcytrdXM4a3VTYmFJQ1NwZnFKV1k4NHhIVTZwcWhFaWk2OVdyWEl4d2IvODIvL0kzZjVtdi92YXZzSDl5aCt2UFgrUFNRenRxQjFZNzVhMW55K0E0cUgyMURJbStIZWlXSGUxaXhlcjRGQ09Hc2k2eFJnbFppMVhQdmZzTncvQ0RhSTFrNXVXYmJ4M3gydXRIUFAvTURodXpTclBzUXBNUFdLMjJSSlFsVTR2RGxDWExJVUlLRkJYMFhhSmRtNEZhWlM4dW1zUjBGREhXZ2JQMFE4U1g5aXo4TWkreXN5V2MxNXo1Zzk3bytWYVhBYWplTzE2OWZyVHNiL2NwM3BqM2cybVdyVGxhZE56cEVxZFIwY3NuZHFjOGZYV0QreWNOMzd0N3lsdUhDMjRlcnJoMzJ0TDA4YXpIOWhmc2JNSUZZSXdITmpJZnRnby9zK0ZZZi83Rm52N0IyL3JpMTdsWUlSaWZMWXhHK2tMc0JWOXlZVzNtbHcrZ2JGT1ZRa1NJaUJseXIyZk93SzhoR1o2L1B1WUxUK3hnWFFacTF1NnZ6dEF2ZEo0ZW84MDIxNElnOUFrNnNoRm1FdVpkNE81OHhkRnlxWnh3TG53ZmE4OTErOWFlSFc1UGpEemIzbk52cFF0MHZaSk4wcGw1TXdTYUxqQXBQSis2c3NYSVdkNCtibGdNa1dFcGhENWdtb0JmOWd6amhxSXVzZDRUQ284dlZHQmluYVczaGxXSU9KUUI2QXpZWmVUNDhDWjNQdmlBVWZVMTZzbVlqZGtPbDNZZlpUclpvZkFqNnRFSTV5eGxNUVdqbzdYRCswZXMyaVZKQnI3NzNaZDUvZlh2VW93ZGp6NS9uWHBhTXk0Tm8wSXlIVmFCdFppdHNRaVJFQ0xOb3FXWnJ3aU5obFlXUmFIUHpRaUxadURPdlJWTkUzN0hoVzhNSEIrditNWTNQK0RKeDdlcHFwS3REZTNORDQ1YUJFMzJrWlJvc3crZXN3WkpVWTArMWhiYlVmMElxOEtTK2tUWEpWWnRvQ2dNeG5nZC84V2srSXczS2FVTUtmNStOdWovT3FYN21rTUNwTU5WZjNqVUR1K0hvWC9wZU5tVUo2Y3QrOHRBSjVvYzUwUTRtYmY4OWh2MytPN3RVOTQ3YlRsb2g3T1kxdklCSUMxOHhFanNvMmlxNllGYm13Zitycmp3ZzlnSENxSVBDVmdjbUFMY0NFeHhIdU4wM3BkTFJpUTBnc2phOWFaY1d4bkxHWUppY2xCaGlHQ1M1WE9QakhuaG9acllaMG1DZ2FwS3VFR0pNa1l5MVZjNGk1d2VSTnVYTGdxclhqaGFEdHhmdEt5YVlSM05waWlKdWVpN1pzNHMxRWx3T0s3WTJaM2hqS1ZQOFJ6RnpzU2FaZCtmY1JzS2IzbDZaOExFV2Q0NmFUanNBcUVYRFVEb0JrSVRjRVdMcXgybThoVGVVemlQRko3Q3V6V3VlQjVtS1lJM2xnS1luNXdRMHlHSjk2bUtiMVBYSlZVeFpqU3FzMk51VFVnRDdhcGo2QWRXcXlWeENEUmR4M1J6eW1SclJ1a3RSUXg0Y2FTZ0lZcStFR0tJdEUxQytraHNCNWFuRGFkSGMwTFhLNjVUbG5pbjlkdnh2R2Yvb0dHNUN2L0txbmd0VDMzdHRYdDg1N3YzK055bmIyQW9zYmFrN1VMbUpWaENqRFR0b0RyM0dISFc0Z3VITDZJNkhpZW9LbytZbE9YQjBIU0p5VGlCQ1dyVUdZSkp5VkI1VjFsbjZvOG9UUDlRYlBSMG9YeDNkNWJ0eTJYc2Z2cis4YW82WEVXR3ZNbUwvT2E5djcvZ3ZmdExqb1pJZTY1bFVOMTNwbzcybklkK1hKeHA4eEVsK0lYSTdyTmIvSUZBa0xQZTNsNHMyZlBtaU9zMFVwU2o3SXB6UHBJeHVobVUwQ0Jud1FQR1h2REJOdWJDMHpoWENwOC9LV0ZyVXZDVHo4K29DOE93U2txU3lVa3VjYW1rR1k5UXlKcEd5OWtoRTZJUUJ6aFpCVzdQVzA2Nm9JZEgzbERyenoweldzenVQWkwxQnNjcE1Hd21DcXRLdHcrSkhCTU1LYkhzT3lydlZNTXZocXZqa2hyaE1BcnZ6enVPdWtISFFVRklmU0FNQWRQMUJHK0ozaUhlMFZtTHMvWmN2MnJNR1gvQzVrUGVHZldYNzVxQjVYTEFtdFc1SVp6UkNzTTdSMWw0ck5VM2FGU1B0U3JxZW9yU1lyMVNvUHFRenZ6amhqYlNyUVpDMDlPY3JHam1TL291UnhUYjh3cm4rS1RsL21GTDE4Wi83UTF3Y3RydzlXKzh5OGVldXNMMjVoUWtjWGx2REt4bzJzUnEyVUdLRkZWQnM5TDE0SXlHZGFha0FSMWloUEhVSTVJSVM5Vi9xRXc0RUVPaXFKUjhiUVJ2amFuTTJrLzdEd2tZeDRXMk5tUWpPL2YrOGVyVlJ5djZaWmRZSnFTNFFHaEpLanMxRnpibldhQ0Y1TExnZ1ZMN0xJUWlUeDkvZ1BqaVBnS1V1emg2dStqTnN5N0pZbjVSRi85K1RjbE5NUnNQbW5PbWswSE9vb1dzemFYdjJyVTBjOWZOdWlKWWE3V3oyMmxNaHNjdlZYenEwZEc1cDNwU3B4WUo2aW0zOWpTeklqakpBb0k4Ry9mRzBFbmllQm00ZWRxeUNQR01tN0JtdzYyL3B4SGxlS2Q0YmdYVW9LYWRwWE1zdTE2VllPYThqa2twY2R3MGJJN3FYTnJxNFRGeWxpZkducjI2NUpVN3h4eGx3d1FFcEZmTnY3aUlGREdEZ2NvaHNCa2NYTnRzcjBkL09nYTNXYVdoQ2JQa01heDFGbSs5U25nbDBRMEtrS2xQWUlGMzJlWlRSRWtiSVNrbE5nbWhDM1NMbnRWcFE3OXFhSmNOcVI5dzJkeFJEVUVUSnljZEJ3ZnRSL2JrSDVyTHVndUxKeStxdDk0NTVPc3Z2OCtYZitKaldHc1kxUVdUc1dmLzNqRkhoNmZzN0U1WUxBSmROOUFQbXBUcW5kTThRWnNZK2tBalVJOVU3anBmYVFudmMvS3ZxVEwvSXlRVGgyano4dnBEVjdxdjM1WWVjSGNXM1R1allIOTFGZmpUMlUvQWNFRm50OTZZVWRtYUN3TUh1U0tZZEtvSDJQUXdpaGY4L05ZZUZ1NjhJbDBiTjUzSk8rVjN3Q2N2c3Vjb05DVTBGYmw2RmlXQVpLQlhMeUo3YnNRb09TZnVESGxNdXNqWERiM0p0YXJoQjRzdFRUaFZyZjBMMThZOHRGV1EraHcrYVBqL2NQZW53WlpsMlgwZjl0dkRHZTcwNXB3eksydWVlcXBHQSt4R2swQ0RHRWlCQWtXUWhJU3dLRml5TE10aTJJcVFGZUZ3MlBybzRZUEQ0WERZWVljc2g4TU8yL3ppUVJJbFV4SW5FUkFKQ3NUY2MzVlhkUTFaVlRtLzhRN25uRDM2dzlyM3ZwZFoxU1FSUVJwZ3ZZanNySDZaOWVxOWU4L2FlNjMvK2crYkRpRkZ0WGtoWFhGaFhmY0kyb0JOY29vZUxoMTM1eXNTbWFZcVRNQjFjZk5rTkUrMjV4Y2xPbkhtUEh1alJ0UmlTcjdqalVJaWl4cXZkNEdSdGF4UHNLU2dHeno3NDViWHRobyttdmM4U0prRjUvODlFa1FuSnBnWlNGcllqbXVyckpUVjVrRFVSbXlrV1N2UFFvSWdKQjdUV0RCWnN1aldWR2dGVFZWampKWHhTRW4zd1JEd1BoS0s4Q2tPRHJmc0dWWTl3UWR5aWxoVnRsTUtWdjNBMlpsbmZ1WTNMaitmOUtGSEdqdVd0SjRRRWpneGNsSVJWaXZQMTcvNUljL2MzRWJueEozMzdqT2Zkeng4dk9ER3MvdnM3VTE1K1BBQlhlL0xpR0F3TVpHMXBQeW1sRmwxbmxRWlJxM0J1VXcvUkpyaXF1UmRJSTBxcFJVam5mSlVQY25WK2lOeG8rY0xYdE1lc0oyUEorLzUrSDhzWVpKZjA3QXQwd2hkZ25tRWR3TzhIZUZoaEVkcjhaaUdWbGpLN0ZuWXluQk53K2MwN0N1WUF1UHl2RnhvNDBXTEhyaEllMVViMEdrZHBaMHJ1VzF6aGFTRGNDRUtyQmdkcENSZlhDR256Ym90M3FTYXJKbHZkU21pZVA0MlpNN3p4SFNwbFJSaDhKbnQxdktWbHliWVZqR3NJaHBSYzJrTnkwR3pTaHBYVENLZEZxcnJtaXlqaTRQcDRCT1BGejN6em1IRHVjcHVQWUpzRHJxODRkOUk0UmRoelBIS3M5ZldnR0p3UVZCNW96ZDgvOEZGemxZOTdmWjBjMXBvTkQ1Nk91ZlltalM0Zm1EazRiSFBISm5DWTlEbkNyOTF5blcra0dPLy9vWVU2OWRQQ2pZV2kyaWp5MEVRRXlFTDdtQ00yYVRaVW1pWGFyME5jVUZXbWlIaWZDRDV3bC93ZmdPUUdpMGFlUjhqcTNuZzdNUXg5UEdIMnkwVmRwYXVZYnJUZ2pGMGc4UDFqbWdEZVNtOTZnY2ZIdk5YLzcvZmdKdzVQVnBTR2ZqS1YyL3kyVGV1Y1hyc09UM3JxYXlscmhWREx3UWxZd3hWcGZIT015aXhIeHUxbHRFb3Mrd0RxNVVxSkxpMGZxamJFTk4yL2lNMm96K05lNFd5RFdNRmIxdjRYN1h3WDJSNFBrQVY0WEdDeHg3dWV6aUxNT1FuQmZVQXlnbS93QmdZMTNCZzRMS0NxOEJMRm00WTJGWnd0Vzd0anJhNlhxNjhySXFLdTBwRVlwQnNWZDdBU200NExoQWludUN6bTNWRXpubUF3THFOTUtXUWREa0kxbjhuSjRqNmZDUlh4ZjNWMnVMeHJvcHV2VS84c1Zjbi9OVG5acUtucnpRcUNWd2VJZ3lkeG51Uk04Wml6aFV6QXRoRmFYRUhENDlQUFhlUE9wYUxVSUN4YzR3Z2NGNWtUNlBHWk9rR1ZnZ1FkTlpuSHAxNXJteFZqT3RpZGxIVWRvdkJzUk9pb09XVS9Md01mZTlvUnczR0dscm51WlNoZFhBWVlWbXZ1ZjlQSHYxcmVhbXhaUlZaZVB2V3JMRVJRZVhYQUdMTXFZQW9JbXd4VllYU21wQVMwVGxzenNRUXluWWprVklpeFNBZDJmcGcwckpTakNteldubVdDMGUzaWdTZlA5YW1Ld1BWU0ZPM0ZjcklHazgzbHFwdWFFWXRkUk5ZcUFWREhRaldrMDhDemtYZWZmOTQ4MlVtazVyYnorM3h6TFdXdi9XOVE3ekw3TzIxREdWc1VGcUx2dDlvblBORkk1L29mWEZJRWc4Z2lhSUNwWlZPR1dXelV2dFBRVk9mSk0vNFF5bjBmR0g5dlBsY2dBK1g4RkREM3lzMllPdnduYWR4c28rQjRGbDRJcWNCSGdKdksyR1NUa3FSNzQ5YSs4SlgvOXh6UC9mS2p4eThzWng3WGRrU0VOZ3Izdjd1TWQvNnZZOFl1Zzd6bEQvT3BsRFhYT01MTitNR01WYm5BUUphczhuS0t1cEMrVHI2SEVDVUIxTm9vdFpXOGlhWE4zVXloUjk1ZHNaSDl4MS8vOXRMVklidFVTMnhQZnNXbFRVMkdKSVNHeXdkTTAyU0V6RHFZcnlZRXlkTHo0T1RnZDduemRxUkgvTGk1VTk0YzVZK01oOENZMnVZMUpwUnBVc1VrcXp4S3FOWkRvNXU4RXlidXN6eFV1emVKVmFkdzFRVktJOEMyZ3h0Z0ZGaDhKM1c0SW9PUmFuejJLZUw4NVMrY0RmcEM0U0h2T25OU3ZCRnlpanZTczY5akFRaGVIelpmK2NrbnpNRi9GUGxDN3VVOGF1QjFkd3pGQVBKWE5vNmJSWFZ5TkNNYXVxbW9ta016YmltYm1zSnQvU1JIQ1FpVzljVjQ1RjQ1bXZuNmUyQUN3dVlweWVlOHE3My9NMi84eDYvOWJ2M3VITm56dFhMTS9sKzBOaktVcWRVT3N1TXRRWmJKNGlLcmc4MFdnSk02c2JnY3hRRllzRXZLMDJqemdXV0Z4R0UrSWQ5bzM4U3lTd2g4M21JMFA4UVo2YjREN0ZyMHhmY05lb3NoaXNoQ2s2MWZPNjEvZWJ6UDNYRFBQdnl0aDU4TGdHQnNGcGxEbDYvek1HbEtWLy9XOS9ud1ZJY0FiUSt2OG56VTJ1MjlYODFsZTlhNTNQWVhxa255MmM5R3FqU2xpb3Rsa2RWVldHckdpWHhLeWlscUlER0tIN3JXMHQrOHpkT21LcWFMU3RMK1h1OTU5S081YlBQYjBGajJkdHVlTzM2bE1ab2NvcGk5aGdUUHNLcVQ1d3NISWZMNFh3Y2VSSXIra1F3OHVMTlBzVE1jb2hjMmFwUnVrWlJxS0tiR1QrVFZXYmxIYU82a2dCQWxHaW5nUmdqbGJVWWE4REhqVE5vbFdIc29RNndxcUN6MEZ2UkJhejFDbXRBaGNLK0ZVdndKNUZXVmRxUGtCSXFKeWxvclNYcGgzVnlRY2xxUzZuY21Ka1l2VWg3ZmFCYlJFSi9YdUJtckJudnRNeTJ4MHgzSm95bkRYVlRTWHFzMGVjcFBzV1hjRmc1aHQ0ekFLYTJqTGVuNU1HRE5VUTNFTU1BeS9NWE9zWE05NzkvakZLd3N6MWlhNnVsNjMyNXlUTytwUEFvRkpXMU5PczE0SkJRbFdaclZKR1Z4cHBJMGJua0tDa2d6Vk44cjgySFlQMS9lRE82ZXVxQ1dZUGovb0o2VkgyQ2xpUS90UzNqcVI5d1hlaCtRejNQV0cxVS9ka3ZIVHgvNmVyb1dUZGs3cnpmNWROanB3eWE2WGFEdDVaTE94TSt0N2RERytHeGR5ekRHdG83QjljMi9aQTZuelhWQmIvMU5XcSs1bCtyQ3lDVWtGU2tWVFRHWUd5RnNiYmMrT0ozcDQwbUFtL2U3L2hpcW5obXU4RWx4Y1JZZHBzYXQweDgvL2NYUEhDTzB4eTVmV1BNNnkvdThObG5kOWh1dGFEdnFkQmV6OHA4L2dsTVAvVkQ2TDJiUWk4RW5Ia2Z1RHlycWEyaGMzRXpXT2Q4VGhBK1hQUnN0Nk5OTzF4NlNtS000ZzVVVzh3UTBjVUtmKzA4cXpKTUhZd2QrQW9HQTk1Q2J3UnhWV3YvZWYza0FaVFhxOG1zMEVxTVB0Zm92YUtFWjhqYVNWeEF5aTNwZmFCZlJYeWY4VU11K3ZYeWRTdEZ1OXR3NWVZZWwyL3NzbmQ1eHZadVExdHJrWWdPMHM0SGx3cmxOdE1qZXZSdVBqQmZEbmdGVmFVWnEwb09BeC9vZkNZNlYrSi96djNVU0hEbDBvUlJXK0ZjeE9oSWpNTDJLOGtCSkIxbEhpM2JCeGZnck1zTTN0TldJbUlTc0RjcFVxN0xwdG4vVVp2UjgxTVg0MFhFOEtJZ2pVL29PRDlXNkd0bVo4Rmd6RlBBdVgzMmxmMXJCOWQzdnZEQisvM1dXOTk3a0JmTHFHNDlzODEyb3dsRHNhanFBd3E0UGhseHE1NXhaNzdndzBWSHlBbDkwU0pLbmQ4NldUM0Z1bHZQR2FXdDBwdmlWbWh0TVVZWU01bk00QjNaRFl3bUV5YVRHWFV0aFQ4ZWo1bnNCMTdzRmFudkNjY25yRHBQdEZaYVpxMjQyZFJzRDQ2VDk1YjgzYnNyL3F2ZmZjZ3JMK3p4K3EwWnUrT2F3NFhud1drbjRZbFBjZmMvcWJDZnZ1WFhCOE1paXJxdDBvcHU4MGJrRGRNdlIvRUJXRGpIZGxYTFRhd0xmOTRIblBPMFRZMWJCYlNQeGRSRDZpL216VGxLNndRMVRVWHh0N1F3YU1rWFNxWFk5WVZaYWUyUVk1U0FsT3ZYZUEwb3BwS2dpNCtra09YV2RpVklVOHprQkpDc0ZlM01zblZwaTB2UEhIRHo5aDZYcjR3Wnp5emJXNVp4TGVDZjd5T3JMdE81aEZzRWZNajRrRmlOSzlwSmhYcWtPSjA3U1dkcEsxcGp5REdSbktQclFyR2pPbmNucWF6bTBzRkUybk9yR2R4NnpYZytXcHRzMGNhVmxDRUJHSHN2RE1wcEszTTZHWlZqVXNVb3RpYlRYWHdjOVIrQkdmMWk0dTM2TG9oUDBrYytSbWJiZk5LV3NWaURDZ29WQytqOEZBZG1UV1BKU1pucmYvZFhQM3hPRWRVTEwrN2x6My94Q3BXeE1FUmNlU2pXbE5IVHBXTkxhVjdhbXJGdEt6NWFyamdObnNqNW9uSU5yZ1ZmNW0xN1h2VGtpOSs4S2kxYklxV0lxUnEydG1iTXRyYTRjdms2TjI3YzRJdHYvQmc3N1l6ZDhRN2JzeEVIQjVkWm5CMmorNTdsOFJIdmZmdjMrZjV2L3hiM2Z2QjJzWXlXUkprWVlHSU5NU2JjNDRGZnZmTStmMzFzZWVQbGZXYVY1Y0hKU3RobVpTZE51UVUveHRQSitZa0Q0Q0psMlBuSWZPWFozYW94UmhSaXVmalJTVHFzSEpMSHE1NnQzV1l6VjJzbGR0cmVSYlNLMUczRk1FUkc2d2tuZjV6QXRENDhtaUI3MGdpY0FJZEZmaGhLUkpxUUkwclFaaEU4cHhnaFIzSnhIOHBlZHZackVoQVh0d29GTDZsbkZWdFhabHkvdGNldDIzdnNYWnV5czkrd3ZXMm9qVHpFNHpiVHRwa1FOZk01RE1uUXp5ekxSUlIzb0NGaUdobFdnazhzZTArMlJnZzhUc3d3K3JFV2YvanUvR2NlalN6N2UyTlNValMxWmRFTjRqVlhWYmdnNGhySytDRStnSklxSXdjY1dHTklPWjZEUDJLS3ErSlR0M24rcHp5azIzL012L2V4UzZXUlgycitsRlk4UG5VcXFmUC95TWRXNGVyYzdTa1haRlhYSTd0Lzg5WjA3NVdYOTlpN3ZFVVhKZG80b2VpR2pPOEMzcWhpMUJEcGZLQ3lpcGsxM0I2MVBGd21EbjFnVUd2eVMxbFJYVWp0ZkhyR0ZWZW14SGd5Wlg5M2o1ZGVlcFdmL01tZjRyWFhQOGYxYXplNWV1VTZzNjF0Y29MM3YvdDdKUE43TkZ0bkJKYTBzd3FmemhnL0M2OTh5WFA1NTU3aDN0c0JkOWFqTXB3K2NEeDhaNkE3ZGR5L2M0b1pXcjU2OEFyTGRwZmpwbVp4ZXA5MlR6RUpoeXptYzdHSjJzd1ZiTXdvVTh6blFNZ0ZNZjM2dFhjeGM5d0g5cWRXZE5yRmh6OW5pYUNXbEZvQm1Ucm5hYldCbEVvaGFoU3kwakphZk45cWw0anF5WWR2TXdTVS9aQXJCQ2lWWVFKMEhoYit3cHU4Smg4Vkt2R1RUMEgraDk1aEdkQzFablo1eE5WbkwzSDltWDB1WFp0eC9Yckx6cTZsYVNVeEovdUVEaGxUeVlIU2FNZ3pVTDNDTm9LeGRLc1M1Nnd6YXFkbDMwZmMzVGxEeW1MQ1VWbXF1c1hXQTY2U2ZaRXFTTzZ0bTF0c3pXcm1DOUczQy9JdjVxTWJmQ0VKSnBLZWVyaTBFZ3V5bkNDbVNNNVJleGlsa3BIeFIybVAva05QbTNHcG9YL1V2K2U0TVBZOFhXVEZibWM5NjA5MzIvR1AvK3l0NTE3LzB0VnRQMlFXcDE1bEw3WThuVThNWGtRUkhpMm1sQlllbjNXTUtrT0lrWlFURXhUekpTeVZTRStOTGV1VzZ0d0lQNmZ6dFZtS2lyYWRjZnZXQy96OG4vbFRmTzFyUDhOblB2TUY5dllPenQrS0dGSEc4TjRQZnNEWDMvc3I3RDczZTVpVmhDVElpclR3NFhPbTJxdDQ3cXNqY21qSkY1eE9BUTQvV0tLNmJXNCsveFYyWjU5bFovWlpocUZsdVJyNHEvL1JmOGpmK2RXL3dhUDVCM2g2ckZVMHJTRjQ4VVU3TytrNXZML0VEWkdoQy9ndVBDRUVTc0RLUlp4UFZOb3daRjhvcitlY0FSUjBUdVRFN2FRdFJYNyt5L2xBc2dwVEc3S1h4RldsS0NTZjh4cTE2N1ZrYWV2WExkbE9BVno2cDRhNC9BZThxcFJSTkxPSy9aczczSDdsQ2xkdjdIRHBjc3ZlZmtVek1ZeGJhQnVSbzBhbDBJMGt5WG92a2M1TkpkLzMwaXVtRXkwdHZkVlVTeG41OHQ2SWJ1RzQvM2lKdGdaakRhYXBNWlZGbGJWSFRoTHc4TnFybHhtMUZYMG56NkV1cmI3YUNKdldGMFp4OTgwWjd6TFd5cDhGSDhWbXpRVkNVbnFlMmN2Q0tVbFBnM0xxajhDTi9yR1A0MytNdytBZjlYNFdKNmsxb0dmMnJzNTJUTjA4RzBJbWhaaE5IeFJPSXAxOGtTb0dud3BFTDY2b0xrUUdMLzd3T1dkOEtxMTlFRkFrR3duN2Erb25WMEFLUmZDS2cvMXIvTXF2L0NYKzRsLzhiL0RhNjU5RmF3MHhrdjFBRHBHc05jb2F5SVozMy9rOUJyNlBaa0xzMUliWm90ZkVuUWhEU0F3NW93MW9uWW9xVGxxNVM4OU5zTmJUKzcvT2g4UGY0MHgvbnYzcEcxemFlWU4vKzkvNXkveHIvOGEvem5mZS9VM2V1dnNQT0IzZUo2aFRzZ3JVVFVWWU9SNjlmOExpWk9DamQ4NzQvZDk4eVAwUEZvUWhiaDYyUGlRNm41aU1EY3RpUm5ZK21NaXRybFhtZE5HejAxUlVGSkRzd2dNYlFoUjVhcVVsQkNGL1hJUHdCSW5uQW1EVEFsc1gwTlUvVUorNFpxZzJtcTJyTTY2L2NNRE5adys0ZEgzRzNuN0Y3clpoZXdyV1puRlVUREF5MEk0ekFTVWpRSVFoS2VvaE1SMWxzTkFwVFFyU0M5WFdZclQwbk1QZWlLT0hjL3JWZ0cwcWpOVlV4dUJxUTlTaWVnc3g0MEptTm1zWStrVHZJazF0NlVPUURZN1d4VUZpRGVMbXpVcXhxbVJjeklWMzBMdUlNUlpEVnZGOHZmYmtqZjVQY1VvMy9PRjhLS1dVemptdlRXVmFZSFRycFlPWHJ6Mjc4d3RiTysyZXpwbXdDR29JbVZVQ1B5UlNsQ1NPR0RMOTNSUFN5aEZpWk9VVHMxR0Y4Mkw5dkJvU1F6Nm50YnBRaUNkbURSWXBFb3JKNUlEL3diL3o3L0p2L1Z2L05qZHYzSVFReWNHVHZTZjNTM0wwYUczUVRjdjhkTTV2L2RiL2s1MHJIekdkaWltbDFybjR0VitZWFNWOEZhdno1cm9WOXAwbU9CRkJlTi9pZldZK3ZNL2g0dmM1bnY4T01RNGM3THpLOHpmZjRKVm52c2d6bDEraE5oWE9uekc0TTVwUjV1WnpXeno3eWhhdmYybVBWMS9mb1cwMGkyWGs3TXhMWjVRbEVtdldXbnlVZU9nTmVueUJDZWhDWmx3Wkdpdjc5cFNsYTBoWjBHcGxETUZvb1hubWN6T1FqeEZUMURsMy9pS2lldEVpN0EvME1EYWFnMmQyZWVFTE4zbnU1Y3ZjZkdiS3dYN0Y3a3hMbW1xbG1OVFNQZW15eHF0TnhwVEZmbzRRa3NJN21GUVoyeWdHcDFqN3E2cGlwbEVwUlZZYTF3ZE9UMWFveWhLR2dCc2N2dk9rcGJ5aDY5ZjBwUmN1eVRxMFJHb1B2VlN3T0J6SDRyMGZHZnFJOS9KNlZGWmpqSkpZS0RrTmM2VzF5bDE0SE9IdlJMa3JmV2w0ZzRKVWFVbU0vbFFWZXJrSWJCbnptblpzcDg5OTV0cVg5NjV1L2VueHhGYUtqRStvTG9FYkpKa3hKSm5YZzA4TVIwdmk2UkpGNXJTUE5KVkNxN3dwOUM0OVNUOWF1M1VtTFcxVzhJWmYrVmYrRXYvRC85Ry94N2lxU1N2SktTY2xrbmZFNERHakNkcGFsTEc4ODlaM3VQdm9QK1g2YzUzSWJtMm1Oa0tDVVVXOFlYV21NWm5hWm96SkcxS0swV3Nlc1NZbVJYQVFuUWJWa0xLaFQyZWNkbStTWW1SbjlBcXQzV0puNnpxM0wzK1IvZWt6VkVveHVDTjZOeWVFaEswMVYyKzNmT0ZIOTdqOXdqWXh3ZnpVc1Z3R2ZJSkpiYWlNZEQyWjgwU1pmRUZtbWxKbTFsYWxDSEtaTVNXdkxpWEZnS0ltb1FvdC9HbkVkWjJ2a0Q1T1ROdDRESVEvd0FPaEc4MytyVzJlKzl3TmJyMnd6OEhWbG9PRG11bFUwNUJSVm1FTnRHVzZYZE1yTTRxUnpWVDZmSkRVbFdJMGtiR3Q3OEFIU1l0MVBwR1N3bHBGVldseVZodytuTFBvdlBEbXo1YjRrNTQ4bkgrdDA3T2U2OWUyMk44YllZMmlXd1c2WHRLRVUrRURweVE3ZEI4a2hsdm8xbExrdFJWL3Z4QnpUakhuN1BOSFhncjk1T2xDVjZxWTRINktDbDBycGRhRjNnRHQ3dVhKMXZVWERuNXVhM2Y4bzZPeEpxRlVuOFJDZVcwRlRJTFFCMklzaG9EM2ppUUNxYlNzSTZzWVhLUnptVDZkRDBHYkJ6UkJ6aG9mNGVXWFh1Ti85ai85bjNQdDRCSjU2TkVwa3J3VFp4QXRiWmlwMjNKeUs3N3pyYitMR2Y4dVcxdGVWZ2VwcU1zTUVsS2dNNVhKaGZDU04vN1JLYWhOTmF5REhMS1h0emdGWWNmRlVOTVBBME5ZY1dueUJxM1pJeWVQVnBhZDZYVnU3cnpPN3VRcVZ2Y0UvUWhsQm95R3BsTGNlR2JFUzUvYloyZC94TW1SeXllUCtuNVNtemlxdFhWUklvclcvUFFOYjEvMEpqUldVeHNscUh3V3cwVVN6SWZFa1UrMFZtN0Q4QW5HUi9tcDR1WXB4YUV1Zk9sL25CYmUxSXJ0YTFPZWVmVWF0MSs2eEtXRGhxMHRTenZTV0NNT1FHMGpqcXRXNTQxZXdZaUpDNDBSa3crdG9US1pjWk1rbnRrclZyM016aWxCM3d2Rk5oY1BmRzAwd1NYdWZYVENZcjVrT0Y0Uno4SVQzL1E2S2VmbEYvZHBXOHR5NlZtdHZCQ1NDdml5QnVPVWloZ3RxMEhuczVoTkZtbnhtbzlnWW40d25OL282K1luRkk3T0grNTY3Wi9pcmI1aHFJNm56Y2dhZmNPN2lPdGpiaVphcFpnM0w1SldHajg0VmlzdkpnaTFsZFNPbkJsYk9Pd0NKeXFobi9LSXowOFJpM1BJV0YzenkzL3hML0xxcTY5RENPaTZoWndrdVVVVlM2WnlEU3FqT1QwNlpkbS93K1RTSU9CYmxqY3paSFd1aU1zWlZaUnJGMFhyT3ExMTdobUprczhsVkxBUVRaQWJJUWRGbGJjeDFVZ21PT2ZsTDJoRmJTWThPL3RScmpUUGNMZjdUZTUyZjVlejhBUElpaGdNdTN1R24vd3pON2h5ZmNxdi9pZDNIbjMwMncrSDVOT3pXbEZGZGU1RXVHWVBhaVZoRTZlZFoxenBEWmdrMm01QjI2MkNTbXVpVGFqU3d1WWZBaGhkOU1aZjN4d05ZaFYyOG84b2RtVmh0RmR6K2NZZTEyN3NjSEM1WldmSDBvd1V0cExDcm1zWVdXblpmVlNTNk5yS0tBWUNDTllLeHZWNlZKRWlUMG5tWjc4SUJKUlFrWDFHeDRTeFFsTzllbjJMZXg4YzhaM2ZmMGp1MHNmYUVLVVVkejQ0NGU2OU9jL2MycUdwRGJiU1F1TmN5NXlWcHFvc0tWV2ttTEUyMFh2b0J6bWNLcTJJSWFFVW1zd09tZllUTmxDUzdaNC9uWVcrOFlxbzZtcXNqVGtJUTZKYnhseTFWaVVuanA1VnBWa2M5N3o3OWlPcTJuS3dPeFZ2czZZaUxucFVTdFFhSHEwaVcrbzhPRjd6Y1o4NUQ3ejA0dlA4d2ovL1o4VmZ6RlJDYlNWRDlCc3Bsc3FBdGFBTmQrOStDT1l1NDFFcTFzNHlDK1pVQ3J0b3AxVVJWR2h6Y1IyVlVVYlEvUlJLbkhBKzU5SHJESW1FMFlyZDlocWphdStjUWlIWEJka0gvR3FKWDJtdVYxL2xZT2RsN25TL3h0MzVyNE9kZzVlTXN4ZGYzMVk3VjE2ZC90YVZpWDd2MXovTXc1a1g2V3FXOElpMWlDb1h3c3RKRjlnWldkclNoNjkxNXlnWWE1R2FHaVExMWNVbmkvMkhQWS94d3ArUHlxMitmSnBjc1I0RkREUXp3OWJCbE4xTFcrenN0NHhuaG1hc2FTb1pqNnF5U25SQlduY3VpR1YwK1laRVVTaWlab04wU1NtZXN5VGRLZ3BUYmx6SnBWR2lyMk5NakVZVkw3eHdpZnR2SGZINGJQNkpQMVBYQjc3OXZZZGN1VHhsTktvWXRSWERFRFpjZldNMFdsbGlqQmpqWmRPallIRHl2cTVGSUQ3a2xETGRENE05N0I5dzNQa0R0ZEQ4MGZoUVdWR2hxSU9MZEF0UDMwVkNGUHJnNGYwRjMvMzZSOFNZbUUxYllvaW8yc0M0d1R1SlFhcVZ0S1BIcmpDNVBvRmtiNG9qeVMvOStWL2t4WmRma1Z0WXI5a2RRaTRSVXo4akQ1TldCTzg1ZlBRQnlSNlNOSVNvNlh2RE1HZ0dwL0ZSNDVNaUtDMXBGeWhpbEp2SFIwVWZEVjNTT09UdnhhaklYaEdkR0ZOSWk1L1JHS2J0ZGF3YWtRY25LTGkxWUMycXNpalQ0RjFQdDFqQTJTN1Ayei9IYTl2L0trMjZpVWs5clJIbHdjNk8zZjN5bjdsOS9mVS8rV3pWakdyVTJoemlLZlJjSy9BeHMzQ2haT1RsRGYzWEdNWEVTanJ1NE5OR0d3OC8zS3p6b3NnaFhUakJ4K1YyZjZLTjAzTEkxUlBGZExkbFozZUw3ZjB4MDkyRzBjaEl1NjR6YlptN2U2L29uQ281ZFhrVHg3VFJ3aVBxd0pEMWhvYWJ5MDBmSXRBYXRGR2trRGZFZkVtekZWYk83c0dVNTErN1ROM2FqekhRMS92L2Q5NDk1dWlvWXpLcEdZK3FrdFFqUVJyYUNQM1dHSU8xaHRxcURZYVJNeGlWc1VadTYzd2V3L1QvMzFuNWowS1JBeXJIbkhMTTNydkljdUhsVFZDS2Q3NzNrRy8rN3Z0VWxlSHF0VjJzMWd3dWdUWGtxdHJJUUlQUGpJQmUvQVEreHZCUlN1R0FxNWYyK1ptZi9UbmEwYWl3ZE5TNUdMMnF6MzJidEVEMGk5TWw4K1VINkdtUHQ1cGNnWmxDTTgyMDQwUlRKOW9tVVRlWnFpcHJOdjJVdWlkSnhwaFlObWN3R2FYekJkZlpSRk5QbVU1dUNucE1JdXNMYjQweDZOb3luc3dZejNib1YyY3NEMWNjcEMvU3YvMUZGdmZHVE5yQXFNbm9sTlZvMitpWHYzWlRQZmVqTjFIR0VPUDUyb2NMRXQxS1pSWjl4SWUwSVhoa0piZDZDcWxFQ2tGY2szWFV4MXYzL0VPRURXdnRrQzNGWGozeFhvQnRvSmtZUnBNSjA2MEp1L3NqdHJjdG93WmFrNm5LOXhzaUpZZGUybkdpRkk0cGUzd2N4SG5HdS9JY3BNSkswK3NZWmxCV1kyY1ZWYVZLYmwwSmN5ekl1UUt1M3R4aDcyRHl5V3Uvbk9rNnp6ZSs4d0JVWmphdDJkbHFzY2FnRVhkWFhYUVIxbFJvbzZpSzk0RXZBWktod0NBb1BPcmowWUtxdUFsOWVndTl1QzRxclZUTzJRYWZXTTBkOCtPZWIvNzJIYjd6ZXgrd2Z6RGw1ck9YcEZoOTJvUlZaV1B3UWFSdlhSbHAxNEdMVDV0T3JuM0Z2dkRHR3p6MzBvdm5JRjBTTVhVT25od0c4dktNSEdOSlQxUXM1bWZFNWg1bTRsQ1ZrdXRwQkxGUlJDTnJ1cVRPZVFRK0s4TDZWMUppSzRYODdndjRKdGhYbVJrTDROaldWeG1QYjRtdmpqS1FJSGtuSzU0U3Q3U2NuOUV2enRqYTJnT2xlUGpnUGtjZmduL3dCY2J4ZVl6eU5KVUVNTFpiaHMvODZlZTQvTUorQVNFVnNUejRhYzBXTkRDa3hId0lHOXVzVUZaUFpDRXo2UTNXSUhPNzF2OXdJODk4b1lYbkFyOTVmR0YrTnhhcVJsRTFGWFZUTTlzZnNYOTF4R2lzMFlVajJ0anpZQXRoL3BVRVdnUndvNWlEMkVLalRjVWtjSDJvNS9JZVBERlNLSkhKcmsxSmM4R0FuSXVNeHpVSGw2WkZhZmZ4d3l5bHpBL2VQZVRlL1FWYnM0YnRyVllBdldManJKVENhQkh1ckVGYVdUMHFRc3FFVUhEUXpGQW80RThlS2ZuanJNMVBWNkhMbUpORFNONjVGSlJTOU12QTcvLzk5M25uMi9lNWZmdUFXN2N2RlhPRHRQYVlraG1yS0t5NmxPbXpCQ0Y4b3VXVVVzU1VzQXArNnF0ZllXdDdoeFM5SktHa1NCcUdzZ3lQeFUzQm9BcmpwbHNkVTAyUGFLeEhGNVJQSlFIWnhIUlM0WnloOTFLMEdRSHBBb3FJSmtiSjFGNDVSUmMwZmRaRW93aFI0WHVGanhtZkRGVnpnMUY5dFh3ZldXeVlVcGJBeDVSUU1kTzJMVEU0Y2s0MFRTdDgvOFVac2IrRU92a3hxbkFGclFMV0tuSk9iQiswZlA3UHZNejIxUzNKSDQvbkJJNGdZYXo0a0ptN0pDNCtTbTVRbzVUc3B0VlRyMmNxOGxUOXliZjcwNktiK0JRU3YyYmFhUXVtRXIrNDBiam15czBwTy9zVlZabHRpNDM5WmtPd3R0NEtTUTVXWTRUT21tTnhGNXBjVkN1cWplbG1DQUtZeFN4YytoRGw5MzRWaEdWWm9wdFR5TVFJVlcweFZ2MHc0Z2RkRjNqN25VT3EybERWbXZHb2VvSkFwRFkyWTBvYXdoSWZGUkpZdlNHREdxVSt2c0JZYytNL2pZVis4UmxLd2NVaERLSFBDcnJlTWZTT2wxKzd5ck12WENhaENENUl1bWpLeEpEd2c4ZkZSQWQweGNyRy81QUh6aUNoOGxjdVgrYkh2L3hsMmxxTUVsTVU0b091RzFSVlE5Mmlxa3BvZFRuaGx4MW5KKy9UTm8vWkgzdkdWdmJLNnh2WmtLbEpORGxpZlNiMWtIeEpQWTFzUE9PQ1UzaW5jQ2k4VXJpc29jMDBrMHpUSnRyR3NEVzVoYUVsZUZlUSswZ09nVHdNRUJ3cGlyS3FxbHFDRjRKTTN6bFcvWXJCZDV3K2J0Z2Vmb29xWGlObWlXZktLWEwxdVIyZS9mSnQ2cmJaeks5ci9YNHVNK3pwa0VxR1hoYit0em9QdjFUcXlURmtQZVZrOVE5SDRTK091blVwY24xaFBsZGFnZzB2M2RqaTh2VXhkZG1GMTVZbkJVbHN6R2xrWjExb1piV0Z0azNZSm1NcWNmZXRqSHp2T1NNcnRaZ2xSeTFrbk0vMFFiTFBnMHQ0TDJHSklTU0NqN2pPQ3hmQ2ZuSko1TEl2ZitzSGgzeDQ5NHpwdEtWcEtxelZHenJzV24wa29SV2I0cFpvSjFQc0x6TytCQUQvc083MlUxbm82NHpvTkN4ZE4zVCtNTWRFOUZFMWpXVjNmMVlra3BtNk1SZ3JWMG5LR2UrakdBcHd6a29MZklLcnpJVzk3by8rMkkveTNPdWYzNEJ3U3A4L1ZjSmZGc1pDUm9HcGNFRVIxUW1WWGVLOXNLeFdnMkkxYUhxdkdKd2hCQkZUMURvekltRjlRbldadkVEWVBpR2orMHg5RmpISENUWFBoQUdjMTRRa1k5cG90TXZ1N0ZVSWtkU3RXQjA5Wm43OG1CQWNXTW54U2lHZ1RZVXlWbTdrRUhsMDlJamVyV2lhaHQ0TnpJOUhwUG56REs3RnhVeUl3c0ovN2tldWMrV2xBNUdLR2lId1ZCZGE4QzVrSG5hUnBZOGtZMmdhS3lpMi9tVGxSWXlGUTFCOWNndi9kTEZyWUtKZ3F3aXhNeEI5WnJJMTRwbFg5NWh0R2RhcXo1U2haRWRTcVZSYStIVzRnQXkzMW1ScW0yanJ6TFRKakpwRVhTV2FLcVBWT2VxWXZKaGJ4cENGV1ZsMjZER2tUU0NFNndMOWZLQ2JPMEtRMk9OLzJNZHk1WGp6KzQ5UkduWjN4MHduTGNicURhQ3BsY1pxSTRHY0Y1bVJNcU9uckRoRWJXSUgwd1ZXOFQvVjFFWDloM3liYjRyOTZPRjh2cHdQdnowTTBjVVFWRGZ2OCtPSFMvb3V5RTdYYWxSbEpGMDFGNko4eVNTN2FJR3pkajVweWx6WWxoTjEyeHArNGFmL0pMdTd1MFRYazRkK285NlNGakdTZ2k4eVNpQWtRdDlCZThoZ0FxZXJpc1dab1Z0cStrNnpjb1pGMHB4bXcxR3d6TFBCV3kwQkVhWXc0eEtZS0xkTXBjRzZoRDZMbU9PSURZbW9ZZWswaXV0TXEyZEpNV0dyQ29ZVnc5a2hNVVhKY1MwS05KU202eDBnYzkvZGV4OUJ6alIxZ3crZW9RL01qeXp6UlUzbkpjYlp4Y3hvVm5IempSdVl0aEZOZnpHV0dDNUlyODk4NW5FdmJRZzFId0FBZ0FCSlJFRlVLc0cyTWh1WVhmUHh0TnExR2FSR29hM2F0UEZQSHdnWGl6NGk5cjlqcmZDRFl1dGdpOC8vOFdlNWNYdEtaWXNMYkxHSTFva0NzcXFTTkZ1U1owb3hwSEpqZXkvVDFucWNzQVhnakVFK0h3c3VFYUlpZUFFWExZQ1Q5emdsOEVOa1dEamM0UEc5RUl4KzZFTmJXdjA3SHh4emN0b3phaTI3V3kxdExZcXBYQ2pIZFZYUjFKYTE2VzVLUXFEaC9Dejd4QW56bjJaNHl4LzJqTDUrQm1KS3VWK2Q5ZC90NXNPSHNRVEpMNDk3SG45NGd1dUNHRzVwUVlhTkVWTStVMXRoR1R6RnZySEl1bTJrWVdZVURYRHIrUmQ0NHlzL1RsdFZ3b0F6RmNvV3FaTFNoZGVjNVhOSjRpQ1U2Z254THIwTEJEUzJ5dXlPQWxjbWpvUFdzOU1FeGsyaWJUSzZncWdGZUV0V29Xc2hnd1NqQ1dOTjJOR3dwYkRUUXQzc0N2aGlMVE43bFhoMHpPcnhSOFFZR08xZlllL0dDN1RqbVJoZ2xzNWpHSHE1a1dKaWZuYkcwZEVEeHFPYXlqWmx4NTFJbldIeE9OTVBRbVZOU1d5ckx0M2VZZis1ZmJMV0cyKzhpNVJWSHpJUEIvQXhNZlNPbU5QR3gvN3A5TnExVDM4S0dhdWdxVFJXcTQ5MW54Y1A0SnloUnpOcmE2N2QydU5QL1B4cnZQckdaVWFGOGRhWVRGdjg4MTJBd1NtY0srR3dXV3l4UjFuTUxZZWdHSUlpUkkwckJnYzZ5MEhSOTRyVlV1Rzg0REtTMVJaSlBwRjhQaS95bklrKzRvYUljMEZTWTFZTzUvN1JtK3l6aGVPYjMzMUlWUmxHbzVycHRLV3E3TWJyVHFsTXpoRnJDMnRTYmM3TjZET0hNVzhFZnBzTEwvMVRUbHY4UXlQTTVMV3ozcmt0VlhodzUramRabVQvTmlZZktGUnJqYXJQSGk5SUdTNWQzOFpZdFVGQVF4UnV0cjV3aTEvUXZrdkJGOUNuVzJWKzlJM1BjKzNXTTBDbWFpZUNMSWRJZGhKUVFCS1hFWXhCSjJubFExb1JXS0t5dUxaaXhlbEVhWEhEVkxuczNrMEJlNExhNUxYRnJQQ0ZxSkppRnV2anNUd0VSbWN5bWk1a2xHN1ozM3FkZHZzU1llaEpLVzRVVWNOcVFKc0tvelFwU25DZk5abSs3ems4Zmt6bk9pNWQzcWZyVGpHbUplZk1hVGZuNGRtU1dRV2pWdWpEM21mUWltZStkSk9UajQ1WW5hNDI0RmhNSlpVMmcxTVFVNkwzZWFNNXYyalM4Y1NOWG9yWGg0eXlVTlZDN1EyZmRDTldoc25laU8xYjJ6ejN4MjZ3ZjNQR1pGYVZsdnNjMkROSmdFc3ZFQWtteTJiQVJabDNtMXIyNjk0THFtNUhzckZQV1ZwMmxTRTV4ZEFYSGtPZjZNLzhKbElyK29TUGlWQnBjc3k0VmNEM2txWXk5SjZoOTJ2WjlELzBJL2pJblR2SHZQamNIbnRiSStxbEUxV2JOWGlYOElWMmJMVWs1ZzYrR0c4SWJMTzhZQ1AxaE1WYS95a3M5RnhXYWpHTC9VWUFmTGQwcCs5OTkvNWZtMnpWcXl1Mzl2NlVNdm8xWXcxbmp4ZmtsTmc1bU9GVFpvaUptTVZTVWlQdDJObzl0VjZmbmxvZVBtMGxCTyt6WC9nOHM5bU02Qnc1SkZiSGgxamJVTmxhU0RMV0VBWW5iaWM1VXpmZzRobVJnVHdVcnJSU0RJMG1HOUdpbCtoemxDbjJ4bHB0QUN1ZkZhNnNlOVlxT2hQRlZOQ1hESEtJYkkrdXM3Zi9PWlFlWTdDWXVpYTVuamlzNkJjTCt1VUNXN1UwelpnUUE4dmxuT0FqZCsvZkplYkliTHBEOUk1dWRZSXpLNDVXeHh6M0E4d3JyQktBemJ1RUQ0bloxU2xYUDNPRGQvL3VPMUpWTVcrODR5M2l0SHJZUjZLRzZkcXM0eWwvMG8rWkNKWmlyeEh1dlZMeS85ZHV1M1pjY2YyTDEzbnhUenpEMWFzVFJwVkdUeFN4MHBKdlp6SjFjZDBObm8wZi9OcHdRMlUyTytta0ZIMlVuUGtxS1JvTHRzNGJ3WHhTNExLRUp1U1FTVU1rZStGYzFMVW11MFFzZWVjaFJvYk80enBQY0o3bHZHTzVkUDlZS3k2bFlMRVllT2ZkSTNhK2NJT3EwbGlyc2RZd0RJNVlkb0xHUUYzTCtqZkhqWE8yWFZ2azg4TnpTVDVWRk5oY1ZtdnJHOTJoY0VNWHZyOXpNQnZHMDlIbkZlbzE4WENEMDBjTGhzN1JUTnRDSmxHb25MQ0ZobGdWaHBSWnU1Q1dhS0pNNHNybGJWNTQ0WG1NaXppM3hQZWU1ZWtKZFRNbHR3b2ZPemx1UTJUd25reG1hMWF6bkI5eU5sL2hPbzFGVWRkU0g4bXVXUjhKWlJReEt6QkM1RkFaK2tFeEROSTJvOC9qbmhLRk1aVmxCUmNqN0V4ZllGeGZwbnQ0U0FnOTArMTkvREJnbXhGYnV3MHFSYzdPRnB3Y253S0pvZThJTWZMdSsyOFhlbXVrcWxyNmJzNXFPR0k1ekZrTkRyc3dXQjNSSWVKTGdJUlNjSEI3bC92ZmJsa2VMdEc2MUhBNnQzRWVNanlPOG9aTUN1ZjlZa3JNMHh1TmRWcysrRXlqRkpQRzBLbkV5aWZhblpibnYzcWIxMy91ZVdZSERYYndtSml3RTRPeWt1YW50TUtZVEswekZabEtLWnpKQkYvV2VWcUk0VDRxWEZBb0l5SWp2UTdSY0FwVlh2dVFGSjNYT0dTdGxsQlFTWUUzWTAwS21YNFZTRW9SWFNRTUVoamhYV0ErNytsVzdoOWQ1RnEwNXQ1SDNuMy9pRnUzZHRpWnRsUjJ3RnBUZkFiUEtjNFdVT0krdFQ1VHovTEhFOExUcDdMUXE5b1U1RFZldEliMmhScE5WalFwNTRrMUlpTlRXaXV0TS9QakpZdXpqblk2d3JRMWR0b3lNaHBmakJYWERreHJzb0lxb3VudG5Sa21aZzd2UGFUdkIrRW9aMFhWVml5NmxjeStyUGUxa2cyK1hDeDUrT2lNOSs0bmZMYU1yV0ZVSmNadHh0YWdxb3hGc3NaeWtKdGFvVkFoMDNXaWlWN3ZqQldackFXR1NWbDJyRnBGbW1yS2xaMHZvakNZMnFMcnNVUWVGVkszcWxyYTZRRmRyL0JoZ1RXS2xDTEhqeDd5MGIzM2VmSEY1NGd4RW5KbU5Ob2lWNWJ1VkpSVjBVdkFoTFRsdVFSVVpDWjdZM2F1NzdBNldoWGV1MFFsbVNScnNIVTA5UW1TcWprcGdwR25BYmxQV3EwNWw5QW9hZ05tMHZMS3o3L01DMSs5eFdUYlluTEFXRVU5czVza1ZxMExTS21GcDE3WnpLVE91QjRXaFY2WUM2RklJWlJkZzJUaGFRMHVhcnBCMGVoTXF4TkpLYnFvNkQyNFFxR09YTkRqdTRSZmVFSnJTRU1nRHBIb0E5NEZWa3YveWJsdEZ6NmEyakRicWpFbWNucm1tTThIM243bmtEYytlNTJtc2JSVlJUVnVlT2dHdkpQTFFLbDhrUkRva1lpeWk0WCsvNWViL1ErbDBNZXpsaGdUeTlNT3BWVEtPVXVoQzBpaER1K2V2amVlMXYvWjlzSDBRR3YxN0pwRm9ZMVd6bm5DVWNDMEVzNVhqeXltMlBXc3d3K0ZybDVtYVdQb1YwdnVmblNYMmU0SERQMEtXMW1VTXFRWVpWVVhaUU0vREVNSkVCQ0YyN3NQSG5EbnZpT2J4TGpSVkVaaDE3cnpWdE5PRkpPUjZNL0Zja25STzBWeVVPbk1xRTZZMGxQR2RKNVZack5DbWNEVzdCb0hrMWZKSVZHTnhtaFRrV05BV1VYS1JacHJMSFhiVXRVVnk4V0NkclRGZzBmZndWYVdTd2ZYQ3hJOFlLMWxFUVlPK3hQaHR5Y2hnZWhHa21YMEVEZXhSanZYZDNqNGc0ZUUzbTk4OVpLU21YMDlvZ1pnVVlwK25PVVFNRThKaGZJbkFIVkxGNW50am5qOVoxL2d1Wis0UlR1emFCTFdpQmQrcFFVNFc0OEZPbWZzT3Q2aEJGNDJMVVF0S2JQT0szSVVtbkpNV29nOHBadGJ3OWVEaDRRdWlMdTA3djJRV1MwQ2c0dlVqUkVPa3M5eW0vdE02Q1EwTWZuSWFqR3dtTHRQVE1QSkdhelI3TzJPdUhsdGk4bWs0dmhzU2M1empvOGRkKytlY2Z1WlBmYW1MWmRVNXJYeE5tL2VyL2t2Mzd0SDU4SUdkUzlmYjFDd3ZCQWo4T2x1M1hQT0xFNjZMRkZJK1NMNjdnQVRRenA1N3pzUC9zTXJ6L1NQdGk3Ti91VzZ0aitHVXJVeEpsZFZWakZFL0dyQTU4eElKWnJxUEY5dFRWKzNSaGZFV3RPdkZuei9yVzh5MlpsaWJJTldrcnppdlN2c01FZUluc0VOTktNUnBySXN6czU0NTg2N1BIallNYkNpcmpWMWJTVER1OUkwaldZOE04eW1tdEZZNXNpY1pTMlVraGdrR0NYRWlVM3NjVkxFMGdyWGxlWmc5N09NbXN0RTE1Y0UxeXlDbWhqUnhwQkNKRVdQTVpxWW8vaVN4Y0RSOFNGWHIxNWpQSnJSRFIwNkJ0eXc0djdSaHl6OUVsdEprRVJDMmx4bHhUczlMaHpVbHZIT2lIWm53dkZISjloeU1PbzFLeTZmZzV1NXRGaWhyQ3ByenBOelAya2RGSUZxVXZQTVR6ekxzMTk3aG1acTBJZ2tWSUlZUmNtbm8xaGFpUkpKRGtDclM3b3RpcWJPR0p2b08wV0tpcWp5eHZ3aVp4RzQ1S1RaVVltSlNReHJlckZYclBwRXYwb01YYVJiUldJVVFvM3ZJcDFQQkEyaEMvUXJ4OUJKQnR2WldjOHdoQ2RZY0xsZ0JQdTdJMTU1YnBlYjE3YVlUaHZtUzA5Yld5cWppZkdFNDVPZWp6NDQ1cFhYci9IcTNvaGJyZVZHZFVBTWliOXo1ejY5ait0ODVLd3k4d3hIVCsvUVA3V0ZmbmEwS3Q3Zk9tdlpmY2FpRWxMbDJkTEE0c0dkMC85eWZqbzgzTHN5KzZYUnRQNjVxako3SnRzc0tqT3RZZ2lFY3F3YkxiTjV1a0J5cjZ3cEdtbkY3LzdlcjJObk5kdlRmV0tLK09ESk9iTzdkNFg5L2N1TVp6TnV2ZmdDU212K3ExLzcyL3o5di8rckhCMDl4bzRxVHVMQW85TVRScE9HcmUwUjI5c3QwMW5OWkZvejNhNllibG5xUm1NcVJXdEYxamw0TWJsbzY3enBBbFFaR1Z6T1ZIYk0vdXlMY2hNYXMxR1pVZjQvV2VHN0pUbGxRb2prbUpoT3B6eDg5SkRWc09UU3BXdkVKRDdwVFRNaXBzalNyNEJFVlZmWVdtOGlsM01CaDlRUUNRbE1ZN2oxN0Q3VDNuSG44WXFxMkdESFhPaTlUKzNPQXlJMURZV2ZVUCtRdmF5eW1odGZ1TXJMWDN1R3lVNVY1TDRDckpuaXI1ZldVbDZ0U3VpaXpPRnJXcTB4bWFyS1RFeW1WZ3J2VlFsdFZNVUhRREhFY3Rna1VZVzVVakloUWIrTUxNNENmWCtPZnZjck1kVHNuWkJraHRWQXQzQmtIK2hYQS9NemQyNDFYUzZpVVd0NTRaa2RQdmZLQWMvZTNKWThnUzdJTmtjclR1YzlmUS9qU25QZGFtNlR1VGF4VEdhV3JkMktuK0V5UjUzbkgzejBpRXpPNVRXZEp3a2RmVHFuSTM4cUMzMnRKUm5OTkRsQnZ3d1pSU0ovVEk2clZxZjlOL3ZGY0xoM2RmYjl5WGI3aTZOUi9SbGpqU2JHaERYS05iVWF6Z0kyRm5SV3I3blNpYm95V0MyWlh0MXF6bi85bmQ4aTlKR2Rkc3gwc3Mxcm4va0NMM3ptTlY1NDhUVzJkL2ZvdXA3L3gvL3QzK2R2L1pmL01WV1R1UExjakhFelkzZFZzVGg1eEtQM1RqbHVLckxXdEUzTmVMdGx0ajFoOTJETTdxVXgxMjZPYVBkTlNXc1ZBRXdIQ1Rlb0RJd3FDWFhvUTJDcmZaM2R5YXRpUkptU3lHWFhrTDNXNUpSSUllSjdSM1NlMVdwTzA3UzhkK2NkVXZhTVIyTzhINFNOWlNxVXFSaFVSQmtsQ0xCUk10cFlDRU5DK1lTWlZMRDBtRW5Od2ZWdGZ2Skt3MXMvZU1TdmZ2dUkza1dzTG1CbVBtY2FibFpLUEJtb3Q3N1pMK2JYWDNwdWwxZC80amF6clJybHl4NWU1Zk1XWDYySk50Sys2eXlDUVl0c0xheUcxaVltdFJTN3JYUXh2RFRra2tzM2JQZ1NwWWlkZENJeHdtcVZXSzBpd3lyU08rR3dheTFrbWFFUHVENFNmS1JiT056Z2lENXljdXJvK3JDNXlhZmptbHZYcGp4L2U0ZlhYOXhqZDZzV1J5T2ZhR3lOVnA2MzNqM2lyWGVPU0Q3engxODY0S3UzOXJoa05Mc3p4ZTNudDdIaktVNDk0T2ZEVlZDWi8rTDBFVXBNK2J1WVB6R2hSWUhrOXAxMjd0TlY2R3ZPZGNya3FqYkt1dzB3Rnk3d1h4SXdTakYvOVBpanMvK29YdzV2VFhmSC85eDRVdjFFM2RwYktodlMxaWk3UngwaFpwWGl1ZHd2Umtub3JHdFpyYmpsd1BHamg5eTQvVEsvOFBPL3hQUFB2TUFMTDc3Q3BldlhhZHN4cStXS3YvazMvaXJmKy9Ddjh4Ty91TWYxbTd0TVpsYmlnUHlZbjFoV1BINjRJc1pNMTBkV0s0V0xpdFBUeEhTbXVISmQ4Y3l6bWVra1lWSW1lR2tuSlNLNXpPNVJVZGxFWGJmY3Z2SW5xTzBXSkxFZ0ZtTzVqRm9uSUJZN21CU0Q1S0ladzluOGxPOSsveHZzYk85czJrdXREVnBiRnJIanpNOGxuSEJORms4U2VhUmp4cDA0ekxSQ05aWktLOXgyeTE1Yjg1ZGZtdkQ4alFuL3lXODg0TDJIbmJUdDZqd3hNejBsVXVuTDV4cldpYUh5WjdPOWxwZC80aG11dnJTRHpwTFJGSXR6ZjJVTG1xY3pLckFCVHEyVnZiakpoVEdpaElzUW9wd2dhMktQQzlMU3B5Zzg4bGt0YkVOWE5QOHB3ekJrRnZOSTN5VmlGSDVGam9uY1JXSmx4Q1o4UHNoNnRuTUVGMWljZFp5Yzl1UU1rMUhGQzgvczhzTHRYVzdmbUxHNzA5QTJXdkNEU3JFenNUdzg2dm45N3o3Z2Q3LzlnR0dJZlBtRkEvN0VDNWM0YUN5RVJLVkhUR2N0cGpKY3YxNFRocFpmYW03aWcxWi84N3NQb2tyNVVSTFk0d242aHdKbGpGWktrUzlOR2g2VkhMNVBUYUVENk55ZzFQRDBtaUh3cEk5QkJPTGlaUGlkMVpsN2YrdGc5RitQcHZYUE5FMzFJN1l4Tit0cHBmUGNaVlFSZkJVQm1BOEo1ek8yVnpUQjh2Ti8vdWY1cFYvNU4vbk1LNTlqMUxSeUwyalJEcjc3MW5kNTg1Mi95VmYvdVYydVhwdENEbVRsS09HM1hESXpubjF4SnNWajFNWkx6RGxoMTF1anFFWVpwU1BaUVhTS3ZoY3dLYVdNRzZEemhzV1FlSEhuVmE1ZittS2g0RkxBcGJ5NXlkY29VMVhWcERyaWg1N3Q3VDIrKy8zdnMxaWNjZXZtTGJTUzY5ZUhnWmd5RDVlSExOMkt1aldiclVPTUNSZWthd29yVDA0SnU5V1FNdFN6aHUvUGwzemx3UExMWDczR1MxZW0vS2UvK1lCZmYvT1kwejQ4UVNtKytNWWt6ck93bS9KR3RXM0Z6VGV1YytQMVMyaFRVbFBKQkNWZGhTcmNWYVVwTGJ6bzhtMWh3c2w2VHc2dTNtbDh5SmhhWnZuZ1pmM1dKMDNRb3FFdnRoUDBTUTRGN3hMems4RHFUSkR6bUVDbFRPd0NlUWdrRy9HbkEzN2U0MEVFVVlOamRicWdVb2xCUWR0WWJsL2Y0dGxyVzB6R1ZzQmNZRFNTN2ZlMzNqcm03LzNPUGI3M2cyTzhUM3p1bVIyKyt1SUJsMGNXNnpKMlpLaGF6YU1ISjZ3V25xcUY2Y3pRbjJiKzNLdFhPVjRNK1hmdW5DekVoeUxiZkk1dDZnd3FwcVFHSDJucUt1OVBhZzZYN3ROVDZNdlR3SGlxY2FLSHptVW4rL1RhNGVMNkxhU1UvY25EMWNueVpQaDJPN0d2TkczMVNxdjRoUXBlUkcwVWc1di9pVkZXV3IvMHkzK0pmLzIvOSsveTdMUFBBMG9LU3RaM3pNL09lUFBOMytMYWJjLzFteTBxRGlXU1dSNCtsVEtwYUo1RFVLQ1NZQUlXUmhPTnRobHRKS28xSm9XUG1tVGtRRkJaYmxSckZTb21qS2w1N3ViUDBqYjdaTzgzM3dPcHRQRFdpRTllakhoWFduTnQ2UHVCZDk3L0FYdDcrOVMySnFNSVFUTEVsbjdCaDZjZkVJaU1iRlhVVTJLWDVHUEpTSy9GOU5JWVVZMFJNMGVkNWNONTVNV1o0UXZQYlhOelo4VCtiTVQvNjdmdTBmZCtBOGlscDFacjZ4VmNRdnpRcnQzYTVyblBYc1VFR0k0SGxGRWtyYkI3R21PRkpqdXFNclhKeEt5d1ZhSkNidmMxZFZqbHdwQ3p3aW9NUWFScjJXU2FrZXozVFJTYWE0b1pZNFNwYkxVdzZmcWhPTmlXbjFjQzZxUGNGQ0hoNWowK1JIb3ZBTjF5M3VQN3lNN1Uwcm5BMldMZzhLVGp1UnRiWkF6V0txWmp5L0hKaW05OTh5SHZ2VCtuSGdJLzk4b2xkaWNOVjNiSFhKODJqTEp3STNaMnhFcnErOS9yNkxwSTNWcXVYVGZVV3pCYWF2N0Z6MXhYZmNpamI5dzlWUkdoREt6Wng0aVNOZzhocGpOZ1hKdThQYTQ0WGZsL1lyVm0vckJ2ZE8rRWRtVU0yTnBJSW1iTWZFS3hQeEhGbkdMdVhSOGZkRXYzZGhXemI4ay9DbGlsWkdXdE5VcHJSUmZoeDMvcWEvejMveWYvSGkrKzhwb29CRk5ScnhsSlVlM21jKzdjK1IyMkx0K2hxUWNVb2p6U1JtWThvODdCSW1zejJsS1liZElOeUk2NjdPSFh4ZzdyRkJTMWRvN1RoQnk0ZmZXenZQSHl2MGdWeEF4TnI4MG9qUlJpTGlZVHlYdjYrWUp1dGNRWXc0Y2YzZUd0ZDc3RHBmMTlxcW9XazRqZ1NTRnkxSi93MXVGYkpCK3dsY0UwVmlhQmhTUDVSSzROcXJMb1NZV3BUQWtJaEtBVWFlbDVhU0xraGRwb09xZnBISngyanM3RkowSWZueWJLSkdDMlArWkxYM3VPSzlkbmhDR2lLdzJ0Z2NhUWF6RmlhSFJtVkNXUmJXcEZiVE5XSzNRQWt6UHRCR29ycTY5Y2xHckRJRnozdGZWVFNBb2Y1UGUxcGJKMzhwZm44OGpRSlh5ZjhJTWtxT1pDUGNacW5FOHN6M29HRjZUWWU4ZWord3RVeXN4bU5TRXFsbjFnTktwNDl1WTJzMUZONmoySEQ1ZDgrUFlwazZCNTlmS01WNjd2Y1B2U2xLdTdZL1luTmVPczBENHptV2dtRThYang0SFQweVFtR0NWbGRtOWZTL2FlcWZTTGx5YnQyUkIrOE9GcC83QklWZGUyVXFrMEtjVVVSR0cwWWxKVmRENStPbHAzTHJDcjZwSEY5ekdYRWZXVGJ2VTFYVFpjT0FuaklxUmZBMzZraForcFN5aXFVaW9QSWVldHJTMzFGLytWWDFFdmZlYXowaDZyNGtHajVGWlhnSGNEWm5SR3FwYmtMSHV5SEVBbkphMDk1Nzd0V2EySkVFa1ljZVU3REZtUmU0cVFaTTJRRUFmVHVoR2pERXppMlp0L2pMYWVvVUtXbmVCNlpWQ2NaSEtNRXFZUUlrYlhHQzFSQ085OThDNGhybWpiRnBRbTVZZ3hHcWNTUjh0RCtxR2pRaFA3Q0ZNUnRDaWZVRDdEeUZKTlRESGFrTEkxUm1FYnc2TlEwYXZJVklQTG1aUGx3SzM5TVQ1SGZ2T3R4N2lRbnBEL1hpeDYweGllL2R3VmJuenVNckVYSUZCdFYraXBQRlpaaVdiZlhqQ1RxSFFTRnB3QlUyZlI5TmNaNVRKcElUZjVrRFdyRmFSRlpMeXZ4WUlyNVkxNTVSQWhySkxrbXNXTVcwWHlFSEJEb0hONTQxbVh0U2E1eUdycEdXTEN1MERLbWFPakZZdVY1OUpNTTI0cmRuY3FUbnJIbzhNRmI3MzVnT05SUmVvaXRUWHM3SXlZVFEzYUM2MTJVSmxSclpob0JZTThQMXRiQmpka0Zndmhjd1NmYVJyRDZTcVJIOEtWeTBZOXVoL3lUZFhjL3BVZnVmV1h5Znh2Zi8yOW85OEd4am5uc05FSlpYTEtPZmN1WkYxYlpmUS9PYytaUHpLRm5oSWJ2WEI1Um5pcWxVOFhSRERwUXNHN0llTWovRzg2K00wS2ZyNUozQjdESkNhYUwzM2x5K3FMWC80S1ZwSXM1ZGJWNWtKK3VLTHI1NXprQnlTdm1CcE5ZNVBNajVzWVhDMHl5YzNPT1pmNXRZZy9rcmhicGdDcnBXSStGMTE3TTFOVWpmQ2RVWjdkMlI1WDkxNUhZeUY3aVhxS21SeGkyYkVvdExXRW9jT3RPcnozR0czNTRLTVB1WHYvSXk0ZlhMdmdNNmZ3T2VPSjNKdmZBekoyWExGT2kwaEZWVkY1djBsVk1URVRmSVNtUXBPcEswMGVWVHgya2YyWjRtaVJPWng3VXRaODVhVkxISjBOdkgzM0ZJT0VPR3dpY0V2YXdPV2JXN3p5WXpmQWFQUVlSbE5McmdRVGFHdVp3ZHNTYUtHMENJTHJFbkxSMWhKeExVUVdSVjVBbWd1TmRhZ1VRU3R5QzMwVW02WlVDamduV1pjdFR6eCtFRzhwazlMR2FET3Y1Y3N1aXBQTWZHQjV1aElBTGtZV0s4L3hVVTlNY0xwS0xCK3QwRmF6M3lvdTI4UndzdVNzYjJqUVRHZVdOb2pLVFJlTnc3VFJiRldLdkV4a241aHNXWEtHbzVOSXlrbzZNcFRRN3pQTWw0a1FZV2RxMUwwdTZHbHRYL3ZsTDk3OHkyZEQrRjk4L2U3cG0wcXBTYzQ1WFJBRlpvQ1ZpMm4xVDlCRDhvOU1vUU9zNW43RFNBS3dZdmFTVTNyaUl0R2ZjTVBIQU85R2VEQmsvdjR5OC9KcHlzK1BqUG1STDMvdEo3OTQvZWJOcVZneXlTQW84N3VCSEFraE1WL2N3elNIWURUZVMxRlRadkMxUjFvdXBoUXhRVks2K05hcFRRK2JZaUZzQkkwdjhzU2NZT2pCQlVPSUhiY3ZQOGVrdmNvbWdTRG5Jb29SU2pEZW9URFlxa2F6WXJrNFliazQ0enR2ZnAzVjZwaExCODhMb3k5RmxOWVlwVGxjUHViSW5hS01SUmt0ZSttYzBWcWpKeFZWclVpVklmZ3lzclJXQ2tHMmVEaWplZUFVbndFV1ErUnM1Y202NHRKc3hNOTg3aHJIUzhmRGsyN3pvS3hick1tazVwVWZ2Y1gyelIyVWdkRkkwazFUbGpaOGJDa2NCOEZJVXBmSnJkb0U3dVVzZ0Z3TWloamtwbmExSWhtRlRlQjlKbFhGT2RjbHZJZFZpS0p1NnlRd0lTZXgvblUraWJWWUVNdXQ1Q1A5MHJNODZYQXJSNzhhQ0VHTVNoNC9XaFNyWmxnNXdBY2FCWmVxb283TFFyT3RLOFB1cUdLM3RoejFBV00xTzlPSy9iRWhMeE5kbnpqWU5yUWp6ZU5EejZyUHRMVW1heVdkVGExb3RHZ0FPcGV3eW1DdFZwbWM5NDM5ekYvNDNQVi84N1QzLyt2M2psWWZhcVZTMnNUTkN0bngzRHIwbjh5Ty9ZOVVvVjlzNDh0b3Rna0VOMWJ3cXFkYStpYzR3MWx5cHg4cnBmcVE4NXRmKzVOLzh2NVAvOEl2M2h4TnBsTXhXWFRGQ2lxaDZnWlNadWg2VGs1K3dOYm9ERk9uY3JJSXFCYUNLc2p3dWJWd1NrSngyaHc3RVpMTGVGYzQyVG5UMXFLc2FtMHVBcGJFa0RUN1c2OWlkU3Zwckdnd1d0cnBLSVVyckpWRTZBZGl6R3h0N1hKeWVzUzMzL3hkUm8waXhsN01hbTFEaWdrZlBQZk83ckVhT2lwVEZ6QlBiNWhvcXRIRXRpR3ROd1hXaUZ4V0YxV1loUlFVUThtYm4zZUJia2hzYjJuNkVIbjI4b3czbnR2amIzLzdQdHFWVkZBbEQvTE4xeTV6NC9QWGlBcXFScllYNjZTVXhnaFFrVkc0WHFGRFpLSXlvN0ZpVkNVeW9pZDNYbER6RE5oR3JKT3pVNWlZcWFKa2pZY0F5eDdPMWpONFRCdHRlUXh5cXhJa2djVUhTWnZwRjU3RmFVOC9Id2lESS9oQXpKbkR3eVducCs1SjYrdTE1M3FFYm9pMGcyZDdQT0xhenBoTFd5TmNTS0pLZElIN0gvWDRVY1dzYlJpUEZmWFljSGdhY2Iwa3YwQW1aUEdJcTVMd0FMb2lFRm9GK2JQS0tsMVZTcjE4ZWZJVC84WlhiZy8vd1crOC83KzdjN1Q2UUNrMXZpRGRYdS8xSTlJMVpvRC96cDk0anRwby92ZS85b00vK0hhTFA2SWZPWU1mNUtaY2Y4cldDbVBVMDBpOEsrdmRIdWlWVW4zTzJSdGpxdi9Xci93ckx6Mzd6SzBEaGg3NlZkNTg0VFdnWkMycnhRbUw0UzJVRHFRb3F4UmpFTUtHeWNVRFRHUnhNcEtMdTZpUFdnd1dGZWk2T0VXWGs3TXlhK05JaVJ1cUc4L0I5aTdYOWorRDBUVnJiN0VjWXRtZHl6L25FRWtoRkQrM1RGVzNuTTBINm5yQzd0NEIxalpZVzVOSVpBVzk2M204UE1JWVE5T0lJaXhwUlZScTR3SVRRdWFpMDhUYXIxNlRxYlh3d2hkTzBmV0tzMlZrT1FTczBtaWxDU254RTY5ZTVxVWIyN2ppYmtyT1RIZEd2UEJqdDZnYlE2c3pvekxPR0NXaytSQ2t5RzNJNkZPUFhVVnN5cWd1bFFncnNZS3lOaGRmdFFLMnBVSitRVkdnRWdhWE9Ea05MTThDcXo3aW5YZ1J4SmlMMzFzaU9MR0d5akhqK2tpM2NuU0xubUhWTS9RT0h4T25aejFIUjkyYWN2MEVVOFVpMWxyV2FDWnR6WFBYdDdsNVpZTExpYmtQQkJlNGQyL085OTk5ek85Ky95SGQ0TGwrMExCWUJ1YkxRRlVwbWxZWGwxbUtSRldZaVpORzNvdk9KVnlRUThBWXJTYTFhbDdhbS96VWYvdkhiLy9yeit5TmIrU2NHM1hPTks0QVE4NWFCaGRVVzJrcXJZWGEvV201MFQvcEl3YlFSaTVUcXlBSnRNWUY2cXdIbkZJcTVKejdWMTkrZWZUYWE2ODlQNm1xV1FvaGEydFZUbWt6L09jVVNTbHhmUG9oVHQwcDVvWEN4VVpKVzE2VVIwV01VdmJBV3RKQVlxQTRqRXB3UUxZWlBZR0d2Q0djYkxLNUNJeEdONWkydDFGeHZUWVFpV3VPb1NTM0ZEVFpCNUozYUtWWUxwYTgvYzUzbU0xbVhMNTBFMk1yMlorajhONXhNcHh5T3N4cFJqVzIxaVhNUUlwWGxyUWxrUVFKUHNoYTFsRUtoVEt5aDY4bUZhMTNLQ0xIeTBpS01LbzBpb3dQc0RXcStOblhybkRuY01uUllrRFZsaGUrZEpNcnQ3ZHBhNWlNZE1tZWsxOWFaeG9MOWZxZ3JOYUJHaG5YYS9RQWJTMWVicXFrcmFRSVE1VEFDS1BFMmpsazhGclIrMGczZDBLWUtXNlIyY3RJa0F2bWtFdVJleGRZbFptOG02OEl6b3Q3NnhCNDlHajFpZW8walRnUlRTckZ0SzNZbVk3WW16VzRuQ1duUFdTR1ZTQUYyZFNjRFk2Mzc1OHliUzBxUzRpaU1XcHpzSXVudTBZbDBUWlVHbm95ZzB2VVpiU3lsY0pubFd2TCtKV0Q2Wi8rNVMvZWZQaC8rWTMzLzhyajVYQXhuRFpmMEJjbGhlSzBjMVNpNnZuMDNPaWZ1SW9iTWx0R01iT3lGcXVzVFU4eE0xTktLUUhwTC95RlAzL3owdlVidDJYSTF1ZTNlRTZTcjZZMHczTEZSL2QvZzF3L0pDZExGUDl0bVJsem1jdlgxTTNpbXJwcFVhdE1XMmRHZGNhYXhIcnN0NVh3dWl0YlFnR04vUG5PN0Ztc2JVbkJFVmNkY2JGZ2ZjVm1yVGN6ZS9JZVAzaHlUQndmSDNKNmVzeHNPaGJHbTdhZ0RENTRmUFI4Y0hLSEdCMVdTK0ZxTGVRVVhSSVZVMEgrbFJGVERLdWdLVzQ2MnFveTB5dkdWZzZIK1RKUVY1YnhxTjRrcmc0K01XMHRyMTJaVVZ2TDN0VVpMLy9vZFNZanhhaVZmMStsakY1YlFidEVOVVRHT2pFYVphWXpxRnRGcWpYMU50UzE3THA5TDYrdEgyQllpUUl0UmpDc0UwcWxtMXN0QXQwcXlyeS9SbWR6c1c1ZVcxZUhKSWo3ZkdCNTJyRThXZUlISVp5RUdEazg3T2k2OERGVENWVklQek9qbUUwcVp1T1d5bGFjTGozRVRGV2NmSTNXakl4aFZGbU0xYng5LzVqZmVQTWh2WXRNUnJKelR4bDg2YkZUU3JoMXhISnhuazBKVmw3Y2U1eFArSmpWRUpQS0lXKy91RFAreFQvN21hdC9hbExiU1pZa3E5R2FmSmh6TmtvcDdXUGlIN3g3eFAvMU4zNlVmL08vK1M5L2VtLzBwenY3UC82bEwvQzlkKytvaDBmSFdWcW10T0YwV0dQdFQzN2xLeTljM3QrL1FsMmh0VmJyVUFZSlVGUWtwWG4wOEM0bnkyOVQ3Umw4MGlpVk1JZytXNlNSRkhCbGt6Tnhib1NvaXdDanlMMjBVc1NrV1hjWkdWVXNveExXakxpMDlUbU1hc2g1ZlpQTHFpdDdYM3pxTWpra1lraTRvV2ZvQno3NDhIMVM5dFIyVEl4QlhHdTF4WHZQMlhER3ZlVjltYmtMMHF3THk0OG92S3VFYU9XcnVnQkVrajZOMGhJd2FDcEZXQ1hxSk43dTh5NHlhaXRCNDlkRUN5TzM2ak43RS9vSTVuTlhtTzZOU0NYV3FNNlo1QlBSaWxYeXNFeFlrNWh1YVpSV3hHMk5pbUlZVVRVWm5UTUI4ZFNMU1RFRXNjUmVaOHJud2ttSVRqTFQ1a2VlYmhWcHJaYjNwakFTVTNHNEZESlR3aTBkL1dMQUxYdVNEd1ZBVFJ3ZGRaek4vU2M2eDFUQVZNT2sxVXpHTFZ2VGxtdTdJL2FtRFRvbUZxZU9FRE8yTmxRK01XdHJnczRNT1hGdnZtRG5VYzNPYkkreE1yaVE1SFdWaUdTR2tNVUNQSmVRVGEzb1hhUnhZazhlbzloUWszUGVhdXpOSDd1NTg2K3VmRnorZjc1eDkrK0VtSjdZTkNVWjN2UGJqNWQ1Yi9kdjU3Yjk4NS8rUWo4cTdkZC8vYzN2aW1Qcms3NlFHdUFuZnZ6TEI5ZXVYWDNWV2oxZWw2aXlSbUQ4a3BLYVl1U0RENzdPb081aGtoWHZiU1ZGdXlaa3hNZ0dFWmJnQ0lYT3hURkdDWFptNnZQZGNsV0FKdWVMTmJ6V0pBWjJSN2VaVFo0bk9VOVlMV21uMnlTYlNUNXNpRGVFUU9wN1hOOFJRbUMrblBQK0IrOXNQTkNWMG1odDhORmpqZVh4OGhGZDZyQ2pHbDJib2dZRWRhR05YSGNqS1dac0VrcXF5ekJyNWVhUEtWT0Z5TDdLSEM4aVo4dkF1RGJGYlRWdjVMWFNLbVZldmJiRjhZRVVlWFFKVzFuWmtSdXdWb0lWOHRTZ0cwMVNJbHh4U1dHdHZHWkREMWhOTmdKK3hTTGJUUnJ3bVZ4SjJ5NUFIU3dXaWE0WFhvRWZvakRpbEZoSlJaZElMb3JCWXgvb0ZnT3IrYXJjNU9JcGNISTZjSHppUGphWHIxdlpHaGdieGU2czRka3JPOXpZbXpKdUxZM1ZyT2FlWVlnYi8zcGJLVWJHa28wbUtGZ3NPdDY2ZjBKVEd6NXpZMmNqajk1Y0JNVjFKNFJ5T1NnWU54cUZvdXNraUdRZDZwQkN5Z2ZqNnZtZmVuSC92K3RpZFAvUk4rNzlWeGU2VkltaGx3Vk44czZwNzMvdmU3eHdNTXMvZUR6L2RMYnVUMXpwTWE2bkdKVlNXaGU1QWV5LzhHZis5QXNIbHc1ZUprTU9RWHB0VTExSThiUXNUK2JjZmZ3TjdOaUxaWEZaRUsvUDBuVlNaeXA4YStmRnlzaVhCRlZkeVR2cnZDSjRKV3dvQkpTU2JFU2hZc1lZMlJxL1RGM3RnUS9rR0lsOVQzZDh5SEIyUXZTZU5QUms3L0I5VDdjU3g1c1A3MzdBMGRralJ1TVJUVHRGbTRvWVMycUwwanp1am9oWllwV3RQWC9JS2lPM2R5cHRycmF5Q3ZTRHZGNmhtRXpJNFFGTmdqR1pSM1BQNEROYm94cHJWT0hLaXllNmNIb01KbWJ5ZXllb2hVTUJkWkd1YWF1b0tzRUJiS1ZRMVhrRWxjcFFHeW42cUlTQUpGOFhjaWpZaEJId2JRaUtibERNbDVtelpXYlZKVkxKU2t0REpBNlJIQkxlUlh4ZkNuenBXWjExekU4V3JPYWRxTkpTNHZSczRQQjR3SDlDRHZIR2E5NXFucmt5NWZNdlhPV0ZhOXZNSmhWMWJaaldoa2x0eEdJY0NENWhqUUJoSTZQWnFXdkdWVTNYRFh6My9jZjg0T0dDVkZKVCswSGtzVEZsa2NxR0pGSnBwUmhaTFd2QmZHNittVkxHKzZ4U3pQbjZWdlBTVDc5MDZWLzc2WmN2dmM1NUMxK1hYemFEV3E0Ni90N2YvdzIwVnJ4OFpmcXBiOTBKSWF4enNrb1Nqekk1WjcyM3N6UDY3T2UvK05MdTNzRlZ5aDQzcStMZW50ZG5mZUwrdlhkWjhBUDJ4cWFBNE9MRHJndmdKakhDeFdPOEZIdUtKY1RQaTVXVXJvdDNPTkoycGd2dHZsaElSV3cyYkkxdlkySUZ5ZFBPZHNsT0hHRXlpZVI3TVpUd25wT2pSNnhXQXpIQiszZmVBUkt6NlRaR1YzanhKa0pyUStjV0hIWEg4dENXbEJDbHdCcmhYWWNTUXdURkRidmM4TFVSc0VqODFDUldha0xHaE15anMwQmxEWk94RmZTNElQOUtLUVlYUzVLenduMTBSdjNlS1h6aGdOcUtMOXRRc3RuV3UwOFNHRnVJTW1adG9pbmE4YlVxUmljRVdVZkdqaGhrblJrOHJGWlo1S1pkSURtSnhqRWxpejU0V2FQRkpBRFhhdDZ6UEZuUUxUdGlqR2lsV013ZGo0OEdodUdIVzBQdE5KWTNudG5oamVmMzJkOGVDVlBRS0JvdHhkeHVONmdJaDNQSnZ4UEt0R0EwVlRMTW1ocmZPUmFyZ1RjL2VFeFZHeTV0dFJ2Vm9ZQnhZbEJhVlVLbWNrNWNjZGFpS1BHbGx4SE9KakdKdnJIYnZ2RlRMeDM4OGtjbjNhUHZQVnpjdlFET2xjWXE1eTZTVHpySHdhVEtuL3BDdjNBNHk4SklLWjF6Vmk4OS8veHNaMi8vZGowYTE4bjc4OWE0eEdVb3E0bUQ1NE1IdjRmYU9pTnBTNHdaWFpJU1ZRSzdTWDZVTjlZZ3JvbXhLK1NZREgxcFdiRXkwNmRheVMxZjNoVWROUWxIYXcrWXRjL0FFRkRHa1B5QU1aWjZNZ09sU0g0UVNtdm9XUzBYK0pBNVBEcmh3YU43Yk85T3FhdEc0b0JpeE5pS3l0WjhkUG9CWFZoU29kQWxHUlN6M2dtWG90KzhRRktzcVRKa3JhbTFKQ3o2WHFKRGRxTmtoNS8xbWZISVVsZDY4M0pwSTBrdkxvalBQZ3BKSmZsb2pybytJZXpNME1YS0drU3cwbFNDV3dTbE5zNnVxWmc1dGphaFZTWU4wcmJyc1h6UHNTU3pwQXUzWEJnU2JoV0lnK2pLczBua3FCbTZzRWxhNmM1NkZpZEx1bVZQS2xrQVhSYzRQUDU0a2ErVnYwWXBudDBiODJPMzkzamg2b3hKWTB0YmJiQW9SRmFXb1ZMczdkWmtCYWVya2pDcklIU1pXUGdLazBsTG53SVBUeGQ4KzEzTlo1Ni96TFh0VnVLWWxPQU94cXFpbHhmV2x5NE13WmdnK1ZTc3ZZV2hxUlMwalZJdkhFeCsrbWRmdVh6M3VQTi81ZUY4eUJjNDhaSU5tWEk4V2JrY1UxS2p5dVIvSEQ3OFArdUYvckV4NVByVks2MGk3eWZ2U0NGbTNUUnF6YkhOS1VMV0hEOTZ5S0g3T3BOOWFZUFJRcTlNVWNRSU1aK0gvU2tGeW1ac3RXYnh5TTJra01pakdPVU55aDVpRGFxVmF6UWs4Q0d3UDczTnBMMkJEb3FjUTlGNUo1THpBckRsQ01xaU1JekdXL1FuSjN4MDl3N2F3TlpzU3lTc0pWa3l4b0RYZ1kvTzdoS3o3THN4SmYrOENHY2dGNWNkV2RjNW4wWGFhVVFmTGxsMG1ieVNNSVM5RUpuM2tlV1FhS3pNNXhmOVQ5Ym90dFdhbUtXRlRVTkVmLytZeFY3RFpLK21wU1RlWk5BaGsxeWlUK0FNSW13eDUvdHFheUZZUmU4MGxTdDRSeXJPdUttc0xZZFUvTmJMZXJKRWJ4bkVJU1lzSFYzbm1SOHZHQllkS2lXTTBheFduc2RIQS8yRklyL29WTnRZelJ1M2R2bnlDL3NjekZyd3dvS2IxWmEydE9naGdhNUVWTkswaGh0WFd1eXg1bmpoVVFrcXBTUzZHNmpibXJGdldBMEQ5MC9tdEI5VjdFK3ZNQnRWS0NVbUl6STZpSHB4emVzTVVRcGVXaDNCTjhybmxjM2tVYVduWDdpMi9jdUhDL2ZoWC8zV3ZiL2UrZmowZGltSG1QTEp5dWZXNm4vODR2Z1VmS2ljUlc3eXBUZmUyRC9ZMnJva2lOZzZObFJraXpsR2NzcmNlL0EyZzdtUHpwTDVaYXpNbWFxU2dJWmNXclNrNVY5RktmUllVZStDbmdxOUVTTmViQ1g3VC9LN2x4QVhhNU9ZU0dNYnJ1eCtnZGJzRmpHTnd0aWFIQUpLYWRMUUVaeVlFdnJCZ2RMMFE4L3gyU0dUU1V2YnRPZmgyUmhJa2RQdWtMdUx1M0lBV0lsRUVpNjdXaWM5RjlmWExFNHVpUHZwK3N1c1k1TWRNQjBDZXlseHRFaTRtR2lLM2RNNnRTWkhRYmNISHpGYXljTlp6Qkwxb3hYNXpTT2hDMXRGM1VKRllqaUp1Tk5FT0kwTWg0bmN5UUdweXlZalJVbWFYU1hOY2EvcG5Eam54dEsyUjVla3dBdGQyWlRWb1BOQ1Z3NGgwUStCeGNtQzdtUkI3Q1gwWXI1d1BEN3M2YnI0QkdsMFRSVzZ0dDN5MDUrNXlrOTk5aHFYZHNia2xCazNocjFwaGMyWjRFc1lSMW5aaWNBdk01b1k5cmNzZFZIOHRaVmhYRmthclduYWl0bHNUTnMyb0RVZkhaL3g1a2NuZEVGQ1FUcVhpak11MkZxanJXQW5LY3RsVVZXS3V0TFlXaE9EWUJMRGtGU0ttVWx0OXI1MGMrY3Z2WEZqK3dXZ1ZrcTFGOGcwZHQwY0RER3B0UnJ4MDM2anEySmFrQUMxdjdPelp5SmI4OE01TVhpVU5sUjFpeXA3bTNvS3dRVU9Ud09MM2xEWG1hYVdtZHBXdVVUeUtqWjV6aVdqU3lGL2gzRnAzNE1TTUduSUpLODJQdDZxQUdNeGVMYkd0N204OHdWTXNxVGt4UEpwRFlVYkE5cGlqYmpSbnA2ZWNEWS80KzY5ajVndlQ5bmJrOXM4eHNoeWRZSzFOZFBSRm0vZmY1ZWxFK25xV3FVbDNZZk13ckVrdmFxeWI4NUp3Q0JkQ2ppcnd2TExjQ05FYk13OFhvcFNhOVJVbTFFbkZhbG4xdEM1d0tUV3N0WXFMTTJVTXZIT25PNzViZXFYSnBncVVpY1lTcXkxTVZMY1ZoVy9leVZwS2hteGVHNXNvbmZ5ZmZqU0RRd09GcXRFNXhJeFNoZVdmSlJ1TENTQ0N3eWRaM0c2WkhXeUlBd0RJVWE2VHRoejNpZGhHVDdWc3I5NmRZcy85dUlsbnIwOHdRQ3BqMHdhdzZRMWVKOFlCaW5NY2FPcHJNUnpLU1U4Z1pneVRXdTRkdEJ3LzlCeGxxSTR3eW9ZeU5SdHhUaTM2TnJTTzhkYkQ0NlpqQ3l2WDl2R0tLaHJDYlpNNWRnUmNGTVY0cGE4SG5tRGg0Q1R1VjA1RjlOdVU3L3kweTllL3N0SEsvKy8vTjdEK1FkS0ZZbEZPYStMMFdMK3BFejNUMk9oNXd2cUgvLytuYnZINzc3M1lYZjFTc0M3SVZ0clZWdVBOckxSeWFMbnl0WTFyTC9LdlpQM2FFY1ZkUU4xSmNiODFtYXF3dXlxekhxVkprQmRwbHlzWktJUkFZYXVaVTVXcWZETGpVUXVCUmU1dlAxRnRwdmJ4TlZBaWdHZlpENVhLak0vZklqT21YWTB4ZmNEeHlkSHZIUG5mZDU2Kzd0b214bU5wa0lhS2VtZmJXTkpPWEwzOUo0OGlFYU1JUlhTK2xJYWw0SUZDUWlYU2h2Zm1NMStYMlZ4ZnpFK2NwQWlwMzFpdm9xTVNscnRPbFBOdTFTby9HTDBvSlhpckhmRnFrcWpMZmlsSjN6N2tIQ3RZYkNhcVZiVWpTSTVFYXdZTFlBYlNZUXVWaFg1TEZDckpQMUdnajRydWdFV2k4aHFHWWw5UWtYaHNZdERyS3poQ0JtMzZPbU81MFRuQ1RGeWR1YVp6OFYwNHFLTUZtRFNHRDUzYzRjdnYzU0ovV21EVmpLRGp5ZVNGYWRUeG9lRVhlZjVhUUZXbFpKMW1tMDB6aVhxVnJOVFZ5UUZ3NFBFU250eHI0MFJheTNqcGtZYllTWU9nK2ZiSHg1VGE4T3IxMmZVdGV4ckJ5Y2dJbXQxWGM2WVNneEFjcEsxcUNyK2RqNWtvczg2NXB4ZXZEVDV5cys5ZXVuUEhhNkcvL1BoMHVleXExamIxUmV6bG8yMTVROEY1OHcvNDFmNWV2d3dTaWtMbVBjK3VPTmVlUGE1Nnp0Ylc1L1ZTcUNQRUlYdUtzSDNnWjNaTmlvcHZ2N203NUN6UmpWRzNHT2llSmE1QUwyVGNBQzN6amIzaW41UWRKMWlHRFJ1elo3YkxGQUZwVmRHNDVOak1yck9xN2QraVptNmh1K1h4S0duVzh4bDkyd3IvR0lodnp2SGNybGd1ZXA0Lzg0NzNMbjdEcGNPOXBsTmRnU3NpNG5LVm96YUNRL25EL251dys5SXlJTVcxMWxkdEo3YWltNDdaV0dlYVFTRmx3ZFFBQjg3QkxKTE9LVzUxbmxlVjRsN0o1NUhwNEhLYWtsbGlWa09ycktxVzdySTQzblAxcmpoZEFoWXJSZzNsZWlFUThMMmtYcTNSUjIweFo5ZERnWmxOYW5WeEZxVEFqUmFIdkNGVjV2SE1TcUZTN0l6Nzg4QzNUemdRMmJvQW42SVlnbkZlVFo1OUludVpNRnlMbHlEazVPQitUeEpvVHloQm9GcjJ3MWZmdjZBcjd4NGlaMnBDSHVhRExQS1VDa0I1WFI1WFpyaTJXK01vbTRNdTd1R3lkVEl6VzJWUkQzNVhBQTJ6ZUJsdEhCQktOVlZaVEJLeTR3Zkk3MXpuUFdCNmFoaGUxSVZoMWxSRElZb3UzVmpaRVlQc1VpSzE5eU5rUEUrYnd5QlFkbkx1Nk5uNTMxNC80UGo3azZVRVRVK3RXZi9SNkx2LzJ3WCtnYXBLc2c3MkxQRndwMmRuWnhkMnQ5L2JuZDM5NW9QQWEydDBrWkxzU2N4THJ5eWY1VVBUOS9oY1g4ZlkydGlhWjNXS1NBNWlkRENCVVh2NWRlcVU4eVhzUElhNXhUQnliNDRlRWxtOGQ3STNqUmxucnY2TXp3ei9lUDQ0eVU1QmtMd2tCTkdHL3F1d3p2UlI2OVdIZDRIRG84ZTg0MXYvUzVLUjY1ZHZZbFNoaGlESU8xVlN3aUJOeDkraDhQaGNRRnl5bG9nSmt4dFVFWnZBZ0x6T2hIR0ZrKzhXT1oxTHplWXpwblArc0IyenR3NTlMZ28rWFNWWHZQLzVOL1ZSbk95Y2h3dEJxWnR6ZkhTTVdvczQ4YUlzQ1NMSlhPVkZjTnVTejJ4d2tteWlteVYrTDVaMFFKVVZzaElLU3RpMU1RSUxtbDVZb01FTHZSZEpBMFI1ektoekxZeFpYd2ZpK1RYTXl3SFhEZlE5WTZUczBBTVQ2YkhXSzE0OGRLVW4zcjlHcTljMzJGY1M2QmlyUlFqclVrKzB4ZlNWVlZwYktYV2ZUQnRyUm1OTmJaV3VDUmNmNjBWZlpkWnJoSjlLR05kMFE4a28rbEN4Tml5YzAvU2pDdWw2V05rMFVVbVZVVmxKSnN0UkhuOUFYektMRnpFeDFTY2NRdStrdVNhWGljR0swV3VqQjdmUGhpL2VIL2VmK3ZlNlhCWVdwYjRDUXJPVDEraEN4S3QxRk1jQ0EzWSt3OGZIajArZkhSbk5oN2YzdDdldm1LTUpjUWd1cjhVNmJvVmJUVm1PaHZ6L2J2ZkVoMXpvYi9KZkNzelZZam5lYmJKaTI5Y05xSmVpMEV4TEJPckZTSlJIV0RvQTk0bG5ybjg0M3oreGwrZzhoTXlDV05sTm0rYU1Ta0V3akNndFM0Mk9wcmxhc1VQM24ySGIzL3ZkN2w2OVJMajBaUVlCYUUzcGlMbnpLUFRlM3puOGZjWndpRFJ2RnBrblVaTFFXNXM0Zk1GL2VYYW1xbFkzbWlnaTNBcEpONndpVVVYdVg4a2FTSzFWcWppdDZaTjBWVUR4MHNuOUU1ak9GejBUTnFhdWhBL0VwbHhiYkV1Y1JZem8yc1Q2UXEwc0FLTktja3Nxc2gxbzhaa01mUndTUkdpS2tZU21jT3ppT3NUMnFkekE1S2NjWVVSUjg1MG5XZFlEZlNybnI3M0xCZm5hUzBLR0ZuTmE5ZTIrTW5YcjNKcmYwSnRGQWJGeUJwR1ZwTjlwaCtpS0tQSzN0d3FFWjVNUnBhNmxnT3VkeGtmTXRZWXRDbk9QTGxRbzVWaTNCckJXclFjQ0tIby8wZE5SVjNZU3drNFczYTRtTG04UFpKTU9TL1lneTB1eGRiSTRTcHp2QmlHYUswM3FjSFdLS3BLSkZKTmJXYVRwakp2UHBqL2R1Y1Q2aWtVL2xON284K21VNHd4eW50L01jSjdQYlRiZXc4ZlBuN24zUi84WURKcWRrZHRmVDJtV0lYZ1ZDalMwSmdTejF4K2pwUDVNZS9kL3o2Vk5nVmxWa1Y1cGpZcmlad2s1QytpTjd6MnpWNDF5TVBqazJKMzZ3WmZlUEhuK2Z6dGY0RngyaWVIaU5hYTFmSk1DaU5HdXRVQ2ErdEMrTEYwWGNkSDl6N2kxMy9qVndscHliV3JWN0dtb2FwR2hRZ2pSaGh2SGI3Tm5iTVBSZmU4bmlrcmc2M05lZkpvZ2RYRms2aUFQMUhZZmVLMktyUDNqNmpJalJvZW5BYk9WbUowU2JtdGxCVzllaTZjOHJ2SFM3UTJrT0ZvMVROdGE5cEtpUFFwWmVyYVNOeHhIekZYeDFSamdYMTBLZkRXaXBvdEppVzNieTQ3OVBXMndzTnltZWxXRVJQVFprYWxqQ0NoS05ORUNPTlp6VHY2VGd3WVYxM2VBRzViclJCZ3Z2cnlaUzV2dGFpVXFiV21OWnJhS2t3R3lxcFFhVUc3UjYxbTNJcEtLUUwxeUREYmFwbE9MYk9aWVcrbllUSnVzVnFFS1NUWmoydWptVTNFd0NPbVRPOGlLeGV3UnRNWUl3ZHUrYlBqWlk5S2l0MUpTd2pyN1ljdUtqZkZlR3hwUnFidzl6bVhNQ2NFR015YnhHcTkxZGdiT2VYVk8wZkxONFAwKzVHUFo3aDl1Z3E5YlJyNm9VY3ByYlRXRitXcWE3QmNINTJkSFg3ck85LzZacmM4cm1KdzE3ejNJKytkaWlteldNNEpMdkQ4amRkNCs2TjMrUERSUFZRMklqMmxNTjY4T0kzbUlwK1VHWGlkaTVaUTJqQ2VidlBxYzEvaGo3M3l6L05qTC80aXQyYWZKNTBGd3VDSUlkQjNIZFpZWVVBVkpGeStiOFV3T0k2UEQva0h2L1hydkhQblRXN2R2RXB0RzVTcHBRdEFVVlVOYzdmZ213Kyt6WkI2ek5vU3E4Z2pWWEc2WGFmNHJiMDZvaytzbzhyWDdVNUVzVGNFM3Fpa2xmL2dvY2Y1TlJpbDBWWlE1dlY2cVhlSnU4Y3Iya3BJSloxUFRFWVYwOXJpZzRCMWs4Wml0V2F4Y09SWnhlaktpTlptYWdPTmxVSUhjZXpNR1hxdkNHbWRreVlzT0Rja1ZNZ01YV0lvYmZWNk81R0NGSHB3YTUxNXh6QU1MSmFCWVpCTzVOS2s1Z3MzZHZpUjV3ODQyQjJoY3NZbXhVaHA2aldmb09qQlhVellXck05cTdCVzRXT21kd2x0RkUxclN4cE1vT3NpODlPQjA1T080Q09tRm9TKzd5TFdLcmEyTFpPeGtYU1lJZUZDS3U0NlJyb2NLM3Ird1ljaUw3V01Lc3VvTm9WK0xEUDZlS0taVGcwcGdSdmtrRXM1Uyt4WGF6WXF3aHlWeW9ubXVZUEpDMmMrdnYzTzQrVkhTaW4xQ2NYKzZTcjB3VG0rOFBwbjJKcE5lWHgwdEY0eFhQeEJrMUpLZGM1M2I3N3ovamZ2Zi9pRG8rWFowYVhqeC9kbmp4N2VzeWZIaHp3OGZLd2EwL0Q4dGRmNXpsdHY4OEc5Qnd4ZVFKWVVwZGo3UVI3RTRETTVDaDB6UnNYZTdDYWZ2ZjBUZlBIbXovTFp5MTlqSjE5bWRiamk5T2lJMVhKQlNoSG5IU2ttYk5WUTF5M2VPNFp1eGVBRzVvc3pscXNsYjM3L08vejZQL2hWOWc5bTdPL3VnVExTcnFlSTFwTFhldWZrRHUrY3ZBK3FzTkNLWmJNdUQweEs1NjQ4WXNLb05pdWk5WFdRaXFydEZTTFh0UGlsUFR3TjZKSURWeFZHM0hxRlpvM2haT2w0ZE5venFpMnJ3Wk9BdHJhTWEwdnZvL0RGUjhJalBCc0M2V0JNdFQraXF0VG0wZFBGQ0FNRnpzRmlXUlJyV2JIcU04dFZ4QStSdm85NEwwNDR4a2lRWGd4cmM0bEkzM242UlU4L1g5SjNqck96U0tNMXorMjJ2SEY3bjlkdTdiSy8wd29BbVJTMWdrb1Z0NTBTL2tDU24zVm55ektxTlYwdmZtNmpWdFBVV2hTSVVicUx2a3NNWHY1K1hlbXlQdFhVamFadERVMnJxV3VGZDVtVFUwL0tlYU1mV04vOFdZbVNiYkhxT0Y0TmJJMGFydTYxVkdJS1FGVVg4OUZDdmZaT2ZsNXRGRzFyeExJN1VrdzJNaXBrbEZHanZlMW0rdmJENWUrZDliNVhUL29vL3RDYi9aOXBNTzVQZmUxUE1tcEg2cTEzMzNtYUg3SCs1N1ErOVI2ZEx0OTk3ODc3MzcxLzc0NitkK2VkZ3cvZS9kNzR6cnZmVTI5KzUrdU1xaEdmZS9GTExCNFB6Qi8zckU0ZHh5Y0x1aTdpUEhRdTBnM2lWM1p0OXdWKzVLV2Y1YXV2L0hsdXp6NVAvOGh4K3VBeEo2ZEhlTytJS2VCY2gzZXk0MTExUzd6eitCRHczckZjTFRrK09lVGs1SWlQUG55ZnYvRzMveHJLZXA2NWVVTnVydUFrZXJpWlVOdVdybC93bmZ2ZjVYUTR3Umh4a1RFbGNrbHJWWGIrQXJoUlRCdVZXclBwQ3ZlK3lDYjNVK1JIZE1ZbXVIZm9HVnhtMUZoc0pWMkNkQnpGdmxyQjRYemdkT1dvSzhOSjU5QkdNMjRxakZLRUtHeTBVV01JTG5FU0V2T3RCak9UaEJPbHhhNDVSTW1QOXdPNFFWSlhYQlRCaTNOU1ZJdGxaQmhTOFdRWDVad2Y1RFdQSVJOZHdIV2UxZGtLMTNVc2xoN2xOWis1dnMwWG45L245dVV0WnVOYTl0VXVZYVBFUUN1RU54Q2poSEEwdFdJME5paWxXQzRES2NOa0xDMjhjOFVUdnZUSzQxWlROYXFFWVNoaTBVbkl1a3htNkhMdWk3OWRGdDM2V2lOUVcwMWxEQ0ZuRnQzQW9oOVFXbk5qYjByYkdnbTZ5QXJuaGRjdnZIaE5SbEVWbWJEekNWOVdqRW5VaEtxcXRKNk03S1d0Y1czZWViejRidStqVTA5YW9xZFBIZXIrK2RjL1E5ZDMzTHQvZDBQeStBUWtNb24wUlJrWE9UMWN1cmRPbDkxOFBsOWNPajArM0wxMzl3UDFuVy8vSHNOcXp1MnJ6N0RkYnJIVDdQUHc3akZ2dlgySDA1TVZReC9aMjdyRVYxLy9HbDk5OVJlNHZmZDUzRW5nMFljZjBYVXJ0REZvclhHdUo4U0F3aEJpa094eUh6aWJuN0RxRnZSRHg4bnBDVEVrN256d0huLzcxLzV6RnQxam5uL3VHV3JiaUU0K0JxeXRhT294bGFuNDRPZ09iOTc1TG43d3drNXJMTlpJN0pMU0Y0bzlGeHBGS1c2emVSZ3pZWkNReGkvb3hPV2NPVDRMUER6eFZKWENWcnB3MWNHSGdncVhkZExkb3lVaHlTcW9DNUcycWhnM1ZmR3lGMi8yVVczbytzRHBFSGhrRkhiYU1wbVlvbWtYTDNaZm9wTlFaU1RLSlZ6Q0pWYXJKT0VMVHJUNHV2RDMvWkFJU1J4WS9SQVlsbzUrdWFMdlBmM0s4K0xlbEMrL2VwWExXeU9TVDV6TkI5R2VIdy9vSkhUWGplc0xzaVlialEzR0tyeVh1MkRVYXNZaktmd01OSlV1V2dZNU5OZHVSS3AwSkxvUWUwS1FBOGs3ZWIxSGpSRUxyU1JvdXRKbDR4RmxCSkZJNTh6eG9xT3lGUWZiSStINEY3US9sdEljaldRVjZvdThOY2FTYWxFZ0tGMlYyZDdxK3ZKT2U2T3UxUDF2ZkhqNnRqcFB6UHFodC9vLzA0WCtqZTk4bTdmZWVZY2JCd2RVMXFxWUUyRmpSZkxFRDF1SXJOUUtwWWFZN3pxWDlucVhYeCs4MHZQVm9FNU9qcGhNUjF5K2ZJWFBmL2FMZlBHelA4YkIxbVgyZDY3dytvdGY0S3N2Zm9uUFhQczgzWEhrN2dmdjgvamhQV0Y1VlMweFJtS01wQ1MvTysvdzN1R0dnVlczd2dlSDk1Nmo0eU0rZVA5ZHZ2Nk4zK0czZi8vdkVWbngvSFBQWUt0SzNneGJNUnJOcU9zUnh0VDBZZURiSDM2SHgyZVBxVktXeEpkSmhTMnBLMnNPZDBiMnJ5bkpyanF0ZlpHaDJEUmxycWJFYTBwNDZBK09ITDNQVEVaaUZra1d3a2J2RXIyTFZNYXdIRHdmSGk2cGpXU0x1NWhvYXN1b2tTU1pFTVVRY1d0VWM3cnduRGpQYWEycHQwWk1KbFdaUldWTGtjcVRHTEtzSTFQSURIMmk3MFJ2SGx3VWdVY3FsTjNTc3FjRXd4RHduV2Qxc3FSYnJPZ0hUNXMwWDdoOWlkMVJRemQzbkowT0xGYU8rY0xSRFpLd0t5c3RnN1dhZG1TWVRxM3dFaktzQmpHSmFCb3RxOVFzNkw4dnBKYXExbGdybjBzRlY1SFlaMm50Y3pwM0tOWEZ4Q09oeEUwbUpVSVVYNEpjVmdKMUxSbFpaNnVPMDlYQWJEUmlaMUlUazNReGF3ZWp1dFpNcG9hWVJlU2owdWJjUmhzbGRtRWxiYWV1OUhoL1ZrOVBsdTU3SHh3WEtlT1RLN2Y4cVJPMXBKelpHcmM1NTZ5YzkrU3NjaFRMbVhWZ28wWE1WUnprVU1OMEIxN1FLZXVjSW9PSHMwNUJ0Y1dObTg5eitkSlZybDI5eGsvOTVFOXplSHJJdzdzZjhmQ0RPM3p6Njk4bUswM2ROQmh0bUM5T0diVWpKcE1kdWNrVnBCUUVHQ3lXc2F2Vml0UFRZKzdmdjh1OUJ4OXgvLzc3OUg3RmxjdmJIQnhjRTRscXlySXp4V0JNUThhU1l1TCs0ajczVGg2Z2dhWTJ4QkozdXU3S1ZibXhueERveGJ5eFd6SkdYaHVUTTdjVmpGWG1xSXVzWEtLdVpLMWpqQ0w2TE1EZDJ2ZWV6Tm5LNDJKaWExUXo3ejBoSlRhVTZnSjNybGQzUGlWOE1iaElwVUNEeXRpc05qZVdDMlg5bHpKeFNMaE9OT1hSUzd0c2pOb1FmbktTTmpyNlJIUXl3dytMRmM0NWlJbWJ1MU4yeGczOTNBbndWc2hDcW93VVEwb2M5NTY2dGt6R2RqTmp4eVJiQ0YwcG1zWmdLMDNiS01GZkVrd21NbnY3a0lnQmZDbENYUTdDdW9CM0xzcFlzSDZQRllxdG1RRXFja3E0UWZianNXUUJ0TVl3YXh1NjZZVFR4WUt2di8rUWFYV043ZGJLR3MwS3lEdWZSMnlsMk4yMVZGVmtkUnB3SVdOYndRYXlVcHQ0WjZOUWw2YjE1Lzc1TDF6N2x6NDg3di85RDQ1WGQ1V2l6WGxqZy81RUxQT25vdERmdi8rQUY2NWZKZWVjcit4c2NUSmZzWEtPL1BHVWw2UWdUT0JxQzY5cEdlWFF3UEhqeC96SGYrMC80d2Z2dnMzdDY1ZVl0QTJ6clMyNjFaejU2UWxWUGVMeWxadHNiZTlpYmNWMHVpWGcydERpbzNESzF5aTQ5NDYrNnpnOE91VGV2UTk1OVBndUR4OTlpS2t5Mjl0YlhOMjVnVFd3WE0ycHFwYnhhQXVWUmZUaW5LTzJpcmxiOGQ3OERxRUtOSFdOYmVSRzBtdmJsN1dVZHMyRFZFVldtNHBEZHZHNEM4QmxNamVLVGRPeVR6U05vYTZrWFZYcmJqL2xOYnNmSHhLcndkTllUVjBaL0dxUVcwVVZkVjlKdUttTXBuY2llZ2tsUHkyRlNNd1FjbGxEdWtRb2FMSXVRSlVQVXVoREg4V3l1Und5T1JYQXMzalFKeCtJUThBUFFuZjFMdEJheTYxTDI5Z0lkV1V3UnVGQ3dxUWtBUnRCOWc2cmtIZ3c3OUJrS3QxaWxCWk5nMUZVVmdxNnNncWR3SkZvR3NXbFN6WE9KZTQvaklLQ0Y0WmhJbU9TN0M1NmwrbGlaclEyZ0F5aWo2aXRZbjlMZkFkOVNKeDJYa2FQRXZnNHFneDdzekVoUkI2ZUxQbkcrNC81MFdjdk14NGJ0TlZZMmY1eGVob0lUdE5PRFdSTG5FZU1sUkV0cmc5d1hYNVpQYjYxTi83WlAvdjVxMi85SDM3dG5mOTNlY1lkSmNYb1lyRi9hbVNxUDdoN0g0QkxXMU9pZDFuV1NSOURINVVDUm9yWHFrejdSSStUTTZmSHgveTkzL2d0dnJVMVlyZlZORXBVVzZQeG1PM2RQVTVQanBodGJUUGQybU15bWFGSXRLTXgwNjBWdGEzcGxuUG04MU1lUDM3SS9ZY2ZzZXFYS0N1eFRBZVhKa3huTTdUVytERGdYTVJvZ3pYZ2ZjQ2FoQS9sUEVvOWQxWjNPWFRIdExNV284V293S3g1MGlYOE1hY05MaUZGa3M2dHJIUEtlRFMxZ2xkVVlxYmdkQm54U1ZodzFpcHFJL3RzbjRYbEZzdnM3V0prOEpGSld3c2hSeXNxYmJCYWpDMkdsRGV5enhBU1E0aUVSaGhvYnVucGZjWkhzWkJLUXVmR0JkRmZFOHVhcXc5NGYvNDlyd1hqYStWYUJKd0xlQi93enBPVTdLVXZiVTNabTR5b2ZLU3V6TWFDR2pSSnkzOHZVSDZHd2VPN2dJcHc1VkpMWllYZVdsVmFISDh6bko1RWxvdEVPMUlzVnA2am8wRFh5NHZvRTV0V2ZUYXh4VzBvSTliTEVpS1FqY0xGVEVpWnlkaHdzRnZURFhLckJ4TFpLTHdUMVYybE5iUHhDQmNEN3gyZWNyQXo1clhwN2dZSDBDV1FiYkdNOUFIMjlpM3RSTFBxWk9zalBxZUswVWhUVjRxVXlKT1IyZnZzcmUxZitMT2Z2L2J0Ly9RYjkzNjdLTnpjaFc3MjAxWG82NDlIWnd1MmpDS2t2RjRwcitkem5VRzFpdDB4Zk5HS3YwUk9vbG5aK0ZDRm1IaDB2T1NzTnV5TkxQdGpTL0NCMCtNVGhtSGc3UFNZWnZTUXFtbXBTMjU1VEpybHFxUHZGeXk3TTR3MTFJMW1NaGt6bVUycFNrRTU1d3FaeEdKdEl6dlNYQUNlR05FNm9TdkR2ZVVqN3F6dWtreWlNb2IxVlNnNzlNSW56OUp1NTNqdWpycEdqRk9HMkFlODFiemNhSzRoYmVpeWozTHJKaWtvWlFXY3dndkFsRXByY0xKMDlDRXliYTFrcjhWRVV3a0lXSTRWY3BZYnZlc2RmVW80YllnNTB5OGRxNFhEN1ZiVXRyd0Z4WGsyeFdMa0tISk1mQ3JlZEVwdVBXSzZnRG1VOVpvTEJPL3hTYjZIVzFzVHRtcFI3c1dVaTJWVzRmVnJpekhTdWllZmlVYlQ1Y3pENWNCa1dyRzFhN0dWSEJqelJjTDFrY1ZaWWp3U0Y1Z0g5ejJMTGxOVkNxTVVGamJyT2F2RmhLT3VGSFVsNGhOdDVQVmFrMy9ja01nUnhpanFDTVpsdk00MHRVV3BpQStSU1ZQaDQ0aUh4MmQ4ODg1akxtMlB1SFV3TGx6K2pLbGt0ZWFEakEzanNhWXZoVjQzbXRGRXRnUUNzR1dsRW5sL3UzbnR4NTdmKzVmZWViRDQ2TnNQNXU4cHNaM1NuQnV6ZlBvSy9ZWFdjTitsOVk1aHpSVXhSY2ViSi9CYXEzbmVhSzJ0VWNyRWhJM0YweXhMejVPQnBZdjBJVEx2UGJzano3aHhtR1ZQVXk5RURHRVVJUlh4b1JMUHVkR2tFUUNvdG96R0xWVmxDRzRnS1lVcHNVc3BaVWFqR3BVMU1TU3dwdEJ1d2ZtQis4dGpQdWp2NDNSUGd4WFpxOVhZUm9zRWMwMEh5cXJZSW90dVhKZjVOeGZGbWt1WktpYXV4OFNrVXB5dElwMUxyRU5tdEpLVkVpWDF0UjlLREU3T0hNMEhvYjBxT09zR25JOFgxbXFGaGFjaDVNeXk5NnhpeEZjdHVqTDRsYU0vN1lsWFJ6aXJNVVU2cTNKR2RZR3dETGdFUTVHVXJzMFUxN2xiV2xib2tESkdLVkkzRUhzaEg5MmNqbmxoZjhxNDFqZ2xiRHhmNkxKYUsrcmEwTlFHNDRMSVdyWE1KV2VENTg3Uml0R1dsWGdrTGJ6ejRCTGJVOFAybHVMa0xMRmNwczBHUXlFS3RnMytRU1pHWWRScGZmNTk1cHlwU2tSMXZ4QzNua3JCenFUQ3A0elRtV3cxcHRKWUw3NXpkV3NKS1hILzBaenYzejNpYzY5c014bHBRbFEwNDVyYVJrNU9CeGFua2NWcG91dkUrMHMzTWlKUUdKbHFnOGxRMzlodS8rVFB2bmJsOTk5OHRQZ3JNZVZoZmJGOUtsRDNUL3JZczVxUVVaMjROYTRMdkFGR3RXSjZ1OWEvZUdsVWYzRi9Naks3bzBaTks4dDJVekdyeEdVRU1rT1piVk1XeEhyaElzcyswcThjcTFYUDRIdDg4b1FVUVN2YWNVTTdhcWlhQ21zclVrcUVFUEMrNUZzclRZd0pZNnkwN3M2aGxHWTYyVUdqcFdQb2xuejMvaDNlTzduSGtEM1d5RzFyck1RN20ySXlrVk5CYzh1OG0wcCtld2k1cEl1SzlWS3ltdXVWNW5XZGFjaWNMQ1BPNXcwNXBpNkVtMVFVVldjcjZmUk9sd04zajVjWW82bU01bkRSWVl4aTFGaWF5dUI4RkkxMmJiRmFjWGk2WW1FeWVYZUNyZ3pSUmRwSnhkYmVTTUlpc3R4VVE1bTd2VThNb1hEdkM2Rm1UVE5lWHo4cFp0d1FHRmFlMWVtQ3Z1dEpMdktGSzN1OGNuMGJoY0tWRk1OMXpESkZrV2ExTG5sNVFoOU9oUnNRRXN5WEhwTTA5WnJucmhWTnBUZzlTeXhYWXRHdGpRaGpsRkpGMjA5UkVjcW9GT001QXAvWDZ3U2xDSDNCSXJ4Z05YVnRoTk9nOVNhV0s2SEtlMnFvS2t0SW1idVA1dFRHY0cxM1JOdHFzc29zNW83VFk4LzhURWhFdWN6bGE2ZzBvUWpGZ3k1NGxFczU1Y0RvZU80V0h4NzN2M0hTKzJOMUhrU2FQcFUzdXRHYUtDbVVXb0VwSGdGMUJ0VnFkZlg2dVBuc2Z0dldvNnBTT1dlaVBhZVBybnpnMGpEd3NQZmNIU0xIT1VzK2M0S1FKRDU0UzRFdGIzZ3FZb2JWc3NQN1NPMHI2a2FjUk5jSWVQQ0pHSWVOMVZKVk5Tem1DN3ozcEtqb3ZPTnh0K0R4YXM0cWVreHRHS3NXV3hucXhwNFRBc29jS3VMemNwdWtkSjVTTWdSNm42aUQrTWEzbzVZWGJXYkh3T2t5NFgxbU5yYUNNaWZ4RkJjalhURlpYRGNLeXlGdVZHQ3htRzZNYWtOZGFMd2hwYzE4M2crQnBRL2tuUlpiVjlKUmFNM2l1R2M1ZDR6YWx1Z2lzVXRZcTJGc2hBVVdmVm4vWlZTVy9mbWFCeERDK2U2OEszRkt6Z1YyYk0ydHZTa3Faa2FOeGlmRGZKNm9LbzFTTWlPSGxORXFZWTFoTmpVTVE2QnpheEFyYzdyeWFDUEZ2NzlWWTYzaVpDR3FPY2xGMHhKSFZkWm95MFhFMXRKS1UxYVhNVXJta3RGRmIyQzFFRzMwT2xSU0hxWjZwTGxVYVI2Zk9yS0g1UkJZOXVKaDZGTmtPWGoyZDhha25QaXROeDh5c3czUFhKbWdLM211dXVYNXVqU25qSXNaM3lkaU1GVEZtVmNwaUZxaSt3N25ibjcvcFB2KzRXcFlGb3oxMDdkZUEvajUxdy80bTk4NzVMMCtFTkltQmxFanhWNEIxVUZsbnAxVzlvWldTdVdNU2dWcDFrV2JQS2tzdGRITTZvcmQzdkZoNTdqckUxMXA1M3NnZWtHVXB5cFJOUW9YZ3BnSmFyVTVNT1FXVHpSTmhROFNKcUMxS0w2Qzk5aktzdWg3N3M0WEhIVWRYUW9sdmRXZ2ZNS3ZQTDBTZGxtMmlrcEJVTHB3N09XYldiZnMwVWVpRjQ5ejVhTE0yYlhsQ3BtYlJZeXhXclBPS3FqS0xUNkVoQytlYmYwZ3R6UXBzVmdOUUthMkJ1K2pPTXRxdWQxOW1hRzFndHBvSGkxNm5BSTFHNkcwYU9jaE15d0dZdWRJcm9iamdUUkV3bFlqemphRkNLS3o4TzM5eWhPR1NEVVZFOHdZSmVWa2NBSFhPOXlxSThYSXN3Y3pkdHBhdXBDWUdkVUdQWVhGS3FDc3VHNmtzdElDT2V5c05ZeVV3aVVCQUp0S2M5cDd1ajdnWE9MU2JpUHJSU1ZrSWFQS2pqeVhsVnM4ZC9iVlJuYllPWXIrSWVVRWpkNjAwVDRLb2NYV2Ntc0RUQnROb3FKL0ZMRVpHaFJMSDNBeHNob2M4eTR4R1RXY0xGWjg2OTRoVnkrUDJLb01Qa0RUS0lJU1RNUzdoSGVKMmlnQ21leGwxYWtxaFRGRzliMWZ2bm4zNUsvOTJnOGUvU2Z6SVN6WFcrZUx1L1JQVGFFckJlUGFzT2lEU3VkRmJrdnJYaWxvOXl2N2t0VjZYQmt0K0pBSTJwOWdHQmlsR0Z1TEdTbGFvNWlzSEhkYzVMU2ticm9NSjBIK1lXWVNxRVNsSzRrdmNxNDRoWWorT0FieHFHdWJHcU1OUGdhT1Z5dVdLYklNZ1NFRU9SeTB4aURxT1I4OWJ0WGpsaDJoSDVPWk1aNkpPMG9pUVI5UWxhemExaVNaNkFKaGlDUVhZVnl4UDY1NVFTWGFtRGxlSm5KV2pNZW1yTENnYlRUQlovb2NDRjVtYlJJY0x4eG5uZHNBVDh0aEtBWVVzb3J5Zzh6d2JWTVJjK1pzNlVpVklkVVdYWXFjbE1rcTQ4ODhZZWJGaUtNVnA1WVlNOE5jaERTMVVXajU0VkZWb2QvR1JJemlDVGNNSGo4NGhzR3ozN1JjM3g1alVSc2dVVnZGck96SUYwdFBIaEt1dVBiR1JLSFR5cHhmSzQydW9QZXl6bHVsekwyem5xclI3RXdxMmtZb3hibHNIbkFTc1YyM1JUSmFRRDhaUThDN0tIdi9LUGxzcVlSVkdpdjBWVlhDOXhTWkNzVkVhMEp0VVNnR0wyN0FCN01KeTk0UlUyWTJHZkhCOFlydjNqdmxpOC9zRnU5M2VVMjhsNS9YYUhHOFVjVUZaMGprSml1MVdQanU5OTg3L2h2LytYY2UvTi92em9lN25MZnNUNUJuUGhVeit2LzQ1NS9oenVGQWJaUzZmK2FVS2tFTzY5a2NhQ2RhWGY3YzF1Z3Y3Ylh0YzQyeFNpdTF6alpFVTBJT1VzUVhKeHJLQXo0Mm1oR0pJV2FHQzYvY09pSzVzckxiTnNaUTFSWFdHT3JLMGpaMUlaUmtmRW9jcnpydUx4WTg2bFlzM0VETXFRUW1ycTBlMUtaTkM4NFRYR0M5TEZzSFM0b0ZVVUd5YzVZNFlCY0pmU0IwanBpZ0hqZThQTmE4WW1USDIzbFpQZFJXNWxKVFZHL0dnQXNpc1hTRkVmZm9kRVVmSXVPMkltZkY2Y3FoVU94TVduVFJVK2NFbzhheTZnUHoxY0F3cm9pVFZseHBPTGRzbnU0MGpNYzFZVndSclNhNFNCZ0tDNjV3eEFXK1VCcytldkNDaExzaDRGZU9idGxoWXVLNTdSa3ZYZGtXMzdxUXl3NWZiazVyeFJiS2U2SE01cktQRDZFNDFHZ2xsT0Y4d2RnaEl5dkJrR2tySTZHSW1zMEJMVmluN055dGtZc2d4SXh6NGxBYkV5Z3JvNWpZZDZWMWxzaUdWQ1NLWWFHem1rSnZFeElORzVYYmJOeFNXNE5SaXM1N2p1WTlsM2JHYkUxcVFoQ3cwQThKb3hWVmF3U2pVUXBmSHBuanVmTy8vWVBEWC8vUHZuM3ZQN2kvY0crWC9YbFgxbXZ4QXU4OWYycHU5SlBPYytlb1I1VW9zZ0xFV2FXb2M4YmNhT3VYZCtybW1kWllVMmxOQXF4T1pYK2N5RWxqVkNia0lFWUN4YmltTVlaTG81cVVITWxGanN2TkhqS2NPWEpVU1UyeXAwMktLb0hDMHcyT3ZOSjAwWlBKK0p4eE9hRzFvYkptSXpXTk1RclB1a2llMWtDUGJSdHBoWE9Xd01ET0UxY043YlNoSHRjb0xZa3RvWmZpaWIwUVMzUmJzMU1wbnJYUTVzejllV0FJbWRuWTBOYnJHQ2J4R0tjNHdnNmxRSG9YT1ZrTXdnQ3JMR2VkM0RhalJrQTdIeUl4Q1dLdGxXS3hjcmlVQ0xVVk5tN0t4Q0dJMmFFU0VzdWdKUnM5RldJSldUWUlKa1h4b2xQbDh3bThUN2plNC92QXNCeVlueTd3cTU2RHF1Ym16cFJKa1ltQ2pCK3FDSGw4RW9CeFoxYkR3ckhxZ3hqL0psREZ2a29WTWxGbEZFMGgyYVJrT0Y0NERBcDJSb3hhUTFYTGU2dU1naExObkl2bGRZd1ptNUdEM2NpbzU0T1FkS3pWWmRVbVI3TXV5clNVRkxxV0xtaTdyYUhSTkNQTDBjTFJKVW0zcld2QllteWxlZWZ1RWIvN2c4ZHNmZVlhcmRiRWNqRG5LR09FVTJwRGdUMWREc1B2dlhmMDYzL3Jldy8rVDQ5WDRSM3h2YUVyeFI0K2xZUVpyUlRQN0RmcTl6NllyL2ZsNnh1OUp0TnNqVXo3MHU3a2owM3JlcS9TSm12QmE2bTBwbFdLSVNZVWNXT2w1RlBpLzlmZW04WmFsbDNuWWQvYWU1L2hUdSsrdWVhdTZ1cG1kNU5zcWptSUVpa09vaVF6c2lISlkyd3BOZ3pCTUJJa0FXSWcrWnZmRHBEOFNBSTRnQk5yY21KTFN1ekVFU1JIbGl5SnNpVlJFd2VSSXRuc3NicTZ4amUvTzU1cER5cy8xajczM1hyOWlyUnNEVjNOT3NCRmtWV3Y2cjIrOTZ5ejEvcldOM2dPRVhoaGFLV3dsbW1jOXdHVll4VFN3ZGMyb0Q4dUEwK3FoaFJaV2Jrd2d6V2dNckZBMW9hUW1BU0pNVkxNbHNGYVEwT0JTUzBvYkJ3WldPMVdzSldnY21DVTFRek5kSTYwMzBGM3BZTThsNC9OMjRCUU8ybmR2YVNlUHRuVHVLaGxUMXcxUVc3a2FQc0VKK2l0aTJoOVdYblVqWWUxQVFmakVxVjFXTTB6K0JCUTFnNEEwTTNGbzd4MDR2U1M1eHBsWlRFcmF6UUVJRXNCSCtDcUJxR3NnVFFCSzQzWnBNR2dDY2hKVG1IdkpVU1NsSXcybWdncXhNZ2lIK0N0UjExYWxFY3pUQ2NGeW5tQlh1T3gxZWxoTFU5bC9lbWp1NnlKTVU3UlRCY0E4bHhqU0tuUVZoRmdZaG9Lc2RCaVNSRTBGSElEV0Zhb3JBY1JjRFNyb1JWaFcrVlEyb0FVMnZCRHNkTEd5VXBUL0FHaytHUmxHRS85SkNiWHN1U2lKNG1zSDYwUUJVQ2FzTkkzU0RNRmpBaVVLSXhLdTRocVVncm9keE1VbGNXcmQwZlk3T1I0L3RJcVFpUDdjNUhBS2dTU2RKM1ozTHV2M3hsOTRkZGUydjFIQjZWN0VVRE5RQUdnUG9zVjk0NG85SSsvYXdWLy94ZmZqQzBUeFJUd3hWb3RaY0Q4dlU5Zi9PN3Z1Tno5Qkh2Vm5ZMEN6MFlCUlMwT0plTlJnSFppZVdSOVFLWTB1a21DeWprVUhBa3VyTkJMQ1d1TjQwUFBLQmx2Z3ZDYkRIeVVHZGVZMFFseHpqMkJRUmhzQlBmM1hnQTVvNk8zR3dzd3QxQXRFSUdkaUdLMDFvQlM0dmxHQ3Q0NTJGSUFxYXhxeEdVbE5UQ1NJZ0cySGhRWW5DZFk2eVo0cmtOQTdWSFdqSlZ1SXJUV21LTldWaDRyZlkyNmxoV1hEWUlnTjg1alV0WXhmdzVvWEVEalBSS2prS2RtQWZ3eFJNZ3ltamNvbXhwdWZRRFdTbjcyeWk3MitjUUJ3VWs0b25jVTBmcEk1bkh5djQyU2ZEdWxSSGpEZ2VHTEJzVjRocWFza1RRT3d5VEYxcUNMWG14dktSVlBlZUFrVEZJdnhDT01OTlBvOXhNVWhZdXpmSUIzUGdaUTBHSkVNc3l5aXRFYVpXMHhLaHZrbVREbXROYUNkc2VUT3dTaHVHcFNJTWZSejE4K09rMWlseFdpYzAxTFZlVzRMcXliZ01ZeU1pTWR5T3BBVm1waHd0ZzBHV2ExaCtPQVJDc2dNQzV0RERDYjEvamlqWDBNVElMdFhpYTYwNVNnVThGVmptZEZlT25lNUd1L2MvUHdwL1pLOTFKczArY1JLMjVPbmVidkhOVGRLTUxUMnpsdTdGY0VzR0tPTFR1UU1hQS9jbjE0OVVjL3Z2bkQxeStiSjVFd3U0cG9mQmhRdzZQaWdGZGVEbmpqVFlmNTNHTThzWmpPbk55d2tSSEZNZExJQm9kdXJaRTFnUlhqaG1QOEdoSCtnSUZQZ2ZCZFlGeFlIcmc5Q1J1TkluVXJxSGlxQnNrckQ5SDVSRVhySUpsWE5WUkVXaEVZQVU3R0NtT2dUUUlRb1M1ck5GVU5GUmdtRVRzamt4cjB1aW1lNldrTUhXTlVpajFVbWdBMm5CaFRLRVVvYWhZS3FoWDhvTEVlNDNtRG9uYm81SEk4TnM2RE9hQ1RwY2lNRmtXWUR5S3M4UUdINHprYUJmaE9BczNpdmM2dDFyS052dkpDaUxIdWhORERTcEpjVWpBb0NrYU1Wb3Uydlp5VnFCcWhyZllhajVWZWlvMlZISjFvVHhVUFdIa2Ztd0FtSUU5RThORkU5OVJ1TjBHV2FjeG1EV293YklORitpMHBCVVV5OHlxdDVhRkJET2NERHFmaXhRY0EvWjVCa3BJSVlOcXRKZ0ZKekVJWHdwQ1FyRnJ1RWlrZ3oyWE1LU0k1YVY0SStKY2xDcTVtMEVCajJEZW9tb0RKM0NIWGhDWkVIM2tHY3Exd2VXc0ZYNzE1Z0MvZk9jSjN2K2NDc2x3ZVBOWUZ2bjh3dzVkdTdyMzIwbUh4VTNjTDk4VlkzS2VMM0oxU3JqMzZyZnYvOGlQWDhkLy82N3RJTlZGMHpGMmM1cEtlUmZsLytzbnRUNndQNkNrWFBQd1lWSlh5cWF5dUVMcm5BalpXRTF5K3JER2JCQnhQTE83dTFkZy9xakdkTmFBcG9Tazl2QmZIR1VVS0h0UUEvREtBa2htdkEzZ2R3QmNCL0JDQTV3SDB4ZmdkRkN6Z0ZhQlNpWU5pSmJFL2txcXl5R0tPZTFtUlZTb0pvMEJ3SHM3SlRsc2JzekM3YmRObUFndG9hSXhCMmplNHNwYmo2WlJRVjJLV2tlb1Rjb2RtMFk2clZHRmFPRlJWUU9sRUlsclVEcnZqUW01Y0NHQlVXWThRR0hscVpOMWw0MmlnRWt6bkZjcTZobHZwZ3RNRUtnUUU2OEJlbkZIRTF0Z3ZkTnV0R1NTQlFGb2hGRFhDdEFFbEd0UXhhS3hIMVhoeGVDMHIxS1ZGbURwME9nYmJxejBNdTdMdmJvVTZMckNzNkdyQkdkSXVTZTlHSndtNEt6MkR4QkNPajJxRU5FcE5td0JLWllBT1ZuVHZXYUxBbktCc0hKckEyQjlYMEpyUUd4aUlxN0pZV3drQUtTQW1TTG9TV2NsRzdibEczS3ZMNlQ2Wk9Zem5Fb21kUjJXZGh4aE9wZ29ZZGcyYVdsS0VBZ09WQzFHRlNGanA1cml5TmNDcmQ0K3h1ZFBCKzUvY1FGVjczRHVZNHNWYkJ6ZGZQaTcrOTd0bCtFMW1GTEhJeTFNdCt6dFBwcG9ad2w5K1lSMy82Mi9zdENhbkN2S2VwNEZocm05MnRqNzBaUDdDb0U5RFZ0SW1HaVhJSzRIaEtzWnN6RUJrakcydXB4aHVaSEFBSmxPTGc4TWFCd2NWN3UrV0dFMEtiZ3BHeVh3dkFDOENtTWFucHdYalZ3RjhIY0JmQVBCcEFGZmhBVitCNFVEY0FKd0hVRWNoU2ZSQ3dLRklPZ1lWWGF0YjNYT01oeFVUd2Znc1lHNDF6aExUU1pCTU1rc0IzY3pnUFQyRHBBcVlWTklLVWtTWTlSSUs3QzJqS0QzR2N3Y2J4SWh4V2pTb0dvczgwYkp4Y0l6YU9lU1pRYUlOWm1XRHVuRVJtU2FNWnFVd3pWSXRHVzRlQ05ZSmw5Mll5TU9uUmV0czRpblBpcUFEdzFmeVVBaUpob3FNTmU4Q1hHMVJXd2M3ZCtneWNINjlqL05yUFhGY05ZSWN1anJPK25GL21tcUNhNExJWER1Q3ZyZW9lemMzc0gySlJQSTJFb0lnSkJkbnBiMVdnWkZwQlpVbmFJSmdHb2V6V3ViOVFTS1dXQ0RVVGg3U1RQSTlPYnJOQkFiZ0FsUXVMcnlWWmRTMTJFa0w2MDdXYzBZcmRGS1JCWk1DK2wwRmF3MzJqeHBwUDVVQWZrb0paZmo4V2hkSDB3cS85L29CRXFOUXoycCs5Zjd4YTdlbjljL3VOUHdaWnBRRWxDd25lWDBXK1BhV3p2ZFJMdlNYZGt2c1RSdHlnWWtJaXVXK1RqaG1WUDN0ajI0OHY3MnVuMWFheVRrR3gwREV0TWRJMXdLQ1ZhaXRFbWNRTDJZS2xoaUJDTDF1Z3Q0Z3dZVkxQVnlkV2h3Y1ZheGZ6ZkRLSzRldkhjL3JIVERLMkRLNStPTzhCdUFuaWZBaWdCOWd4a2ZBNkhzTDloYmtIVU9SRStjWEZrY0lwVFVvU2NIRUNCU2dSZHpWNXI3TEtnd1UvZWdqR2hVRUpDUmlCSGJRQkR6YlMvQWtBZE5DN0Y2MWtnZUZpd2FPV2hPS0txQW9oTXBiMW9LZ055N2dlRll0NWxkWk96azB6bUZ0cFFNQ1kxN1ZBQk1HblJTem9rWloxSEJFNE1SQU1RdFhJSUtXQk1sSlEyeUJpWURnbzZGRTlOVm5abEF2QmFjYXJ0MFZseFpsVWFNdVBaUmxyQTlTYksvMU1leG55RElaSjJ5azlyWVVQbVBFeXkwNDJYZDNWelRxSTBrVjlaN2h2RWVTS25UN0JtNFNFT2hrNXVaSW5WV0tRRUdNSXhRck1Idk1Hby9kNHdxSklReklMRkIxNThYUUFORW9OQVI1NlBnZzQwR3VOSmdFb2RXUXRSd0JZQmZRNldqa21heHdZMitDWHE0eFN4Vjg3VUZhTHh4bmlBaVpNWGg2ZTRqOUczdjQ5Uy9mNDRFS1IvY3E5MC8zSEg3Vk0yYVFJaStXaXR6aG14aEVQdEtGL3MrK2NBRHh1Q1ppamlBY0lXR0d2akJNMTc3dmZmMlByQS9WeFFVbEdaS1BwbnNNTTJCTWQ4VmJIRVRRU2tJUFdxYzlGejlJQmNLZ2x5RFJodVlsNGZaaGVXSFcyR1RVaEhwcE5tcGw3WTRadndiZ1ZRRGZUOEQzTS9BVUFPMHN1Sm96Y2JBd21RTnJCV2dkN1lOTk5FNDQwWmNySW1nbUVTNUdqL1BXNU5GN0J3NEJ0WE00Mzgzd3ZtRU9IUVFvU2cwdHJKRVFwWjExRlZCVUhrWHBVVmlIeXZwb2JWU2hhaHl5UkxMYXZROG9HNGRPcG1VMnI0U3cwczFUS0FKbVJRWHJIZnlnQXpaNm9SOFhJMG9GanNJZEVZQ0V1SUhRVUczeW1BZklHS2hNa2wydEMyZ3FKNmFQUlFVdUxmcXB3dnBLQjROT0ppYUtMZjAzbWtPMHFTYlVZcCtwUW5jOWdUWkFiY1Z1eXpjeHFFSXJyQTFUR0VVWVR3UllkWDZSWXlRZ2FEUm41QkNnU1RDZlVkSEFIQUFZNWtneWpUd200bmdTZkVBRkxGeGtPajJETk5IU3BUQ1FLa0JuYXFFUDFVcHdDQjl3b2kxd0FhU0FsWUdvQTh2NGNHaVRjTDBUR3UvbFFSNXV6TVpVcHppWWdiN2ttU2V4VlMrWGRPZmZ0TWdmNlVMUGpjTHRvd2FDc1ZEclFtVEFTQURvdi9TQnRldVhMeVR2VFR0SUhUUERnM3dFd0VCQXNFQTFGOEJGRkdodDI5d20yUW5qQ2EzVmNNV1lUR3BRQ0Vsc2gxdERDN3QwcXJjQ21wc2cvQXd4WGlUZ1J4ajRMbVlrVFEwT2dTbnpERTRaWHNmOWJKYkNKQW1jT3NrUDQ1aW5EUzArWm93QWIwVW8wd28xc2s2T0Z5NnNRUVhnM3NTS0ozcGtsalZXQ3MwMmtwUmFXeS9oZmhIOUR5Rmc3M2krU0VsMVh1eWltQmpkUElIekFWWGpFSmpSNzJUd1BxQW9LbFFNaEVFbm50RHhoRklBR3cyVjZKUG9LeDlnYXcvVDB3aEtBRWJTaE5BUnZJRWpLbDhWRGVxeVJqVnJnQ2JnL0ZZZmw4NE4wYzJpOVhKTWRXV1dkUlVUWUxRVUhFRjgzem9kd3RISXdZZjRkbkVNb29qQ245VmhDaUpnTkpJSEFhSkpCcmVVcE9oT28xaWlqcGtKQjdNR3FkSFlTbU93QW9zME5VbUZSV2Nkb2QvWE9IKytDMnNaNDZNU1JDUTU2M0d0R2xxOVEzdVA4ZEpoNG1VOWx4bkJUVUpVeTlWeWNISFRPTmJNYXJXakppUG5QMk05NzVDczBjcUhyTkcrWVlqREkzMmlKMXFSazVORHR3UVpJWkZSN3djK3NQSWQyMnZtcVNBR0FlUkFjRVF3Q2NOMGdHYXFNWjNwbUhFTzFMNTkxM2loaVE1QlNCbnNnS29LZkZ3MGRGQzdyeFNPSjBUUUFLa1kxN3hzdWV2ai9wNEQ4THVhY0tBWWgwejQ4NEhSZFEwWUFXUXRnNzJITVFGNXp5UHRPaGhqb0pTR0JzRGVJWkJhQlBLRjRPR3NCWWNBTWdaWm11SURsemJ3OUVvWHYvKzFYUnlOU3ZqZ1lhMUhZLzJpRlFmRUFGTFNRak4wc2dUOWJvYURVWUhHZTZ4azJVS280a05BbnNoc2JpTVkyRTBUZExJRWV3ZGoxSldGSDNaQmVTYVd6RkhlUlhrcU5rZVJxeDY4V0g2MFZwMCtwcXR5SURUeXhzRUh3TlllVFduUkZGTG9tV09zNUNrdWJQVnhicERLcVIwbHhGQmlBVVZhV0daZUNVQzJzU250ZFZrS3VoMmlUTGMxdmJSV3dnelgxaklCQnpNbGZuV1ZFd3RvaVB1cURuRUZSNEN5SHZQZ2NEQ3JrYVVhMjJ1cFVHTVZpVDY4WnBoRVliaWlwVTNSZ01vVW1qSUlvY1lRMGx4RlN5OVJ3VWxPdXZ6N3RnR3FVamdNYVNwT3VwUENRbXNoVTltbXBxUHhqR1pOczE4Q1A3dFQ4ZjliQlJ6Rms3ejZvNXprajNTaFgxcE5jWGZVdEFhWnFtWEN4ZmxjZitxWndmbXJGOUwzZExyVTliSWdrLzFuQ3VnK1F3MERtanNHWmExZ1BSWXBHWjVPNUtrY25VdWlId0tLMnRPa3JPdmp5cjVaeTZpWkFseUNLSkdPbTRFSHBZRWhrcmRlMGNDUGFjYjlEdUd2V2NLNXhpRjRpUllERWFOcFBGZ0ZlT05nZENLbm8xSWlzL1FCRkFTMTE4WUFTcUhUeWZIKzg2dDQvMFlQTDcrK2p6LzQraTVzNVJkek1oR2dUR3diTTQyVURiSWtRVkhWbUZVTzl3OW5jTjVqcFplaGNWNlliNUVoT09oMlFBRHFScnp2T3AwVXM2TENlREtIVHhPb3JSVW9GWG5xa1FZV1NDMEZEVVExWU9PZ1NndVhDQWtsaWFveERvemFCWVFtb0NwbHBWWVdOV3poc04xSk1NaFRLQ2N6YkwrdmNYeG9NWjg3a2RmaUpOU1NSYUtOcktzalFFY2dKU0NsaWxwOTlqRVZOUkVRN3ZLbERvYXJCcmZ1bHJoenE0bGViZEUxTk5WQUl1RWNJSW8yelE1dkhzd0JRMWhKTkxLT0FJTmNNMVpYUkxWV1ZBNVpSeUZKQ1dVbEFwUyswYUlLTEFOTW9tQXlXcEJ2Z2hmdXVvdWdZcUlKdzQ1QlVUb2NIWmFZRm5XNE41M2ZPeTdxdzVuenYzaTM4TDh3OHppSUJmN0FybHdST0ZNU3MvV09MSFFBMkY1SmFIKzZpR1BTeXdLV0gvakE4RjFicStaWmFKYnpGVEUvUEFWTW53SE5DSTBVdFBOaTBXdWoyNHVLZmx5SXYxWU9zRXc4clJ5TlNudFVPRDVrSU9tdnJLNWV1dnJNeFZkZi9NSXJIQUlUS2NNYzZxV25iTE1vZHVBK2dKOVZoTjBMSGZvdmkwRG5EaXU1cGJ3SHVBRUNzZVN5S1ErVGFoaGpBRkxRVWZsR1NpTW9qWTErQngrNk1NUnp3eTYrL3RvK2Z2OXJ1MmhLSjE4WFJ4Q1R0Q0Y5aEVSckVNdWV1YlExaXRvaFVSQSt0UmVDam9KQ1dWa1JnQmdONnp4cTIwWWtFdzRPSnloTEQ3NjBBalpLc3NnaWc0OEpENmoyU0JFSUNxcHgySnBXS0hzcEtsSWkrb2hyUlJjQWJoem1reEx6ZVlYWnBJWU9qTFYrZ3BVOFFhb0k4Nm1EQVl0UllrYVlUYno0enlQdTVnT1FaUXI5Z2NIdWJpTWFkQ0pZaWRtUlpvTmttNkxqV2pQUmhHNUNHQTRTN0NZNkR2cTg4TmRydXlCRmhGeHJ1SVJSV29kN0J3WDBzSU5VRVRyS0lCM29PRTRRaGwwTjdSV0lOSTRySzYyNkpzeHRwTWg2QWVxTTV1ZzB5eWdyNlh4TU5NUnNQR05uTk1mcmQ0NHdxZDBYZDV2d2Y5VWh2RHExNFg0VmVQa2tmNEFRd3d3WUJjWTdzZEIvK05zMzhmazNaeWptRGxpU29wS0FjT2JDTUIyK2NLMzd2bzIrUGhlY1BPbHRJQVFubmx6YUF1d1V4bk9OMG90V21mbEVZc3J4aGlHMFpCTVJXMHhuTlk2SzVuYmg2Zmc5Ny8rdTkzNzM5Ly8xVDE1NjR1bG5YL25LNTMvbDUzNzJIL3owZkRZWitZQ0VRNmlYVG5VWFA2RGdnVkF3ZnFYUFZEMjUyZnV2TGpNdTNUZ3VNQ2s5dVRxS1BGTHhXV055NENoNmNjd0lVT2puR1o1ZDYrS1QxN2FnYmNBWFh0ekJGMS9lUTEwNStSRGpJMDlGTHJUZ0RtTFFNSzBiYVZzaG1lV1VBRTFqUmZHbmNoUzFSZTBzMWxjNkNDR2d0bkxEOWpzcHlxckJlRlREZDFLRVRJT3RBeEt6c0pScVhXTmJjMGRSMlVuV1dUNXJzT1VzN25RNkNNSVBoZ3FFUkFQVDJtRTZLVENmbDZqbkRodUp3ckNmSTFVYVpDVmM4WmdaU1JuUVh6SFkyTklvNDFZaGNUS3ZuNytRUWh1Z25IdlpacWpvaWhzZmN0NEZPQ2VTdmNZeWFrMlkxU0dHTnVqb1lYK1NhQ1BZZ3FqZWVqMERVZ1RiZUJ5UEt5Z2JNT3dNa2FYQWFDWXVNbG5HS0NwR3p5Z2NIQlNZVGgweVRhaVY4UGgxM0daNEs5Wlcxb3RmdnZqOHlUMDNubGw4OWVZQmJ0dzk1S24xWDlwcitNZDNLdjhIZkVLRVdXN1hGN3R5QWloZEpKSDlPL2cwUEdxRi91N3pIV3oyRTNwNXQ1VDdSc0MzbEFoZEFObjN2SHZ3eFBkL3gvQXZYcjZZWFBWZ1ZnREJBNzZSdFZiYVo5U0Z4dUd4UWRNUUdrOFB1T2kxUFJFRklEUUI4TXpGek5OTHQ0K2FHd1UrLzY2UC9zRGFmL0ozL3B1Lyt0UXpMM3d3eTd0YlY1OTg5cm5uUC9TSnA0clo1T0J3Nzk2aGR5Nmg5czQ1cFFzT0FCY2VkeEtqWDNsaW8vL1UwK2VINjVtV1Q2dTJnWnlMaUw4SDZrcCtIYVFHVHc0SCtMNTNuY04zWEZyRGZGTGpNMzl3QnkvZVBJYXpmc0VXYXhORlZWUk5GWjR4YWNUMTFicUlqRWNBdjgyNU1FYURTR0ZjVnNnemcxNmVvbWtzeXFxR01ScHBvbkZ3TUVkWmU5QldEeTVTUERWRkc4T0k3b3RvSlNCWXU4Z1VNOHhZWmNKS1pqRHBwTUlCOFBGbnFTeEdoM05NanNhWWpTdjRtY09GUVlwTG15dFl6VE4wdElKSkZJSWlORlZBTVJkZC9PcUtFVUdKVVJpdUpiajBSSTZEZllmai9VWWVjblFpT09HNENsT0tVRmZpZTJjU2toaW1KcHBnTm1FUkZ0bStoOVlLcDc4Vjd3VEkxNDRMaXp4UnlMc3BraFRvZFFtVEdTSE5EY1l6aC9zN1ZmVHRFeUF1amJpSWlxOEFnbVZaNHpMTHlYNDhiZkQ1bDNmNGxkdUhQRy84bDQ4OGZtS3ZDWjhQUW9acFh3K3cza2cybUNGVkJDWDMwenV6ME44OGFuRHpxS2FpQ2NTeFhTY2daeUEzaW5wLzd5OXNmK3lUMzliN2dheExQUVRBTllxcVFxR2FDNHFlOXdMcXNVSXgxZkJPVGp3YmpSRWRaRmZxZzdSL3pqR2NZem80cW5CN3h1NjV2L0NmWlgvbGIvNjk3OXcrZC9HQzBTYnBkRG8wSFBiVGpZM3RxODg5Lyszdlh4bXUwYzc5Vy9lTDJkZ0JwRS9SRUxsdHQ4YVYyN2VCWHo2MzB0bCs0Y3I2aGVjdURmV1Z0UjVXOHBRNmljRkdKOFAxOVQ2KzYvbzJQdjN1aTNqZitWVm9EL3oyVjNmeFcxL2R3YzVSQVFwQktKaEwzeVFRTUF2QUpBQlZkRTJPSWFEeWltdEdGVzlHSHdqajBrR3JnTlYrRGtDaGJocGh4V1VKNXZNR28xRUY5RlBRZWxkMjBkRWFDVEdSSkFTVy9iajNnQTlRUnZiSnhqUFdsVUxRQ3ROaEI4SElBODNiQUR0dmNMUS93WHc2Z3kwYkpCNjRzdGJCaGVqWG51VWFTU2IrYW9rbXNCVXp5Y1lCZVVkc20xZUdDUVlyS1c3ZkxGQTNRSkxSNG1uZFJpc2xTYlRmb21qeVNLSUVVMEZ1bktiMGNMVUlqUUlFNVFteEswbU1XdERNRVAwQlIzT0xmai9CaGUwY3MxbEEzak93am5GNFVNTkVLcTVXaEx5ajBPdnB1TGFUOThrRzhZUTNVUko3TktyNTk3NjJnMWR2SHprSGZQNlk2U2QyYXYvN2NVOCtQK3NrSjBJZ0FpZml4c3VJS3NwM1pLRS9kNkdMTzhlMVVvb29oS2hRQTNJQStVZWZHbHo0MjUvYS9DdnZ1cEo5SUhnR0hNaFpCZHZJbXF6VGx5ZnU0WjVCWFJKQ3pQK3lpQzE3QzhSeDNQazZvRzZBRzNlUDBmU2YwQi80d2Y5OHZkTmZ5YXU2cHFLcUtYZ0hJaUt0TmZWNksydFhuM3JQQzFldXZldGlWYzczSnBPamFWMlZMVnR2K1FvQU1LbmMwZEc4L2xKcWxIMXllL0RVdTg0Tmt1ZXZyTkczUDdGTzMvWDBObDY0c29hdFhvYUQ0d3FmZlhFWHYvV0g5M0Z6ZDRxcWRySnpiUUZEQlRnbGQwWjdkOWhsSVRKT1ptalZhcklCVEIwd2FzUlZadGhMMFVrVGxIV0R1ckVBUzBNK0dkZG9BcURPRDRBOGdZN2RCMFVYUjJsVFJCTktMYWlzRkh3STZER3drWWhiYTVJbFNMMzQyWlcxeDlIZUJIdjNEMUVXQllLVEVlWEtXaC9YenEyaTEwM1FUUlI2aWNReGF4S2pqTzVLQXVpVFpOdXRyUVJsNFhGODVERG9hd1F2R1dqdG02MWlmcngzSjZOWjYyTnY1eDYrRHJMZlpwSHRoaEFESG8xc0tZeFJxSnNBWmNRSG5wblIySUFtQUQ0b25OOUtSZlczMzhURUh1a0FsSktNTjZVa0dLTnB4QWFLVDFTc09EaXU4YmtYNytQRzNlT3E1dkFiZTB6LzhLRGhML3VUay94MGtZZllJbkt1VDhKRXkvRHZYamVQVktGZjMrNWdKVmUwTzdZVVYycnQzanJYaXJwLzU3czNYL2owK3dkL3RkK2xOWlpsRnlrQVpJV1gzQmt3bW9Kd2ZLd3hiNklRSWpBOHlWNlZIQzlFQ29ERUhFMEtqOWZ1SGlOLzR0dHA4MTBmUmgwWk5pckdIdGROQTYxTlRJamg3TnIxWjU5KzRZUGY5Y0p3YlRPTWp3LzJScU1EeDh5S1dyTDZrdENnYUh4MTk3ajh5dTV4Y2U5NFVsM2NHWlhyUjVPS2J1N084TG5YRHVnM1h0ekJiNyt5ajV1SGM5akdpLzF3ZTNCUnZCc0ltQXVmNU9SbVhuclBhT2xYWG9KdUhZQkJwckhhTTFBc0h1ck9PZUhpUTZHdUE2ckNnVlp6cVBYTzBnd3JLRDFpaUlPS2F6WUZRRVhsVi9DTUs3MGNLd3BvYW9zdEtLVEhOYkpSald4dXNlNDl0bk1ESFlDRG1jTzhDZ0FyWEYzdllwZ2ErZTlrd0RjUnhWZGlvZFI2Qk9RZGphMXpDZloyRzR4R2dzaDNPOUhyTGJick5nQlZKUlJZV2NHS0dTUmNnSzlGYjlESk5SSWp1MnVPSUI1cGNXeFZtbUtXZS9TdzF4b3VNT2FsUmRwSllKVEN3WUY0d0NWSmpJRzJZZ2ZkeGxhMUVkd01RZmNiRzdCL1VQUHZmZVVlYnR3NW1wUWgvUEplb0o4NGF2amxJQjlMVytqMVVxc2VBTEJSQkFLeGlYbHl0ZWMvVXUwOFVvVysxa3Z3MHYyU1F1QldjNzQ0emE5djVodC85M3MzZitnRFQzYys1Y0VFSmdvTndaWUU3d2k2SzRqN2JLd3huV28wRm1oQ1ZDSXhROGQxVFpEWkI4RXlLZ3ZzakdyY1Bhb3hmTy8zb0xOMWxhcXFnSE1XalczZ09VUUNDOEU1UjlaYUNoNDBYRjFmdjNiOTNSODhkL0hKSjdST3BxUGovVkZaekZyUnpRUEY3Z1BqYUc3ZnZIRTR2L0hLem5UdHBidmpjMSsvUHpHM0Rndk1pb2EwWitSZ0pQR1IzakRReENLM2NkNG1QR2ppVFV1RnZiems5eENWVmFvSmFad2RLOHVvQ2lseTd3TUlHa1pwMUhNSFp3aTAzUVZTRFVZMFh6UWFDZ1RmMk1nbzFHQW5mQ0ZsSktta3F4V2UzeGpBaElDeUNlaDFNOWc2b0NrdDBzYkJOQUZEaytMaW9BZkZDZ2RUaTZPaWdXSGc2a29IbVpHOE42WGlVWllRMGt3ajYwaVl3ZnFtUWFlcjhNYnJsVVJhUlVBMWJVL1N3S2lMQUZ0SnRMT09jNzNZUjh1T1g4ZFpYbXR4enJFc3E3cldPVVlaK1o0aE1HcnJ4Y2ttVWNoeUE1MG8zTHd6UjhLRVBOV3ljWWpjOWw0V3d4VUJtRnhMdHhqTksrN3N6dkc3WDdudjM3Zy8yaThRZnVtdXd6K2VPdHhja3BxV3k5eDFJZ1N0aURVUnQydlRPakQraURYK2FCWDZmL3VYcitGcmQrWTBLUjJDM05jQ3drbWhkLzdpQjFldi91Q0hoMzlqYTlOY0NBN01EbFFXQ3ZOS2JwcnVaZ0Fid3NGQmduR2gwRGhoSjRuQkNTMmNYanpKL3hmVkZuQjNiNEpqdllIaHU3OGJ1cnVDcHE0eEdoL2o0SEJYQXZXY1F3Z08xdGFvbXhvTU1aMGtNc25hNXZtbkxqN3gxQXRYcnI0cnovTE8rUDdkTjZvZ1ZEeUtKM3lydFZBQnRBL3dTNGFoTStCY1N0UXpiU0lMZ1JvQUZUOW9Cclo4VXA5MWV2T3BwNG9XRWh0cVVYbWlkb3pLeTJwUlFsUUpuVVREMVFHTkRhRDFIRFRJSkVEU2kxdUwxZ3BlTEhCaDBnUUs0cUJDTWQzVmU0OUxuUlJQRG52WU9aZ0JwSkFuWnBHbnhvcFFWQTVsSlBZTUU0UFZUb0pwWTNGL1VxR2ZhSndmNUFMcWFVTFNWY2g2Qm5sWFJRTkt4dnFHd2VHaHc3eVF6RGJKRVpmNDRhWVcwMHZmQkNSR0ljMGsyVlZyZ29xcU40NVphb0VCRG5ISGJRaVV5b3p0cmJqOWhFaUZsaTRIeUhPRGxaVU1kZVd4ZDFTZ3FCdzZScUhmTVZnZEdLd010TVFxQStJN29JR3FGbzNCblowcGYvWVA3MVd2NzA2K05OUDh2KzgwK0xreVlDY1c5bXdKZExQTFBJeE5ReGhxWUxRSTJQajN1eDZaUXYvMDgydjR5dTBaSGMyZDRwT2RlVTVBdDUvcDN0LzgrT1pIUC9sOC93ZlNISG13aktyUU5LczBDaS9CaE4xK3dIeWljWEJrVUZuQXhwZ1c3MlZHdDdISUVWMDh2QU9La3ZIbXpqSEt0WGRoL2JtUFlkQmZoWFVObkhjTDcvWjVNVU5abGJEV2dwU0M4eGJNVE5ZMjFEUVZyNjV1REsrLzYzMHZYTHJ5MUhPWG5uaktGY1ZzZnJCM3I1SHRGMmtTaEpnalJqYXp3RmM4Y0JBWW14WllkWUNPeGIzY2tUOEF3dEhTQjdrY2xIMGFDV3dIdnROaTVSRFIraXhHL2JvbUFJTUVhcU1MQnFPcGEzR2dWUnJCZTFEd1NOSmtvZDlHakcyeVBpQUQ0MzFiSzlqSUV0emNIYUdUWitqblJrSWtvN0dGSnJGMEFnRFhlSFFUalc1QzJKL1hlSE5jWWIyYjR2eGFCMGxYSStsbzVMbEdWUWRVRldPNEtzazF4d2NpaFMycXlLbG5qa1V1dWUxWnJvVXJUMWc4REpyQ2dSMlFkWFFFSStXaG1lUkNobWxESFlKbmxJMkVRN1JZaE5HRVhtNlFaeHJIb3hwbDR6R3ZIVGd3TnZvcE5vWkpqTTZTME1UR0EyVVRVTTRDMzc0L3hlZSt2ak83Y1RENzliSEdqKzgxK0t3VDlXTjVTay91bDRzY0FQZTB4R0JOL0g5WS9Ud3loZjdzaFI1OTRlWVVsUTBxOEFKdDd6RFErZmk3VnM3LzhDZlhmK1M1WjlMbnZRb01yOGcxQkJzVUhCU3lUa0MzRXpBNU5wZ1hHczdLL0MxZUNaTFhYUVZHRXdtc2JCbkJBNVBDNGRaK2dSMGVJRjIvalBXTmMrajNWNUNtR2NCQXA5T1RsdFlMQjkxWks3TEd1a0pSRmJEZWtXc3NPMXZUMnVhNUN4Y3ZYLy9BNWF2UFhOellPczlIQnp2VDJYUnNXK3dvTWs1VVpJZStUc0NOeU5uWlZFQ1hzQlFhSWgzNGdpVFRYbTZwd05XcFdSMUx2My82QnRDeDBHMzBWZGVKQnEybjhKb1J2SmdzaWk1ZWcwT0FVZ3BHb2xvalFRWXhuTUZqSzAzd3Z1MGhuSE80Y3pCRnY1ZWpreVVnSlJiVEVtSWdxVE0rMmtnRlRXRDI4RTJETzlNR1krdHgvY0lBV3hzNVNFdFFnWGRTYkhsSFkzSmtVYys5NkJRaUNoaHQ0bU5ra29xbW4vSEJFcVdpaU56NE5GUENycU9vSlZCQUdyM3hxbG9NUWwyUTlXR1dTVkJGb2tpU2QxeEFWVHI1MldOZ3BMVUIzU3hCb2dYVnR3Nm9Hc1o4N3ZIYTdSRys4UEx1bTY4ZHp2N1ZIdmovbURpMEpvN3pNOFFwSGdDbkJPNW9jTVBBUFB5SEYva2pWZWczRHlxYUZJNENzK0tUdHIyamlEcC83U1ByNy85ckgxdjlHL21RQndBQk5SRTg0QUtCUGJBeURFaFN4bmlrVVpVRTF6QnNJMklEdjlUYmNvelZiUndqT09CZ1ZPTE9oSEUvZEhCWVRER2RqWkNZRkt2RFRmUjZBL1M2ZlF4NkswalNETXdTbXFpMGlkRkMwdUkyVFUzQk95cXJnclUyK2NibSthZlBYN3o2L1BWbjNuZnUwcFduMG1JMmFVYkgrK1dpbnllcDRRRHNlZUJyQUk0SXlBallqdDIzRkYwOHpNT3BOcDBlVXVCdGtTOUUrL0hWZm4zN2tOQUpRYThtQ0ptQzh3N0tKREJKQW1XTXRLTVFUQVBXaWN4V3hhS043ZnlsUE1YVllSL0gwd0w3a3hMZFhnY3FNZkpBWkdIT1pZazhKRXJyVVh1L01MYzRtbGFZV2NaK2FlSEJ1TFRlQmJHc1FJMFd5K3FtQ3BnZldzbGJ5eFNTVk1XQzVvV1poK01GaDBlWWFrNWFjV2hDa2lsUUloWlFwTnQ4OVBoenBjTGdxNW9nRDZPNDNVaVVzQUViRjFBM2tnbG4zVW04MWJTdzhBSG94V0lQREl5bURiNTY0NUEvOStyZWwxNDZuUDJUK3dFLzF3VHNrWnplczRjbzBBSUFyQnJDMEJERy9vK3ZmaDZKUWxjQTVrMGdJdEtCSHdEaE90ZTM4dFVmL1o2TkgvalF1enVmOUJ3WXRZQndkU05hYzIwWUsrdnk5SjhlYVRTVmd2VzB5QU52VzFjRUFlVGFPSi9HTW03dnovRm1tYUxzYjBPbE9hYlRZeHdmN2NGWml5enRJRWt6MFgzYkJxUVZoc1AxV09BT25ieUQxS1R3d1VmWFZTTG5MS3h0dUQ4WURpNWN2UHJzaGN2WFhuanFtZmRkdTNyOXVYdzZQaTZPai9ibUFJSVVPMmtJamZuVkFMeE1ncjNsRFBSVTlGUUpTOEk3ZGFySWFZazIyTDdNcWQ4amt1OUNCdEFHMEJtZ0J3clVFWE1NYmVSUklJeEJ0YmhocUNXR3BJbDhQODlvckVVSGpQZHNETEhXVGZIbTNnanoybU43clk4a01jSkhqeFJaSDhTY29YSWV0Zk9vRzR0WlVXRjMyaURycE9oMk5HNGVGTEMxeDFZM2s4ampqa0tlYVJTRkY3dm5qdVNidDVub3dUTzREV0pRY1c1M2pLb1dnMFdPRW1VVjdhNmpmNGZnRGtiY1ZSSC9Ick5nRVlsUkM5cGxjT0tXYTZLL1c0aGJDSTZBYWxtSk4xMldHY3htbGovLzJqNTlhWGV5Ky9xcy9ySDl5djhibHVJdVRzM2o3U251RFlseU9UQzRvd2hHL2ZHYzVJOVVvVWRidjJWT2V4WUx2ZnZwOXcydi9xMlByLyt0dFRVNkJ5YVFCWGtuUmU0OTBPMEhaUDJBNmRoZ1B0Sm9tcGlqMVo2RVVmd2dvRnpNMXdxRThkemk1bjZCK3pSRUdHd2pTVHRJa3hUT056ZzgzTUZrY2lnNTRVckJlZ3Z2SFl4SmtXVTVqRFlZOUFib2Ruc3dKa0dlcHZKUWtHSWhMNEZhMU8wTitxdnJXOWN2WHJuKy9MdmY5K0VyNXk5ZXl3LzI3MDJuaytOcExIaERSQ29BaDA1Tzk5Y0oyQ2Q1MEdVUmlJeG0wVytkMzJtcFZRK3RaNXVXb2tZaVZGalRBVXdHcUJ5Z3JDVkY4MkluM3VyYWVjRTFscE5PYVIyOXl3T2M4MmpxQnBmekhNOXNES0VWOE9iOUVVQktDajM2cmpQSnpyOE1JbU9WZ21IVTFtRTByVEJxR0ZmT3JlRHA4eXNZRlJhdjdFd3hTQTB1YmZZV2ZtdytBRHBWQzd2cWRxeFFNUnhSa3hoSnNJK1J4eEJubHl4VGtpMGZTWXMrZ291a1R2TGZmQkRWV3lkVGl6ZVJFTzJsb3dlZzZDWmlxRU1RYTJzVlJUQkY3VENhMW5qeGNJYVhpOGFQdFA2bDQ3bjd4YVoyWTV4UUhVN1RXUU1BempUeHdCQUtML3Z4UDg0aWZ5UUsvUk1mL3podTM3cEYwVjZ3QmVFeUluUlh1NmI3TnoreCtZbnZmWC8vaDdSQkFnOWFST1kwOG9IMmh3R1VFSTcyRGFxWkdFMklWYStnNitJWVFaRVpGejl3Qnh5TUc5dzVxakhLdDVHc25rZWE1Tkc5UmQ2eWNqN0ZhTFNIcXB3alRUTjB1d09SR1dxRExNM1I2WFNRSkFrNmVRZkR3UURkVGhkYWE2UnBDaUpRMWRUa3ZlY1FBbVZacHp0YzIzank0cVZyNzM3dkN4KzVkdjdTVmJPM2Mzc3luNDVuOFdiUUVHQjhKd0N2c3J6dUFMakh3SUVtTXYzTTVKMVU2OFFvOUZLTjFVNktsVHpCU21iUVR4V3lCTkFKd0ZrczZCUlFxYWpjS0E3NzdRTWlzT2k5T1FReHJOUWFLa2pnbkNJaGhtQ0pIbHJWTmZMQWVHNXpGZHVESEVWbDhlYmVCSWt4R0haeitlUUlZS05RQmthSTJlUUtyZTEwZytOWmhieVQ0Y2xMcTloYTZhS2JLT3hQYTl3ZEZYaGlxNHV0bFk0NHljYUhFRWZWSVFjeGpSVFhsemFaRlF0UGRtT2lHVWZFRWdJTEY3NlZqSXBqSzhkQUNma2FIUXU3S0oya3BFVHFyN1BTMWlzU0c2OFFhV2xhaXliaGFGeGlPcmM4U3pSTlUvM3kwYmo2SjhjSDg5ZVpNVDlGWnhVU0RDRVlXWlJ6bXoxZmhUK1pPbnJiRi9yVko1N0FiRHFsdXFrMXN4UTZFWEl3ZWg5NTEyRHI3M3p2eHQrNmRpRjV4a2NtblBSU2hHQ2xGYzNYR0UxRm1CeHAxSTFhM0FEZU0wNE1rTnJUUWFJM0dnL3NISlc0TndtWWREWmdlbXVpOGxJR1dxZlFKaEdqU0c4eG1SeGhmTHdQNXhwa2VROVoyZ0hBcUtwU0RBdVVYbWpjRTVPZ2syZFFTa2N6UUVXcE1YRE9zWE1PYWRidHI2eHVYTHQyL2JuM2ZPakRuM3Bxc0xLR2UzZmZtRFoxMmNRSjNvQW9CS0lqVDNUSEFTOEg0TFcxWHRxODU4TEswNWZXZS9sYVArV3RRVVlYaGgxczl6S3M5MUpzREhLc1pnWjlUZEFJS0JyRzNFcS9yNWI2ZldvNWx2RXNNOGFJMTdrRWdFVkxLR25yT1VZT1dXdFJ6MnVjeTNJOHVUN0FzSnZpWUZyZzN0RVUvVzRIL1U2R1FJRFhKTEF5aDVoekZyOWZZSlMxUldVZHJsL1p3TVhOQWFyYW9aTVlkSTNDL1ZHQld3Y0YxdklVd3p5Uk5SNUhnTTZLU0VkeTRVNzg1S0loRHlpNnUxQTh1VnNnSXpBdGlsdDRGRUNTRUxvZEJVT0VzcFJSejBBTUxwTkVDNkx1b3c4ZUFSVGs1MGlVUW0wOTVtV0RKRFBZM3V5VFN2WEI3cWo4bVZ2M3hyL3BiSmd1c2QwV29Cc2h1b0ZMc2hNYy84a1YrU05SNk5ldVhxWDdPenRvbWtiRlFrODFVU2ROVlBxREgxcjc0QTkvYk8ySHRlRWVsTVI0Q1N0VGpwQzB5MGlHd20yZmpRd3FTNmdkaVQxSHBFV0dscm9aYURGN2pVdVBPN3N6N0lRK211RWxtS3dqSFJZUmpFbWhkQUp0RExLc0M0QmdteEtUOFNGR3gzdnczaUZMSlF4QUpKVU80K2tFempxWXhNQUhRWm9iMnlETFVxejBCOGl5bEl4SnFKT25uQmhEYWQ0ZERBYXJWOS85YlI5K3ovcm1lWHIxNVMrL1VSV3p0dFhEQ2VCT21rbTVicXF6bFlTZVR4RUd0bTZnaUdrbFQ1RXFCV1VVc3N3Z1N4TVlJb1Rhb1p4N3pCb0lsOEFCemtWK1A0bVRxWTRzTksxSVRDbWprWVJTT2xwU3k3UEJXNHZKdEVMaU5aNVpXOEhXSUVlZWFOdzluR0kwcnpIc2RhQlRneUlFVkVIQU9HMTBOR2xVNkNSaXBUV2VWeGoyTXp6MzVKYnMrU3NIS0VJbjFSZ1hOVzRlbGhqUEdseGQ2NktiSjdCV0RCOHBoaDlDU1VJc2UxNkVLQ3dFSmZva2hDRkU4Ym1QQWdDT0Q3YzBWY2h6TGVJVHg2aHJjWDVkNlNkaTc3d1VJYVdKWUNMenQyVUxNakVHdlpTVDNHQU1ydTlOcWw5NDllN29YOHptelI0ZXRINXlSUENraUpQTVFMbkFUUGozSXNEOFVhKzN2VXhWR3dOcjdRSkRJb0lPelByeVJ0NzU1UE9Eai9TR3RPWTVNQkVwdGdLeU5FNzJ3UWFNVUJCOFFhREFDS3hnd1doaVpoWkM5RzJQdGtLYUNCWVNRVHh2R0hXNmdxUTdSSjczNHBHbjQrRW54Z1kycXJYeXZBOHdVQlVGM3J6eEV2WjM3K0RDeGF1NGRPa3A2Q1JEWXh2VVRZVUFScHFrTXVPU1Facm1nSkl3UmlreVEwbW1rQmpOUHJDeTFwOW54cUNwS3YzYzg5LytudS85ODMvakE3djNiOTM1MnBkKzUvN04xMStjVkZYcHdjeEhSWE83MjAwK2E4NnYvR0RhMFoxODJyQ3VBZ1ZJc0hhSXZ1cGFDK3N0QmFIRGpFa3M5TmlKbzFZTTB3SnpLaURKR0VZRFJpbXdWZ2pzSllBQlVibzdkMmhLNEltdERqYjdPUkt0NDI3YlFzZjV2ZzRCYkFUWUlxUEJKRlRVbklBdHJiRXpxNUNrQ3RjdnJxRmpGR2FORi85NEJzb2FtRFlCSmdIZUhNM3gyWmYzOGVlZXZ5QTNRUndIeUV1SUpNZE5DWk9BZzBySCtkMHQ3U1NqUXduSHRsMXJMSUZ0SE5kNG9oTlhpUUJ6ZzQ2R2R3N09pbVcySjBMVnhFZ3NGbjdtc0ovemdmVzRNUzJ4WDlTL2NYZDM5cytQeHRWOW5HRVd3U3gzblU0MSs4ckpTaGVQQzEwWWF5ZWlXeEZCS3VKbkwrVG5QdnBzOXp1UUJLTUNnUnZBV1VMVEtISHVTQUpVSnR6MmVhbGhFYjIxb3ltQko0SW4wVWZyMk1ZNUFpb1Fpc3FpOEJwTnJ3K2pwRVVuQ1A5WnArTEF3dXpCemthWm80ZFNrbkRxZklQNWJJclhYdjVEN08zY3daV3J6K0xpcFNmaFFrQVo2YlBCQjNTeUhIVmx4WnpmTmlpckVxazJHSzcwc0xFNlFHNFM3TzN1anU2OCtmTGU5c1hMSC9qRTkvM1FwNzduMDMvcC9ZMzE3cS8reUg5UjdlM2N2dlA1My8zMUYyL2ZmT1Y0Yi9kT3FWZDJNWGp2QnZxVUlYbHhIODEwQ3E5Rm93MW1jSXcvVm9sR2xnS3BqYTBwVGxwZE1TNDhLWHlhaTBWMmtuaDVQNVZFV3ZnQVZMVzRuMjUwVXB3ZlpEQktJVFVLVldOUlZBMVNyV0VpS1VaRE10YURVcWlDOE9MWHRjWjRXbUZ2VkdKdHRZTWtTMUUwWXZwbUVnMTJBZnZqRXZQYVJWTlp4aGZ1ajdEYVMvR1JwN1pBT29ZcFdnbGtRS1RNdGlnNHgwZ3JIOWNyaWdoSkMrS0Z1RnMzMFR1T0dmVThvS2s5VktMRWxobGlkVVVNcEV3U1BVMVJBQk03UWFzWVBsTjhZMTdnM3J5WlRrcjc2L3VIeFQ4NU9pcGV3MFBNSW1KM3dSd1l6WjlpSGIzOVQzUXhNbHlzaUJsQU4xVjQvN1hlRTJzcjZqTDdpQXNIZ0MxZ0t5Qllnc3BsTHJNMW9TakZ6TTh3SXljUlNNRHpJa2tsalE4U3kwQnBBeWFGd3h3cFF0S1J0SmJnRWRnaEJQRnNTektoYUJxVGdoRVFuRU03OFhNSWNLR0dNUm1tMHpGZWYvVXJPRHJjeGVVcjE5RmZXWmU1Rkl4NU9VY0lIdGFsQ01IRFc0czZCRXhtZ0xVT214dGJHSStQeThsa2RQa3YvY2MvK3YxUFBmMzhFMnVydzd3b0s2b3FoK3RQdmVmQ3RTZWZlWisxemhYRnJMNi85eFY5WEh3OW43MzZOVXhuOThuYkdoNnllUkFHbXdHZ2tDWUowaVFCS1ljRWdHSUpnWHlBTGJkd1hJazBZUWRVMVlrMVdYUmNoaUhDYXNkZ2tJclRxbUpnWERhb0dvZEJ2NGR1SndVU0thNnE4VkNtMVhrenlzS2lyRDI2eGlCVkJuVXRVNG5Ta2hicm5NZGhVY042aHRZS3lnRE1EcDk5WXgrcnVjRjdyNjdEeDloY1VQeDdMR21uYVNhODlNYUdxRk5YU0JOeEQycjE2aFR0bUlsbHp4NFV3M1JqTEJPQXBoTGZlMUhyQ2VGbVZGckpxdU9BbS9NQzkydkxRUlBQWGJnekwrd3ZIQnlVLzNJMnEyOUhLL0JpQ1dIM3A1akxZb2I1dU5EeE1MYW54TXNvQld1ejgxKytZVXd2QjRZZFJsOHpmRFJyYUFQUzJRSlZvVkJiUXJEaTY2NEFaTXhJR0tpWjRlT3M3a2o0MzFYdE1TNGNDdDJIU25MSlFoTkRhV2d0cm1WTk9SY1VPWGdZbmNiMUV5Tk5PZ3ZlZS9BT3BBaE5YV0ozNXhZT0QrNWphL3Npbm4zdUJXd1F0YWk4QUFBbGNrbEVRVlNzYm9rd25SbU5iZERZUm15UVhJTzZxVEV2NXJBQjJEczg2bi9nTzcvbkk4OC8vOEdObGVGRzJsaEhXaWtraVVLU0trVklPbG9ybGVjYjJOcjhjOXpZajFIOTFDSGNKMmFZSHR6QjdhLzhCaVo3ZDJDYkNwUDl1emplMjBOWldnVEwwYUJDL0xGSktjaWphbUdXRnd1ZUh5aitGc3hxSlpkR0U5YTZLWHE1UVRjMUNNeVlGRFVDRVRyZEZNT1ZETW9vZUI4d3J6MEN4TDIzNW9EU0IyeGtDWVpaZ29vQ2JGeDNlU2YrOWtlekJydVRCazBBREJNTUU3SXN3SkxENzk0Nnd2blZMdFlHR1VMTGZZak9yaFJKTXd2cmp5QXRCYk8wOFQ0d2RDcDdjWEdFalRNeUViS29YM2ROV0lCN1plMmhqSUxLRmJSVE9KNFV1RGt2Y2F1dUFhMGNOL3pWOGJqNW1lTlI5ZHQxN1NlbkZHZ1BNTjdPdUo4ZkYvcUMxdWtjS2FXV1kyYkN0SEx1TTE4NS9vUE4zdURvMG5aMllUWFRZWmhBd1RNU3hVZ01rQldFYnFIUk5CbzFSRWZOMGRVMVlVS2p4SmFtOG93U0JIS0M1TTVtRFdaT0I1dXRnRXhLSEVMTVh4UDdVU0tOQUMrY2IxS0xHWjhJNHJmT0FTWkpvWlFSUlZqd1NOSVV6bG04Y2VOcjJOdTlqVXVYbjhLVkswOWpmV01idlc0dkVuUnFZWEFGRDRLaDJYU0MzbUE0Mk5qY0hwaDhCVVhWa1BWQWxpWVNIRkRXbEJoTmlkRk1pTlRQdEl0K3J3OUZoUFdyNzhiNTkzNE1vU25CdnNIczRDNTJibndWMCtrRU8yKytpdHUzYm1GM1Z1TCt3UjdLcG9ZSkFjN1poZU5zaU9nVE00UDU3TWV1VWNCS3FxRzRsWFFHVE1vYVJpc011cGs4VkZWRXVUT0ZtWk9IaVZHRTBrdWtjNmVYd1B1QXlqcFFsa0JEWktOdmppdzJMajJGQzVsQjN1bkRKQWxlL3ZMdlFLSEJYbDNnTjIvczRmdmZjeEdkVkhqcldhNWk5eUYrYkxDQzAxZ1hrSkFTeHlBWC9mU0NpR0VDaTBxUmlKR200Z1BuSGNOYnNaUnk3V1ltTU1yYTRjYkJCRjg2R0tGVXhFYXA0RXIzaDBkais3OGRqNnMvOUlIYlBmbFpKM240c3l6eVI2TFF2ZmN3eHFDdTY1YmY0aG5BNi91emwzNy85YVAvK3ovcW4vdTdDU1B2UUlWVUVkVVdOS3NaOVZpSzIyU0FUc1NoZ21LYUp6c3g4RE1hU0kwNGYxakZzR0NNUzQrZDhleitUaktaYlcrYVMxbmU3VHBiZ3puQWUwZXl3MnNqbER3b0VKVFNNRHFMZUlJY01jRjdjSEF3U1FaQVEybUZMT3ZCTmcxZWZmbkx1SG5qUlZ5NTlod3VYTGlHSkpNQzdYVDY0a2hxRWlSSkF1WkF6aldveWdyTUFjNTdPTzhFQlk4N2ZhMFZwWWtCSTRXUHVXemFHQVF2OXREYTVPajBWekhjdm9xcjcvOGVBSXhpZklScWVnam5QVWJqWTB5bkl4d2Y3T0wybTY5aU5wdmk2UGdBUjRlN3FLb2F4WHlHRUR6cXVrYndIc1pvdUpoY3VKRVR0amRYMGM4TWlCM3FtbEZiUnA3blNMTUVlYWVEeENqTVhRQ0JNTkFFaythWXp5cjRMSVVhOUxGeStRcFdld05zcGl0SUI1dFFhWTZnTWx5akREcnZZWHE4ajd1M1hzZkxMMzBaaldla0NhQjB3TmYyeDFoOVBjWDN2UGM4bEJaY3BwazcyTW9qeWJWNDM0Y0lyREhFVGlvd2VscUlOeURBeHZ3MnhZQnRuT3pYalJMRkdvdGhCRUFZelJwOGFlY0lyMDVuWUsxQklKcVA2dVBSUWZsTGs0QXZNck5iS3ZMVEovbWZlWkUvRW9YZVNpQnh3bFoxek53Y0Y0MzYzSTJEL3pObGYrNnB6ZnhUbThOOFpidWZkVlo3Qm9rbVNTSW1JbXNCMUdGQnBRMnRPVitVSnZxWTJzWkI1c2hKYWJtczdWZGVmdVZMUDM5NFBQcTJKOTcxYlIvZnZIRGxpVFJKQjhFN1dHZloycHFZNWRRTDJzU1ZtNGwrWVczaUg0Tk1HazM3L2NLQnhTUVpsRGJ3M3VMTzdkZHcvKzVOWkhrUFc5c1hzYlYxQ1p0YjU4R2t4R01OUUpaMW9KVkNWYzdobklXek5lcTZScGJseU5JVXpzbE1YOVUxRk1UcXlRUkdZZ3lJTkt5ek1FNkRPY0RXY3dHWDBoVDUxaVVFWm14ZnVpNHJMeGFzd1hzUEg5ekM2WFUrSFNNRWg5M2QrNWpOSnVqM2NzeW14MGl6RGd3OHpnKzdDT1VjMWRGOWVCRE9UK2RnTUhyZERremVBeWtqRWxpVHdTUXB1c050c0VwQXBnZVQ1a0oyVUFwVlZlUGdjQS9qNlJqejZRZzNYL2tTYnJ6NEI5amJ1WVhKOFgwRWI2R1RJSTR3RGdqczhlWGRFYTZkNitQcHJaV1lyOFl3bVlaT1NCQjBqN2diRi9aYkZydUpwdllnRWgxNmExM05UVURXMVhBK29HbFA4OERZbXhiNDNOMUQzRzhzeU1qV1lqS3EvUHl3ZnFuMi9QdE1zQVFVL0ZidzdiU0lFSThML1J0Y0lRUTJ4clRUbG9kd0N4b0E2dFp4c1hmdnFQaWZlcHIremZsZTh2SHpnL3hEMit2NXhvWE56dXBhSjAzV0JoazJoeG1NVWh3ZzZDa0VmQ0xSTENPMmFNRGNPajRjMVRTYk5aUEtoZGRDQ0RmMjd0eDRkZi9lbS8vMjNPVW5QMzc1cVhkL2FyaDI3a3JXNmEra2FRZkJXNjZxR1p4dEZybkhSSkpVb3VNT25abGpLa3dUeVNFZVFYa29FbzA4TVVEYW9LcW11SFh6WmV6Y2Z4TmIyNWR4L3Z3VjVIa0hBTkR2RDdBMlhFT3ZOeEFXV1RsSDRCb1UyZTAreU02WnZjUThkOU1VeG1oWUw1bGVyVjBTeDVnZktPbEV2SE9veWdZTUlFMUVuS0sxRm1SZW1iZ3pWbGpiT0E4aXh1YjJsVGl6TS9JOFFab2FlWmpFckRVWElPTU1pK0JqWGxTWXpXc0E0dWZ1dlVkVkZRQVkzVFREZERiQnZidDNjWGk0ajhua0NMUHBDTE9qdTlpLzl6cHUzMzREQjd2M3dMWkd5L3BQVWxvUSsxdUUvYWlwOEtzdjNVY0d3b1cxYnN4VEV3cWhqd3ZaSUdMR0JmSWV1RjNEaVQ1ZVI4ZFdaMGoyNTVGWlp4dVBOdzluK01MZU1ZNmNoMGtNa3NTZ25Edk1qNXBEZHVGZjE0UmJZTlQ4WUx2K2dLLy8yNGxHL3JhK1B2YXhqK0d6bi8wc2FhM0plOS9DeHdiUmRJS0owamhFcmhuZ1doOTQ3MXBPSCt3bTZuSnU5TG5MNXdiRHk5dTl2SithYkt1ZlkyT1lnNHhrWWRXQlVaVWUrMGNWN3U1TlVaUzJtdnZ3MlJlUDVqLys1cWg4STI2R2F0bmYwN1hleXZySG5uajZ2Ui9ldnZUVXRiemIyeUJGR1FjSkxHd1JkeUtDVGxLWmNSa3dKb2xvc2hIeVNiUnhGdWFXRkZiTDlIR3VBU21OTEJYMm5OWWFhK3ZuTUZnWm9wdDNzYnE2RG1OU3BLbUJNUWw2WFNIeUpFYkhPVjlRWXFNSmloVHF4b0tJb1pTUVFYVDhONzEzY000akJJL0VwRWhUY1lPbGlIcUhwZXh5QWUxNHdRMEhDYXRRUjMvM0xEVklqSkt1b3JHd1RpeWdxOGFpS0FwVVZZbkpkSVRSNkJESHh3ZW9td2FUNlJqVDZSaDFVOEg0R2xUc2c4b2pZSDZBRy9kMmNPZG9CcFVRb3JKMGtiZldldCtSZE5pUm4wNzR0bk5yK083cjU1RnJjWWd4Y1QybUZTR0xMb29VNDVLZEYybXRUaFJjN1lVWnFBaTFGODJEVm9UUnZNSHJoeE84UEo1aUZ1UjkwRVlqTUdILzdzUTI0K3BYUytCL3JCaDNZcnMrUDFYby9IWm8xeCtwUW04dnBSU0ZFSlpWbHEwbVBZdUh0U1FlZ0ZNdzBoVFk3QkNlVFJqWGVna3U5UkwxcnJWKzU5eVZjNE9WcmRXc2wybHQ4aXhGVVZqY1BaaGpYTlI3cFErL2ZudGEvL3lOY2ZVaVRsSXFpVWlSUkxHd0FiRFo3UTgvZFBucDkzeDRZL3Z5Qy8zVmpTZU1NUjJ0a3piRG5IM3c0QkNJT2NDNVJnTDhqT1IvNmJodmx4TlVuRmNXVnMxYVF5c041MndFOWxoYTZoQ1FaVG02dlFGNnZSVjBPMTJZT01ldnJhMWpwZGVYK0dXZElQaUFORTNSNlhUZ3JGdHd1dk0wUlpKa01nb3BGYjlQZ3lTVkFNVkV4NThyM3A4YzdabEFKdzR5cmQxVVlLQnhvci8zM3FHcFM0ekd4NmpLT2FxNmhnOFNMMVVVY3h3ZkgrSGdjQTlsVmFDeEZZSnpVR3pSNVFvOUtwRlVoeWlPOXZIcS9XT1UxcUwwVnNoTUVRVHpjYi9QY2ZZeVpwbFFJYitmR1lNUFg5akMrODZ2SVVzVmtsU0x1Q1ZLVC9OY3BLTTJXbCszZ2JXS2djYUpIcjZsU2U1T0szeHA1eGgzaXdxc0ZSSXQrSW8yaGc5M3A1anR6KzV3d0g5M3pQaXR1RWFiTGpQZjNpNHorU05iNkZwcmlyRzdwNVdYeXlrdDZkS0p2ekFFSldEUTBiaVlCMXd6akt0clBYVnVrQ1lYKzVtNXFJMm13SmpPUGYveVZ3L21QMSs0Y0l3VGRWSDdkRllBR1FtSjRGYnR1ZDd0cnp4ejZmcDd2bnQxNDl3SDgwN3Yrc3JhZHM5a09ZSjN6REVpT0FSSDBUNEtJVGg0N3dBQzByUURrRjRJUkFBNS9aWFNNZWd4SUVUYW1sSWFJQ1ZGN3oyOGQ1Rm4zcURUNlNITE1saG41V0doQ0ZtV1lkQWJnRWdqeXpwZ0ZqNUNsbVVpb2UzMG9MV0NWZ1pKa2dMTXlQSVUzc1ZJWmdncTdYMUFFNUY0MFl4WHNJMnNBTXRxRHU4Y3lySkVXYzR4bjQzaFhDTU9PMUFnWlFDZGdMMUhudVZRQ0VqdElWSS9RN2NaSWJNVEdISm9Hb3ZYZHliNDNKdEhnR1prR290WXFaUE5TMXdGSmxGV1N5ZXZtSU9KZnByaUUxZk80ZW1ORmFTcHVNc2tDa2lpTEJVUUcyam5XcTFEZ0VsbDVQQkIvdnR1SEU3eHBkMWpIRm9CSFRVcEtLMlFwQWJUY2MzSGR5YVd2UC9aTWVnZjJzRGpXT1R6SlFEdWJUV1hQNnFGRHUvOVdYSnJmY2JMbkhxMXkyRURvZ3pNQ1lEQkJ1RnFxb0VzTjdQN1pYaWw5bUVTMTh2TjBucWtQWERiZnpjRktDVkFzL0RPaHFUVTB4dm5Mci8vMHJWM3Y2czNYSHQzZjJYdGNwWjN1NUxHRWFTNEpRK1pyS3ZoYkExU0FvQWxKb1dPb0oxV1NsQjZwYUdvalF3V3hKcFVHN2pZSnI1NlZPVU16SEtTZTI4UnZCVXd6Vm5KRU9Qb25Fb0twQlJDa0pXZ2lhZTNqcngxQnNHWVJGeGVuRi9RWWhoaWd5eVlnNXpvN1lsdlhST0xNV2FyUjhrcHg1UlRBaU1OTlFhcVFtb0NLTlJZRGNkSVllR2FCbFZsUWFSUk5SNnY3WXp3OHU0SXJhU05ZNmtveEtqMU52WXBPbVdRaXY1MzFJcHlSQ1o2cGQvSEp5NmZ4OWF3SzdubTBZWkpDQytTTTI5ckJxbFlqWXFRcFJxam9zSFg5OFo0OFhDTXVmZElraVJtM3hGTW1xQXFIUi9jSGtOVjlnOEt3dCtmQmJ5RXM3WGwvSFk3eVIvVlFqLzljNS9scjdEc3NxU1hUbjZ6OU9jVVNYYlJmZ0JScExnbzh0UGg4dTMzV2U0Z1VpSkttYUZGNlkwRXdOYksrdFpURjU1NDVrTXJhMXNmU3RMMGVuZXd1cGxrbVNTTWdwZzVjUENPUUVUZU42QzQ0eWRnSVFsdEZYSmFTN29xWXJ2ZHJ1OEVGQ05ZSytrZ3hxVEM0RmFpRlhldWlVNjFGYndUdHlyaXlPdVBQRkVpQlE2eTk5ZEp1bERqdGRpQmlta3N6Q0hPNy9LOWhjTWVFOCtKUUtSQkpFYjQ1QnFvWmdianB1aTZBbHQyZ2w3WFk2WThtQU42bVFFQ1lUSnJNQ3NzRkJqVGVZMnYzaDNoMW5HQkxCRzlmQXRVNnFpZmp6YnlJQjM5N1pUTTZMcDlXQ2tsbm5hZThlemFLajc4eERieXhFaUtEY3VPWE11VEdhRFdlMEMreDNGUjQ4dTd4M2psYUlLR0E3STBoVFpHZ0VtalVEZWVEKzdPUUxONjF3SC93ekhqTXhGOGExdjJlbW1WaHJkcm9UOHlWbElQQ1psYUJqMldmUkg5cVpjNzFZNjdwUStuL2ZObXFRVTdUWFlJRC9tM1k3dEcwUmNEODdvczdoenUzUDc2NGM2dHJ4V3owY3UycWQrd2RRVlNhcUFVWmNwb010b1FRS3lVZ1ZLeUMweVNETnJJbksrVkFTQnJPVm5QQmNoRGdVQktMNTQ5V3B2RjE3WW92R1I5cTVNSEJFaGt0VkVydjZDTTBVbG1tbXFscVVSUmJ5NVdXRVpwcUJnNEUwRHdwQ1NNSUFRUUJ4aGZZVlZWT0s4bTZOWDc2TXp2WUszWndSQWpETUlVM2FvRWg0QkdLOG1BMXdxKzhaalBHbFMxZzIwYzlvN25lUE9vUkdWUGlEbGF4eE5iaWNCR3FaTk1PVEdMb0VXbXVUWWFTUlRyYUsweGJob2twREJNMGhpeHhISDhGdnhCSlNMRmJXekFtNk1aZnVmV0x0NGNUeEdJa1NXU1UyKzBnbFlLODduRjBjNGNldFk0TVA2Zk1mQnovcTJrbU9XVG5OKzJCeVhlR2RmREN2NkJ3b3plOTQ1T2l0bkdBcmNrdis5T0ZUTGp3UXpxc1BScit4QndTdzhTVDBRTW9QYk83cytub3hzSE83ZStPam5lKzRwdG1sY25SM3V6cGk3bXBIUW56Zk5PMXVtUklnVmpNcEJTckxTQlNUSm9IV2QxZFdMbDZHeE56TXhhR3lJUWN3akVDTEhGbCtLV2RqM0k3S3FpQTB3UWRMMHREazA2TXZkVWJMQVpQdmc0V2JUL2NRcU9sUlEzUzdTVDVGNlYyS0FKTHFWVGJEWUhlRkx0NDduT0VTNmJNWHJOQ0dFNlFzWVdaR1RWeHc2WTFoNHVBbU1taUlmOGFGYWphaXhHa3hLdjc4OHdqZjdySWVxeVcyV1psb1dFdkNEdnVJb2pUT3NXMDZvSjVjR2s0QUFjVncwNnBKQXBEUjhDaklyY2RoSm5uSU41Z3kvZU84SlhEc1k0cWhzWWt5QkxNNWhVNU1kRUN1TnhqZEhlbk0zY2tnRStPd0Yrb2dKT3kwN3RLWHJyMi9ZaXZMTXZvZ2ZiL09WMm41Wjh6MCtjcGVLdk12b1J3b090eE9sL1E1K01BZ3Q4SUpIV25wS0kwcmZ0ZmdmQWNEQmNXMXRaUC9mOFlHM3ozY09OY3g4ZHJtOWZTOU91NktyRm0wbkF0a1hPbVZCU21abUpXdldWK0l5SFlFR2t5SmdzbnRTTUVFU1htYVFkRUJTc2JlQmNFMGs3MGgxb2xVakxiVFJjOFBDdWlkL1hnb05IcGdKeU5FallvME0xVmpLTHpiU0NyZ3FzNVFIQmVkakNJb3VPcTBtaU1aNWI3QjQzSUVNWVIyTy9wUFlZbHhiVU5hREF5TFJDVVRrY3pTck15eHB2N0UxeGQ5b3NUQllYVCtZWS9ad1lRZG1UUkQ0czF5REdKZ0dVMElMZnJyV0VNMURjTUhnR3RySU1IOTdjd0RDVGs3M1RNOGhUamQxNWhTL2VQOExPdkpKTU5qcDVBSkJXRXFoNFhHTitYSEczOGFTQnIwNkIvM2tNZkk0ZlRMNnFUNDEzL0xqUS95eGJGbHJranBGZXpqZ2xrSS9CQllrQ0VrV0xQMHFqODhxNEFidTNqZ3luRTQ5TzR3Um5nWUxKVXNFbkFES2w5TXI2dVl0WHU0UFY1N0tzZTIzai9KVjNyMjlkZkVacG5UbG54WDRHNEthdWxITTJhSkdnVVR0VEoya1g3RDJDczZCNGV2dEkxdEhHc0ZZSnROR1VwR0xSWE03bnFKc0tIQm9FMVBMZlhEZm9lb2VVR3RHZmswV1hHdlNOaFdFTDEzaGttakRvQUhraXBoUWNoRTdhVkFGNXJ1RzlaS01WbGNQZTFFSmxDbE1ueVNldWNIRFdRK2Nhb1hZd1NxRnFIT1psZ3hzN1k3eDJVSWpUem1tU1ZDejJRSURSUUxjSEpIRmlFZlVaQUszRWxUYnFES0puSzVZVmRsZTdQYnh2ZlIzcnZRdzZVM2p0ZUlKWGo2WVkxVTBNbkZDTERpRXdNSnRaek1ZTnVIS2g1MWtsd0wwWjhBK09nRjhOd0FRbjdxMzFHYWY1MjdyUXpUdTkwRnVsVlVyZzZPY3ZoQXROUExieTJSZ0NCb2tZRlhnR2pDS3NwREdFOE9Gand2TC9ma3Z5MGFtaVh5cDRNZ0RYSWZqNXdmM2IrN2gvKzZ0SzYveDQvOTc2eXRybWUzV1Nyc2FaUCtVUUVIeVRlTzhka2VyRS9YWU9BbmQ3L2VINXA5YyszdG5vYnBNbkp2WkVvVlczYVdRZEEvYSszcjl6aE1POTQ5UUdSMG9IckczbTZBMDFNcTJCVVFHcUcrUkZnNzRpNU4wRVdhcVJraExkdVJiWFUyc0JzRWFXS1RReElLSHhIa2tVaHpnblJCVExBWW9wR25nQU50Y0lKRXBCWllRMVNGcFE3dHZISlZ3OCtVKy9pUnF5NC9ZU2JZNXlEcmhNVHZhRUFCZ1ZJVlJ4L2ZFQkNNUXhOcG9RallidzVud0dJc0tUWVlCYk8zUHNsalVjUnk5NnJVV3Z6c0I4WmpHYk5yQ2xSMm9EZCtWRE9wb0RQejBHZmpPY09MaWVwcmcrRWtYK0xWSG9iWXhOYU5QcTJqYlJMNWtoUXViUVJaSXFHSTBuZU9ZL3l2TWtuRkg4UGhhOFBTbDZOcWVLdndyZTY0T2QyMGNITzdkdktLMVZ0SHRXSjA3T0xBNDZFbHhobUVPeWNYNXc0Y0o3cnordFZvYmJhQUtURHh4cUYyYkhaVEUvbk8zWFJYMXZOaXQ3eHdmenA1SnVtcDY3dW9Iemw5ZlFINlRnSUcyK1grMWcza3RSRmcxbXN3YnJObURnR1pxRjdlWXR3enNQbzBXazQxeEFrb2dJaUdPK2VKSklXUlcxUitNa0JpbEFVbHZxMnFJcEhWaExPbWxSV2h4UFNyeHliNHpTQnFnekttVjVOakp0VDJ4bGw4NEtjQWtqelJrNkU0NjY3Tk41QVNaQ1JUQVNzaEc0VjlmWVAyalFjTlRsVXpRQ3JUM0t1WVd0eEhEQ2VFYVB3Wmw4KzkwNThNOUd3UDluZ1VPY2VMNDlra1grTFZIbzdWVzhoY3B3OHZsVUhxaVdqYnZzdjlmbmQ5WmY4RXZGN21LQjI0ZnYvMG16RHlvc09nSmV4aGswQU0xeDl1LzAwd3U5ZnVmY2VIOCtQNzR6M2ltUGlqZU85NmIzbTNtejc2eXJ5YWhudXV1ZGo1Ky92cjJ5dmJWS3cyR0d2SnVJODIxMFJhVEFDRVN3ZVlvanBYRmNXNWlpd1dEV1lFMHJESW5RMFFwTWtqcmJORURUaU1zTUdiSHRxaXNCK3FwSUwrMGFNZUIwbmxHVkRYemo0UkpKeHprOG11SFYzU2tPUzd2WWsrT0VrZlJBRUFXZjNwOHlZTnAzc3dtQUJyeU9oaE1HQ0ZwY1k0SVN5bHRyWmVXQ0dJcFFBSnhsTkk3aEd3L3JKU2ttQWRCaklJMjRqQU1PU3VBZlQ0QmZkTURSRXZoMldwSEdqOUw5VDNoOC9XbTl4OHMyNjB2Ny9FWFIwNm5mUC8zM0h1RDU5NGI1dWMzTHd6ODNPaXlyY2xMdUJ4dm1JYkRwRGZPckt4Y0czemZjN0g5Z2ZXdlFIM1lUU3BrUkdnOE9BUFV6Y0JxVEFyd3d3cHdOOEZhQ0ZBTXpRdU9nSzR2VWV2UXFoeUVEYS8wY3Zkd0lDWVVCazJweFJXMENBZ2VNS291RFdZM2hhZ2ZlRUk1TGkrbGtqbHhwdU5yai91RU1ONDlMekJxL1dLT2RUcGJoaDl5UVp5R2dLUW0yMGdwY2RHdFpUZEVrSXlhd2VBK3dFenN5amJoRDU1T1ZrenI1VW5oZ1hBTS9Pd0YrMXAyYzVNdXJOUHVRN3UxeG9UKyt6cnhmSDd6UGlaUVF5ODlNVlRyTkFwUndTVUt1dEVxOTV6NEJ3N3lYYnE5ZFdIbGg4K3I2cDFlM0JzLzErNm5KRFlDNXBkQVdWMkFKY3VpSkswN3dvdGxtSCtBYUQyY0RnZ3NpVWZWZWdMTkppZm5OWTNTYWdDdm5CN2l5MGNOYUw4V3dseUZSNHNsVzF3NzNSd1ZHaGNYS0lBZG5Hb1VQdUhuckNMTjVqVWxsY1ZRNGlWMCtkV0tmOWVid0dXOFdUajBNb2haRkNqOFd2WXA0UzRqemZWdlF2RlNTeENjZFJFdTZZNEE4TVBaRVB6OWwvdWxhUFBQUENrRDBqOExPL0hHaHYzM2U3K1g3OVp2RnBwMHU5RGFPcWd2Q3dCaTlzblZsN2RuelQyMyswT3E1L2tlNy9YUkRnK0J0SUFvQjJubFpMN0RNMWQ0RmNEY1ZWMWNYQlBWbVJuQUIxc29jVGk0V3YzV3d6bU44T01YUkd5TzQyaUhYQ3B1REhOdXJYVnhjNjZKakNQZEhKZlpHUmJST05xaVpZVVBBL2VNU285SXVPTWgwYXJDbGh4UXduL0drKzBaRmZ4WXF1dnpyNlVCS09oa1ZXdEMrRE1DL0xJaCtxbUMralFjVmFZOThrVDh1OUxmSnBZVHRSc3dCdkZnVHhSdVl1VjJSdDYzN290RHpickp5L1gwWFBuN3htZTBmN1cvMHZwTjhnTGVCdlEwVWZBQ3NSOG9NQlhHNUZROXlBblVUMlRBNEw2QmtZQVFmNEx5MDhPdzhuUFVJemdNdW9HNHNqdTZNVU83TmhUVE1EREhnVmtpSVVQc0FIMzlBZlFvS29ZZjB1UHlRb2p6OWRIdFlTMy82YTVmL0hYN0lqUFNRcnlzMDhHL253RCthQVMvSHdsNHU4dE5pRlg0azc3SEhaZmEydWZoaHJ6VExFQmwzRDJSbmIxNWNXWDNpMmEyL3ZuMXA1VHZaaCtCOVFCd0JwSGhySjRYYmVqNW1DYWlYUnNxWkVJSVE5ZWFPNVdUWFVhZ2lWa3dNRDVHb2R0ZHpxRUd5Z0FkekVMUVBxSjJIWVVZVzExcHQxcnBhdXJuQ1EyYVdiM1phbjVVVWU5YWJ0VXlCUEVzNnRuQXNPVG1hT1NMUmhRSitlUTc4MkF3UHhCay9zbXUweDRYK05yNWFNMGFPM0R4ZWVnRkFkNUJ6cEtQTEsxTFRsU0lOSHdad0FjRUZSa3hBVVpyQWNZM1VCZzBTQXlwUk1La28xblNiWkVKWXFNMGtuVVhGTkZLaDRMYXBvV21hWUdXckIrcUlINXVQNEZhNldGdEs1OUJTV2NPcE5wbE9GYWQ2Q1BwNCt0VVcrVm42ejI4MjYrRDBreEVMRUk0U29GTEFyODJBbjVvQkw4WGlQbDNrSG84STgrMXhvYjhUanZwNHVqNXduQUVZN2MrUGp2Wm1yMWdYT0RJNUZ6YlNURUF3SWtMeExvaXJpaUlvT2dIRWFLbkk5WUlBSE1NT05NRVl0YkJQTmxxajAwbVJyMmRBUW90VGNwbStlcnF0UHIySE9sMzArQVp0L2NOYTlMTmFuOU5BeHNQK0RSWG5ua3lBdGwrZUVuNjhBRzRzbmVUbEdVV09SNzNJNDhQdDhmVjJ2NnFpQnQ2NlprdnJ5cG51YW1kbHNEWDRPTFJLT1RDSHdPU2NwS2tFaU5rQ21HRmltSUwzdk1UbzUvZ1FpY2N3bjJTVWhVaUs4VEhlV0VYWEdWSVNsZXhyc1gwSlp4UVhQUVI4ZXhnbzlMRDVuTDdCeWYyd3VmNzA3eTExRHB5SjB2V0FnWitiQVArMGtIYTl4bHV0b0I0WmF1dmpRbi9uWGFmUmR3TWc2YTkwa3BYMTNzZXpmclpxblFjTGFJN1Fjc2lqRll2T2pKaEljcXYzUHJHd2FvdSs5Wkh3THFCcHhNb0tURkxrUGlCWUwxQ2hadFNOZzI5T2VPWHFJU2YzTnp0bEg5WitLeng4RlVIZjRMUS9YZVJLcUlpVUNjWHdxdzN3TTBmQVA2dUJlN0hJaTRlMDYrK282M0doUHlKWGttaUs3ZnNEaGU2c1U4T043dVdWamQ1N3ZRdWkzd29DeGlIdWpscm4xTVMwT2NtblR0MklwQ3NpdU1aakxoMEVOTkhpSkEvV0kxZ0w5c0xiODBxRUxSUWVmcUtlTlhPck00cjNZWFA2NlllRmVzaWZuL1c5SXVHQVUrR3RCd1orcXdCKzhoajRUQUNPWTNFWFo1ems0UnRNRlk4TC9mSDFKM3VsbVlGejRTMm51cTA5NTcwMEd3dzczNUYzMG83a2RUTDUxdG9wRXZpOVp4Z2pBWUlxb2xSUzVCeTFJUXAxWlhFOExrR2trS2ZpVTg4UElHdTBNTE5VeEF0ckpqeWtMVCtMK2JPTXh0TTNtYzIvRVYxUW5icUpsMWh1U0tSTjUxUWVhL3NlK0pVNThCTlQ0QThoQXBVYUQ3Rm9ibVdHL2gxVTVJOEwvUkc2cmoyOWlhT0RPY1V3aXdjc3MyenQ2OEZxOThuQld2NVU4REtudDBoVkNCSkY1VmswN0ZscW9wWTlCbU5FTUcwK3EzRndOSU5KRFFhZFZFSU5lTG1vNGhZZ1dscFJZQ2pGYUJvUGRnOTZiUzNQM1hTcWNQblVTWHphNmJQMTVGSVBPY1gxcVpabTJRMDAvaDVIRDhrUWdLL1V3RS9QZ0g5UkFHL2doTks2bktqaUlab25ib3U4UitEeWNldisrUHF6dUk0UGkrVUk2UWZNTHBySzJkNGcwLzFoNS8xcG12UzhDOXlhc3JRdFBGalFkNjNFMmJTbGhIRmdIQi9Oc1hjd1E5cEpzRHJvbkFCejhZRVFXRlJzSVdEaFZDT25PdEE0RDF1R3MxaG5XSjR6emdMZWxndlpMSjNNS1Jib09CSTZNZkZQNDBPZ2ZabWxVNytkVU9MNGNNOEN2elFIZm5JSy9FNEQ3T05FbkhMYTU4MjNmemVKNW44ZytZTEhoZjc0K2xPL09sMERreWp5TGl5Q1laYnFpTXBwUFJ1czl5NTArOW16Q0V3Y0VGVmtZYkZ5Q3pHQU1FczAwa1FNS1hidWo3Q3pPMGEzbjJOanRRZnl3cElEeE1rbWhMalREN0ZFQThQVmpSQnFBTW1EcS8zQ0dyRjFTRnhJVFBGV2RjNVpUaDB0VFRhY2F1OGYrSHUwWkNSeTh1L3kwcDU5Nm9EZnJZQi9QQU4rb1FSdThvbFp4UElwYm5IaWJjRXRLdC8rWFBOMzRQM3p1TkFma1N2UE5aZ0JhOE5aMnlmanJHOXM0OGJkUVg0OTdTVG5ndzhjR0dSZEFESEYrVG93QjZIVU91dm81bzA5N0I5TzBWL3BZWHR6SUp4M0g4U1BMYWJQbmhCNEJLbEgzT21MYVNYZzJhR3VIZGllWFp6THhhNGVBdGd0ZjExYjVINFpyR3V0Nytsay85L08wUEZZcmdIY2FJQi9QZ1ArU1FWODFRR2pwUk84d2hreHhpYWFBN1Q1RU8wZjRuR2hQNzcrcks0azFTam1Ea3BSdXhuRHFmRlZWYk5tMUYxSk85MWU5cnd5T2dlRE5ZRlNwWmhFM1I3cWVUVzdlMnV2dVgzbklCMVBLMXBaVzhINWMwUG9DTFMxYWpEZ1pMN0hVblJ5Q0J6TkcySzhzdmNpZGEwbFBsb3ZGYk5hT3RuUDRwcWZCYmkxbEZZZFQrMmtQY0ZQZG5UTWlCcHpvR0hnWGdQODZ3TDRSd1h3YjZ6c3lkczV2TVRacUhxSU56OXJ2RVAzYVk4TC9kRzhiQk1XQVE0NGU3MnNtTUdUdzJKM1piMjcxaDNrejdUYk1VWE10bkhOM3EzRFYrN2ZQUHhhWmQyR1NwUCsrdFlxTmpjSGxLV0p4RWFSaEVNc0NqdUdNd2JyUVpwT1RPNkpKTEF3bGlzem95azlWRGdCM0dqcEJrdFBuZlRMbGxHdDduYjVoRThnY3RNMm9FR2ZwTEt3RWw5MjY0RmRCL3pDQlBpeEV2aVZHcmdWSGdUYnFxVlovQ3pEQ0c0N0RQY3RjUDg4THZSSDZLTG94VTUwcHJDTEFhamd3N3ljTnp2RDljNFRXU2U5SEJ6NzQ3M3hHN2RlM3ZuTTd1M3haL0xWN3ZXVmM4UDNERmI3cXBNWUl1OGxwOHlJSlJUSGxuM0JhbE1FaW1tSEhuSzYweWwxU1hBQnJ2VFFqdC9pRHNNNFFlSXJuS0RxZXVuWGhkME95UWt1WEh3eGhJeDVFMkwxQlRRZTJKOHovdTBVK0lrWjhLOGE0SlkvQ1ZNb3ptalR6M0pxWmVCRTdJTEhoZjc0ZWp0ZExWSk9hdUh1akZPSEpRTlFUV2wzdkEyN1N0UFdhRy8wbFpzdjdmek04VUg1ZTl2WE50KzdkWFhqQjd1OXJKc1JVU2diMUVVTmI4VVhUaG5KWlYrNE04UTVmREVjUjZZY1E1RDRWdmtXUW9DMURxRUtENnpPMmgvUHgySVBlQkR1Yml0eHVhLzJCRzdOOWhzR2xRd3VBMllsY0ZnRi9PYVU4Wk5UNE9jdDhISTRvYTR1ZTYwdis2Mi81UlQvbGowa0hwZlBvM2VsS1lFWkZBTURsM2dpaTFkR1JCa1JyVEd6WVdac1hsNTk5c2tYTHYvWFN0SDdtbm10Zk5XUUR1THo3bnlBTVJwNUwwZmV6NUdta292a3JZZHpIajRpOGFKZmp6N3owWjJtYVJ4czA2QTRMakhiTGFEQzJlNGE3UWsrajVWNEZuSG1GTG1tQVhEc1pWWDJ1dzc0VXBEaTNvL0YyeWJyTktlZkZYalFKT0pidXNEYnl6d3VtMGUwRmRQRVJFUk5FMW9jeWVHVVBEdUVZSW1vQndDRHRjNlRSdUhKZWxwcVZ6WHRDbzFKVENMSjFRNnplb1o2WHFIYno1RjNVNGx4SW9DRGc0OHhUY1FCaWpRQ2lldGlZalEwcFhBZEI1VW9oRG84Z0xDclV3VThJTmwzTmJ4SVFpWnpBc1E1Qm80Wm1IcmdheGI0YlF1ODZJQTdMQ2QyS3lzL1hlQU9ENmJ6ZkNOeDNMZm0vZkw0TFhqMEx1OGxoOHg1QmhFUm4yaExUbnN4dFAvZnU4WUY1V3dTR3M4SUlRTWpkOTVSc0o3WWVmYk93VHRIemJ6RWZEeEhPU3ZoYWh1RmJvUVFoQXZmc3VsYVZTdEl2TlFETTJ4aDRXdi93SzQ4d1Z0Y01ia1R5WFZ4cEs5SjNGWnZPZUJ6TmZBdksrRG5DdUFYTGZERkFCekV3cTd4NEQ3OFlTMDZQeTd1eDYzN08rckt1d29oZ0pxcURZTTlNMDY2SlprWkFQMXVWejJ6dXRiOTlqVFgzMGtLenlubWJYREl2UGNMRytnRlFZYUJORS9aWkNsSUtaakVRQ2VKaEVGSGVTc3pFOEJvYW92Wi9UbmNxT2JrcE5yb3RIS05BU1FLbGdqM3B4NTdjZForeFFPdlcrQTJpK0NrWGlyWTVvelQyNS94TUh2Y3BqOHU5SGR3b1h1Z3FjUHBVWGQ1TkRZQUVpTEtXSExoRTRpUTdjcGdKWGsreStqYlFIeUpnOThBd2xVaXJCSW9hYitIYW1Pc1luU3poQkRLR280SkNJSFpPMEpUQnZqQ3d6U0Iybm53VkNKbHd4SlNlRDhBTHpQaEN4NjRVekh1QmtITkxSNE14VnhPdFQwOWY0Zkh4ZjI0MEw4MVA4aTQ4eUppeEF6R00vM2c0K21lNFlSaVBpQ2dtMmM0bDJaNFJpdWNCNkduRk00VDBhWWk5RWlSQVlpSWtJUFpna1h6RWdJYlcvTVZXd0xzRnEyNVZjQ01nU0xTVDQ4Q2NDTUF4d0Y0dzB1TGZnZFMzQTRQV3JxZEJhcWRqcTdtSmVVdFA2N3d4NFgrTFZ2b01RV1dPSndaL3RpR1BxYW5SdWdXR0U5SUlVMFRXdEVLZlZMb0VwQ0FTR3ROT1RNN1loQVRzYmVoRXl6L2VUaHNFVEJtS2ZBZEJ1NHhNR0pnd29LYzcvRUpTMjE1ci8zdlV0eHZDVXhRa2V6eVNPUVZQeTcweDllZjFKV2tDczRHT3NXaWUwRGFpZ2Z6MzA1THVzL1VsRHlJcVFFUVhzdVdCbGJpVHJzT1FNa1BTa0E5M21yV2Vuclcva2JGamRNQVd6dVR1TWNmOWVOQy8xYStUS0xnYkRqOStaNFY4YXpPZUFDY2ZwMlZJS09YL3MySDJiaTNCWHY2bFBaNHEwUHphVkR0OGV6OXVOQWZYMzhNbnpmaEcyZkJuWDRvOEVNS1h1RnNveGhlS3ZMVHAzUTQ5U0I0dlBkK1hPaVByeitGei8xaHBxdG5PVUdkOWJBNGZaTHpHYWY2Y2tJMVArUnJIMStQQy8zeDlTZDhEL0EzS2VodjlKQTRYZWo0SnNYTUQvbStqNi9IaGY3NGVrVHZtY2VGL0RhNS9uOG4vS2F3eTlQd1BBQUFBRTkwUlZoMFkyOXRiV1Z1ZEFCR2FXeGxJSE52ZFhKalpUb2dhSFIwY0RvdkwyVnVMbmRwYTJsd1pXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9sUk5UbFJOYVdOb1pXeGhibWRsYkc4eU1ERXlMbkJ1WnpnYldTTUFBQUFsZEVWWWRHUmhkR1U2WTNKbFlYUmxBREl3TVRVdE1EUXRNVFZVTVRFNk1ESTZNek1yTURBNk1ERGViRVlJQUFBQUpYUkZXSFJrWVhSbE9tMXZaR2xtZVFBeU1ERTFMVEEwTFRFMVZERXhPakF5T2pNekt6QXdPakF3cnpIK3RBQUFBRVowUlZoMGMyOW1kSGRoY21VQVNXMWhaMlZOWVdkcFkyc2dOaTQyTGprdE55QXlNREUwTFRBekxUQTJJRkV4TmlCb2RIUndPaTh2ZDNkM0xtbHRZV2RsYldGbmFXTnJMbTl5WjRIVHM4TUFBQUFZZEVWWWRGUm9kVzFpT2pwRWIyTjFiV1Z1ZERvNlVHRm5aWE1BTWFmL3V5OEFBQUFZZEVWWWRGUm9kVzFpT2pwSmJXRm5aVG82YUdWcFoyaDBBRE0zTStVQXUvTUFBQUFYZEVWWWRGUm9kVzFpT2pwSmJXRm5aVG82VjJsa2RHZ0FNalkyVVI5SGh3QUFBQmwwUlZoMFZHaDFiV0k2T2sxcGJXVjBlWEJsQUdsdFlXZGxMM0J1WnoreVZrNEFBQUFYZEVWWWRGUm9kVzFpT2pwTlZHbHRaUUF4TkRJNU1EazFOelV6SUxzMGNnQUFBQkowUlZoMFZHaDFiV0k2T2xOcGVtVUFNVFU1UzBKQ1BHYU9CZ0FBQUROMFJWaDBWR2gxYldJNk9sVlNTUUJtYVd4bE9pOHZMM1J0Y0M5c2IyTmhiR052Y0hsZlpUVmxNbVEyT1dJeU1XWmpMVEV1Y0c1bnRUemtCd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvbWljaGFlbGFuZ2Vsby5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRDhDQVlBQUFBeXMrc2xBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQUJJQUFBQVNBQkd5V3MrQUFDQUFFbEVRVlI0MnV6OWQ1UmwyWFhlQ2Y3T09kYzhGOTVsUlByTXlxeks4dDREQlZzQUNFOFFBa2lSb2toSk5GS0xsRVNOWEd1MXVxZEg2cVhWNnVsZXEyZTYxVE1TdTN0RTJTWXBnUkpCSThJUUJWc0doU3FVemN6S3JIVGh6ZlBYblhQMi9ISHZpNHdxb0kwa2lzd3E1S24xVmthYWlJcTQ3MzUzNy8zdGIzOGJycDgvNnFQZTlMRjYwNTlkUDlmSW0zUDkvT0ZmOSs4SENLbGViLzc0K3JrT2tCK1k2NjJyajgzb1k2WFU2TytjaURqQVZ5K3VnK1NQN3VqcmwrQVA3aHc4ZVBEL0NCaTZBa1JZdldyVnF3N1VSU1FTRVNVaW8zOTNQZFc2Qm82NWZnbitBQzVpYUZBb1RwdzR3Y2MvOW5GbXBtZlVoUXNYbFBkZWZ4OWdSRUJjdlVJZ09IbnlaUHpUZitwUEwzejIwMy84L1VjUEg2ODk5Y3kzVnE2bldOZkdDYTVmZ24vL016NCt6dVRrSk11cnl3akM2ZE9uMVVzdnZZUzFWbHRyOTRJalVFb1pJQlNSQU5EMWVpMzh3T01mbUg3M3U5OS9lNzNXdUsvSTNEdDJ0dHZ6V1dML0MrRHA2blBkOWF0OEhTQnY2WnBDUkJBdkFLclg2KzBGaGFtdWJ3Z0VWZXFrang0OTJ2emdCejU0NktHSDN2bWgxWldOK3diZDdOVFpsOC9yeTVjdlA3dXh0dnJMYTF1cnYxMTlEWHY5OGw0djB0L1MxMDVyclpSU1NrUjBsVTRaSUZSS2pVQVJBSHBxZXJMMngzL3NKdzRlT1h6c3RxbkptY2Q2M2VHOUZ5OWNuTHQ4OFZLdnM3UDlyZVhWeTcreTFkNTZZWG50OGlxUVYrQW9xZ2h5UGMyNkRwQzMzUFVhRmQyNmloTEJtK29NRTRaaGVQalFvZkUvODZkLzlzNjV1Y1YzRGdiSnZlM3R6ckd6WjE4enF5dkw1d2U5emhmYjNaMnZYRm05OU5KT1oyZXpBa094QnlDVzZ5eldkWUM4aGE2VDRvMXNWRkRWRnFHSWhLTS91K21tRzVzUFBmakkvdnZ2ZStEUlpuMzh3WTJON2R1dlhGbWVQM3ZtVE5wcGI3L2M2M2QvUGMwR1Q1OTUvY3laSXMrVENnU2ppREg2ZFVUeFhvOGUxd0h5bGdKRkJRd1ZBQkZJQUpnb2p1c1BQZmpBOUljLzlOSDd4aWVtSDFhWWU2NWNYamx3L3R6NWFIbjU4blk2SER3N1RQcS90YkcxL3RTVjFVc1hSWGJUSjdzbllveDZINDQzTmdxdm4rc0F1YVpUS0xNbmpSclJ0QUZnYnIzbDFzbUhIbnJvOEVNUFB2eVk5K2JlTk1sdVBYZnV3dmhyWjgvS3p2Ykc5bkRZLzUwc1M3Kzh1YlB4M01yYThzYWVLTEUzalhKN3dNSDFxSEVkSUcvVkZDb0V3a2FqWHZ2aFQvN3c0YnZ2dXZmZXljblpSeFRtOWdzWExrOWZ1bmd4WEw1eU9lMTBkaTVrV2ZyVlhyL3pwU3VybDU4ZERQdURQV0FZMVJoT0tlVW91K1p5UFdKY0I4aC8wUG5NSC9zczI5dmJuSDN0RE9mUG4vL2ZlK0x2UFh0dk5QbkE0eC9naWE4K1FaSWtsUGZqOTRCQzhiM1U3RzYwQ0lJZ09ubnk1T3duUC9IRHAyNDhlZXBoVy9oN25KV2JYbjdsVEhqcDRnVTIxOWZTd2FEM25TUWRmR0Y3Wit0clc1MnQxOU0wR1ZhUklkOGJNWlJTVGlubHRkS0NRcnozb3BUQ3Vlc3RqMnZ4WE5OOWtHYWpTVkVVSER4d2lDTkhqbkRvMEVIKzRmbC8rUDF1YmtXcFo2SjZJbnRBbEZJeU5qYkczTndjUVJDOEdSaHY3bG1FU3Ftb2loWUJFQjArZkxqeC92ZTkvNFpiYjdudGthV2xnKy9jMnVvc1hibTBzZkQ2NjYrcjFaVVZ0NzI5dVRVYzlsNUkwK1FMVyszTkw2K3VyNndCMlp1QU1VcXJ2RkxLRzIxa1pucFduUGZpdmFQZDJlR3FET3Y2dVE2UTczTis5cy84R0MrK2RKcXpyMTNrMFhlOGk2ZWVmSklyVnk3VHFEZm8yQTVmK05MdnFjMk5EYmEydDlUM3VjRkhMeVVpdG9vZXVreGY4RkVZOGN5M255RkpFaVVpMzQrZWphcFhLQ0ltanVQbVkrOThiTis3SG52WHJYT3oreDV0alUzY3Y3bXhNL2ZrdDU2TGxpOWZabXRqM1hXNk81ZXlJdnZtOXM3bTc3YTcyeTkxdXAzTk45VVhleU9HMTFyN2VxMHVlWjZqdFpLVE41emlpVzk4aWZHeENiejNlTyt2MzRuWFU2enZQWi85ektmNS9PZC9tMjZ2aDRpd3ZuYWV2L1NYLzNPZWV2S2JuRDkvWGpubnFHNXFwWlRTSXFKSEhlazlUMzREMEdnMDFILzZOLzdXTGQvNCtqY3UvcHZQLzZ2bEtvcDRwWlFvcGRUZVJoNFFLRlFrU0RSS3AyNjUrZWFwOTc3My9iZmZkc3Z0OXpYcXJYc0d3L1RJMXRiTzVNV0xsMlZ0WlVWMU96djVjTkE3M3h2MHZ6Wkllcis5dWJWeHJ0dnY3SHlmYUZHTTZndEFSRVRHeHlaa2JuYUJxYWxwbm52K0dRNGZPc3JrNURSUGYvdWIxKy9BSC9RSWN2c2RkeERITVZGb2VQSEZsK2gwdXJ0MXdOLzlyLzVMdnZpbEx6Tk1oaHc4dUtSMmRycUlpTXF5VEkzQVVBSEVpSWhXU2htbGxLbEFzaHRON3Izbjd2Q25mL3BuNzF4Y1BQaFhoNFAwNy95YnovK3IxUW9NcmxMSWp2UlFrVWdKQ2tIQ2d3Y1BUdHg3NzMyTDk5OTcvOTJIRGg1NU9BcHI5MTIrc3RZNmZmcmxZSFZsaGMyTlZRYjlYamRKazlQRGRQQ2xUbWZuaWMyZHpRdHBtZ3oyRk56Rm5wZFRTdms0cmtrY3hWS3IxV1gvd2p4bnpwOUh4Sk1rUXdwYmNQYmM2ZXQzM2c4cVFENzc2Y2RJWEljbmZ2ODFkcmI3akkrUFV4UUZlK1lkZG5QdVcrKzRUeVZKb3J3WHJseFoxWHRacEQyeTc5MVhCU3lKYTNGdzhNREJ4cWMrOWVuamM3T0x0NHJJVFJ0cjI0KzgrdEtaNUR2UGYvc0twWXg4Vkt5YlVScFZTVDlxNzMvZjQ0Y2ZlZVNSVzQ4Y1B2YVFFbjJUOS9ySWhRdHI4ZVhMbDluYzJKRE96cGIwQjkzdEpCbStNRXlIdjdtNXZmNzAxdmJtaW9pTVFKSHRyUytVVWg3d1JodHgzc25EOTc5VHZQZjgxSS85TEQvNVozOEVnRjYvZS8xdSswRUhTRDJPdWYvK2s3eDIrUXoxUnNUMmxxaHZmZk1ibUNCVTRyM3kzbWxqOU82VGZ6Z2NLdWZjWGhaSlZ4RmlCQW9Ob0RUQm5iZmZHZDF4eDEwTFUxTXp4dzRmUG5xekNIY05COG5KOCtkZWIyeHRidXhzcks5OWZtMTk3U3V2bkhtcERUU3JnbjMwZGVLang0Nk5QZnJ3b3lmdnZ1dnVldzRkT3ZydU5DbU9yYTF0TkZkWDExbGJYV05uZTROdXAxMGt5ZkJLa2c2ZXlZcjhpZTNPMXZNYkcydnJlNkpGV29GamI4U1FlcjNoalRhRVFTRGI3VzNLMU5Edmd1UDYrWjUwWHIyWmFYemIxaUIvL2EvL2RZYkRBYSsrK2dwUC9QNFRIRGc0cTVTeFhMeXdyWklrMzl0WDBIdFNuYXREUVNKYTNsaFRLRURGY1JRZlAzN0QyRHNlZmRmU3phZHVlYmpUN1orTXd2QkV0OXRmMmxoZnMydXJLNi8zdXQwekcxdnJYOTNZV0R1OXRybDJjVS9FVUlCcU5KcU5qM3prSTRmdnVmdStlK2RtNXg1b05zWnVTcEpzOXVLbDVXQnRkWTJOalhYcHRuZm85enFGTFlyWE01dDlZWDF6OVluMXpiVXpSVkhzVFo5R1VTUGJVNHhicGJSdk5wck1UTTNJbzQ4OHptLzg1aitqV1creXVySHlBNCtHRzhkYmJHVTVtMW0rZC9Cckw4a2liM3BkazBENUR3SklGRVU4K2VTMytJM2YrQnhQUC8yTSt1M2YrbTJjZDBvUUxmNHFJTGphZlI2OTl2WWROS0RIeHFlaWd3Y090QTRlUERCLzdPZ054NWYySHpvVm1PQlV2OWRmekxQODRNcktjckcydXJ5NnRiWDViL3Y5em5OYk81c3Y3WFE3Mjk2NWdxdjlDMUZLQmJmZWV0dmtndzgrZE9LQit4OThZTisreFlkNm5jR2h6WTJkK01MbHk3S3h0azU3WjB2MU9tMHBpcXlmWnVtcldaNTlyVGZvZnYzaWxkZlBPK3Z5cXJndjlxUlVlMEV5a29PNE1BaDlzemttY1JTaFRjREs2dVhyY2FJNnQweU0wUzRLcmd6VDc4YzQ3bFVOZU40NFh2eldCc2l2Ly9xdjg1V3ZmSVYvOEEvK0FRRHZlOS83MURQUFBNUG01cWJLc2t4NzczZWJiWHVLNGdnSTUrWm1XeC81eUVmMkhUMjRPRGN6UFRhOXNIUmcrdFVYWDhpLy9wV3ZKVWRQM0hUVDJNVEJ1NnlZbVNKUFo5czcyM0dudlYxc2JXMnNkenJiTDIvdmJIK3RQK2k5M2gvMExoVFdKbS82L3RXQkF3Y24zL09lOXh5Ky9iWTc3amg1NHNZSGd5QStzcjYrTmI2OHZCcXNyS3l5dGJraDdlMU4xZXQydlBkMkt5L3lydytTd2RjM050ZWYzZHJaMnZMZUZSVXdmQVVNZS9EZ0FmTys5MzJnNXIzNHhhVWxGdVlXeDc3MHhTK2MvNDEvOCtzZHBaUTNKbkJqclhIWmFXOWRSOFRlZk9sLytOc2Mrc3YvSlQzclZDY3ZsTHp4NGNoZk9YN2swSGUzTzlsdjdleGM1cXBZMDErTEVlVGZxUWI1KzMvLzcxT3YxM2ZCTlJnTStJM2YrQTAxU3ArcUlqaWtHaWtWa2JEVmFvNmRPblhUN0MvKzRpL2NkK3JVeVlmbXA1dkhwc2JpZVE5anAxOCtINjllS2R3OTc1N3lyYWwxay9TN1ptMUZjZUhzV3JhMjNQbE91OWQrdXRQcG5lc24zU3ZPK2FITlhTYWUydWdwRk5jYXdYMzNQN0R2NFljZXZ1R2VlKzU5NFBEQlEvZXNYRm1idm5oeE5ieDQ4UkpiVzl2UzN0NmswOWtoejFKWDVObHFYdVRmN2c5N1g3bDQ1Y0t6U1pKMGVLTzAzQVB1WXgvOTJPeDczL1A0dzkxTy8wSHIzRnkzMjVOQlo2Z3ZEeThQQXhQOUhlQmJnQkx4NnYvcW14b0dobVB6VTlRQ3czTVgxOTdleGNhZi9VOTU5L3lNK3RybXR0cERyVWRBOEVzM0hqL2N5b3EvV3ZQK253TExiNnNpL2VEQmcvelNMLzBTN1haYlpWbW1sRks3RVVPcDNZWmJEWWp1di8vZStZOSs1R08zZi9DSFB2U3VwY1Y5cDFvMWZTaFN5VVJjRCtrUENuN3I4Ny9HQzVlZVlPeHdIaXljMENnREUrU3llTHRTdDd3ejFzTmtjc1l6OGJCWWVkQUthS1djeTEyN3ZaMnRYRHpmdVJUWUtmZjRJNSs2STNLTmsxTXpDMHViVzl1Tkw3LzRvbDVlM2FEVEc5RHQ5V2p2YkN1YjUybFdaQmVINmZEYjdjN09VeHRiRytleUxHMVg2UktnQk1RRC90RkgzOUg0MUE5LytsMjQ0STlmdWJpeWNQSEMrZFdkOXZZMzBQcWxMRW02dlY3dmZHL1lQMU5GTGc5SzhqemJ2VDYxS0ZET3lXNkdYWlR5RVFFd0NpWWFOZXFoWWJJUkE5QWVabTlMZ1B6Y0RVZjQ5Y3NyMkxLK0RCUkVBdkdIbC9ZdGpCWHlOeTUwK3JlZUhnei9td280QmRldzVPbi9Fa0FldU9jT3Z2dnlhZjdKUC9rbjZ0S2xTL1Q3L1ZGOXNldlFJVks1ZEdpYWYvNFhmLzdtUC9OVFAvT2pKMjg0L280ZzBNMmtzNlc2eTY4d3RXK2ZiSzczMUcvKzdyL2tjdll0amowWW8zUWRoYWRpY0pVWElhenJzRTUweERraFJGRW9SV2pLTzIwLzRvN2NPTzFYbjB4NDRZdWZEOXpBS3VzOVJtblNQQWVscWVzQTdhQldVL1JVdnJMVzNmaHFaM3ZuMWZYdDdxWXR1OWFqUWo0QTRmYmJiNS84eE1jL2RlZjAxUHhIT2p2ZE8xNTU2WlgxNWVWTC8vMXpMejd6cjl2ZG5mYWU0bnlrdWhVUkVlY3N3K0ZnWk5tajB0eCtqOGVWVWtvUW9YQWlaMWEzcEJFR0tLV2tGaG9LcjJqRU1SdWR6dHNHSEgvdGhxTjh0ZDJtV3hUS0M3cDZhTlpuNHFoeFV4UitkcjNUK2NoV2tuNXh3N3YySG9DOHRTUElUL3pFUi9qTGYrM3Y4VS8vNlQrbGF0NEZlNkpGVFJIV1R4emZQejJ4MkYvODVHY2VldnpUSC83cDl4NWRPbllETnNGbm9ycnJsNUJpeVBhbHMrcjN2djAwMzluNkdqZmUzQ1JHVUFyQ1VLRlVtYW5VQW9YV0VHaUZWaG92bXNJSjNWUVlPcy9tNlZTZi8xSkhEOWN5RlNwREVBVkVZVUNnb1JtSGVPOHBYSTYyRmtrU3hwQ2w1blQwcWNYbTVJNWRHdDlLY3J1KzNlMmYzK3dPeitkaWxqLzlFejk3K05TTnQ3eTcyK25kL2VMekwvbnpyNS83amN1WHovL3oxeTZjZWEwb2lwVHZuZXpiTzhpa0JOSElHMWc0dlFja1hxU01UdDU3MXg2a3ZnT2l0Zkx0Z1plSlZvdU5Ub2Y1ZXAzMUpIbGJBS1NwTmFlN2ZaVTdyL1lRTk9GbjV1ZnVLL3JKajNiU0xNd0NmVzRyOVNsdkFWZWQvMHNBK2RwWHYwT3IwVkRiZVdjRWpsZ3A2aUkwN3IvcnpnTVBQbkwwM1lkdU11K1Q1c2JDWFRjL2VPVHd2c09SejNzb3BVZ0dDY21neDhLK0Ezem5oV2Q1b2Zjc3Rka0k3eldEVkFnQ2p6Z0lLcEFrb2doVVFCUUhLUHh1NTdBVktUYWVIWERoZDlyS0QyQm1ZZ3l0RlZsbUVTL2tyaUFyTFAwa1kzT3JUVkdrS0R4UkVNUWdzZUFubE5KSFlwVHNHNCtLK1paSlRWamJqZ1liazY4ODk1M0o4NWV2UEhYNjdLdi82NVdWaTg4bXlYQ2JOdzQwdlNGNlZMKysyZXNxNXVybzdkNG80Z0FyVUNCU0NEanZ4QUkrelhNWnI5VkU2akc4VFFDeVhoUk1SeEViZVRIU3U0V25XcTNKSUMwK3Z0b2ZITXE5SCt3ZzU5eHVtbnB0ejcvOG53TGtZeC83SkYvKzZsZFZ1OXRWVmIwUkFRMFJXaDk1L0owbkgzcjA2Sjl0N08rOU41NU1ZMDlMN1p1NkRZUEJPa0dVc0xGOG1UaU82UFY2ZlAzRko0aGJqakFJS0t5bm56amlVRkdMTk5vSXhvRFNpamlBdkxBRVdyQWlLSzI0OHRTQVYvOXRteWlJYUUyRWlJQzFqc0JvY3V2WTNPbXlzYm1OOXdXQmhzZ280aWpHT1UrYTU1akEwR2kwQ0lPSTNMb1FJUXBNTUg3Nk85K2c4RVpXdG5ybXlzcUdTY1FIMWMyZTdnR0RleE5BUnVBWUZaOTFCYlhwc2Nia1pDT2Vya2RtSEpSYTd3NVgxenVEblQwcDJ0NStpczN5M0lzeFBuYVI3QnV2czlwOTY0TmtQY3RaejNPbGxOS0lCQUxCcmMzRy9uNmEzZDIzaFJLbE9oMHZGL2RFWlBrK2pLcThKUUR5NS83VXAvbkMxMTVpYTd1RGMyNzBwS3dEelU5KzlFTkgvOHlmL3RoZnZEaDQ0dDFkNlpzc0RhUlpxekZSbjhYbEdlSWRnOEdBenRZYXg0OGY1anN2UG9XdGJ6RFdDTEhha1JlQWFOSmNTSEtITWdwUmlpQVFBdTB3Q0hHb01GclJQalBnOVMrMk1jb1FSUUZLcWJLUllnek9PMVkydHVsMnVrVGFvUU5kM3RYT1k0c0N0R0ZpWW9vb3JwUG1qcFhPVUExMVFWUXpCQXA2eW1KYVJrMGZyTit0RnVmTThvWGUzOXZhSEw1U3BZK2pwdUNieDJCSFQ4Y2EwREJhdDk1OXkrRjNINTRiLzR4NG1kTmFqVnVQZnZMMDVUTlRqZmozSmx1MTdmWDI4UFQ1amZZRllGaEZtVlNneUoyVDNuQklhSlJNMW1xMDAvUXREWkM1TUtEd1h1MzJwcFF5TTBGd1d5ckpmdStGSURDRFFybkIvMDdrVUhzZVFQSVdpQ0RDenZhcXNyYlFJcnVhcHZvRDk5Kzk3Mi84bFovL3N3Y09MNzc3d3RlZjFGbnFDUUpSM21wY2twTHBMdDVicnJ4K0hvMWpZM1dWcDE5OWd1WStJUXdDNHNZTTNhSkRiZ3V5M09QRVk3d2hDaFNGRlh5Z01VcGhDK2lmN3JQOGxUYmFHY0lvd0huUVJwZEFjWjd0OVM1U3BEUWloWFhWVmEyaVRoRFhXSmlmeDNuRmxlMGQvTFRqdHZmUHNuQnNqQ2pXR0NYa1RzaFVRS0VOM2E2OWJmMWkvK2ZQUExYMmo3Nzc1Y3ZQZWJkYjBBZWpwLzRlZ01SQUt6UjY3T0dUQng0N1BqLzUxMnFoT1RqSWN0SWlwM0F3MVlxWERzeE1QQmlHeGgyWUhqOTdhRzdpMTU2L3VQNzVuWDZ5T1hwaUNraFdXR2VkWmp3TzN2SVRoZjlpWlozRStaRUtPMmdHSmd4RkRnMDk5VUJybnl1MWtlMHlpTHRnTUh0b2R2V1dpU0JoYzRaYXJRNG9EUklDdFRBSUduL3g1Mzc4ZlRjZVAveStJR3lheGZGajdPUlg4QVdzZFh0c2JLMVR5Mk84VXB3Ny9SS0g5cy94elBNdjBuWEw3RytPWTdRbUNIM1ZUdFVFU3RGUWd0RUJWZ1N2SU5DYU1QQjB6dzA1ODN0cnFEd2tDQTI1TDZqWEZGbVJFOGZDOW5hYmZtY2J2TVA1a2drckxkdzBNOU96dE1iRzZQWlQxb2NkYm5pMHhWM3ZtU2RxeFF4eklTM0FPMkU4TDFEaTZUa2hNYUxIOTQ4OWVPdFU3ZER4Ky9ZOWVmbUZ6ZDk2L2t1WG5ra0hSWmVyQWtWWHZhRU5vSG52OGNVSGIxcWEva1d0MU1HMHNEZ1JTbDJXNXFhRDgxanJZdytNTldxM1Q3YnFSeHR4UFB1N3o1MzVaZWQzUjIyOWdEZ1IxODN5dDM2S2xlY1lwVlFsSDlLSG83Z3hyNFA5cTlZcGo5bythNHQvc2V6Y2RnVUU5YTdwS1hQL3pOUXRIZkVYL3FlenIyOWVhei9QL3lHTGNQblNDdXNibTlvNUZ5aWxha0RqNTMvbXgyLzdpYzkrOGhjYmNiUmtUSWpDOE96NVoxbmQ3dFBwRnh3Wk84eHNjNGJjV2RaWHI2Qzg0OHZQZm9uOU54a2F6UWdmS0x5Mk5HSkRHQ2lVZ21ac01FWWpDcUpRRXhyWXZqamcrYzlkNU1yck80Z09RQWVFZ2FFb1BGbHVRV20ydHJZWkpIMEdhWTRUd1ltblhxc3pONzlBclZabnV6Tmt1Yi9OM1IrZDRSMGYzbytKREZubTBWb1JCcUNVcHNDQUtPbzF6WGhkVXpNb0UrbnhzZG42VFFkdW1ubm95S25acVhSZ043ZFgrdWtlNXE0Sk5JN09UOXgwNjhHNXZ6QldqMi9MYklFVHorekVPR2toaUFoQkdPQUV2QWdDeEhFVWE4V3BPQWlHNjkzaEdWOHlYSFlQZGZ5MktOU05Va1lxK3Y5RXZUNXpXMVQ3OUpsK2I3OGdObFBxcVJYdnp3Q0ZndlRUYzdNbjV1UHdodC9jMkg1eExVMnZPUit3LzhNSXNyeTZPcHJMQ0pRaWpxTXdmdis3My9HTzJmbkZrM20vSjNtL3E2YUNHYWFEUTF3WVBJZk5ISjErRnhORXJLMnZrT1VaYTFuQzBHelRHRitnVUpwR1BTUXlHcTBVOWNBUVlQSGkwZUl4cGt4NU9tM0hzNSs3d01XWHRqQ2hKc29LV2cxRmJqM09PWlJTUk00elRCT1N0S0J3cFV1bjBZcWx4V21DSUdLclBlQnlmNGZiUDc3SWlZZm15Q3cwSTAxa05MbUFjMEl6VWd3TWRGVkE3aUZXd3I0cHpWVGhTWnhTbllLNStzMVRQekUyVjc5dCtrRHJWMTc0OHFYbkJwMHNBWUxqK3lZUG5OdzMrV1BPdVR1N2FVWm9ERnJnMGtZYmxLSWVCK1RXa3hVV3BSU0NzTk1ib29YeEF6TmpQN25XN3AyN3VOWDl5aDZHYkJRQUpUYUc3QzA0bzM2OEhuTXV5VWJGUlRYb3BnTVBqVExDeS9pVTB2Y3ErS0pBc2hCRlppb003MXROc3RlZTMybG4xMkxEOFBzQlpIZUh4WjZlUjAyRTJzMDNucGkvN2VUeGg3SmVXdzg2YmJ4WFpHbkJQZnZ2NS9UbDE3bVVyTEhTM1NITlVycWREdFk2bGpmV21WcUswTFdRV21TSVE4QUhXT2ZMbWtFMENpSFFtdFI2aHJuaXd1a2RMcnl5Z2RLYU1BZ3ByQ096Rmk4YTV6ekdhTExDVWxpSGRhNXNNb3FnVEVCbVBiMmt4NlhOSFU1OGFKSDl0ODNSRzJyeUhMSVlHcEdnbEtjV2FMVFNCTm9UR2tpdG9qc1VoczRRQlpwbTZLbEhubDRtZ2RsWHYvZitUeHcvY3ZqdXVTZGYvTkxsMzJ1dStQcHRCMlkvQTl4a3RBa1VpdDRnWlhtblF4U0h6RStNNHp4NFBFb3BuUGNVMWlJQ3NRbTRzdEZaN1BTU242d0Z3ZXVwdGEvdEFZblQ1VGppV3pLVXZKWmtSRnFwb3ZJcUJuU3VJV2pFV1J3RURJcUNVS3ZKTWRGalhlKzc5MDZNSHpvdzFwcjUvVXZMbjZzSUlIc3RBK1I3SEQ3MjlEeWF3UGhPcDlPOHNIeEJOV3NSUlpaVERJZm9LNXZNdnZRQ24zeWh6MnZkSWJHN3dNNlJEWkk4cDdBNTRYU1grY1V4VEJEVHFJUHlFWU5NY0M3QWlTWXBCb1JhazR1bjJ4ZldCNTdsbDl2WXpGT3JoWURDT2tlUzVSVEdFSml5Z00rdEpTOHNYZ1RuSGQ1N3hzWW5DWUtRZGk5QmpXbHV1LzhBOVZDamxTY3JQR21oeUdQRFpMT3NnS0lnQUp2UmlxRVJhd1NoN3pWOUMxWnJ4a05oMmpocXVjUFUxV3g0YlB4RHMrblIrM2wrU0o3YVdSRkZraFZvcFVrS3k3NlpTWklpWTZ2WEl3NENCTERPb1FTMEFvVW1sNEplbXFucHlkWXRvVEVQbkY3WlhHWFBmSW1JU0d5TTJMZFlCUG1YRDk3Ti8vemFCWDV6YzN1My9nRE1TcG82WjlUYVpEMld4Rm8wM0RTdjFQRXVyTnpUYXQzYUVhbXZpdXNwTUhJTnV0a0hid0xIYm5OSEtXS1JNdWNXb1I1bzFXcUVtOU5QdmZEL1NRK04zeXhMVVZlNWJCMS9lb2Y2RnhKcTJ6RG5oRXZMTDNDcE5VOXg4amhEczhIazhaeEVOMG10SXNwamNKckNPbklIdWJWb1pYRFcweGw2T2gzTFRxZWd1OXBIU1RsNUtPTEowb0pHdlFFb3ROYmtoU1BRNWQ4cEZONExTaG5DcUVZL1NVblNuSGdwWXBnNWdzQXcxbWdRUjVBVkdVa3U1TjZqbFdPeXJxakhtaWlBS0dpaXRCQmxDVW1oS1J5a1hsQW80c2l4WUJ4YnI2UXErVzR5TytobGVDL1U0eXE2RlJsaFlNanpIT2M4ZVZIUUc2U01OMkthY1V5cjNtQ1lwQXl6REswMXR4L1pSMmpNeEdaMzhOTTduZjdHeGpEOUFsZm4ybDFtcllxRFFETDcxako0MzdGV3FUME5WQVhCVmw2NFRlc3V4bUdBQnlKaGRrSHBoeThwLzl5K3VIWnFiWml0dk5ycEdhN1JWUTk3QWFMM2RJUnJJc1JBODRiRllPYlBmS1IreHcySGczdE9IQXp1T0xUdjNJMzE3SXpTUTFDRnByZ3BJck14VjM1VGNXWWpZelVkc3ZGUFA4ZnNaeDVrNWdIUXRScHowVGlUelNYU1BHTjFzTTRnOHdnZTV3VHJIUDFoUWJlZjArdmt0TmVHZEZlNmVQRmwrdVNGVW9sZUZyNTVYcUMxaHRCZ2ZmbjVIcWhGRVU0Z1MxSnk2d2pEaUdGbXlYTkxVWGlteHNhb201REVaZVJaaGhmSUNrc3Qwa3cxUTNMbktKd25VZ1pNR1dHc0E3d204MEw2U3NyNjB3T0czWUpobGhNYVExcFl0TkhVZzRnc3R6aUJPSW9ZcjlmSnJRVXZhS1haYkhmcERoTEdXeldNTmlXVEZ4ZzExYWdmWFJodlByNHhUSitxd0pFS1dPdTlhSzNmVW1sV3BCV2J6dUVxRHdFZ25JM0Mra2RuWmo2YzVmbDlSdW5DaWtRV0g5UzF2dkZRSEIrcWFYVmpMODJmUzUwTDkxQzgxeXhBUnJxWitrMUhncmtIYmcxTy92aDc2bzhlV0l6dVdKeFV0elZpcHNXaFhHcElzNGcwRFJsMERjTytaaGhwTGgzTStNNjVEbWNIUTl3TjR6eTBmeE5wemlGYU1WWWZveEZPMEI0c2d5aGM0Y205dzFsSGQ1alQ3bVlNT2ptRFhrNTN0VWZhVFZBQzFsckVHQlNRSmtQaVdwM0FHTHozWkhsRjY0cVVFVVFIcFZnUlJaWmJBcU1xQUhtQ0pDTk44N0lMMzZvVG14WmVXM0tYczlOMmVDdm9zQVNhTmhxakZWbzBEWEU0RGIwcmxzMG5lM1IzTWtxeG84S0tVQlNsRUZVcFVMcWtyQU90cVVVQi9TUmpxemNrdFk1R3FBaU5CbFdtaTdVd1JMd29velVUamZpZWVxQnZTS3p2Y0ZXODU5MWJ5QXJvRnc3czUxUGZmSlo4RHppQThIaWpNYk5veklkZjJ0aStlMkFMc2VKSkJZeFNNek5Cc0NUV3pRN3pJcWtleWlOR3oxNXJBQ25aQmdnRTRvZnZqR2YvbjM5cDRzOGRPUng4ZE1yTGpIRXFTb3FBWGx0Sm5taVNKQ0FaYUFZRHpUQlJKRU5ZYTF1ZTd5WjhPUmxRT3puSlIvNzhiU3dkbWNVNXcyU3RSYUFpTnJ1WEdhUkRzcUtzRnlnOHc2U2cxeS9vNzJRTTJpbURUa2JuU29ka21GT1BRNnkxS0JSR1FaYW0xT3FOTXErM0RxMFZLRTFST0pSV29Bek9sZlZJSVk1YUt3UUI2eUROaFZBRVcvVHA5Qk1halhHYWpSck5SbzJHOWlUWmtEUXJDQ05OcXg0aFRvRnpvQXgrWUdsL3M4dnFwUjY1c3lpdHlybGVVY1JSaU5ZS284RVd2dHhmNEN6cjdaUThMMmhFQVVvSms2MDY0b1RJbE5GRHZLQ05Rc2NoNDgzYWdibDYvTmpGWHZMaW5pNjdjdDR6MTRqWnVNWWw4YmROanZOYWtqQWZoZXBTbWluWk0vOXhhNnQxNC9vZ09kalBNZ3BFNVNJb3BRaVVpaHRhVDA4WU0zZXEyYngzSmdqT2JGbTcxK0grbWhtZUNuYlRLMFdBRUh6bS9SUDN6S3Z4ejJ4OFYwL1lNY3RrTTJlbkg5SHVCU29id2lEUlpCa01CbVhkc0xsVDhPSnlsKzllN0tDT2pmUDR6OTNHN01GcFFoVXlVUTh4WWhnbU9jTzhJTThzYVphVFcwZVdXNUxFTXRoSjZXNE02RzBOMmRub01WanU0cTJuTUxaTXBRQlJvSlJnYlVFWXhoWFZhOUFteEltZ3ZVTHJFRUZST0VkaEhiV1d3WHRIbWxkMWlsWjRKeFRXc1RQY1FSdk45TVFZUitZV0NSRlFqcm94WUhPMmt4eU5JZzQweWVtVS9xVVVKMkM5cHg2R2hKRWhDZ3kxT0N6cFhhWHd6cEhuWlVwSVhTaThrQmVXempCRktVV2pIcU5RUkVGUXBwVlpRVnBZaG5rUnhLRjVNRGJxMXpJbnZSRkFBcTJ1cVk3eS85NDUxS2p6MUZhYjdUemZHejFxRGFPYlkwcmR2ZUhzclBXZUFzRURTWm03ajBkS3pVU0sycTIxK0dmZU56WDF5ai9mMlBoUzlibjV0WlJxN1UyeERCREVSWGgwYXlXcXB5a01kZ3paZ3NKNXpmcWFwajhVdWdOUForam85U3hwNnVnTWM3b3B2UE9ESDZKMXQyZDhmMWx1QmFISEFFbVdrOXFNdlBBa2FVNlJlOUxjc3IwenBMdVQwVjRmc0hXbHcvWnFoKzVPSDJsYmlrSlEyaEdHVUJRVzBhVm1NTTh5d2pER2U0KzFrR1VGem5xQ09NQjZ3UmhkYWpjVVJMV1F3anVzOCtSVzRiVENDeFNGQndYZUN4dmJIWWI5aE1uQVVKK2NJdFIxaG9WRnhLQkR6YkJUc1A1U244NHd4M3RQSTQ2WW5xaFRqME1VWlRrNkdLWjBoemxaWWRucERDaXNLNXVlZ0xNT3RLWlpqNmxITmJxRGxMWE9KdDFCUmkvSnlLekRsYktNUmFQMEFyanpqQXd1UUJWeTdRUGszNjV1b0VENXE4TlJzVUQ4K056Y01Zcml3ZTBrVVU2VmNnRlZoWWloczJvZW1qNTNSb1Y2OHRINW1VZC9kWFB6U1ZlT09nZGNIYUtTYXdVZ3UxVHYxcGJycTMxNG93R24yRnlPMEpIUTdqak9yQlFNRTBjQXVFSkljOHZLeG9BSFAvZ0ovc3hmL0l1YzY3ekNOMS8vTldKVHZ2R0pXTVJCV25pR1dVRS90ZlNTZ2w0M1pXZHRRSHNyWWYzMUxYWld5eHUxeUN3K1V6Z3YxQ2liaVZsdXNhcWNHMG1TQVdGY3A3QmxkREZCZ0Jld0hvTEE0THpIYUkxU0dtdExFa0JyUVpRbnQxV28xS1lzL0wwblN4ektndFFDMXRmWDBWclRhRVRVNnhIYUdIcG5lMnhlN0tPMXB0V0lxRWVHTEMzWTdQVFo2dmJKdGFjd2pxSDFwRmJJQzArV090SitUdDR2VUNLZ05hMDRJRFRyRExLY3pGYTA3MTdGbTJKY1VFdGNsYzhya2ZLbXVoYlBVaTFtT1MxVHY5eDdwVXBBNzJyMXhvT2dlWE1jdisvODl2YU5pYlZsdlZibFRhYjhISyswUm9NQk1RdGhlUHVwaWZHNUY5cWRQbGRuYXR5MUZFRVk1WDA3SGI4cFhuSWoxQVNGOWpCb0s5b2R5MDQ3cDJZVUtNVXdMYml5TTJSRGozSG5nNDhpMW5GeTZqYTZnMlZlMlhnQ3J5M2VnUmVMZGNJd2MvU1NnbzJ0aE41V3d2YmxMaHVYdHRsYWEyTnppN2p5aGs0THdYaklNb2VJNER3b0xUanJTQ1dGWHA4Z0NOQWlHQk9BMHVXTldSUmxzMUJSTmhCelM4MlVOWWcyZ2xNSzd5a0R2UUt4VWhieTF0RWRDb1dVVFQzckhHbGhpYnNCR3k5dWsyU1dScXpaNmZRNVBSd3d2bVM0K1pFWmJsMVlJcHlzTVRZVmsrZENtc0V3RmRxZGdyWExBMWJPZGJuNDhoYWJ5MzA2eVZXTmxkNXpCMVRxUFBGQ1E1Q1pQV3lpRWhHc3ZmYVl6eHZxZGM0bUNRMWpTSjFUVXM0czc0SkRvSDZxWGorMDJSKzg0OHBnR0FoWEIyczgwRkxnUlExV2JiRStFSjhXUlVFdERnN2NPemEyNzRWMjV4SnYzQkYvVFVTUVVqQW5aU2YzNmJQSmErOCs1VjdiTnhIY2xZdElicFJLbkpCa1FpQWlTZVpVTDdINWxWNjZ0akZXbjVobzdSdHYxT3NrYVlFSllvNDI3bVExdU1oR2RxNjZJUlY1THZTVGdwMmRsSzByWFM2ZjNtQjdlWnRoTHlrNzQ2WEpHK0lFZkptRWlnV2xxcHZXQzRYMktDK29MTVdFTFhKcmFkWnJOSnBOdXYwRTcwc1pTcUExSU5RaVRhUVZnUzdyRndrVTFvUHpIbVZLeHNtcUVSdGxHZVlPRTVpeTJ5M1EzeGl5ZWJGTm5sbk9yM1JwTE1MalAzcUFleDZlWjJHMlJpZFhkQk9QY29Za0szQVdra3lZbVk4NWNHU005bTF6ck55L3hObG4xbm41RzVjWmJBL1J2SEVrc1FLSWtsSUltZkRHYVVSS3FkYTFkZjdhZ1FQODFRdXYwN2RPeVpzaUI5QzZxZFdhdTd2WitNVEwyenNuckpUVS9PZ3VEeFVTS1UxUDhjcG1VWnpmZHJiWFVJb2x6OVNodUhZTStIWjFUK3BycFE0SjlvakRIRkI4K2FYZWxjZHZtZmpjekMxakowSkR5eXJZN0JTc2JxYTArNWxmNjJXbkw3YnpiNXp1Mk84MngvUVBuVm9zM20rZDRMMWkwT3NRcVlBYkp1NWpmWG1aUWdwY1lVaFR6OVptd3ZtWDFybjQ4aW83NngxODFTbldTaUhlbDJwY1g4NTUyT3FTSmhZQ0pSZ0ZQaFhpU0hCRmpyTU9wY0I1d1pnUVRZb3ZjL2xTaTY3VnlMOFVOSVFhUkFrYUFhT3hYaEF0R0YxK0RhMGcxS3FVdnlnRm1TVzczR1Z6czB2Yko5ejkyRFNmL1BGREhEcmN3Rm5JQzZFLzlCUzVVRmlQc3g3eEVCaW9pMElqK0RHRlVuWEdtZ2RvVGtRODg3dXYwZDlNZHZjN3E2c1hYaXFEN2ZJaTdwSDdYQ3V1NzFLeFR3Qi83clhYQUZHNUwyc09JRkpsNUppWWkrT0pEODlPLy9Cck8rMVBkZk04cnU4SkFicFNBMWtsL1o1U3p5UWliWUY4UWdmVW9MNVFqMitOamZuMXpMbHJCaHh2aUNEVis1WUJ3YTk4ZGV2ZklEVHVPdHI4NDcyQm5mdkNNK3V5MmMyWE80WDZ2ZE5iMlZmV0JyTGVyTWYxV2RYMHhwZjBhcEhuWUJSQkZITm82aVNuTjIvaWxhMW5FZXZaV08zejB0TVh1ZmpTS2xsYUZyeEtWZW84Ny9FaWVDZDRVVGk1K2cwbDFTT3FCdFJNK2UvekxFY0hLWEc5WkxNY0dxRVVBNDQ2Nzg0Si9VRkJscFJRRTlHN3p5U1JFb2lqTjEwRWN1Y3B2T0JFd0NtVVZiU3ZkQmhFR1ovOW1aTzg4MTN6VEkyVlFCWUZoU3VIMEwyVUFCR25NTWFnY2RTQ2NpNTczQXRqZGFGZEEzM0hIR2s3NVprdm5NZG1ibmZXdEVLQ1VoWHo4eVl0M0RWeG1zYkEvK1BQODluRldmWGJHMjI2MW80aXgyanlzaUhRSEErQ2lVL056bjdnY3JmL3g4LzErdU5CRlJLRHFvZGdCQ3pZbnZDVkZlUXA3U1ZENmZaa0dDTFdVZmdpQ0l6VzE1cEk4ODBSSkFmTVN5dko2dC84dFN1L2ZNK2gramZKM0QzZFlWYjBITTh1RDdoUXZiZnh4SGh0N0laajg2WklBL0kweGRrQzd6UTZpRURCZ2ZnRVQrMDh4NFZ6eTV4OTVoS2J5enZWVTc1OEl1a3F4ZlFpdTNKd3J3UmJEZEc0cTkvWDdrVjJncktGSis4UEdkZFZkOU1ZYXJXNGpFVFZUZXNSVWdmdG5rT0xFTlVNMmloRWw3ZWo5NzZxQURWS1NvcEZLUWhWeVlMNTFCSFU0RE4vOWlUdmVNOFNJWllpOHloZEtvWURBY2tjenBZVmRoQ0FObzZRMG9VbEREV2loSG9neExFaXJodE1lSkJCUCtQRnIxMUJ5a0dzM1NUYmd6ZnFUVVdwVW9TUkljdithUHBtTjQrUGMyVTR3S09JLzliL2dBSmxSWlRmTTRPdm9DblF2Rzl5WXQ5OWplYkh6L2Q2bjduWTc4K0o5MWV0TGtmdm8wSVZ3amN1aXZ4eVQxaXZLNis5c0lWV2FCU0QzRzRNQzF1b3E5ekVOVGRST0lvaUtlQzlpSDNxd3ZCSjRDbSsxM2c0Mm00UDhqRFd6OFltZm14amJUTmNYTnhIcmRFa1RWUHlOS1hoSXZ5NWlDZC82MldLWVlxb2Nuak1lVUc4SUZxaGtISmFxQUtBcnFwWGVlT3Q0ak5Ra1VmSERwd0g4UTVySFlVdThOcWpqYWF3ZHZlTzg5NVJwSjVCN3BIQ280ZU9NTlRvUUpkZDcwRGpVSGc4T0dIUXk1QmFRS2cxeGhqRWV4NzgwRDd1ZVhBR213c093U2loRmlsd1pjU0tvNWkrYzFpZklDaGFrY2FJNEozRHVsSjJWd044Q0xvWm9nOFpIdnJrY1lZRHk3bG5WeGw1NHV4ZVZObTlLYVJxL2FBeGZ5U041VHVuSmxtS2FxeWxRL3JXS3ljeW9uSDMxaHNOcFZUai9iUFROOHhINFo4NjNlbSsvK0pnVUJlUjNadktWemRUSUtnQ1hsdUgvN2tMNXdCUzc3a2s5dmxiUS9ORHpvcTByWDJwV29DMGQ2SHBOUlZCNE9yczlRZ3N1d3RxcnRhVWFLQ1dadFpmM214LzYrQkU5UHI2NnNhSk5FMHhRWUF0Y3JvN08zejNPOC9UUHIxT2tCbUdvMEpjbGVDZ2lpSWlDZy9sRXhlNm9sbUxhbHhKQ25ldytuK2VVYkJpb1RuMEhFSTRyQlRUNG4yY0pnVmhHSWdTVVZwcmJKSHZBcTNJSFZ1cmZjYjJOUkV2R0lFZ0srbFZFMmg4b010YUJQQWVoZ09McEk1YVBjUUV3c0pNeU0xM05CSHZzYllTcG9hUVdZLzNqbDRtZUVMRWx4U3owNUE2VDAwSFpHSVI2eENyaVpRbVU0NUlLNXFoWjNZdTRvR1AzVUE2dEZ4NWVXTVhJSW8zUEhEbEt2MWJQcGZpMkdDdHgrL2hmWlZXakU5R3RMZitZRHZ0RDgvTW9iVG45S0RQMElrcXZGZFNaa2dqZzRvRzBEaFFxMDArT0Q3MkdNNTkrdm1ON1h0NmVSNkVlK2luakYwcTI2Ync3UzM0LzI3QzAxV1dnb2lvcDRlRGIzOW9mS0xkRjluNWVyZjdDbTkwdWVSYWl5QnZCb25kUXp2dWZicVowYS9mUG4zcHRZVzdKNS9zdG5lT0pjTkVLNVRxZGpxOCtOeDNlZXFiVDVJWEJhY1dEbkJtYTVXZFlVKzh0eDZGVndybEJDdGVOcFRXbDUzWFY3eFRUNmNEZDdiSVpSTm9WUmRwUjhxSFVKUkJxeEFPQkhCN0lEeEFWdHhZdC9Hc0RoVTZDREVFWlgxaXlpZzE3QmNrZzZMVVhSdEZnU0pRb0R5NDNDTVZwV1NyaVQ4N3NDaFI2RkE0dkZSanZLbko4L0tTRkw1TUE0bks0aC9yeWFTUFZ4clJrS1dlWkNnMGF3cWxwVXdqSFF5OUw1OG9xZ1J2TTRDNStaaTczbitNdEp1eGZhVTc0blJ6QlQyK3h3WkhDRU5ERUlRNGw3OGg2MUNVRXZvdzFydC83TDNnN05WL1UyOEVCS0ZDRzBWbisvOThuUGRVbzBFek5KenZKNnltcVVxZEc5VWFveHFwRVdqZC9PRGM3QTBIdGY3NHhWN3ZrNjhueVZUcXZBcjNmRjk3VklmOUJINXpIZjUvL1RKeVpIdmFJVUZOS1pzNnNTOFBCdDkrc3ROWjVvMEdHZGVrYWNOZWtMeDVnNnpzaVNRYXlKTzA2TDF5YWVWZkhUeHc1T0dkcloyamVaYnozTGVmNWJsbm5pWFBjNkk0cEJYVTNHRzE4RUt4cGwvZDZHeGZWa2dtQ3NRejlKN1g4R3JGTzkrM3VSdXRTNWFxazdyWFhrY0JXeDR1NThLek9meG03dVNFR3FUdmE4WG0wYWJJZkJSR1Joc3ZYcXhTSXJqTVlqTmJOZzY5Smk4VEtoUU9LNElvaFU4dDFubDB2YlFSU3BPY2lURGkyUDRRTDVEYmN0SlJ2S0lRaFRJbEkyYUNzaitrQWtFVmlsQkFwS1NqalZJb1FoeEM1b1RjS216aGlRSkZwRFZqZFZqWTMrVEdCdy95blg5N2xyU2JDVXExdmVKU2RZVWRWUzNWejNJRmduTk9lYzhiWEJ1ZEU5cmJPV1VjVmtKRlVodzgycFN4eVFoYkNISGRTR2NySlFnVm5aMmNLTkxjL2RnQnRGRjgvYmN1dk9HTmY4LzBOT05hODlLZ3krVWswMW5aNHdqMnBGVE5oakd0ankvTVBUQUZQL2Z5ZHZ2V3pUU05jNUNSR2RpZWVkbk13a3M5K053R2ZDR0REYTc2aTVYUExLMzFZaFRQL2Y3T2R2ck5uWjF2RkNJRHZ0ZGU2Wm9EeVBjRHkrNDNlbmltcWE3c0pHSzlIekZlNlV1WFZyNTdaUEhLUHpsK2Nma1hkN1kyVzYrKzlCSW9qNjRGc3U0SGFpVnR2N2l4M1Ardk81dnArVFJueU5VRmw5V0ZjSDdQNzkyZVZPN05ua203c3lwQTM0b3Nidy96Wjd1Sitsd3J0dStmYkxxSEE4VVI1NHJRSU9URG5DTEpVWEg1YkRNS3NkYWpwS3lHckM5YjFkNDY3S0NjYVBJZXhoY2ltczJnakJnS2hsbFpvSWRod0VSZ0VGZEs2STNSTkVPTldQQkdvOUE0TDFnUG1kZGsxcGNPTFI2Q1VFaUxVc25xUGRScW1zVkRFMnlkbk9lMVo2OG92S3g3WWVOTlA3c3ExODY5WVZXRWVtT2ZSQVFGVW5rTGl3aFhMZ3k5dWpnczAyU0ZhSzJvK0F0QktScmpwWWl6TlJsVHBJNHN0WHp6blEvelg3MThscWU2SGJWVEZDb3YwNnFnS3NRYkFzMUhwcWNYN3h0dmZmeHNwL3ZaNTdxOUE4NjVVY21uU2dZWFpXRG80YnREK1AxTitPSVFMdTBCaHE4RXNkRjRFRVEvc3JSMHE4clN2L1R0N1hiLzFhSjRscXYrWTllVXkvdS9rM24xc2YyejBzN1c2ZlNURWVNMUJQUTNYM3JwWHpicjhhTDJ5U2QzMG01OUp4K0dtMm5QRDJ6K1NwN0ovOUJlU2IrTHlONEZOSTQzR3JMdEJjYjNjOXRUM3dja0VaQmFrWFk3TFY0Y1pQWTNJNjBlREkwOElKNmJrNjIwZGVINTlmN2tYS1BkSEk5bmE3V3dyclF5Q2lrTEZjb1d0b2pnQzR2em5qejNCTlJ4VWthRktLUVVLUllRQkNGSnJpbnloTUFLY1FOQ293aXE1MmJtQkZlbFlvRnk2RkNoOFNnSFFhQlFLUHFKeDNxTkdJaWJBZk5ISmxpL3RFMW5mWGdHeFU2bDU5dHJoUk9JbEMvZXVGdEZWZTJKOHIrOU41ZVNrc2lyZnU5ZENSNnRsTmpjKzIvK3prV3BOVUpFUkI1Szk3RnhkOEdEWC9rNnQ0K1AwYmFXNUNvNGFoV0YyM2hvY256L0hZM2F6Ny9RN256OFlyZFhaMDg0QzY1R2pPOFc4SlV0K04wZXJGYjFlYkVuVlE4Rm9vTzFXdXVUTTdNZlhPc1AvdmhHdjNjODhmNS8zVktzbGc3RzMrTkI5dFlDeUMwSHh2blc2UlV4Um90enUxRkViL2Q3YTcvenpTZi8rOW5wNW0vdkZNT2xwRWlQbWxEdCtFSi9OZTI0aXlEcG15NllyNmcvditjTi9wNU5RMi9TR296ZWs1RWRhRlo5elFoSUM1RnU0ZVM3T0g1ZHd5RkJqcXhmR3F6dHJBMTM2czF3WDYyaGI2bzF3aHZqZW5Bc0N2VVVXazBwcFl5b2l1UDJJbGxhcUlBSnZNQWc5OVJEVFMxUTVLRWlzeG5LcWRKdnEySEtGQ3JOMFY2VEZJcENQSEVzVE5RVnRWQ1JXYzh3by96eFJMQU9iRk96MWZkc2UwSEhpdnBZeUw3ajA4bXdsNytXRGd2N3BvZkF5UGc1SHRVQUI0NjBXdE96dFRoSm5Ld3REN0x1VHA3dWVhZzRxdFhYZ0ZkcVYrRmhSYkFqaGlnWldKY01yRmZBTitxcjNGeWJsMzFSamJPRG9VcXUxaHh4Vll3M2YyVGZ3b2w5Z2ZuSko3ZmJIMThaRG10eDFVNEtTK0t0bjhPTFEvaWRMbngxQUd0NzN1ZlJqYjdyei91eG1kbGJGb1B3NDJjNm5RK3NEQWZUVTZqdFZPdXY1U0x1VFE5TzNwSUErZHpUVnppeU9NWGFkbDkydWtQdlMvVWxnT3RtYWRGZFNUZEhyRmZaaXZOdlhwRnNLWWtyVVFwUlNpR2xQeFJLSzZsUEJ3dzJpdS9KOGZiOGRtOE5PTHFvbzkyQm82Z3k4SEFaK0FZUUZMbVlJczlmNmU3d0JLVE5JR0MrVnRmNzQ1cStOWWowUVczVVlWRXlKOGk0SzN4ZHJGV0ZGKzJzRUJ0ZkRuaDVoeGROWkFKRUtWSXJHSzFReHFDVXdsdExHRUtycG1qV2hHWllwbGlaZzA1YXpyTkVBVVFhcHNlZ0ZVTWttbVE3WXVIQXBNdFRtNS85OXNyZTNTcWphRkdibklyRy84VFAzdmpnd2VQajk1blFMRVdCbXM2c3o1UFViYlMzazlVczg4TWtzZjFrVUxTdm5PdXZ2dlpLWjdQYkxqcWRuWHpBVlIrdjNVMVo0aVduNUNhY3RkNWZQdGRoNElxUnJtcXZlMmJqc2FtcEk0dkcvSVZ2NzNUZXN6SWNCbzJyR3JLaWdOY0g4S3RiOEtXMEJFYjJKbUNNelBXaWs0M0cxQU9OMWlQZXU1OThwYjF6MDNxZXFRbUJRcXRuTDNuN3doN1c5Sm9xMFArZEFYSnBmWnZiamkvdUdqaVZ2YnMzME1LNzVzM3l4aDk2dCtaUUNqRVJZb3dtTUFGLzg3LzdOSC9qVC8xakJFZzcvNmVjdjd5SlVmUGZCeWptKytUc285LzNyR1c5My9PdjlIditLMEE5Q0prMUFmUEdzTjk3bHJZMml4dlQxTC9iS0I4V3RreU5JbE5TdklXenBZVmVaY0NnSy9NSTY0VUlSVDhUSWxNeUVJS25HWUVUeFRDSFlhRlFxbXhRT3FPWW5OS2N1S2xHb0tVNUhJemQ5SnBhL1QwUjJUc0xFZDd6ME96U3h6NTc3SWYzSFIzN3BESm1YNlFEd05MRUk4RENVb3d2STBQdXZNK005MzN4dnRQckZhK3ZYQnErZHZsQzh0cmxDNFB6cjUvcHJTNWZISGE0dW9RMEEzSlhlTHU1Tm5TcUREdDZEMXRWLzhqU3ZrT1BqSS8vaFgvNStzVjNiNlNwR1MrZlBsTEF4aEErdDFPbVV1ZWtUTE9MUGNUSzZPdUUrOEtvZGU5WTY5U1NDWDdrM0hENHlKVmtPS084bHpwZ2xOcnN3Rzl1ZXRubUdoeVU0ajlFMWpBOTNnQ3Y4Q0txbTZSS3hLdXlYRVMvU1lucHFScmNWYUdJTWxVVHpHaU1MbHNzNmJENGcvZ1ozdnovMTkrbmZoa0JKWGpUeHlOK3YzN2ZldzQ4L1BHZlBQR2ZUVTNxOGZGYXFldFNva2dLd1NwVmNrYXFYTkhnUGZRemk3WU9aWFExa2FnWXEwRXpMTzJFQ2dlOUhOWUhKVkMwQ0dLaDhPQ3RwOS96dlBaSy8va3YvZXJadjd0K29YTVJLSlJTOG9rZk8zenJlejk4NEdkcVkvRTl1WmZBMmxKUUU0ZTZsTXVvMG1wVmxlcFlGRUlVUUJ3SW9SWVJ3Vmt2V2JkajE3WTI4OVBuenlmZit2M1BYL25TNjYrMGx5dWdEUFk4OWFtdVJRMW9IVzIxWm41a1lmNW5YOXphK3VrejdVNVVLME9Ccy9DdFRmaG55L0F0WDM1Ky9pYkdNUUNDOFNCb1BEbzVlZlJ3RUh4c1paaTg1K0p3c05SelRzZWxmNjAwSU0yMCtWOWVFZm1maHVJM2dmNmUxT3lhU3JIK3ZmWXpKRm5CTzI2NUVZMmgzUitJOVI3VW01N3FaYjlqVkdOSUVFSWNnODBwWmZCV3NJWEhGdjRQQk9YcWpWSEZmeDhTWUc4azI3dVlNOS96OU5KeExkQ0hicHArZEh3OG1Lb0ZaYS9CR0ZYUnZ1VnJMSnJHQVoxaFJwcTRrdG9OTkdGUTJwbm1ialI3VWhZRmhSVzBVaVJXa2VYbHp3NUNQU3dML2VaWU9OV1lyRFV1dnRZNXI3MUVmL0kvT2ZtdWQzeHc2V2ViRS9GdFJta1RhZ2kxb3g2VSsxTWlVK3BzUEpyQ0tUS3JzTlUyYmVYTGZvaDROS0lpWTh5VXFZYzNOQ2ZyOXk4Y25EamFiUmVYdGxhSDNUYzlRSFFsT213RVdqZCs3TUQrOTEzcGRILyt6RTU3TEFhcGcwM2dkeTdCLzdnT3o4dFZHMWEvSjJKRTAzSGNldmZNOU0yUFQwNTlzc2p6UDNtdTMzLzM1V1E0bVR1SEJsVTlpYklDOWFzWEZML2NGYjlWRVQzWnRkWWcvQThDQ01EaCtkbkttS0NQRXc4MVVPV0RUWXpSb28wU3BWWFpPYTl1RnFWS1J1Z1BLUXlLTWtpZ0VEU2lkTm42MkFNZXV5YzlHd0ZJSllNaU8zaHkrdGprWFAyV0tQQmx0V3dVYVE3OXpDTm9qQXBMMXhJUjhyUlVKelhxaWtaRjZhUzU3THJRbDZzWVNpOHY1NkUzRkRLaGt0cVV3SXVNTXJXeDZNaDh2VDd6Mk1Nemh4Lzg4TktQRTRRSDAwS1UwWlhlUzVkcVlXME1jV0FJcXlWRDRzditpMEpHQnFZb1FYbFJTcHpDT1hCV1VWZ1ZxaWc0Tm5kNDRzNnBmVTI1ZktaOTBaZnI0a1pSTkFZYWo4M05IQXl0L2NWWHRyWnZETHduaE0wdS9NcDUrTWQ5V0ZYZzFOVmhwZ0NJYnhwclRYOWdmdTZlTzhkYVA2cWQrOWtYdHJiZmVYazQzRGNzQ3ExRjBLVzVNd3JXVS9pVkM2ai9wUzJ5WEVXeHZVVTlieHVBbkYvYllLUGJMY0ZSVlFWSzloUUpjbFVTSVJYLzcvNHdaVVZWa2lmVjY4ak5zTE5lZm12RzdORThxZDJvQTZDZDlXcHNwcTZuRjVzUG1WRFhvMnIxVytaQVNZQnppbTZhWUJSb3J4bW1CWTJhWXJabGFNWWxwVnV2S2FMQUVCaURVaEFIaGtBclFpVVlVNlpwem1zeXB5aTh3bmpQNHJuQzNMSlFQN0wwOE9RdFJhQmFSaURKSVhjS3BUVk9OUGxJb1ZYUjFJRlNhR1hReWhNZ2FEeGFsVTFMcVhqZ1VmYWpxbVptRUFjekU3UDF1NmYzTldWbmZiZzg3QlZ1MUF4c0JtYnNNM01MbjMxeForY2pXWllGRVF6YThJOWZnMzlkbERlekJ5UlVTdTJMb3ZFN1c2MmpqODlNdjNOZkVQellJTTkvOUxWMjU2SHozZTU0WnEzUlZjNWR2VElIei9mZy8zMGVmaldGVWVSSTl4QUoxK1FpblQrNEZWanlwby8zM0p6WHdtbHZ2RUVvdTN1MFllUVp2VXV4SnYyaW1EODhjWHZZQ0ErRmtjSm9qZk9Ld2tLQklnd0NtbkdOSkhGNDc1aWQwRFRpY3J5M0hrSWpWZ1M2ckZWeXB3aFVWUFpJZkdteEdwcFNPYXpRZUEvN3Y1MHhnNUEvWE5ldXBvd1NSYWdnRjQxSGt6ckJpc0tqeVYzcGdDK2lTNkJKeVpSb1ZVWVJKMlVLVzNvKzZGMW5GMWRWNFpWZ0xSNmJydCsrY0dCc2JuTjVjSDdRelZGUSsvRURCKy9RUmZHelozZmEweEVNK2tyOXhtbjRMUStaUnNuaGVqMitaMnB5LzcyTjVudU9oOUdQaUhPZnZURG9mK0R5TUxsbHVUOFl5NnhWWVhVUnBjeTd4RUM3RC85aURmNWZhL0J0S1NVMWZVbzFmTDVIUFhGTkRoZ0gvQUNlMFJ4U0dFT1JnVkpLNUNvWG4yK3RERFl1bmVsK1lXSzZka2M5aWxwNHdTSVVVcXFBb3hBU1Y1Q0x3MVFqeUVuaGFTcW9oWnJRNk1vQ3lKRlpUWHVZNDhWanRNSTVJYURzd01kU1ovNjdYY2F2NUd4K29vVUtkZW5Xb0RXWkU1UUc3eFI1VmFDSHBxeUhCdFVnV1VCSkFnUktsWFEwWmJTeFhpZ3NpSk55dUwxS1FwVXFOMi81QU1UVDJIZG83S09QZnZSNDR5dWZPL3NyYmoxdmp5djFnWmZiN2YzZXU3eWoxRzllVWZxM2o4Vmg2Mml0ZG5SYzY0TUNOMW54SjY0azZlSnFra1plUk9ucTZhTDNBS09DWnMvQzE3YmhjMnZ3bElWMkJZcGtSQTRvOEthVXJWMnp2dmFHSCtEanE2eDNZcTZoaXRTeWg0a0x1cHRwZStIZ3hPMjFablJBcXFlMEt3U3ZORW9yUWgyaWZZQ3Qxa0RIc2FZUmFzTEFFT3FBUUpldWlubWhHV2FXdEJDeVRHaDNZR05UMkdnTFV5OG1IUHRLaDQxMzExSEhhOFRHNEVRenpJWENVeFhnNVZ5K1VCbytHbDI2R0liVktMR3ZOb2o2b2lRQ1JNQTZSZTdLeUlFSXFhMmlTTldHR3hsZFdDZTZOUllmYms0MzVscGJMaDBidU1mUDlib3p4cGhYSjVxdFowL1Y2L2ZPYWZPaHZyV1BiK2I1WTh2SjhNVGwvbkN5V3hUR2xJeVVxcWhCVVZmcmpFRU9Udy9oSDErQmY3UUZMM2pvN29rYXUrQlFJSFdVdkllSXM5ZG1DZktERFpCZDJucXhSVkw2N2U3U3dWbFMyT1o0SEkxUDErODNSb1ZsVGEzSi9XaWtWNk90UXJ6RkJERFoxTlFqalVqcEdsOU8rNFlvSWpvRHgwNWIyRmlIbmJiUTZ6dVdYazE0OE90RGlnbE4rL0VXOVZaQWFnMkRUQ0VTSUNwZ1dEalNvdFJ4S0FGRnVRNDdxTXpydENybjdpTkQ1ZHBZamdPTEtBeTZuUFQwaXF5QXJDakpnOXlDM1FNWThhS2JFOUdCOGZIYXlmVDE3dUtZTW1adXJDVkpVZHkxbkNSM1hjN1NwVTZldDRiV2F1Y0ZBejRvSTIxQVJWOEZaZUcrYnVFN2ZmaEhxL0RMbS9Ca1VkWWFnejNGZUE1WURiNkpZZ0V0Q2JDSzUxcmR6aGhjaDBjWlNTcVp1Sy9TckJTSVR6Kzc5cVdwK2NaN1VSUHZMSXFBcUNhb1VKTnJqWGNaS25HWUNPcFJHVldzb3hvZDlnUmFJK0lvQ2s4K3JMT3kzaWZQSEkwTTduOGw0NFpYRXBxWkpwMHRtK2E1clpIbDVUNlJNQ2h2YmlXYVdDdGlKUVNxdERndG5PQjhXWXhyWGY2NUZvMTF2aHc5VnBYOFV5aU53UVVRVDJFOWFUNmF4eW1GVDFvcEFxTlI0bzA2MGpoUVBEakQ4cGN1c2JXNXRaQ1hlaXNKeWpwQ3lkVW0wK3NwL0phQ3hSaU9lK2dXOEVJYm51bkNxOGxWNWU2b0tibTdKWGdVTldLUUNPRTRob3RjMndiZDF5TUlVQXc5UWF4S0R4N1pzOXNpdFRZSVRSSTNvanRGNlhFUlFWV21jTXA1WE9IUWtXSjZYTk9xZGlSNkVZd3FpMi9yaERTTnVMVHVzYzRUYXMyOVR3KzU2YnREZ2x4d1NvaURrTTVpUUhjeUpNMDgxcGNzbDRnaVVvWlFsVklWVldWL3VaVnlZaEZJQ2tWYVFKSlhmeVlsWnpRU1RlTEw3Nmx3WUF1TmR3cnJCR2RCZlBsdmRWVTBLQUUxR1RNUW9YMjVXK2FVSUI0U1Zkb0RyQ3M0bmNDdlhJTGY2TUxYSFh5bERaOWZodDhmd0ZrTE8xVWFOZGliVG8zQU1WR2xZNk9ob2xlNDl2Mkhyd01FY002eGNHUUNaNzJ5MlJ2ZU5MMjlObGpYUmhkeEk3ekRhQk1yclpTdUduVWF4WGpUTUQ4VlVETWxjelZpcjd3SHJXTGEzWkJ1MzJHQlUyZFRibjJtRDlaWFhVekJZSWhYSGIwNWhadU1pRlJRV2hOUlJxTVJzSXpXcGF5bFdqemtmVVVEMjlMd1FueHBkeXErcWpXa0drK1dzaGRTRkZLbVhJWEg1bEpXeGhWNXB5aHRscnlGeG5TZE5QZkRyYlgrTTA3NDFoQitJNEhQRCtCWE8vRHJPL0JkS2V1SlhncHJlUW1LRVdVNzNBTU1xOENaUFJUdWZrclIxbWl1KzYxd3JnT2tPbVBUZGJxYkNmSkdxeDBGME5rY1hncENIVVcxOEVZVDZOam9jdEZvcERVVFk0YlpDVk4xeFN2YklWT3FXSEliMGU0cVVxK1kzeXk0NTRrMlJUZkhxMG90NkR4SlZtQjZqbFlXMHA4TnNBMURWRGxHeGtFTE5Zb0ludEk4V3dtQnJpS0JLNzNFakFvSVZFQmh5LzJpdm1vWWxtbFdhVXhSQWt0d1JXbmJHT1NxMnA5WTBraEtSZ1crSUpFWjdxVDJmN3U4bGZ4R0FpK2s4RW9HbHdyWXJzQXhBc1FidEYyOGFkWkhnZFJBSnJqcWNIS1lNZ2ZqT2tEZVdxZTNuV0lDamJOWFBhQkczTHozNG5mV2htZkV1V0ZZQzA0R29Xa1lZMmhFaHFtcGtJbUdMalZRb2FwMFVZYkNhZnJEZ0dGdUNFekN6ZC90TW5VdUozT09icDZ6Y21pSitmdnZJbHRleGVjRk02cEp1QVA1eVFucVl6TllDNE1zSlMwS3JITVV6cGFwbXdUa3VTMWRZYVNTbFVnWmFheVYwcU9yb3JKVnRZNEJOTDdxdzNnUFJtdXNsTVY2T1RRR21vRGNPZm83R2IzdEpBNUMzZDdlVEw1aEM5K3BHS2k5d01pQVRKVnNWS0hMd3R2cWtyYjF1a3pOZHNWWlZKOHdlSXVCNHpwQXZxZFlGNm9KdkRlM1BoRXZzck0rdkpBUDh5U3NCVGViT0t3M1d3RUhGcG8wRzRySStJcG1OV1FGOUZORGJoV21sakl1T2NlK2tSTjFQYzU1K2xuSzVnM0h1UC8vL3JlUXpnN2Q3N3pJSU0weFd5bDVMNk4zcUFWS2tlWU9RMVNPQ1R1SEUxM3VsYzhkb1RiVjJHRTVHcHhtdmt5cGxBSXBheFdEcGlZZVcxbTRTdFZORnl0azFWSjU4UXBueXgwcHlkRFNYVS9JaGxZRmNlRHkzRDNSM1VsSGtwQWhrQ3FsQ3FYS21nTHdVUmtoZkZsNEk0MEtTYU16R2hwNnE1N3JBSG5UVVVweDc5MG5hWGNHMktzcjBFWks0TERYempaNjdhU2RaL2JnN0w3NitMSERZMnFzb2RDcTdIWTdyMGdMVFpZYkpNaFFnYVcyNlZoOE1vZTB2TkVIZVU1eDZpWnUvOVNQRU5mcnJIemh5d3lUQkhHZXlRNE1qZENicTJQUUtGWDJVN3hYRkZhUXdwYno4TDdVZGhWZVNQTFNMRzlrOVZwR0ZhcTBESnd2YXlKdlpSZFUxcGR6N2I1SzAvSzBZTmpPNkxkVFFJaHFVWllYL29uTmxkNUZWSmxPYWEzc3hFeGRHbDZ3MW92ajZuam5Yc09DOUcxMFAxeW5lZDhjUmJ6dy9Bdm55YkkzT1BEdmpTWjJxajcxNm9INjNNV2RTOG5CY3RSYlY3dEpTakdtSWNJRVpkR3MwS2hBVWVEUmVXbXdIYUFZSHg4amlFSTJENHpSV1lob2RNdDlpQWJGMHRjM0tRSk45N1lwQWgyVlk3cDJnUEtPV0lmbGtpRHJ5YjFRSUJTRlVCUEJLWTIzcFVPa3BreWxrdEhnWmlYUjFLS3dVcElBV29Ra2Q0Z1ZrazVCZnl2RkZRNmxJWXlpT0l5aVJ0bGhLZGRvZVM5TVROZWxKVUkzdGNSN0NwQzM2N2tPa0RlZC9mdG5XVjdlUWtUMkRsc0ZRR2lNTmovNVkrKy80KzQ3anY1RWxneHVXdTh0cXlnSUtzT0dBa1NoeEtBd0pENm5GbWtDSStUamh2NlVvbm5aNFRXTVJ4SHF5akxiNjZ2OHI0T3ZNMzNYQkxlYzYrQzlKODl5SWgrdy84a2Q4bGpUdldFY1gzaFV0U2pJV2lGM0hsLzFNYlNIUUdtc2VKeDFqRndlbkJkc29DbTh4L3V5TDZOUWlDdm5QQXRYbWZiNTBqaXZ0ekVrUzRyeWF5cU5Sc2ZhK25xRkk2MFUyZ1FhVVlhdDFGNTd1OUt1cDFqL2NjL2RkeDZnWGd1NWVHbUxLQXB4enUvZDI5ZzRkZkxBM00vOTlBYy9jc3VwZ3o4blByL0p1aUtZWGd5WVBSaWhsY2Y2SEdzMWlyQWN0YzBLb3JCTWJUSVVyWE1GelNzWlZqeG9qZXIwdUR4cCtQWG9WWHBQckxQdndnNHRyYXQ2d0JNVkN0TzM3TXlIdUZpQjkrUlpRWjU3VXVzcENsL08xUlN5NjNHc1VMaHFqVVJRT2JhVUsrL0s2R0dkbE5ISWFaS2tJTThjTnZGc3IvWVpkSk9yWXdOR1VZK2lNRm9aWHJxeTJYdmFYUTBVYnRoTnBadmFINWo3NGpwQWdDaUtXTm8zeGlBcDZQZHo1YjNYSWpLeTJXemNlOWVKL1gvNlQ3enZGeGIzVGYzRVlOaGJiTGUzS0lxY2lTWEYyRlNBczMyc0ZaSzg3SDRuaGJDVE9CcXhKczJFUWlDeWl0bnpIcGZaeXY2eFlQdmxsM2w1S2VjYno1eG05bkxLalhHOUdoRXNuUmJHSklTTmhNNUNTQkVJZWVZb3FyR2lJaGVLM0pianZWSzZMc3JJZmJGU1VaZTFpTUZWREpldDZvMmk4QlM1bzlmTzJGa2JrSFJTdkIrNVg0SUtEWEVVcTNDNVA5eG9ENytZSUQwZzF5anJuSmNmcEh2ak9rQ0Fnd2ZHT1BQYUZ2MStwcXoxeW5zWm1SYzBnUHBZSzdydjBQN0pYd2dEbWU1MU85akM0aWlZUDFyRFJCYnhXVmwvMkxLZTcyWEM5ckNnV2RNWUJhRlg1QzFGYTlrU2Jsa3lCS3VnT1N4WXVqd2tPVGJPbGJzbXVPbEtSaXN2blZPczBYZ1JtZ200WHM3bVpDbHhLWEpYdXN3N2ovYStHZ211T25HNjdHZW9hdjdET2NIb0VGR0NzeGFEQmhHeTNORnZaN1JYK2lUZGxLSW9rR29udkRZYUV3Ym9yU0ZzNWQrK21HUmZ5c1VQZ1V3cFplVXRzRGZ4T2tEK0FNK2pEOTFNcDl1bDA4bFVVYmhkdG9wcUlRd3cyZTRNNGt1WDFtNnhSWHBnZkN3R29EbHVtRDRVSUdRZ0h1c1UzaW1VMG5Senp5Q3p0R3FLZWxTQ2hIckFNTFhVWHg2V1M0UEt4U0RVTm5PT2JGdk8zalJPSExZNGRMbVBHRVVoWmJGdHJhTytsZU9HbHEyR0p0VlN5Vnc4Vk1XMkhTMnAwYVdtekZsZldRMTVDbHNndnRLYk9jSG1qbXhZMEY0ZjBOc2VZcTNERjVaQTYxSVpiQlJxYTRnNXN5WGRmdmE3bDd4OVJrVFNQUUR4RHpSYVhDbnk2d0Q1UVRpMzNueVlWMDh2cThKNkpTSjdyVFliWVdER3dsRFAxdUpnWHNRZXZueDU2NlIxVHUyYmIzSDh4a24wV0VIcGZDUTRYODZGTzZYb0pPVytFYTA5WVZDQ0ppK0VRUWpOeXpuTlFibGdJM09lWE1OWXJyamw5WUx0Z1dYUTZWRXpCcThWdWhJbkZzN1JhRnRtdHdzQ0kyUWFNaEVLRWF4M2VGV0JLZmVsSTd5VWErakVRZXc5ZWVISW5lQUtqODhjdzA1S1o3MVBsdVNNaGc2Tk1lakVNdDdPbVZ4TlVjT0NGSjVjRWYrZGFnWTlFeWdDcFdRK0NGbjVqekU3ZlozRnVyYk9MYWVXdUhCeEhlZlltMWJWZ05iQnBZbWpqU1kva3FYWkhiVmFiVjlvWkdtUXBPcTVGeTd6MEFNbk9ITERHSmU2NnpqdkNJT3lUK0dxMU1iNmNtN0RlK2lsbG1ha3lRcWhHRE5zUGpMQnpML3VVUFJ6VUlwSVNzT0hwdlVjMmU1elFVRkx5cjN1bzAwWmhRaDVWbUF1Rjl5NGxYUHowaGpKV0VBbmNPd1lSNjhHdzZZaER4U2lMSkVGck1kSjZmaHRMYlN4REgxVnRIY3l3b0ZseW1tVTFyUWtZcXdIZG1PSVR5MlpzNFFLeGswd2JieUxQTEpycGFUQUZ5SWN3OGk1YTNTRzR6cEEvb0RPcVpOTC9QN1hYbFZKbXF1OVJmbU5OeXpPL2ZDSGIvdVpLNnRyUC9MYStkV2czVWxVYmd0VW9Mano5amsrOFVPSDJXRllQcjI5b0x5bnNBcnJ6YTRSZzFhbFZpcXpnbmhiamRwcWVxZnFYTG1Rc2ZDa3B4NllYUWVKd25zbWd4cmp0UnJPT2J6U0pLNzAzS3FteXJFYXVzNFRydzRKTmczVFhwaklMVU52a1ZhTXJ3ZW9VQk5tSHJHdU5OTjI1ZmV6bFNXMFhVWlhMTFBlZzFlNFFraDhqdkZRcEFXOUpLR1V1UXROYlZTekZ1MkxsV3NXV2Q2dDdoVnRSZFNGTEpVWkZMVW9KTTJMNndCNXU1NGpCL2Z4MitrTGFtL2RFUmpkK1BEN2IzNzN3bnpqZzgzbWZIaHcvNlJzYkhRNGYybVRZWnJ6NTMvK1lZNmZuT0NiWnhQQzBzSUZqeTlUR084SmRibVNUaHNwYlY2ODBFOHNZL1dRZWxUcW9ycnZtbUM2RGJWWGh0QU1xZFZqOGlRanp3cDBZVkdod1FyZ0ZMa3Z6YTlrWkJIdFBLbkxVQ2dLNThnclExKzNrVjFkRzEwNVVWZ2xaTjZUTzBlV0YvU0xuUFVzcGUwc3VWS2xKRjU4T1M0clpaR3VLQnVNQ2tWdHJINzNxVU96ZHozMXdtdGJWV1ROQkZ4UHZHUktTMHZwdDFYWC9Ib05VcDJudi9CM2VPWE1NbC84NnN1cTF4MXE3eVZVcXJUNGYrY2pKMjk0OEw2RHY1VG54WkZTR1Z1b1JpTmtZV0dTajMvd05qNzBROGVweFk2WmlaakRDek1jWHBoajMvUVVZM0VkcmNyMTFlMmhCZTFvQk5YV1hpczRGUFc0akRBNlZQVEdOYzBWUjl5MUdGMEtEOFdXSGxzbUxOVzhhZUhJZkdtc2JTdnF0eEFvUmxyMTBuU1h6SHNTYXhtNmdseksrZmxNQ1FOclNhd3RUZVlRY3UvWXpqTjYzdUhGNzY2K00zdTgvcVFDU0dnTXI5dWlYbHVZbmhwdjFsL1kyTzd1TVBML0JlODFZclVpTUNXTmZEMkN2STNPNFlPemJHNzEyTnpxS08rOUFVSVJhdlZhMUh6M08rNTRmNzFldjlHNXZrU3hVZGJtRktsbmFXR0t4OTV4Z2xxUWdHUk14ZFhvbmc0aGJISjBib1pCTHF4dDdQQ1ZsNjl3Zm1lSHZHcEJ4eHE4Y3lSSndmUjRBNk1VM1NOdy9pUFQzUHlGSVhLeGg2YzBZWEJDeVVLaENKVkNpNkthRGlrNzdkN1JMU3dlbUFxamtoSzJqbUdlVmZzT1BKRU95MzZJODFBNFhPQlIxcEVYQllQUlVoLzJtaHlYdy9oaDVTYU9VbmdGSzhPRWVHM3I3aU5MOHgrcTFhS0xhWmxQV2NDSkZ5bXM4OTU3T1hWaWlaZlBMRitQSUcrWGM5dk5oM25xTzYrcGxiVzJGcm02SU9hRDc3M3RsanR2V2Z6WkpCM3VHdzRHS2t1SFdGdlFhTlQ1NEFmdTVPaFNoaHFzUUs4SDNUYjAyakRvZzFnVWxpZ3dURStOTXl6Z3pLVk5uSzBjU1FSMEpZWVM4WVNCUVN0b056emRPWVB1ZUdyOWNsK2k5YjRhZnZJVWxNMDlMNk90dW1YVTZEdkw2OG1BbFN6bGlpK1lQSFVqZW1tT2kyWkEybXh3dHBmd2FyL0x6azBUYkwzbkNCLzUwVC9ORFhmY3k3bWRMYTVzYkREYXhqT3lWclFWT0twQWhnRTZ3T3Zlc3pOSTllUlk0OERCZlRPdlhWN2R1c0liOW5pSWpMWHFqSS9WMmR6dVhRZkkyK1c4Y25hWjh4ZldkVkc0RWEzYnJOZmk4VS84MEowZml5UDVRSktreG50QjhCUkZ3ZDMzM3NKRDkwK2pWNTVCdHJmdy9RVEpVdkMydE5ZaFFqSUxhUWVsQ25xcDVlbFh0eGowUEZrbTVabzNWNWJhV2U1SUMwZXpGaElvVDdmdVdWNHlGQlphbDFPd0hxWEwraUN4amx3SlhwWFM5UXhmcmxsUWh2RTRKakFhcnpYSEgzeUFHMzdxVS96YVEwUHNiZnQ0NGZrMXpzY0ZxejkybE1iNzd1UXZmK1FYdVBNOUgrRG14eDdERHdhY2Yra2xiTFVBNTgxbXloYUlXalcyRnlkWTdaYjc1OU1zYnk3T1RVeHJwWjl0OTRhOVVhcWx3RWRSSUdQTkdwczcvZXNBZVR1YzQwZm5hTGRUMWVrT3RJaEVWZTNSK3NqamQ5MTY2Nm5GbnhzTSsvUE9sY3M2cmJWTVRZenozdmZkeWxUMk1tN3RFallyOEw0MFNMQ2k4ZGFWdkc1ZVFEcUVJaU12RXA2L21MR3htckc1UENCTmhWdzB1Uy9ud1llSnBUKzBSRVlUaHhBMERaMzlBZHZqaHNCcXdrNkJ6eHlpeW81NzZidHcxWTFQS2MxWUVEQVRoa3pyZ09UTWEydy84enhxczB0M0lrTnVHVU85L3lEeHNVUDgrUnMreVR2bmJxWG9kcEd0VFY3OC9HL3gvS3V2UW1uYnM1dHFVUUZFQWtQdHRvTU14MnFzTDI5WFZxcUY4aUtMTnh4ZXBEOU1YeGdtV1ZxQnhGcnJwRC9NeE5xM0orWDdBMWVES0tYWWJ2ZVFrdHNQUktoRlVkaTQ5ODdqNzNIT0hpOXlpNmVVYzNqbnVPUGVFeXhPYkdQUFhTQlBTZ00zRlpRN1ExeVZ6YXVzU3hpRmFCU1Nac3dHaXYwTk9KZDZObC92ME9rTW1ENDh3ZFNCQ2NhYUliVllNVENlVHJ0Z2ZxN0d2dGthd2JobDg1NGF5OGNpNWw0S1dYaW16L2g2anM1ek5PQlVhZVhqdFNEZVV6aFBWRFVVdlJmY2xUV09uTGNjZUNKa2NLaUpXMmh5WW5HV1cxOTdrYWZjaTd6MDlGTTg4K3gzZVBIMUMzam5kcCtNVjgxSlFVS05XeHFEQTFOazV6YXFxRmVlMWMxT01EODk4Y2xUeC9lL3V0UHAvNXAxUGdkeTc4VW5hUzZOWml6RFFYWWRJRy9sODEvODlZL3hyMy83dVVxTXVMdnpPN3JqMWtPTFkyUDZIY1BCME9pcW9MYTJZSHlzeGFuREFXcjVPZkwrRU8vS2lUeWN4Nm95QlVNTVNtdkVPclF4YUswSVZNQlNIY0thWm50N3dNYWxuS214RnN2OUxTYjJ0WmlhcWRPc2E2eUJLOHNKdzc0d05xRnAxaFRSbEdiejdob2Ird05tWHh3eWRUcWx0bTFKQmlrNVlJeW13T084UTJtRjFocGxERjZEMHdFcWMweTgwaVU0M2FmTEdwL3pYNlJYNUt3a0E3YWRLOTBWS1YzcjJiT2p2b2cxdzRVR3pOU1lGQ0VkbGplN1ZtVjMwRnJIbWRlWHh4ZG5teCtLUXYwRjYveG9KdDFxcmZ4RW95NW96N0QzOXVxTC9NQ2tXUGZlY1l6VFp5OXorclVObmVYV1VMbVpOeHJSeEUvOTZDTS8wcWlieC92OVlXaGRnUzB5a2lUanBwdG11WHQyQzd1MWhwZFNhK1dyU2J5UjF5N1Y1Z2V4bzFVT1pUZEJhODFMYmMrbEMxMXF3U1IvL1pmK0pndFRCM2p5eWFleFdLSW9SRkVhdmZVR0JkMmVKUytFeUdocWtTSWNOM1FQUm13ZGpPaFBoUGlvV2phU09xejFLRjg2SzJxak1YR0FGVTl1TGNwb25CR3NFZ2JpY0VEWEZneWR3NnVTMGpYVmQ0bFdGTEdtUHhuU25hM0JXSTFtcTBsanJNSEs1UzE2bmFRRWtxclV3YzdoWGRFcG5Iek5PdWt4Y21VWGZKb1hZaUpOYzZ6R2x6Zi9Ddi9nYno5eFBZSzhWYzc4N0JnWExxK3pzZFZIYTZXcTZCRUMwZjEzSGQwL016MzJualRONm9XMTJDS255RExDUUhQNzBRamR2MHpoeXpVRGVlR3FzVldGSU9oQUljcFhOMDgxd3VyTE1kYUZPT1RrYk1EeVhVdTgrdVF5MzN6NmFmN1NYL3EvTWRhYTRwZi8yZjlJTnRobWJuRU1FMnJRR2xkb3ZQVU11Z1dOcG1GaXdqQmVNeFNMRWQyWmdPMWJhckRhaE9XRTJvV1UybWJPMk1BeFppSlE1Y0NXUTJQQ3NHUyt2TVA1Y2dkdDNRU002WUJRQ1VNdERKUmoyQWpJYTRaaHBBanFOUUlOWWFqUldwTm5PYldtWVhhcGhiZENOc3l4bVVVaERETjNJZ2lDOTJydFY3MlhCQ2dFckhYZUc2ZVpuSzIvcmRTK2IydUF2UE9PZzd4NmNadGFyVndGSFlhQnN0YU9sbVJHWVJqVUg3Ny8xS1BPMlJzNzNSMXNrZUVxbGVxRDl4L2dhS3RIc1oxQjFSMzNydXdoZUNsQm9DdVJYK2s2V00yQzV3NGxVQTgxSjJxT1Z4Y2JGTGZQa3NzQXZQRFRQLzJ6VEl4UDgzZis2LytDM3ZvS0M0ZW5DWnNoZWFCSkkwTVVLbm85YUc5cm1vMkFlbDBUMUF4QlhWTWNpVWtQUkd6ZU9vWWtubmdyWjZ3bmhGdVdZQXRrNk1oOUdjVnM1YWE0azZkMG96cTVqK2daSWExcENnV0VBUVpGdlpLS2VQRlk3OG15ak1GcWdqYkM0dUZKNm8ybzh2NjErR0ZHYjN0WTM5bEpQdURGUERGSTdNaWh2UkFSS1RKbjQxcWdIbXo4YmJrT2tHdjgvSk9mZjV6YWRKMC8rei8rSHV1YlBTV0NzdGJwYXFWeUROUVBINWlabVpxTTNqc1k5bXZXRmxpYjQ2M2wyTEU1SHIybEJwdFg4T1d1Z1hJcXp5aXFwVE9sanhSbHhEQ01ldEJWc1dzZCtTRGpSTTB6TWN3NWNzTWtnVnRqZGZ0MVptYW0rZUZQZllxRitRWCsyLy91Ny9MOE04OHdkMmlNNW1TRElEWVlVODVrMUdORHYxdU93RWFSSnFvWm9ycEIxd3loVWJpbXBtaldXTGNlbDRYNEpDWWJPbXptOE1PQ0luTVFHZkJObkNxOXVob2U0c0pSNUFVVXBibzM2WUV0SE01NnJIWGthWjllUDZNMTBRQlJlQWUxVmtSanRvVUpGSTMxTHVsTGF5ZTh5ejh3VExnaWV6WjBPZXZselBOcmJrU0dpTHoxY2ZLMnJVRmVXZG5oSDMvNVpkVVpaRHEzWGp2bmpZaEVWR3Bkb1BYdWQ5eDAzL3hjL1k4bGFWTFA4Z3h4RHU4OTczbm5BWTdFMitUZGZybVd4a0hoS21sR1Jmc29CZVg2cHpLdmwzSm5ZN21YbytwN05FS0Y3eWY4L2t0OTVnNGJMcTIvU0tDYnpFNHVjZUxFU2U2NTgxNWVQMzJKYjMvclJYYlcyNlQ5bEdFL0p4MFVEUHNadzM1T01yU2tRMHV2bTlQckZLUjlTOUt6SkgyTDVCNktjc1dCcnZZKyswcTNWVG1QRXNRQllhZ0pBbFBaRWtrNWxtc2QrYkRBNVk2aXNPUjV3V0NRc3IyZU1CZ1dSSTJRNWtTZDFsU0Q4ZWthcmVrYWplbVlzWVVXNHd2andjeDA4OUJVdmJtOHN0Njl5TldOWGRWU29wSUJXRHcyeGMwUEh1VEsyZTNyQUxtV3prMzdwbmgxdGEyeXdpbnZSY3ZWOWNvamNJelg2K0hVNCs4OTlZbkFxSHZUSk5QT09teGhPWHlneGZ2dkN0RDluWEw0U0FTSFhQV1U4dVhOcUZTNVBVdVpNcHA0WDVvZ3FNb2lWeWh0ZXZaUEJseCt2Y3VYdjczRDVKeG5lZXM1WHI5MEZ1VWliamgyRSs5NDZHSEc2dU5zWE5sbVk3bkQ5dG8ybmMwZTNlMGg3YzBCdmUwQjNYWkN2NU9ROURJR3ZhdzBkOXRLNlc0a3ROY0dkRllIZERhRzlMYUhKUDBNYTB2WEU1dDdpc3lTOURPU2ZrYS9uYkM5MGFPN1BXRFlTY21HT2IxZW4yNC9vZHRONkc0WHBFTWhySWNjdm5XUm8zZnNZK2JRT0dNTERjYW02dFRHUW9KUTBacUttZDQvM3BxZEhsdHFidytmNit3a1BmYnVobFNJRXFpMVlxYjN0WWpIYXV5czlLNEQ1Rm81V2ltR3VWVytsTER2cGxSQVF5czFiclNlWFp3ZlAzYnZYWWMrZ2NoaW5tZEFsVVlWQXg0OG5JTXQ3WEM4TDRGZ0FvT3ZGdG5vYXU0RHFtVTgxUkkzclJUVlZPdW82WUxTaXB2MjEvajZVMXY4N3BkWG1CZ1BhVXdOZWZYMTc3QzEyV2JmL0ZGdXYvVjJianArZ3JtSktTSWlsTldrdzV4c1dORHJadlE3R2NQMmtINTdRSGRud0tBejNQTks2TzBNNk84TTZXME82R3dQNkc4UDZHMzI2VzcxMlZucnNMM1dvYjNaWTJlelIyZW5SNzgvSkUweTBqUmptR1lNVTB1YUNEWUJFMnFPUDNDQU85OTFBL01IbThTdEFCTnJkRkF5Y3hhRkt4eE9RemloSjZkbWFxMmQ5ZUVyL1c2V1ZGZWk5T0pWU0JBWWpOR3N2cnBLVWNoMWdGd3JKM2RlZVMrallyd0dOSXpTNDR0VFkzY3VUclgrMkV5dDlxbEQrNmNlWHpvNGZkSjdHM2hYem5YY2RIS0djK2UzV0J4ekxFMUg1TGxIQndGQkZPS3JNVmVsS25CVXhnaEt3SWphdGNzUnlqa1FwY0RvY210b0xkTGNmYnpKeStkNi9QNDNycUNWNGNSTmMyeDB6dkgxcDU0Z1NRcU9IRDdKMHRJUysyYm1XSmlZNXREc1BwYW01NWtmbjJhaVBrYW9Jb3BjVVdTZUpNbklrcHdzelhIVzRtMlpHbHBYemF0TGFjNGd6dU9jSzAwYm5NTlZ2c09xU3NHczl4U0ZVR1Rna2hMa3M4Y211ZVB4NDh3ZGFLQk42V2F2Zk5rUDhRS2lOQ293NWN5TDFtWmlNajQrdDlBYzMxd1p2RHJvNWVuZVNKS25WdkxNTWJrNFRuZHJlQjBnMThJNVBEdkY5aUJSU3FsUnI2TWVCMmJxNU5MTUg1dG9SSCtqV1kvZUZVZm0ySUZEMC9NekM2M0EyZ0tQWjJheXpxZmVNOGtOczBQT1hVbzV1aThBcjRoYU1kNURrUlI0VzFLNlpRK2hYS21rS3daTGVWV3hRVkxScStycUxrU2xtQmtMdU8xd25iTlhNcjc2elN1c3IzUTVmSFFmelFsNDd1Vm5XTnZZWkhKOGdUQ3FvelRVb3hyampRWUxrek1jbkZ2ZzZPSitqaS90NThEY1BMUGpVelRpRm9qQkZaNmlzTGhLdnU2OHJ6cmc1UW8zVmMxOWlIcWorNkZ6Z3JVZW00R3RsakNiV0hQSHV3OXg4czRGd2tBaklvU0J4bWhWZWdFakZOWmpURm5UaUJNRU1hMkorSWFaK1VacmMzbnc4ckNmWit5S0daRWlzNklWcEduQjFMNFdhVCsvRHBBL3ltT2R4M212S2VmTFk2QytPRGwyMjFnYy9XVXRITk5hcVdGaG1Wc2FWMU5UVFd4UklBcmUvOEFrTjdZMm1kSVpZdzJOcWVUaXpqcXNkYmlpV2xBajRCRk1VTjV4Q29VYXlaQjArWGRvMEZydnRxbEhtMzZueHd6MzNqakc1ZldDSjU5YjU5THJHOHpNVHJLd09NYkt4bmxldjN5V1FaS1Q1NDVoTXNTTEl3Z05vUW1vUlJITmVvUHBpWEVXWitjNE5MK1BJL3NXbVp1Y3BoNDE2UGN6MGl4RDZkSTBialN4S3lLN3RMVDNKY0FMVis2b2R6bmxMc05Lbjl1Y3FuSG5Zd2VabVc4Z0hpSnRNRXBSaThwSWFKUm1aRnZzUzgrSXN2WkN6TmhZZEd4c3NxYXVuR3UvWE9SdTErRWR3ZWVab3pFV1MzZHp5QWYvM0wyY2ZXcjVPa0QrS003TVJJdnVJQm50aFFtQmh0RzZkWEI2N0tPQjBSOFV3VGdyYXIwN1VQc096REEzTjRiU0VRc3pkZDUxc2tPWTlyQzVvbUZBdVhMWGhpMEVqR0ZrdllrcXUrZmE2SExmbndOVkRUTzVpdDVTcU1yaFVLRXFxM01UR0VSZ29tRjQ5Tlp4QmlsOC9kdGJ2UFRjRlVTRTZaa1doZlM1Y1BrVmx0ZXY0SndtR1NUMGVqdGtSY0l3eThqenZES0djNGdYZ2pDZzFhd1RCUkhiN1lUMXpSN2VPclM2dWpTMkhFSXMwejduSE02WHV4WnREamF2NnFXS2Y1cmEzK0xvdmZ2UllWRE9zUkNXUm5mVm52YzRESWlDOG5MRWtTb2RVQ29xV0pDdzJRaFAxWnB4NTlMWjdUTWl1N3ZucTYwbGNPU09CZVlPVFhEbXllc0ErU001OVRnaXlYS2wxSzdPcWxHUHd1bUZxZFlQaDJGd0MwcVJXY3RPa3JOL2FZckp5UWFOMWhnMzdET2NtdW1WcG1xcEw1ZkpWQjF4ajhMRVFVbkxTRWxScVdwSmpvdzJ5Vlk3QS8yZXRkZEtLWFM1dEx4ME9veEM0bnBJa1R2RzZnRjNIbXVRRm9yVEZ3ZWNlM1dUNVl0dHhNUGtkQjFSR1ozaE5vTWtZZEFmTWh3TUtWeEM3bE4yZWgxV050YTVzcjdHZHFkRHU5Zm5oVFBuT1g5bGxUU3pLQ0NLS3NKQWxRTlF6cGNMZHB3RFY1VEFzR201RjJSVVZ1dEFjZVQyZVJadm1NSUVaYVJRdW5vZ1FMbkVCMDh0Z0hxa2lFT0RNb293S0FlOHRGSVlRMWlyaDRlczU3V055OTFWOXN5T2VPZkZGWjZqOSs3ajlOZXZYQWZJSDhWcDFDSnlhMGNPSlRIUWFOYWl4YWxtN2NlMDBRdk9lL3BKVGlmSmlDT0ZNUjd2RTVhWDJ4eGZpbWo0RkttY0M4VUwxaXY4NkNZclJWZlZRaHVxNkZFK0czVlZrMVJrRm9GUnV6dEduQ3RSb3hWRVkzVjg0YkNGSXc3Z29idW1lSFhaY2ViU2dGNTN5TXFGTmx0ckEycXRtTlpVaEk4eUVqVWtTUlB5cENnMVdBcE1hQWhDZy9XT3pVNkgxNWZYNlNjcFNrRzlCa0ZZVXMxZUtEMTdYUWtPVzVRdmw0RVVWd3VTb0dZNGN2Y0NkejU4Z05aNERDWUE3NGtEWGZaWHZDYzJtcm9CSjU1NlZEWXk0d2pxc1VLWmFpN2VDMEdneHVOR3VOalp5Wjd2NzZTZFBTQ1JiRmpJMlc4dXk5S0pHWHBieVhXQS9HR2ZWajBteVlxUmJXZ2RhTXlOTjAvVVRQQWoxdHFtRXVnT2M3cEppdGlTNXB5ZmFmRHNTMTIydGdZOGVuTWRkdmVUZXp3S1Z3MHZhVk5STTBKbEpEMktGb0xSMVI1a1NyWkg2V3F0V2JWeVdWRXFnRlVZWWxvdDhwMEJ0WHJBSytzNS8vd0xXM3ptc1gwc05DTzJlamxiTzBOV0wzVkpCaG1Oc1Jwak0zWGk2UkJwQ0puTDZDY3B2ZDZRVHJmUGRyL1A2dFlPVGhjMHh5S2lDSUxRNzk2UnpwYzB0TE5RVkNtVno4cDFhN3MzUUd3NDhZNkQzUDYrbzh3dU5nZ2pneEtJbE1LVTVSU2hMcEZrdEREUk1OUmpSUndxYWdFRVJwaW9HYlFXakFFUWhkYjdnamdLTnk3M25pOHl1OXRwQnlSdVJOS1lpSzhENUkrRXdacWZZYlBUMXdLaEtnRVNMMDJQdjdOWkN4KzNUb3hXcUoxQndpQXJPOGp0YnNZUHZmY2dkOTQ2eFQvNTNHc2NQRERPaWFVR1VpMzU4eUo0WFJiYVFSQVFHSTM0Y2tsbkVKcmRQQjlkZGRjQlk5VFZBcG5SMHBycW56Z2dDUEJwUnRBMC9MZi8yeXBMTXpWKzR0RVo5dFVpRnNkcWhBcDZ3NVR0clJJbzIydDliT0VJNjRibVhFeGpMaUtlTTBSVG1yQUo0OU14azlNTlhDV1ZzVkkyTEoxY0JZZE5xNmd4dWsxSDVKcFczUERnRW5lKzd3aXRzYWo4SENlRUNKRVI0a0JvMUlSV3JkemM2N3pRaUNxM1NBMWhVR3E0NmdHSUtrM3l3cUNLcDlvYzh1aTFqWXVkMTBRcTFTKzRTck1sUmZiV0dMQjZXMm14bkhPajZWRXRZTFJXWVQwMGkxcGpBZzNXZXRKcThxMndNRE1lODhoTkU5eC83d0lYejIzeUsxOW84OUN0TTdRa0J5MG81ekFleENpaUtFQlZkNTd5VjBkb2xhcFNMUkdNMGJ0cnp2eUk3L0ZsVDhRaXVDUkg4alp4cVBpWFgrM3g4dXNGZit0SDUzQ0pwZFhVM0xEWUlFQVJlOC81dFI2RElpZFp6Ym13MHVYMVVCT1AxV2hNMUdsTXhIanI2ZTBrSk1PY0xMTVVlWUVndXphakkzQkl4VGJ0UFNPZDFPVCtKcmU5OHdDVHpSQXFLamVLSU5LTzhZWkJHMmpHUWoyQ1hxYnBwMEkvZHdqUWpNdjFidldnL0RsRG8vQUdnbnE1b3lTZmtmSER4eWQvb3JNMis4cUZsemVlb1pUR0Y5NkpHM1l6eFZ2RTQvZnRsV0xWSXRVZHBwcks0Nm9XUlJNSFo4ZmY3OFRmaXFBSzU5Vm1QOEdMUnhSODRGMzcrYWtQVGhEbUtYZWRtdUJiejI5eTlsS2ZCMjZkeE9ibER2VEFtRjNIZEp6Z000L05YZG1NcXhaeFVyRldBaFdqVTdhU3k3bVJFa1RHYUp5VXhnZ3JYZUh2L2ZvNm4zcHNnVnYzUmVSVkE3Snc3SzZCN2c0eWlzeFIwMlVvakt3Z2c0SjBjMGgzcFVlNjJjZDFVMGdMVk81SU04Z3lkdGtwUDZKdlI2UkI5UUl3MmxCclJweDQrQUQ3YnBqQ2VZdFJqbFpOVWF2QldGTXoxdFNvQUZJdlpGTFdYVmtobUtDc2NieUZKUGRZVzZaeURrVldVQzRZRlVXV2VXekd1SFdTYlN6M25uV0ZyN290dXoyUzZ4SGtEL3RzOVFkSUZUMG9pWm1XaG9OZVJDdEJSaDFuQWFJbzRKRzdabWlhZ21Rd1pGd0YvTUxIRi9odi91VTZuM3VxeTRmdmFsQU1DNExRb2IxQ2tuTDRpS3ErOEs1c0ZJNXV3SEp4WmxuWWE2VXdXdkJTUHFtOUJ3S0ZpQ2V1QmZ6cTcyNXdhRGJpb1NNQmFWSVFSdVdkMDJ4cHBvdUFOSyt6TXh3bnRXMDZ2YUswNU5IbEQxV3JhaDBFQW5QVnVxY21zSlpCdmpzLys4WnJvNDBtcmdmTVRJM3o4WTk4bFBlKzd6Rm1EazR4OEgyNnZUV3laQXVudDdEQkRwbHJFd1NXcGpJTUNrT2d3RmJyMi9wRFg3bkdsMnNhUWwyU0ZLSktlMVZNS2ZXdjF3T0NNQStuWmhvL3RQL285RytmZTNHdFN6bUJtQ3VGRzUrTzVlWjc1L25HNzF5NkRwQS9yRE5JODkwVUM5Qmp0WEJTaWQ5SFdheXEzRkZhZVFvY096ek9JM2RNWVlkOXhCWmt0bUJmUy9Qekg1amlWNzQ2WkhZMjVwRWpNZmtnSnpDbFVERXZQQjVmMVJ1eVMrdnFTc3pvcW5hMWx6S2FhRjJwZjFXNXRqblU4RnJiOE5JbHgxLzh4QndHS1UycU5kUWlzSkhRckNtbVdnR0g1MXZrMXZHYTZ6Qk1IRjdLMGRkcXUzT1pSa2xKNlNvRjAyRnBNYnFTUTFRejFKc2grL2EzbUY2b1Vhc0Z6TXczbUpxdmMvamdFdmZkZFpTRCt5WTVNbnN2WVZERHBRbmlIVWsrSUNsMjJCNWVaaWQ5bWRTK3pLRFlJU3MwZ3d4YU5VVmtMR3ViQmJtVXRjaDRYYUcwa09VVzV4UzVhSlFJVWFTcE5RT0MwRXlPVDlkdkI3NVRNWXNaS0t1VUVxMlZYSThnZjBqbm9WTUgrZWJMbDBEdEx0elVDK1BOZlVaSlMxVUQySVYzZUNuWFBEOXc2elRIcHpSNXorSjkrVlRNY3NmQmNjMW5IeDNuNzM5K25mcEg1cmw5VXBNTkhVbzdyQzJmMkZwVk05MGpwa3F6MjJXbmlpVGlJVFFWZzZWQWU0K0pEZi82OTlaNStNNXBGcWRDdXUyY1JqMUFHMFdST3VveDVIVVl5dzBMTnNLNU1jVEJ4YlV1ZzhUdXpwQUw0TFRDRm9KU0RZSXd4QllEYnI5bm1rZFBUSEhneGlrV2xtck16c2JFTmJQTHJHVld5SXVDVjFhZTRKV1ZiM0wvRFR2Y2RlaGRDQnJSaW5wdGpNalVtYXp0eDdyYnlQd0syOG16TFBlZVp0TzBLUXFOVnlGV29EY1FsQyszNTVwQTAyeVV5b04rNGhoa2d2S2FXaU9RTU5aQm94bmVIamVpeVd5WVowQWtJcmE3bmNtelQ2ejRJTlJTamlwZkI4aC8xS09VS3ZOODcwY1JKS2lIWmoraVdvcVMxOHA5V2FBdkxvenhveDg4aE1rVDBzeVg5am9lbkN2cDJFTk54NTk0eHdSZmZMSk44OEVKRGpmTHBwZ1dSNUc2c3VlaHlsMGE1ZXlIMnAzYkhwa2NGTDdzdkNzbGlDdTd6NWV6Z05jM0hYL2hzU2E5Ym9JV0tQcEZ5WDhxQlVxSUl4aHJsRW9aNTJ2bG0yUVV5NXQ5dXYyc0xMcFYrYjBlUFhHU3ovelVUekYzWUo2blgvNkgzUERnQlBPek5RTGxFTy93VmY4anR5VXBVVGpCNVE0bG10d1ZQSGYrdHprNGZZS0ZxUnZKa3g3T0pxQmlpa3I2WDR1UGNIamlCaWJpVzNoeCtWK3dKZXVvUW1qVUZMVlEwOTBxS0lhZVVDdFU5V2VOMk5OTG9kMzNoRTJsbWhNaFlTMjhkWFpmNi9pVmM5dTdjK3plQzhOQllhdDEwbkt0RnUxdm15STlMU3pEdE5oMVNsUktOWTlPdDk0cnFBY0tVTjRMbTcyRXhEbysrYkdiK2VtUExXQzMyN2lpVk9sNnIzQ1ZzV2FXd1hRallISWk1bmVlRzNCc0lTUndVaFhrZ29sQ01LYU1HbzQ5dXFmeVNZMEM2OEE1alRabDM2VFZDdmhYMyt4Z1JQSEE4UWJEeENJQ1JpbVVVVmcvdWxOVXRjNjVCSDJnTkxVb3hCaE5iaDFaYWpGQmkvZC83QlA4MG4vNXQzblBoei9FeWR0dVorRlltM3I0T28xQXl0UnQ1T2ZyOU80cTZNeDZNaXNVRGtRMHc2eExYSnZpOE1MZEdHMEk0ekdDcUk2Z01GcWpqY0s1Z29ncDBzMGEvV1NGVFBkSXM5THdPcW9ackMxcnNWcXNDUXhFZ2FJWksycHgrYVJvdEFMaVNFVkY3aTlkT3J0emhxc2wyL2NEaGJvT2tQOUlKOGtLOXBneDFDZGI5YWxqcytNZnNjN2ZtT2NlYnoycjNRRnpjeTMrcy8va0ZvNDMreVM5RkhFZXNWSXhQMVdYWEJSNUlVelhGSzFZOCt2ZjJPSElZbzFXRk9BS3dRa0VvU0dxaGJzM3M2QVFYMDRaK3NyRXdic3k3WW9DMlBJQi8vRHpXN3puNWpyamRZT2dDY0lBZ2pKVmNnS2k5M2djN2c1bGxiTDVLQW93Q0xPTEIvbUpQLzlYK1pPLytCYzRjdUlvUmd0YUdTSTF6bkQ0REU0U2NxZklMR1FPVWl0a2VXbGhXbFFiYnRYSTk3Y01XcHhZZW9qQXhMdHBvdGFtbFBYcm9ITHRoVm80d1dDMVFHcnJTSkJodE1aRW1xZ1drRGxOVWpGWVVWQktjV3FoVUlzVUpqSTBwK0p3ZnFrMjJ4d0wyNXVydyswc2NTTjdZSFd0MzFkdkc0QlVOS3V1Q3NINlZMTSt2VFJlLzZIYzJpUFdLeHpDV3J2UEJ6NTRuSi81NkJ6RnlucnBSRktVOHhONW9iQ2pCbHZaNGFBb2hIMlRFYXJWNExlZTdiSi9NbUNxRlpUMVN1cklVd2RhRTBRR0UrZ3FncFQ2TE85bGwrVUtBc1gvOHJ2cmRQdWVUejgyaTZac3FBSGtxY05YdzBSdWo0eCtWL1JvTkRyUUJBcU8zSFFIZit3WC9qTWUrOGhIcWRjMFV1U2wvRVZCRkV5eE0xaGpzM2VXUWFicFprSXZMUmVMNWxaaGJZRDRXcW5JRlkvUlY3MnhEaTNlVDdNeHkyaXl2aVFkUnRLYTh1c0h0UnJGUU9PS1BucGlFd0xGZU4xZ2pNRXJnMGVYYVc2Rk9pdGxEUlpVSDVzb21ObC91SFhuSGZmUEhwdWRyeFhuWHUxdWVDZWFxeGJCNnZ0Rmtub3pabVpobkVFM3ZRNlFmOTl6KytGNTFqckQwWjZQQ0tqUGpqVm05NDNWUDV3V2Zza0hta0k4dmF6Z3h6OTFsSGZkUGNWZ3EwK1JGbGhiUGxVOXVteXVqU1FrVWhhZmVlcTRZYW1KYXRUNDE5L1k0TmkrR3RQTkFHdEhDdGxLV200OWVlYjN5TURMYU5Lb0dkYTdCZi93MzI3eUozNW9QMHVUQWRtZ1FKeVVBSE5sT2piYU1hZ0FyUUZUS29ITHZvWGkwSzJQOE00Zis0c2NPWGtLWElvU2gxSUdGVFlRRkZvOFcvMXRYbHQvampRUEdLU2FJZ3ZKMGhpYnRqQnVtc242ZnFLNloyaDdwWXQ4bGVNY25MdUxpZG84SXJ2dFRZbzhLM1c0NGhCWHluMU5HTEYrc1UwL3ZFSVlsN2xWS1ZKVVJHR0o3TlJDSEl5NjdPWFhDb0tTRnBaQU4rcmp0Uk5Iam8zZGUrajR1Rm01TkZqcGQvS2lldC9VbThBaFVFYnFtZmx4Mmp1RFA1SXE1VzBCa0lYSkp0dTlWUHM5TXlCVHpYaCtybEg3Y09iOHZEV0tOQzhZbndyNXhjOGNZckVKSm81SSt5azJMU1hnaFZkbDU3bVNhUGlxQys0OUpQMk1vM01SUjQ1TjhpK2UyS0FXS2c0dE5FcEFWVFZNNllsVmR0V2Q3QTZtTXpZZThzMkxsb3RyS1o5NVpKck9kb1l2aER3YjlVNHFNT2xTTm84ckl4QzZiT1JvSXl3Y3ZaZTdQdnh6VE16dVE1d3RiK1NvVllvS0JjVGxvQXdycXl1OHV2SWl2YUZocTYwWjlFSzhyNzV3Mk1QcURZWkZ0d1MyVk4xK0ZYTEQwaU5NTnVadzJRQlVhUkRuckMwYnBDaVVOdGdzUlN0UHJ6M2t1Yk9YV0U4M21aOE15MW1SaXAwd1N1T2xMTmFubTVTZ29SUnVqcGkwWGdFRnBqazFWN3ZqMktucGcvVlduS3hkNm5jckprdC92L2QzT01oVVlSMFBuVGpLNWEzMmRSYnIzL1dVT3dGVjFZVXV3M1k5Q3BwSzA3SmF4Qml0Q2dkM0htOXhaRW9ZYlBjd1VZQXhCdnhvczVKVSs1WEsvc2F1QVVQRlRQVzJCaHlZYXZEKzJ5YjRGMTlhSlNIZ29XTk5iRkd1V0hPdUhFNHE2VjlWaWErRVFTWjg0Wmx0Ymw2TXlMcDUyV0dYVXBxQ0xmK3RTS211MVZxcVRWTGwvTGVKTEJNSFRuSDhIVDlKclRWZFJqWVRva3hVMWozT28vRDRvc0M3RE5YWHJLNEViT1hiTEV3RmpFMXBtZzFQSEZRZGZ3RmZqSWFveW5ReWN3VkoxaThqbHdtd2FZTGdzWGs1em12Q0NLME5PcXpodlREV21tUmFsdmpDU3hmWTZRNjUrMlNOdWNtQXRiNWpLQkFFbXR3cnVxbGh2TzdMdVJGdGdITGljYWFoMkJnSWZXZHFqWVd4RDl6M2dmb2RSMjZkK2RLM2Z1ZkNQM3Y1eWJYVDFUMFpBQW1RMjhKWjU3eHZoRVk1NStSNkJQbjNPUHVteDluc0RwUVRHYTF2cnAzYVAzdjNkQ1A2b1Y2U3g2S1ZTbkxMeHg4WjQrNGxSVHJNUVRSWlV1QXlXOXFLaXI3S1JGVlNkYWttOGhDRlVaQU5DMlpxaXFPTE5UNzN6UzBTNjduNTZEaEY3bmFuOVJSWFB6OE1GT3ZXOE0rL3NNNFAzVHRGWEpuTWlTb3Z2SWhDS2NFYnRRdEtjWXJBYUV3Z05NYm51ZUdkUDBOejZoREtSS2lnaGdvaWxLcWV6R2hzT2lEcGRlaDAra1NOS2M2dWZaTURCNGZzbnc5b05SUnhOZXdVR1VXa3l5RXZvV1NZQ2twYnhPUHo5ekRYWE1MYUhIRkZWWmhyOGlUQjJSeWJwWGpyVUNvZ1MxTFdMbDFnMDdkWjZRN1k2SlVwNmxROVpLeG1pQU5ON2lGM2lrRld1bEJHcHF3UnJTKy82OGlBUTZ2VWd0YTA2bVB4elpNSEoyNmMyZGZJT3V2RG5XUlFGSHYxQUVxUVdoVEsvdWxKTG03dVhBZkl2K3RabkJwam96UFE1UnBuVlFOcXh4ZW1IaHFQZ3ZmMDAxdzdyWlVKSFQvMm5pbG02NlZzQW1VUVViaGNxdHBEVlVDcEV1R0tpY0tyWGJXdVVPNGhINjlyanMyRy9ONXpIVHFaNTRiRkJtS2xBbGZaTTFGS1VZODF2L2ZkSVN2ckF6NXc1M1FsR3BSZFJ4U2pLWWVZS3JiTGlzSUUxWWlyRTRKb25IMzNmQklUalZXaExDeGpuU3RLZysya1Q3ZmR4cXVBOGJtRDlQb0ROdnRmWkhLNlhCb2FtMUZUc3h6ZUtrU3dLTHpXV0NrMVU2R0pPRFgvSU9QUk5QbHdRQkRYMGRxVTd2YWkwUXBzVVpBblE1eTFGRmxHYjZmTlVQVm9KenNvSGJEZXRiUzdsdGhvWnNhalV1eWpOWVV2RndqOS85bjdyeURMc3p1L0Qvd2M4emZYcHEzTThsVmQxZDZnMFJoNGpNRU1oOVRRRFpka3lBUVZqRjFwU1czRTJ0allvS2dIQmg4WWVwRWVOeFQ3UUdsbGRrVlIxR29wUjhxTUl3ZkF3QkFZQU4xb2d6YmxYZnE4OXUrTzI0Znp2emV6QzQyWndYQm1oVzcxamNqb3F1cXFtM252UGIvemMxK1RLSUhXRVlLemdQK25Jcm9DbHphZ1JaQlpxczl2bkJ0ODl2TDExYTJxTVBjT2QrWUxuYUJJdVBJaEZIWER2RDdodEc4T3VsemJYbWR2TXYrNHhQbzlSN3pHUmlSckNLSzluS1VrckFvUnBQQU9uT1RxMlM3bkJ0RFVGdWNGcGluUmVZb1ZNbXBmK1phYWFzTnllb05vT2VaZUxMRldBTjRFTm5xYXYvS2xEZjcrTjQ1NHRGL3hyMzU1QzZvR2ErT1lORWtGSnMzNXpkOTl5TlBiT2FrU05HMXBzeGptTGl3L0ZyL1dXcEtrQXR1cXZzM0NsRWZqZDNtaSswV2NOUWh2b3UyQ01WU3pHY1lZdW10YjVMMFZwTlJZVzZJVFF6K055aXVOalhXL1JWQ2FRTzFqWURqZmJsS2xwNXVzMEJjOVRGbFJ6WXNXNmk5d3htQ01RMHJSVW85ZHBCYWJxRDY1bnF4RStIN3RJSk1jakJ6VG91QmdZcml3bGFFelJab3BxZ3FhVnVYRkJvZlFFaTBqRW1CRkJRSUIwOEJBZVJvaFZwTnovYi84K1Q5ei9hbXNrLzE3cjMvai9sZENpSkJMNnozNzA3bVZZaW1PRWM2dERibTBzY0x1YUVvL1M3aDFNUDQ0ZzN6UVkxelV1Qk9mODY2U3N2ZjhoWTFmeUpYNDVHaGFDdSs5S0l4QWVuanliSXB4c1NHdlM3ZUVoVHNYYTNMajQrRTZHYW0waXU1dGJlUkRQTjdXUVVjSlhyNDI0TWFSNGRWYmM1N2N6b2hHdG9JMFRmbjZIY3V2ZldlZi84MnZuR09sSTJsTVdHS29sbjE4MndqTFZKTEVuaHZqb0pNcGpqYTd5TTJMWEZ4N0FZU01rajVBTlM5Qkt2b2IyK1RkenJMa0txc3BrL3FycElraEJNaGFxTXVralA0K2VFbFZDMm9qcUd2QmJPNFp1ck04a1Q1Sk1aMWhxcHBpUEdVK21UQWRqMm5LbW1vMnd4ckRiRHlPdWxqVzgranVYWHFyUGQ0NnVvY05JZTVFUkN3WnE5cHplR3dvS2tlYVNKSk1jZUtmQzdON2x2bmR3UGhSZzVTd3NwcVFLb2xIa0NuUUJOSFVuSE5Pcm8vMnl1OFVzL3IwZkZjc1NNQkNDSGswSzlrWlRZV1dnb3ZyQS9ZbUJadkRMcGMyVmptWUZoOW5rR1dUYnQzcFBZaFFTaVpab25wQ1JCVk1YOWMwMXZPUHZ4MVlIMmkrK0d6ZUhzeDQ4RU9iUFlqVDFWakdMR1JHT2ZrOXRHTmdFVGNHalJNSWEvblZsd2I4eGc5bmZPWGRnai81ZkM4eThIVENWMy8zUGl1cDRFd21tUnhhbEc2elJZdXZFTFpkMm1tQlhoQ3RmS0RUMFZnQ295UmozWlZMbzU3Z1lYeTRUOUxwMGx2ZlJDWDVZZ3UwMU5FZGoyRWpjM1NVb213VWswTGpqTVEyVUpuQXBEQlV0YWMyZ2NwNFh0cSt5TTY5QnlpZDBPbjFrQ29PTDhyWkhLVTBFSkJhNHhwTE9aa1NoRVRySE92cTJCd0VrTWhJdHhXeExLMWQ0TkZPemZISWNHWXJaN2lhVWh4YTlsODc0c0gzeGlRK3A5dk5PVktPL0VyQzRMa2N0WnJpY1hTSGlFdXBZRDdPbjE3ZDdqNTVzRE1ldCtjMElhS0JEV0JEQ001Njd5Wmw3WlVRWVg5V2hGVEwwRWsxOTQ3R0gyZVFEd0JqTFhqb2VTOUxObDYrdlBVWEJmN0s4V1JPWStLSzNBYkJ1N3VlWGk2NXVKRVFGajNITWtNc1NxdDJtdFZDTkJaVGViK1l6cmRCdERTU2JUelBYdWd5M096eWo3NTl6Tlo2aHRlYS8vQi91TStYWDF6aG1hME1ZeU1FSkpaVEF0Zlc0enFWcERxT1FhV1VwS2xFaHNEWUswYWJROUpPd3ZuK1V5aVJNemsrcGlnclZzK2VKOG42TENjSk9CQUJnZWE5dTkvQnFTbnphc0RScE1Ob0twblBKWk9wb3lnZDg4TFMxRkVaSlFzWnI1ejlOTnBybksxUlNsT1hKY0Y3bXFwa09ocFRsWE84czFockVTSHcxaHR2MGRRbEtsUGNtTjVHSm90eHRNQUNKa1NCaUk2RXV2Rk1KNGJwb1dIL3V6T21iemI0T2xCV0pYVmRJWnpFSHd2MmI4MVJIZWh2ZEhCenlIMWdiYWh5TGFYWnVUTzdYNVoyQVV0WmVFcnFVN3NUNFU5RXNvVnZNOXF3bHpPdm1vOHpDQ2RUbzBWcEwxSXRjeVhZZEVnU3JVUWtOam44dk9EWWVmNi9YNHVZbE04OW5VZWVRNGhnd2VCUDFWYitaRzBWVHRObjJ5QnhMVk1RNGg1Z1BHb1lkalUvYzMzQWQzWTlOMzkzaDZyeGZQNkZOYXlOMjhmUThrTm9NMUNheWJiNWo4czJJZVAyM3BTV2FpM0RLOG1rMm1WMzlCNGJTakNaVHRsNjRpblN2TnVTNE9NQ0x6Z1h4ZWE2S1d2REt6eWNIT050em5oYU1wOVhHR013eHVLbG9JYW94QmdjNXdibkdTWURVQkxuTXF5eFdHTW9abk9rRXBURkxMcG5BWFZac2I5N3lIZzI1b2tyRjdrM2VZZ3pQamJmN2ZaZEMyZ1FHQUplU0lMelZMV25DQjUxWHREdmRlanZkaWlQYXFxeVlqeVowTzEyR2NnKzQyOFV6TitxMk81MjJKMDBPT0gwc05TLyt1WG5MbDB2Qy90TzQ5eWJoN1A2blhjZkh0NmFsdldFcUNwZnQxbWxCb3p6d1UzTHhxZGEwY25TOEhFR2FSLzlUaWFNWFRyVzVtdTkvTUpUMnl2L292UDBLK013MXNhRDdRTythVEFpNGZhQm85K1JuRjNWN1lqMUZFZ1FDRDQyczZIRnovdDJnUmphS0Ftbi8yNTd2eldOWjZ1dnVIcHRoYi8zUHo1Z09xbjU1WmZYNkVtb20wQVFjVndzMnl5bFZTeXZraGEvVlphZStjeUFoOGxhVHJYU3dZV0dkM2R1OCtqK21MUGJWOW0rY0FtOGEvc09XSEJzZzNlNHNtQThHdlBhN1RlWmx6WHpTVWxUR1JwakNWS1FwRG1aVGhEVzRaM2pxYzNuT05lOVRGMmJtQ0Y5ZFBVTndTT2tSS2NwU21tOHM5eDg3d2J2M3JqQkU5Y3VrU2NacisyOHcxNTVURmZKOW9LS2Z1MVNRWklJQkFvbEpOWTRqUEVZRzJnNkFyMHRHZlpUZXE1TG5xVk1KaE5xNStqb25ObCt6ZDdPRkt5bW1ZTXRnKzdrMmJrOFVjOFB1OW5uTG02dS9zSzFzeXVmNlNWcVJRaFp6T3FtQ2VGOWp0WXQ4VE1FSHdMOVBLRnE3UHZ3SzZyOTh2OUxDaEFmRU1IN3BkVG81cUJ6NmZyV3lwLzFpRjVqUFM1NEVGR0VRVWlKRUlIS0NINzRzR0Y3UGVIOGhzWXN4clNjTk5HK0RRUmFPbTNzRWNSeUxCdVdnSWdUcjcraWRLeG8ySjg3UktMbzl4UTZFU1J0WUxnUUVDSHl2eGRBSkNuajV6dWZtcWhFSW1DODJjZDBVeXJyZWVmQklVVVYrUEtuZjRsTzFtdHhXdTNQNVMydWFTZ200eWkyYlFKdjNIdVRnK0k0Q3N5cGdFZ2xTaXNFc2RHM29VYnJqQmMyWHFFcnVpM0xNdEJVQmM0NTBpeVBrcVUrME5RVjFocmVmZThtL1VHSDg5dGI3SS8yK2M2anQ2bUZKYytTaUY0bWlzaEZYYTdvbllMM0NPTmJSM1ZvQ2svUmVPbytwQ2JRRHgzU05HRnYveEFRREFkZGpJUGoyUnhCUUN0Tm5tVW9yVEhXSmQ2SG9VQmMwVUo4YnIzZitabno2NE90Vkt2cDBhd3NIdHZDQjJ1ZHFJdzdIUnRDbkNvemdoQmMzbHJsbGV2bnViMTcvTkVPa0JDQ0RLZFUzTGVIdld2WHQxZi90QkIwcThhQkVMRWtraktDQ1lQSFc0Y1RpanNIbHJWaHd0WlFScmhJT05IWVhRYk1naXV5Q0lXMmZ3Z3RjM0FSUEl0czB1MG9iaDQyZk9uWkZaN2J6cWhWd28wamkvQ096V0dLWFVvR0NaSlVFWHhnUGpQdDJEZGdsT1JvcTAvSUUyYVY1ZDdEa2dzclQvTGxULzU4L0lCVkNzNUVGdUJrVEZNVWVPc3dUVU9xY25hTzk3bDkrQjVTdGZwWVBtQ2RwV2thakcyb2pXV1lidkRNeW5QNHhsUE1aeGhUeGI2QXFPVmxUSU5zczhPTjkyNFJndVhpK1MwU25iQmZqcmc1dlIrYmRDMWF3WWY0ZW1RUVpFSVNXemRKa2loVWl6Rnp6dE5VanFMeEVYcHlZQWtpN2x4R2t3bDVsdEhKTXFyR01qSHpLTC9VT0lRSVFnUkVJRVNqSCtjVlBteHJLVCs1MXN1ZnkxSjlzRDhwOWs2ZDUrWGRJNFNRVWdxaGxKWUlJUUpDQ0NuWlhoK3cyc3Y0Wi8vQi80MS85Ky85QnZiSExPay9FZ0hTcmkwV1N1NmQ3Wlh1VXhkWGUzL0tPSjlYeGkyaEhWSktoRlNFRUxERzRtcEw1UlR2UG13WTVJcnR0dHhhSE41WTV5L1VTVTZXaUp4cTFnbGlLZTBqUkVBb01BTCsyYnRUcnZZektCMWQ2VmtkSnJ5elgzSHZvS0dUUlZxdGRSSHBPNS9aVnVNMmZpK2pKYVBWRGo1VFRHYU8zWjJTaXl1WCtNS0xYNGl3RFcveHBxYVl6R21LRW1jOTNqUjQ3MmpxQ21VRXQvYmVvYkIxVkZUMHJSYXZjWmpHVTllV3JmUThsN29YS2VZRlFnZ1czdkRHTkRoblkzQVErT0diYjNOd3VNK1Z5K2NaOVB0NEJ6L1llWWZEWm9SU2tpQ2phSnhvRlNTREQvUVNSU1lFMW5xOGlNdFBMV2duZ3lKcWptbm8xSkppM0NDVm9paEtwdk1DSVNTSlRoblBhOFI1UlZkcmZHR2pSWngxclErTEYxSUtRZ2hLQ1hsK2tLY3ZkckprUEM3cWZSY3JpYVQ5MGtBU0F0cDdyMW9KYnhGQ0VFWFY0RnpnLy81ZmZvV2pXZlhSemlDUEJVaCtkV1A0cWJPcnZWODAxcVZWWTdIT3QySnVvbFUyanhXb05SWnZQVTVwYnV3YThrUnlmbDBqYUpjVXRCOHFjY29VaUtJTWhQZVRwSlpVMndCU1NJNUx3eHVQQXA5N2VraFZHS29tUU9NNXQ1N1M3eWxlZjFEeStyMFNyV0NZS1l6MWxCSFlpN0h4eVlwaGp1bG9qc2FPMFpHaExnMmYvc1RQTXVnTzhNNHhuNVhNamcrSi9sWnhvZW1NcGE1SytsbWZlNC91YzIveWdHQURwbkxVbGFNcUhWVVZwMW5YVnE0enBJc3hEZDdGTERzK1BrWWxDbThkVFZWeDcvNUQ3dDYveDlhWk5icDVocFNSTnZDN08yOVMwSkIxRTRTV0xRK2ZVeEtua1ZBbGpNZlk5a0lYRVVJajI0V3JEWUhFU0pnNjZsWUVZanFkWWIwbnl6TlVrTndiemVnODNTY1lUMm9rblN5Ti9CZ2xTWlNPbkJVaGtFS3NyWFR6bC91ZHJEcVlsZy9hSUZrYXRaNGFFeThuWDRGSXNwdFZEU0g4ZUY3S1J5bEFra1VHZVhwNzlVdHIzZnlMUmVPVWJUOHdJYUszaFpRU0tXUVVoUXNPWXczZU9JSk1lRyt2d2RqQTVjMFVyVnFVYWd0a1hBWkNlUDhHUExRbFZ4Q0NMTmYwQndtUEpvNTdSNGFmZWFKTE9UZExVSkYxa0FuQm1WNENXdkxOOTZiYzJpMjVkQ2FuMTFWNEI3YUZ6eGZEaktxYk1qNTJURWNOUlRYblU4OS9ndTJWODh6SFk0cnBITzhjeHRTdGVydW5ya3JLb21RMm42R3M1TDM3NzFHVUpkWGNVczRNODdtbEtDelNhMTdjdUlhZE5SRVdJeVZLYWRJMEkwa3pUTk53NDhZdGJ0Nit3OGJhZ0xYVklWcHFoSkE4bXUzeHcrTzdDQlZJdWpwS3FsWXVDdWExcWhJdEdCa3RCSTBCMjRwalN5WFJPdUoybEFRclBaMUtVYzROSWNwWlV0Y1ZTWktTcGduVDQ0cTZKMG5PNWRUakVsRUhza1NqcFl4KzlGcmhRMEJyUlpib1hwNm81NTg4dTNiNTJ2YjZwZTIxL3RhNTljSDVyWlhlMlRQRDdyYnpqckt4dmcyV0pWbnJNUnRGOFpFYzg1NGU4UUpDUzlrMTFxbXlOZ0VsaFZRUzYxenJJU2hSV3BPMlhocENTT3Fxb1pyTzhmME92L242bktvSi9QbFA5Mm1WYlU2Q29mVW14SitNYTNXaVNCS0pVaEpySWxIcWgzZm55S3BtZmx6aldqV1N1TUdNNE1DbThWeklGWnZQcm5Jd043eXhHeVZIbnozWDVmeHFSdDBFbURVVXE1NnFkcEdBNVdydTdINlhLNzN6alBhT1dtaEtRcEttVk1VTTUzMHNrNExEMm9hVmJNQUZmWkZ2M3Y5dTYwVVlTNjBrMTV5L2ZKWkJPcUN1U3dnQzV5eGw2ZW4xK25qbnVIbnJEamZ2M3VQeXhTMDJWMWVpZzI4SVdHdTVjZkFBR3dLcGpMMVRFSUtnWXFub1JJVEpLQ0NWQXVrRHVSQk1qYWRwb3A2V1NrQnFTU3JCclFWOEJTdFZ5dEdzSnMwN05LYWhhV3E2ZWM3WmxRSDNIeFJVZ3h4MUp1WHdmc1ZhQTRNOGpYTW9IOUJLWUt4SEtrbWFxUFZVeVQ4NzZPUUJLWjJVb2d4UVdlK2EwYno2M2x2Mzl2K3oxKy9zdlFFVUxWcDQ2ZExMaWNmaVJ6S0R5Tk1aNU5KYS83T2RSSDI2YnB6d1BpeTFaVUtJdXd1dFZPdWhJZG9KVXFDcG94ZDQwa25ZSFR2R1plRHNXa0kzamJBU1lCa3dRc2pvUnBzSWtrUmlHazlSV296ekNPOTUrMUhGbWJVTzV3ZWE0QU5KT3dXeklUYi9xQk9Kb05WYzBkZXdlMVR6OVhjbVBCeGJybTZrSkIzTmJwWnhmR3lwNW9iZ0lCMk9LTWNsbS9sNUVGQlZWZXdiNm9yWmRJcHpEdHMwekNZVEpwTXhvZlI4Ly9VZmN1L09JMlpITTRwWlJXVWRuN3oyUEJmNm0xanZzZTBTVUVxSmM0NkhEeC95MXJ2dmNXWmpsYXVYTDBJSUtLVkkwNVJ4UGVlTm8xdFlERmtlN2RXa2pFYWhVcDNvcjNvWEFaa1NqM1dleGdXYXhtT01YMlpUTHlCTEJDRUhNWExZMGlHa3hqbERXY1lzMHMxemlsbE5Jd0txbjlBa1VJOHFmT09qemJWejdVN0tMOHV0T25neHI0eVl6bXZsdmM4U0pYdHBvb2VEVHZiVTFrcnZVOXRyZzJFZ1RFZnpxdUQ5NUt6d1VROFFEV1JDaU43RlllY1h0T0NUMWdkaGZSRGUrK1VreTNtL0hLdTYxcTVNU0lXVUNsTTNsTE1ha1Nic1RnSVBqdzFQbk0vcDUyb3BOY29wN3c5ckkvWFd0SWhncVFRaVRmak9ROE8xallTVmxsWFhhajlIa3RLcG5pWGdhVWhSM1MydW5OdmtxZlByTkdqZWVsQmduV1hheXptY05GU3pCdUU5YTV1YW0vc1BtTTh0VzcyenBHbENVUlJ4ZCtFZG82TWpadE1wazlHSW84TkRqdmIybVIvT3VYbnZQbzJwTWM2eHZySEpaNTk4Q2VVQzArbUlwcWxKMGc3T0dkNTQ0eTF1M0w3Tmxjdm5PWDkybXl5TDBIclhXdFE5bk8xeXQzaUlrSEhKcVJPRmttSnBOZWRhUG96M2djcDZiQUJUMmNpY2JIcysyemdJOGRLeER0Sit2R2pDa2FWcFBFcHBURlBqdktQWDdTSTk3QjJPRVYxRk9zZ282Z1pkdGdTMUZ1Q3BGZ0xqVXJaTXlkWjhOUVNLeWpDZmx6anJoR25NZXIrVC9Nelp0Y0hQcEVwVisrTml6NGR3eW1YeUl4b2diVTJwZ0ZSSjJUbmJUMzlCRUQ1aG5NZURzRzR4NnZYUkVzREZJRkZLTHU4UGxXaWN0NFFRbUJjTnZWd3pLdUhXYnNOYVg3TTUwRXRvaDJ1WEh1NTllNURZQ2FsdXhwdjNDNTRZQ0ZLaDhPM2hrYUlOa2dXSzEzdms2blc2VC85Wnd2bWZwWGZsODNTM251ZmlFNjl3N3RyTHlQNVY4czRaaEUreE5UaHJXZC9TVE9lR0cvdDNHSThuYk9ickNBUlZPYWVZRjB6R1k2YVRDVWY3Kyt6dDdQRG8vaU9Dc1V6S2l1UFpGSkVvdnZ5RkwvRFU1a1hxcWlaSk5MVXhXRXROR3djQUFHNFNTVVJCVkdlNC8yQ0h1dzhmY3VIY0ZoZk9iclVscGFldTRtSDF3ZlB1OFIwbTlZUXMweVFkSFcwZVpLdFAzUFpwVWhEQmkxTEdjWFpwOFpYRktySDBUZlF1dEhaMkVmd3B1NUswRXBTakpscmtlazlkMTZna0ljOHl4cE9TbWFuSUJoaytWelRUaHA1TU1kYlJXSWNTQ2gwbG41WTNacHBxZEtLeEFZS00zUGFvZkZOTHJlVm1OMDAvcFlSWW1WWE5XOGI1NWxTUUxMN0VSeWxBRmt2U0pJU2cxM1A5Q3NIOWpIRmVTS21Fa0xLRmR5dzRIWEdzbWlRSlFzUU5jRmoySjlGOXB5eEtwRlJVWHZIREJ6Vkt3dFpRbzNVay9tZ3Q4Q0pPYmhhNnZBR3dDdDU2V1BQcytTN0J4TUFNTFdSY2hvQU1BaEVDWG1WMG52bUxaT2RlNFdodVdGM2RZREt1K09HdFBYWU9DaHFmMFFtYlhGNTltaWZQdjhEVFZ6L0I1dkFLaVJoaWpPZk84UVBlZWZRdVJURkhHU2ltYzBiSFJ6eTRlNThIZCs5enRIOUlYVVNZaVpDS0IwZFR6bXlmNTFkLzRjdkl4bUdkSTBrN0tLbDUrR2lYTy9mdmMyWnpqYzMxdGFVSWQxbFZTQm5vZFRyY0grM3p4dUZOSklHc28wbHloWlN5TFZ2YnpDb2pHa0VLZ1pieGRZcUlxMGNJU1M1eUpBTGpMR1Zwc01aaFRaUW5Da29RRGh2R3N3cXROVVZaeEFNdk5jNEdEa2RUa241S2R6V25kcDYwQkMwa1ZXT3dMcUMwSmdTUGFSeWROQ1hWVVRDdnNoYVZLTTV1cklBUHlOYUFWQ2VxczdIU2YzcDkwR1U4cTI1WHhsYWM2QVl2czhsSFNYcDBZV1p2RHVmMXQ0VFhmMW5LY05ZNlI1WjNFRjV5Q3RRV0hXSHJDTkNUU2tVWXFrNXdqVU5waWZlUzJXZ2FiN3QrenYvdzNRa1BEZ3kvOHVraGc3NXFiOEVvekJiTk1tUHBsT1FaYVo2aFFvVFFDeDk5TTBJSXJUakRTWTNsdlVmaVVRS0tLcUpqYjkyNHlYUStvNmtMcXJKRUpRa1hMbDdnM0xsem5EOS9nYXRyVjNuK1RNcThIbkV3M1dILzRBSDM3NzFCV2puQ3ZPSndiNTl5TnNkWlM5VVlVbXU1NkFLaDArY1RuL2dVYVVpWXpZL0k4ZzZUeVpUdnZmb0R5cWJtbVd1WEVkNHhHWThvNWpPeVBHdW5SUm5qWXM0NzQ3czBHSHBaaWt6amFGZTB4cUVpeUZZeFBsS2ZsL3F2QXJ5SzdsVE9ncFlTMzhqb1AyK2lDTGd6SGx0N2FnZkJHQTZQcDNRNk9VMFRtRXlQNk5ZdDByb01UUGRtZEFjcGVqV2xMaDJaVmZpcXBqSVdxVFREYm9LV2txcHBVRmFTYW9sMkFTMER0akhvRm9IZ2cwY0tSWktvN3ZiNjRGOTdXUWo3dGRkdi9mdlcrYVZOdzZJbitkQm5rRjZxRmx2UUJTWW5LYXliSklKVWlmQ1N0VFoxTnA1aTYyS21VRkl0ZXhBaEl1eGo0U2ZvWEx4ZFJZdHpxc3NhWngxSmxyRXpzZXhQTFJzRHpVby9LcHRZRXhseldScGxmd3ByZWU5UndaTXJHbWZpeGxndWJLTUpyV3FLQUZ0anlVaTNuME1Ld2RHMDRPeldPb2Q3ZTl5N2M0ZXFMT0kyVzBpS3FtYi80SkE3OSs1dzU4NDk5dmFQc0kzZy9QcGxycDU3bHF0WG5xTTcyQ1RycnRIcERnbFNNUzlMcmhZRnYxUVlmc1lFWGhDYTduUk81UnhqNzVqTUMzNzQ5anRVcHVIaXVTMTYzUTR1ZVBJOFJ5dUZrZ3BqYXBSVS9PRFJEVzZNSDVJb1JacHJaSFRVUVltb2hhVlY3QU9janp1S1dHSUpsSXo5U0xTREErTU1qVFhVeHNYM1ZNcW83bElhbXRKUzdWY2NIb3lZRnhWRlZWR1dOVUVvcXJxbUtodHFaK2tNVWxTdWFid25UQXlKaXFQZXVtbG9mT3duODBUVHlSTHVIa3lvbW9aVWE0cWlRVXRGMDlqbzFDdGx1M2owdXBNbEY1TkUzOWs3bnQxcGxRS1dUaW9mK2dEWjdLWFVOZ2gzQ3ZJY1FNeXR2OTNSTWtzRXp4dnJ0QkRnZkR6OFdpY3RRekRXckZFb0xYNllvcTNZQW5GNUpSWFlKcUpoZGFJNG5BZHVQS2pJVThsR1I3Yk5PeEdrcHhVN3h6WHYzWnZ6ekdhR2M5Q2E0VWJlU1F1SVhDQ1FtL2t4Zm5DVi92b1cwMWxKbW1hczlITGVlZnR0aWlJU2ZwVFdwSG0rTEFlTnRZekhFeDd0N3ZMT2V6ZTU5L0FoWlZreEdLeHkrWW5ybkw5eW5TdFBQYytWcDE3azRwVnJkQzgvZ1ZqcG8vc3BvcG5qYjl5aWVQQ0k3Ky9zNHJLRTgyZlBrQ1VKMWpxeUxFVW5LV21hWXEybDErOXliN0xQNjNzMzQ2VWhRR2NLNjF1V2pHd1ZHSVZZSUhDV3hDZ2g0bHBXdGoyS2JuY2tvWFVUVWpMNklEcmphV3FMTFJ6bW9HSjBQS1ZwRE01YXBCU29KS1dwRzhyYTRCTEpjTE1iUzdNRTlpY1QzTnlTS1lYekVTRlExQWFwRTRyYWNEaWVjUG5jS29OT2psSUs0MncwUUZLeU5TUlZKRXFobFJpQ1dOMGJGMTl0akoxekVpUWZqUXd5ajZDMDA3cEtLb0JjRzJiN243Nis4c3hrWmk3TXlpWXFsd2dSZ1h0Q3RFSUxKemZjWWkyNFhBNjJFcDVTaWNnQmJ4eUpWdGlnZUcrbnBtNDhHNE9FUEpOWUY0TnJWbnVzRTF6YnlwQTZlbjA0RjFvenpUam1GUWlFa0lqUTBKUXowak5QbzdPY2FkbHcrZncyUjd1UHVIZi9BWUYySVpZa2FLVmJvS1ZBS3JVMDZTekxra2VQZHJsMzd3RzM3OXhqVmhUMCtqMDJ6cHhCYjUybDJOeG1mdVU2NXFubjhOZWZ3WjYvZ0toS1pnOGVJTTlza0hWekNHQ2RKYzl5VE5PMGJscUtVVG5uZDI2OHpyaVlJb2p2MndLZnRlQzUreEMxaDcyUENHRFowZ1lXMDZ4QTdOY1d6cjlTbktUNnNOaTh0eVdVT1dxWXpZcFdnU1hFVWJwS2FHcERVUnQwTjZHLzFxRTJsc1pZaXFibXdjTVJvUWxrVXJhVTZIZ0RHZXZSSXRETmNqcHBpaVErWDVJa1M5RSsxUzZORytNNG5sUnFielQvamRyYXcxTjdFZitoRDVCNTQ3aDRaZENXTzM0WklFS1FUVXJydnZEOHFuajU4dUF6anc3clpESXo3YXcrb0xWR3RiZ3NDRXY0dUZSeWlkSmRyRnExMGkxeTFsTVZOVnBLMEpvYmV6WDNqd3huVjFPR1hjMWdvRG1jR1g3bnJRbFN4S0JKczJqQXMwQUwrM0N5KzFkS0V1YjcxQ0doZi9ZNng5T1MvcURIUmk4aFBmNEJycWtvcmNRVDBiaEt0WktnUzFKWHE5K3JOQ0hFcG5wdi80RGJkKzZ6ZjNpTVVvcE1SK2lNVEhQa2NBMjFkUkdlZUFZeFhLZXNHNnFtUkd1QkVvcXFhbUxnQ3NHOXcxMSsrNjN2TWk1bktDSFFXcEptQ2JJOWlNNEZiSXg0UW1NUkpxS1VYV3NjRkxmbHNpMnhUdkMwN2J3a0JzY1NGQnBRYzVnZHpDbktNdTVSQUtWVUhOczZSMkVkT3Rmay9SVG5ZOVpwaW9ySnFPSm9WRk0xWnBrVnlyS21yaHU4aHpTSmtxcnpzaUlJMlVLSEZuWVZnZHJHa3F1c211SmdWdjdqc2pFSHA1YUgvaU14eGZyaW43ckVPejg0d2tjbzdnTGxrSVZBcDN1KzEvK3puenZ6cGFmVzg5N3R2WXJqU1kyVUN6dG51VndhV210QkNKVFdTMDkwMWZxalJ4eVJpamVtYzlSVkhSZDNXY0trOHJ4enY4UzZ3TmFLWnEvMDNEc3lKQ0l3S2p5bGlkN29xOE9rUmZ3dWxvWnhYQ3dJMUtOSGlONDVrdUVaNW1YRGhZc1hVTVV1VythSGRKU2xjb0thRktVU2RKSWdwRUFLdVNSc2hWWi9kS0Z3ajRESmRNYjlCNC9ZT3hxUjUxMDZXWVp1cFVHMVZ1VHJaK2h2bmtkbFE1eHpWT1VjZ3NmN3dPNzRpSys4OVQzR3hSUXRGWjRRRFhqeUpPNTZQSzFsUkR1cWJkeHlPZWpraVhScnRNRDJ5d081b0JRdmxucUM5dWYxRUk0OG83MEpUUlBWN3IzelVWMUZST3hjYVFOcFI5TmJ5WERPWTR5TFJMRFNVTmVCZVcwWmx6V2RVM3NSclNSYTYvajNiSHh0amZVWTUxRktMYlBjMFdUT2c3Mng5ekw1K3F5c2JyVUIwbnhrQXVUU2s2dlVsUlBUY2IxWUdLWkMwSk5LOVA3Y3YvN3luem4vN01ibno4eEsrZVQ1cmhqUEhidEhOZDdiQlVDN2RZSHlTS1ZhbGtiRWFVWEVLTXRiZS9IQk9tY3A1dzIyZHVSNVNoTUV0L2RyUmxOTEVlRHFWc2Jucnd6WTZHbFd1NnA5eGtoTFhXejBMWEZNakJmNHBxU2NIVE80K0FtbWxXTzRNa1RxTHFPN3J6TVVZOVk3RmFPdXBSSWVyRUlKZlZMUGMvTHpCZUt5TExTM3I5SUpVaXFHZ3lIclp6WklrNFNGS2dqQmt5UUpnK0VhdXJPT1EyT2FrdHVQN3ZITmQ5N2d1SmpHOXlJRWhGYW9WSk4zZE93cFRtUDhXeWRmUkd1YUltVzdEVzB0Nkp4Zi9wekIreWp3SFVSYmFzWi9FcHFBMlhNY0hZeXgxa2FVZ3d2STF2N09Xa2Z0QTcxK1NtODF3MXFIYVFjdXhsaHNFLzFZbEJBTTg0UlVhN1J1ZjlZMjIvb1d4V0R0eVM0TVlEd3R1SEZubC9tc0VzNzczeTJzZmZVakZTRFB2WEtHZDE0OVpISmNDKy84UXB1M0MvVCsvRjk1OXRPZitmS2x2ejV5YmswZmxlSjhKbmptNm9EanFlWGVmaGtGbXRzU0s3UnZvUE54Z3VVV3JMMDJKY2Z0KzZLc0FXTmROTStzSXpSY2FjV2prZU85MjNNeUJGb0l0R3lKUWliUW1PaEJJcVhBMk1ockNENjBVcVVDVnh6alNlbHVQOEhoYU03bHExY1lqNllVdSsrZ1E4Q0ltb2ZNR0plN1dPOUlaSTRTRWRFYUZsdVk5dkJMSVpGS281T0U5YlYxbnJoeWlmNmdEeXIyRUZJSWd2TTQ2NUFDZXQyY3djb0dxcnZCdUFuc0hCNVFGaFBBSTVSQUo1b2tXVndlOFRVUW9pbHFsR2NOTkM3QzlYMHIxeUpiQ0gxajI4SEh3dmpVMHhxZGhqYkRCRUlKNXNCd2VEU0tXM2pqRVl1ZFJWdWVXaWxZV2MvSnUzclpPeEk4dHJFMFRSUWFYdXRvMXJ1ZDVkQWxUUktVakEyOHNhYmQyY1RyeWxwUDFjU3g4dEh4RE8vOXZIVHV2Mm9DTjRrVTNvOUdnRHovTTF2Y2VPTlFXQnRrQ0V2SWUrL2lFeXZiZitHdlB2Ty9WUm1mT2k2ZElOVnNsSVp1SXJpOG1XTWQzTnRyRjJtaURRSVJ5dytJUzZoVWE0U0FKRW5RS2lFcytwRVE4RDVPZFd6aktPWTF4cnE0WWRhS25mMkc5eDRWakl1SWNrMTF1MjBPb2IwUlBiWTlPSXV5QXdMVmVJZnV4bFZNc2tMZXllZ04xbmowenZmd3pRelZPRVpCVW5jRWRaaGkvQlJubWtodFZlbHlEeUZheExMU2lyelQ0OXoyT2JhMk5wRko3RjhRN2ZhYmdHa01WVjFURkJWTll4Z08rbHc4ZjRWelc1ZkJDNmJ6TWNZMzBaZXhGYXBHUmdaazlHbGNLTU1FakhIeHJtblZHMjBUNFNraVJBS1dpRlFNdkF1dGQwb01MdXM4YnVLWjdaWk1aeVhPZXlyakZ0bytzWWtuNEpWaTgwd1hsWW1sdzFmVG1QYVNDbWdFNjNsQ29pTXVMRXQwdk5SQ3ZENGkzNlZkQnJlOW5KU0Nzalljand0ODRFNForSHNPamxvUW93SGNoenBBL3NSZmZwSmkwckQvY0M2dDlkSGpVdEJYV2d6K3hiLyt3cC9adWpyOEsvUEM1VnBLWEs1WkU0RnNWcE5xd1ZQbmV5UmFjM3Uzb2lnTkFvZjNqdFo1WU9sTUd3K0RXSllLVWtrV2xtNFIwaFZ2dUxLeFVkSlVSRStNeHNQRDQ0WWIreldqbVczaDN2SGZSUTJ1c05UWWlqZ21nYmNWMWVTUXdZVm5PWm9aTGwyNnlHUlNjbnovYmJBV1V4a09IZkg1VGNubzZCR2p5UTd6WW9SRWthWTVXcWNSVnA0a0RBZXJiSi9aWmpEc3hZRkFXeTZHZGdybHJXVStMN2wxNXg3dnZYdURnOE1EckRPc3I2MXo3ZXF6WExyNERIbldZMTZNS2FvNWlNaTZ4Qk9aZlRicWRDa25vRFFJRzczVW5RczAxa1VSdmhCbzJvMzVZa2R0Ylp3SXVuYVBaQThzeHc4bmxIVWQrNDBXMUdoRFhMUmFRQ1NLOWExTzlQTnVzVlpOWTJnYVM5TkE2cURYWGd4U3FSZ29JdTY2dkE4WVoxdlVSS3dhRnYzYndXakt2S3dSVW55MWhGOExNT05FWHVqRG5VR3V2N0RPMjY4ZWlPbTRrWVFvR2dmMFB2ZUxsNTc5d3ArNi9IK2QxVnd3TnBDb2dGYWVxWmVzVGlxMDl5Z3R1SGEydzdtMW5Qc0hOWWVUQ0FpTXdTR1g4UEUwVGR2SmpZOTl5bUx5MVlMalRxTlhyUXMwVlVOWk5nVG40cUgwa3QyeDRlYWpta2RIRFVYdENTMFVRNHBvS3FwVU5LUHhRZEJNRGhDcVEzN21HaDdCK1V0WHVQZk9hNVRUQTdwQ1VrOHI5cXZJbjdER1VjMW1UTWI3SEIzZXA1aVBrVEloU3p0MHVuM1cxalpZWDF1bDI4K1d0MzRrU1VabkhoRThaVkh5OE5FdVI0Y0g3Ty90TUJwUG1NN25OTmF3dXJMR3RTdlBzcjF4bWFLY01aMGZ4YkpMcU9Va1NnQytkdmpLWUJzYkVRYTBONytKMEE5di9WTDF3alh4ejV4YnNCdzk3c2d5MnA5U1Z3MkZjVFRXeDFocTdZcHJJT3RvaHV2WlVoemNHTnRtRUllcFFSblFJYUJiNm9GU0NwM281ZWNXMmt3UzVacDhpOHNMN0IxTzhNNDFYc3IvdXZEaGQ5dnNzUWlRRCs4ZUpPOGxqQTVLUm9lVjlIWXAyTkJYaVZ6NUMvL3I1Ly9semxyK3kwVmxWYVlGV2pza2dWa2owYlZsemRvSUR3RzIxMUl1bitsd05MY2NUZ3pCdCtZeVVzU05lenNhbEsxcnAydWxPWVdVNkhZakgwTFVwUW9MMjRRUWFCcEhXUnVhMmthQmFnK1R1ZVBCc2VIMlljWE91R0hlQkxTRVBJMlRsN3FLQjJkK3ZNdmd6RlhtUG1kOWM1MFFGQWUzWGljRVJ3N01KeFhUeGtWY1RXUHhkZFRNSFkrT09EaDh5R1N5VC9DZTFkVXRWb1lyREFhZDVmaDY4VG9XbGdTbXJubTB1OGZPZ3dmVWRVV1dSd3UyMld6T2FIUk1WUmFjMno3UGk4OTltbjYrUmpHZlVaUlRyRFVvSWZEV1k1MkxKWXp6dUxZUmRrM01FcmFKQ0Y1VFcyenRLSXVJd1hJbVVGVUdVMW80OW95T3hoaGpLSTNIdEJwa0MvcWZBZm9yS2IyVk5FN1B2TWMwRFhWanFadEFVMGJkZ0ZSQ3I1UFJ5VHNrU1ZRaE05WkdWUThoMzdmRWxLSXRyMFl6OE9GaEkvai9OQ0hjYWJraXpZZCtVYWhURlJ0ejYyVTRsVDArKytXTHp6N3ptYTIvRnFUWVZrS1Fwd0V0UGJhSkIvVFlCYllESksyTVp3RFdCcHFYcmd6d1huQjdyNkp1TElnNDVsMlFTVUtJUEpMRmd0RzFDR0h2UFM2NEphcFZpWFlPSnVLSFpyeW5iaXhWWTVja0t3OU02c0REbzRaN1J3Mzdrd2JyUEZrU1I4NVZNYU1wSnF4ZWZJSEtDcTVjZjRwSGQ5NWhldkFBSHdTcldqQjBubnBTTWkrYmVPTzJOTmNRTEVVNVptZm5EcnM3ZDFsWk9jUEZpK2RRU1lUZEpVa1M5d3N1d216d250RjR5c01IOXpGTmpXakxNNjNqYnFVb1NnNE9Ed2dCTHB4N2dndGJUOUh2ckRPYlQ1aE9qeUlxMTNsc3UvRHoxbVBxU0JHdXF4cmZPR3h0cWF1R3VvcVFrcm8wbEdWRDB4aVNXdUlubHFQak1jWjRTaCtXVU5wa0FRQVZzTHFabzVQSVp6ZkdMUHVlcXZDWTFtc2xFZEROMUZKN1lNRUU5WVNsNHI0UDdTWTl6VGdjelpqTlM0TGdyVEtFLzhyRElTYzZXKzVERFRYUmlTUzRJTHhua1QxNjNaNGUvc3EvOHRTL05OanEvcElJYUtrQ1FnYU1DZFIxb0NvRE0rT1JEamFzVzJqNjRHd2dVWkxMWjNJNm5ZUkhCelZGYWZIT3NaQlNFSUN4WnJrYnNjWXVKMTZMc214eE80ZldleU5MRTVSV2VCR0ZxeHZuS0J0TFl4eSs3V21zaGIySjRjMkhNOGFGcDZnOXNvV2hKSGtYdlhxQlhyOVBrdWJjZi92N0xWZkNrMHJCVUFuV3RLU0xJSmVTVEFrYUgxcHVmR0F5UGViZ2NJOG5ybHhuWS9OTWk4d1hkRG9aeHBqWUx3bW95NW83ZCs4eW5VMWk2U2drT28xTHdVWHpQeHFQMk52YnhWbkg1WXRQOHN5VHIyQWF4L0hSSG1VeHd6VUcyNWpJK2FqTmovemVOaFpURzN3clRtY2FRMW5WRE1tWmp3b21rem5HQjZwVGtBalZubEtaU0ZZM1cwNjg4L2gyWDFQWGptSWVjUGJrNzJleUhhY3ZsT1RiM1pCb2lXNkpWZ2dSUythZG96SFdPdWNGdjFFRi9pbXgvMWcwNk9GREhTRGJGL3RNanB2SUpCUnhjdldaWDdydy9JdWZQL2QvVWtwdFJFZXdXR2NHSC9CV1VGY2VVM3QyQzAvZkJycXRhKzJDeXlFVHlhVXpPVStjN1hJMHMrd2MxVkhRSUxoSWtITHg4Q1pKZ3RZdDNKdEFtcVR0Tk1wSElKaU1DaWMrUlBQTmJockJjMHBLUEdDY296S09lV09wR2tmVmJuUHJHdlpubG9jang5Nmtadi9CYmM1ZGZwcVE5cmw0NVNxSHV6dnMzMzhINHlLTTJ6cVBDSjZ1RXF3b3dYcWk2S3I0UFd4YnBvekdSMHdtWTE1NDlrWHlibytpcXVsMmNxUVVXR3Zqb3M0NUh1N3NzYis3MDlicnNkZFNXaThOUGFXVVVRak9HbzZQRG5IVzhjU1Y1N2x3N2ltYzlUeDY5SkM2S21OR05SWnJiRFJJZFI1dkxjRjduRDM1ODZZMktDL1pTQWZzN0I1UlZnYmJYdDNxRk1ISEFwMkJwamZVYlhubDJoR3lZMVpZcXVLRWt4T3pUaUJOMmlhOXhROGxTZHlMeE1HTElrMDA4NkxoK0hpR0NHRm1oZmpQRzNpekxhL3Fqd1JZY1cwekY5TlJyUWdrQ0xwQ2l0N1AvdmtuL3NLWjgvMC9tYXNnMHRRTEcrS0V5Wm1BclFOVkZhSFZvN2xsM2pqT2VJOG1vSFdjN0N3c25OZUhLZGZPOVRBT2RvNGI2dG9SV3YxYnVXamcyeTJ4ZDRFc1MvSEVoVlpNNy9HNXJJOGIzcnF4Z0NEWGltR1dNT2hrU0tVSUFTcm5hZHJhdmJLdXBhaDZxZ2Iyand1bWt6RlBQdnNDM2NHUU5PL3p6dXZmcHFwbXJkYVZiNWR4YmxtVzlKUmdMZFhrV21KYWR0M2gwUkhEL2lyWHJ6MURaUnpPQjFhSFBjcXFqdkFQQXBQcG5BZjM3bU90YVMwUU9Ba1FLZDluREJSQ1lEYWJNUjRkaytVOXJsOTdpZlBucmpLZFRKbU9qL0RPUm5MVVFpRGMrNldUMTFKZ29uWnNEelp3ZGVEUi9uRmMrclVuVTU3aVlUZ0J2WUVteVU1R3RjRUh5dG95bTRabzNYMktOWmNyU2JlVFJjRTUxY0x5VzhkZ0tRUkppelBiT1JvekxTcWs0TjBxOEo4NTJHK3pSMzBLN3M2SHVRY1IxZHpHeFdDZ3M3SGQzZjdzbjd6eVZ6dWQ1SWs4Q3dTY21GUUJhOEEyQVZOQlZibUkyYW9kb3lZd1ZJS2U5VWpaR25MYU50c0VHUFkwMTg5MTZXYWFoNk9HOGR6aVRlVFRoQkFpZUxHRnhVZkVhcnZyV0k0Vkl3Wkp0NlNxMmppcXhrYUlkWUIrbG5CMjJLZmZ5YU9DQ3RGSG83U095anBLYTJtczQyQnZqN05udDNucTJXZlJPdWU5T3p1OGMrTTltaUNpVjBoTEk0NW1vcTNZWFlqV0RHZnloTlVzSlZXQitlU0l5OWVlWjMxams5RzBZSDExc0F3eUtRWE9PdDU4KzAxR3gwZkxQWUZ1OFYreDFEcWhUd3BvTlhzRHhYek9kREpoYStzQ0w3LzhCWlRLMk5sOWdMVk5kTHh0VmI5RjFMSEN1OGhUVDJUSytlRUdqL2FPbWN5allGMTE2cURMdGxOV2lhQTdpTnozQmZpeGFoeVRxYWQ1ek9GQUF4ME5lWjZTNXhtSjFtMkpGZUg3RWIwZENYSzdoNU5nclF0ZWlQK3VoRjl2czBleEdPOSs2Q20zZFdGbENFR0hFSVVhcmp5MWV1MnBUMjM5eTJrcTE1WHlvckZRbXhaTzNjUWdzWFhVaC9JbVVEYWVJeHZZRHA2azNYQkh0bUgwNXpBMlpwWnpheGxYdDdvSUJBY1RRMUhaMW5vcWpqaXpOTzRkYUlYUklDNERuZmYwdWoxNnZSN2VSNEtXRFZIOXZMWnh3alVwYTFRSWJIUTduRjBac05ySlNKVEUra0R0UEZldVBjbm52dlR6Ykd4dXNicXl3dHR2MytEVzdkdmN2WGVQeWdqbVZ0S0lGQk5rRkVZd25pWXFEK0pEYk02MmVoMWVPcmRHRDhPRFV2UGNjeTlSVk5IaGJORExxZW9tSW9ZRjNMaDFpeCs4OVNxeitaU3FycUlNcVVwUVdxTjEwbVlTOGI0Z1VTcG1tUGxzQmdpZWVlWWxOamZPY1hCNHlIUjZ2RVR3aHRCT3VWd2dlTW5ad1JwRjBmRGdZQlF2cFRaN0xNQjBDMHBmcnkvb2RDUGV6UG1JbzZvYlR6VnZQNGJIZU5lWkZHUnBYQmdtaVk3d0dpbVhFQndDVE9ZRmg2T1pVUERJSVA2akJtNmNHdS9hajBTQThINHRyTzdMUDNmaDVZMkxnMS9KVXRHTEtuelJMczJZS0xQajJ0bWhNejR1cnF4blpnS05oVzI1ME1oZHdEYWkxS2h4b0VSZ3BhTzRzSm1USnBLRG1hVW80NVJMdER1RmhTakVBdE5sWFZ5Q2FaMnl0Ym5PeHRxQVliOUxrcVkwMXVKQ0JDdGFINmdheTdTb21GVU5rc0JLTndhSkVaby85Y3QvaHUwekY5bmQyZWZWNzczSzNUdDN1SFg3UFI3dDdWSTFqc1lGakJOWW1XQlExQ1NVVmxBMkF1TmJRS1QzcEZxU0pKcFg3K3p6elBPZm9EOWNZVlpVYkcyc1V0ZDF5d1FFWXl6dnZQczJSK05ENXNXVThmaVlvNk1EaXRtWTRIMlVHY3BpZVVpYk1SZUNGMW9uV0dzcHk0cnQ3WXM4Ly93cnpJdWFSM3VQQ08wd0k0UjRBWFZrQnhrVTkvZU80d2IrVkZlOEVOZ05RSmJCY0UyMTJzaWg3ZDg4NVR4Z2FuNUVZa0VDSFJrdHFSZFpRN1h3L09VVXl3ZU9Sak9xeW9RZzVEOHU0TDlwbDRQekJiems5RE4vS0FQa0MzLzZDdmZmR3dzRUNUR0RkRi82L1BtZjYyOTJmaUhMWkdLdGozQUdDOFpFRjJUbndOdklYVERXVTVZVzd6ekhOdEFWc0NZQ2lZNDNsZmRFTHcvUldoTm9RU2RUYks5bmJQUlNiSUJaNFdnYTE1WTE3U0txL1lxTHFFQlJHdzVHVXliVEFpVWsvVHhqZmRCanBaZWhaUXd1RndLMUQ1VE9VVlFONDZLbXFCdXNjeHpzSGZEdzNoMzJkeCt5dS9lUWg0L3Vjdi9SZldwcmFieW5zckhSbjVZMTg5cEdwR3FRR0NlcG5hYjBpcmtUVEJyUHFIVGNlSFRFWUdXTjU1NTdnZW04WXRDUDR0RmxYYU5hMHRPTkd6ZlkyOXVKY29UZTQ1dUtZakppZi9jaEJ6c1BtVTNHT0d0SWRFS1NwRzJmSXBGU2hpUkpSWmJtRUFRYkcyZDQ0ZmxQTXB1V1BOcTVqL2NHNzBCWWlmS2FuZEdjcGhXWFhnVEhJbnNJSU5Vd1dKUG9WQzVQdjNXZXFnaVVzM1lBeVFjRWlKTGtlVUxhanFxVmlrYzg5b2V4dWQ4OW11Szl2K2VVL0x1VjgrKzJ3ZkVqMmVOREd5QVhycSt3YzJjcVF3anBJa0JlK2RMNVg5N2V5aityZEJEQkJieVhHQlBOYllJSFkyS3pIak9JcHlxajFwVHpNR284NTdTZ3J5TzhORGFDN1kzWHFyc0xLZWgyTlAxTXNkWkw2R2FTYWVXWWxYRUNGVUY3RG12ZHNoK2d4U0dWeGpJcFNvNm1NNlpseEcxMXRHYllTVm50NXVSSnJKVk5DSmdXcnlWQ29KaU5PUjRkY25DNHg5SG9rTWwwRWpGZ3ZGL1F5WWU0a2E5TUhDTVgxbEU2VDJVOWxZVnBBNk81dzBkU1BDKy84ak1JblZBVU5XYzJWaWlLYXZtY1IwY2o3dHg4Qitucys3UTZwZmZZdW1KMGZNait6bjMyZGg0d20wM0tOTy9jemZKYzZ5VE50RklpU1ZLNm5TNnJ3eUZudHplNGNQNEtvL0dVZXcvdUVHcVBiMkJTUncyeHNGZzJQTlo3NUJLNks1SWtGMUVxU1lCeGdYTG1LV2NzV1ptUGx4TVJ4aDNJVWtXYVprdTF2N0FZTVBqQTBYakdkRjZWVXF2L2JPcjhyNFhBOU5SeTBEMmVsejZVQVRJOXJxbExxNEtQSlZiYTBTdWYrdm56dnp4Y3kxNndMakwzckFObkFxYUp3RUJuSXJUQis0ai9NZGEzRzEzUHVIS1JlSldwOW1ZLzBhK3lyVDJiWHpyVFJsK1BZU2Vobnl1TWN4U05peHZkeG1OYU1KNXhDNXB0Zk5jdDhmZU5jOHdidzdTc0thcElMVTJrWkpBbDlGTk5KMUhZNEdsOGlMZHBDd3RmSE5SdzZpQ2REcFRUcFVucmtiSE1NcVd4bE1aUk9jL2hlTXlWeTFlNGZQVWFvMW5CMmMyMTJOTTFjVE1lUE54NDUyMnE2Zmg5Rk0zVEI5RjV6N3l1NnYzRC9WODdPTno5dTJWVmZVL3JwTTd6VGpmTDhtNm4wNUZuTnRmb0RUcHNySy9nak9MV3pUc2NIeDVUdVpQMzBuOUFjS1FDc3I0ZzYwdU1qeGRHYlR6elNZaDl4NDhKanFVWXIyaVZMRnRhcjFReWxscFNNcHVYN0J4T2drZitlb1g0OXh2bkRqakJYbjEwbEJYcjBpNnljUXAwdXNOMDlhWFBiZi9KNFdyeVZHTkROS3Z4MFFLc2JqeHhsUkZWU0VTQXV2TFlGZ3RramFPcExEdVRDdVVEWjNPTjFBditORXZ1Zy9VaEJsb0lDQmtSdXIxT1FyK2o2YVFnaGNjQnBSTlU3bVJrdVhqWEY0V3RPL1Y3MXpic3M5b3dxUm9hNDVDdFdIYlozckNjK3RURUIvejM4Uy81WS81OGdSK3Jtd2F0RlovOXpHZHBsVmtaRHJyTWkzcXBhWFg3OW0wZVByaTdETHJUcGxzMlhyWDdGdjRMRC85SldaWDM5bllmM3JoNzU4WTNEdzUydjkzdjljMXd1SHBwWTJNdHovS1VYci9MYkRKajk5RSs5eC9kajhyeHA0SmpJWWtwaVFjNzY0UHFSUW5UMmdlYUJxb3BtR3BaaFgxZ2FiVzhLQUlrSXBBa2lrNmVveE85bko3dGpXZk1xdVpoRVBML01iZjJ6YmEwK3BISjFZYytRTnFNdVRUTU9YdDVjT2FwbHpkL3RUL1FGNjJOTjdnMzBkWEp0dk40RmNDYktIOVpWYlpGa3ZxV0Z4RkxycnVIYzFhMFpMdWJMRSttYjBzbDMyYVNKWFcyZFpqS1UwMm1OVklFK3FuQ1NVazM4U1E2TExPSGErZjVwd1dYbGtHeXlDNHR5M0N4RjFsa2l0UEJKVDdnTnYrZ2cvSjR3UERZZHJxWXovbkVTNTlndUxySnRDZzVlMmFkcXE3eExTeGhOSjV5ODcyMzhkYTB5dkd0bmhJVUZyN2g0RDhNOEY4RHU4QVVLSjJ6NVdoMGRIRG56bzIzbEZRSG14dnJsemZPYkt4bWFVSTVuL0hlZTdlNGQrOG16cHIzOVJ1TE1nNEJhVGNHaHljNEc5aXZLMzYzbm9HM2RQbDlKS29XejVrQ2lSU2tXVUtTdGdTeEVKaFhGZnZqZWVHOC8zdUY5NzhXWU5JR3lPbTlSL2lvQlVnSzVPZXVycHg3NHZuMXY1aG1jcU14Y1ovaFRTUXF0ZVpTZUJ2d05zS3VuZlZZNDF1TDUwQmRXNXFxWVRhcitPR2pLUmRYT3B6cEpXMHYwZkkxRnRJOXJjeS9jWkVBNVVPYzhVdXA2SFZTYXVQcGE4Y3dnOVZPL0JybTBFMGcwVEgxdC8wd2k2YzkvU0cvVDlidnNmOFhQdURHNUxIQUVhZEtNZkVCWllnbWF2cW1hY0xMbi93VTAzbk4ya3FQVHA0ekw2c28xZVBneHMzM21JME9JV1lNMjhCN0R2NGpCLzhCOEYxZzFKWW54U244a2pmRzJGdTMzcjF6NXN5R2UrYVo1ei9UNlhaMHNKWWJOMjd6em8wZllteXorSGxDdXpFWFh1QkZ5a2oyT0hhQlc3Ymh2MjBxL3RObXpqL0M4M1hnM2ZiN3lQYS8rZU5uVjV3YWE2WTZCb2hzUVlrQk9Cak5tTmZtcXpYOFhSY0RlL1pZWS82QkRqb2ZCZUU0a2VZcVYwcjBiY3RzTTYwZnVWNk9YbHNnWFN0OTZheGZucmltanVDNXBqYjRkai94UDc1OXlFcTJ6V2JuQkt6b0Z2NFh4UC9hMXMranNaN0tlTHdrQ3M0UjVYK0NEV2dSRU1LVDZSZ2tQa1IvRWVNRHBZSFNubnpWbG1WdEhoN3JLMDRIaU9SSGcwcnl3Zi91ZEtDY0x0ZUU5N3p4K2crWUhPMlQ5OWJaMlQvbWljdm5VRW9SZ21aN2U0dUxsNjl5OSs1TmI1M2RzL0JQSGZ3M3dGdVBCY1hweGxhMmh3MUEzYnQzNS9XaW1JOVhWbGUzZEpLUXBub3VoSGdud0xxQUxkWGF1SHVvZytDM2hlRFhxem03enJEbkxZL2Fza2NBOTRBZkFQOFl1QUQwZ1Q4djRFOEg2SDdnUmVMQldZZlRNUk9YVmNPa2FONHpnZi9Fd3NOVGtKSWZXMXA5VkFJa0lpQzhEekk0NzF2RkFPZGlLU1JkSlA4SDM4cUpDSllRQ0NVQzViekdWaTJ3cmpZNDYxQUNiaDNQK1g5L2Y0ZC8rYVV0enZXUzVVVExoa2gyV3RCTWpRdHQyUlU1RHk0SWprdkhSaFphWVd4T0tMRWhMc3kwakNWQVI4ZG0xUVl3SGhvSDh6b0dTbTJoYWNXdTNXTlpacEZoNUk4cHM4S3BUenc4Vm42ZERxamRSNDk0N2RYdjh2bGYrQmM0SE0yNGNzblQ3M1VZVHd6OVFZK25ubmsrZk8vMTczL3Q4SER2SDRRWUdMdHRTVEkveFpkd1FzUXVMWVFnVHAycGRHOXZkMmM4UHI1Nzd2eUZyY0Z3UUsvWG0zZnk3bjgrTDZaSHdCYndySU5WRCs4Rnp6L3lGYnVuRHUyaU12V25rdCtVQ0FmcEFIY0RIQWo0aThCbVN6QThLVEdsYU0xTkkvem5lRnBNalE5L3o4RDNPTEUrYUFBdjMrK0I5SUg5elljNU9OcmxqN2N1aEtacFI3blJUNlBOR3A2bzIyUTkzb1pXYmljS0tadkdZcG9JeTI3cXBpMjdJSkdCKytNNWYvKzFYZDQ3cXBhMWxXcjN5QzdFc1dQVE9NclNSdEpPNDZncnM4UkhlVUlyNkJ3eFNCSG1IckZJeGdkTXEyN3UyMzVKbUJhU3JHQWxnWUdPdjg1VmJGNGZ6eVR1VkEvalRvMUxUL2NzcC91ZHh4djl1cXI0bmE5L0RWdlBrVkp3ZURSaE9PZ2pwRUluQ2RldVBoRmUvc1RQdk40R3g3ZzlXSXVSYUMyRXNGSXExKzMyL01wdzFRc2hUclVxbUJzM2IrNGZIUjIrMWpRMVVpbzZuVTdlNy9ZTjhHNkFYemZ3N3hqNG13NytQUjgzMldOaVh6QTU5ZXZwcWQ4di9td0UzQWYrbndIK1ZvRHZ0QzNoOHZKWXZOSVFBa1ZaK3FvMlgybmdOOE5KOW1zQUt5TmpNSVNQY0FhSkwwSkw1VDNTTmdIYmVLeHB1ZEF0UDBFR2xxVVc3ZWpVR29kMUliTGJtb2d3YlYwZjQ4VEh3NjJEZ245UTcvR25ycS96aVhNOUZqdXJoUXVVYk9XQnJIRk1TNHZ4Z1U0aUViU0kwN0RZeTRmbEhKNEYyODVCMWNBNFNPaWxkRmM3a0NpNnZZUTAxNjFvU01EWmFKdG1UZnhaVFdXd2phY3VHMndaeTBYWGNzUDlqN2xCeEFlVVhrb0lidCs4eWEwYjczTDFtVSt3ZnpqbTdKazFPbmxHYVMxcmE2dnkraE5QdnZMZDc2My9kOGVqbzRVbmVYUHFoZzlKa2dSYTUrQVFRaEJDK0JDQ0Ewd0lvUzVtMHgxcmJFMG56L0p1RjUxbS9sU0pWcHhxa08zcFdjVUg5QVRpRkR5ck9mVnpmQTBZQi9qcndNK0thT0FsRmtvbUxuakt5cnhadXZBZk90ZzVCVVkwUk5GM01pQ1RNUE1mdlFCWmx0WE9obUJ0dkRPcnhzZmxYb3YzanFQVE5vT1lxT1JSbHBiNTNGS1ZocVpxc08zU1FyWHVkV0VoUEMxZ2QxN3g5MS9iNWVab2xUL3g1Q29ycWFJSWpycUpjQlhqNHU2ak1wN2RtYVcwbnZXZXhEVlI2MWNLRWVteEx1QkNGR2t1cW9EeEFubW16eE9mT3N2R2hRR0QxUTVKSmtsVHVkUUxoa2dRYXBvWXpJM3gxSTBqR0U5ZEdLcHB6ZXlnNEhpbllISlFNcC9VMUtWZG9taDVyRmxmc1BRQ1VXbSttczNjMTcvK3RlTGFVODkzUi9OR3plWWxheXREcXJLaTErdHcrZEtsWjU1NStvVXIzL3huWDcyemVEb3BaVmc4QUxLOHc5SFJ3ZkxiQ1NGY0d5VDJlSFI4MXhnelRwSmthM045TFNnbEYrWE52QTJVK2xReURJOGxnY2NENUhTeXRLZXkxZThDajRBdkIzZ1orRXdnWEhiVzBSaC9mMXE3ZjcrQzE5dnZ1ZUI2ZUMwSTdVQ1N1Zi9vWnBBQWhNWjQ2eHhHdGRZRXpyUjlSOHNWOXkzanJqRU9VenZxTWxKQTY2cWhxcHJsaHJsbDBFWWxrNVJXSUEwQ2pxL2ZQdUxScE9hWG4xcGpOWkhNYXhlT3B0Vm9WdGxSMmRoUU9kOGtVczBxRzU1OU1BdjlTUmw3RE9NRHRYUFlWbUhRZXFnZG5MMjJ3b3UvZElWTFQ2L1I2U3BzZ0VUSnBaSUhvWFZwRW9vUTBoYkNFaTNjblBPdENJSkRPSSt0TE9QOWtzTzlrdjFITXc3dVR4anZGN2dxWmtYSHlldUttMm1CZ3FramZQT3R0OSs2TlQ3ZS85TlpmL1BTL3RHRTYxZlBvN1FpWkZuWVdGc2JYTGw4OWFYdmZQY2IzN0RXcWxQN3lsaW0xZEU2K3ZUbjBlWkpDOWkzMzM3cjBaZCs5aGRIU3AvZjZuUTdTWnFtdlZNSGU1R1ZIZytJSDZsNHJrRzR0Y1FGdjI5S3ZuaXV1OEIvNGVDL3F3S3ZLQnYrVlJPY2JRTC9jT0xEVjAvdE8yb2lRZEhuV29iQ2VPYS9YM1h5RWNnZ0lLVHdGb0ZzT1JJMlpvTVFRUG9RMTlyRWhyMnFiTHo5VFN5dG5EVXRpeTUrOU11TnVZZ1FoOURhVjZFQ3QwWXovdUhiaHEzMUhvbEtiaDg4TFAvanlhelpDUUZwZkpBTythbkd1QmRzT0lGbWY5QWp5UlRYWHpuTGhXc3JkSE9KVkFJbEpGbnJYZUY4RE9ZVERWd0pJc0puK2lrazJqT1pHK3BhMFpFWlBqSGtXckIydnNmbDU5ZVpIdGZzM3AzdzhOMGpEaC9NS09jUlhKbGxBbXBJcGFLVHA4MjhNZDkvdExQejl2MDd0NTU0OXVXdEMwZkhVM241Z3FYWDZ6SnVqT2dQZXNtRmN4ZS9jUG55RS8vbzVzMTNweEdlNVJkRXYvQ1gvdEpmNGgvK3czKzRmRjFycTZ1TXhtTWZGWTVDZU91dE4zZUtZbjR6U1pLbis0TytUTk5Vbnc0RUlVUkkwOHpYZGYzanBxd0EzUDdSei96eEZzeTBoNzgwOEU4bm5sZUREelpFQ1ovRi82dFA3VzNEelBnL1dQbitZWXVLeXhkV3VmdGc5TDQvSzZaTldaVituQW9abldMYkRaMW9zU0todExGemJCenplVU14cldpS0J0Y1l2SW5qb2lqaEV5ZE5KKzYycHkwTElNc2tJZFVjQ1lXdDNMZnVIZFRmeG5rSHFHNG51ekxNMUJjYlUzYWNENy9uYStpdjVweDlZb2lXQ3lNZVFSRFErRUFpRlltSzZvVzZGYTd6QkxRRzRTTHhQbEdnQjRxcGltVWpNbW9BYXkzcERXQnROV1YxbzhQNXF5czh1anZsd2J0SGpIZG1OTWFnY3dGVlFFbTVtcWY2Nm14YXZ2b2IvK1EzdnZiRVU4KzlaRVRuN05IeGhLM05OU2FUR1ZrbjQ5eTU3V3VmZVBHVEw5eTgrZTdOeFY1UENDSFcxOWVGdFRhY0dPaEFudWN3SG9lMnhITGo4V1JlRlBQZHNpaDlKOC8xNnNycVptenpoQW9oeUJDQ2NNNkozNmRQZnJ5M0NvL05LOExKZ2g4TmFCK2IrZFAvYjlFM2VSVm5OdS9iNXY5ZWp3L1ZGS3ZmVDNuMTEvN1BDN245WmFyZnVUc3BwcFBtVHQyMHU0NTI2KzFzb0xHeFB6QzFwU3dNVmRGUUZVM3NQUnF6OUxvVENOUkNPYkRsTUN3RkdOcnlLODBVU1phZ0UzVnNTdnRkbko4QmRhSTFXK3VEWDFSS1B1bC9uK0FBV0QzVEplOUd4Yi9HaFJhajViRXRqRVVRRlZXa0ZHU3BacGduREZKTkp4RWdBdk1xTUMram5ZS1FJRE9KeWlWSklwRWlRcndIZzRUMU0xM09QN25POVU5ZjRJVXZYZWJDRSt0a2d3UXZBODU1bFdyMVhLcGwvdW9QZnZEdTdxUDc3M1R5aFAzRE1WSUt1dDBPVW10V2g0T1ZjOXZuWGhvTWhyMTJNYXNpZGpHSUsxZXV2djh3cWNXN2hSZENXT2Q5dGIrL2QyaTljMnZyYTNKOWJYMmI5M3VYSzJ1TitIRVFrdCt2dEQ0MTBGdG1rRlBsVkhscVgyT2tsRTRLRVhRY1MrUC9nTi9vUXhFZ1dhcTV1RDVBMVhEMUMvOHVTc3ZUQ1ZtR0pvajYyQWhieHdXaENDeVhnbzMxVkVCUk82YmprbkplNHhzRExnb255Q2dSaFNPU2xLeHZZZXMrWUwxZmd1T1NSTkxwWktoVSsyRDk5eWQ3eFp1TEQyWnJZK1hxb052NStlQkQ4bnV2LytQQXZyZWFSN2Nsd05IYUdiVFdBclVOMkNCSkVrVTMwL1JTVFNlTnF1VlN4MkRRbVVRclNTTGpmOU5Fa2FYUlhVa2lTR1NDVm9vOFRWZ1pacHpaNnJONllZVkx6MjF6OFprdE9tczVkZDBFUWppWGFyVm1yWjE4NDV1Lzh6WGhtdGxrWGpLWnpsbGJHU0NVcHRmdmk2MHpXei83N0RQUFh3VlNJVVFhUWxDejJZekJZUGorVEY0V3djZjB1MnlrSHo2NGY2T3U2M0xqekxwNDVwbW4xcFZVblRaQXNsT0I4b2NKRWo0QTVyYklKTFdJWDBhQVZVcjUxZUV3Yks2dGhaLzBHL3pVUTAwdWJBNnBHMHVXS0dybnhLeHNoSE4rQWVQcEFOM3QxZTZWRFpuOFpRUGJJVk54aEZySDBhMnJIZk5aVFRHdG1VOUx5cUxHMVRGQUZuVFpWaHo5WkZmUU5yT3R5ekJDUXJlVGtIVXpwTmJUMlZIOTk0NTNpeDhDUVFvaExwM2QrSE5heVMvTjV3VmxaWVQ3Y2NIUnJzRXZQclBCOXVVK1FncVNUdVFzZUJRMlNIeUltL2grcXVob2pWWXNGUUlEVVlaeklWenRDSzFXZlB3aGxWUW9JWmNjY3VlajdxK1NPc3JnS0VtYXAzZ1htT3hNVVVJa05vVHZOTmJmTG9yNTlCTXZ2ZlJjMmwzZHhudXh1YkhLdktqdzNnYzh2ZEZvOU82YlAzejlyWk5ER1B4WHYvcVY4SGYvN24vQWREb0JvQ3lyMHhldkFoTHZYUFdKRjEvKzB1cjZ4dGxFNm9HMTl0WTc3NzU5UDBSM1dmZDd3VHorc0VNYkNTR0pVSmFnV3ZQV3FxNHBxaXFXM3grRkFQblZMenpmOG9rRnM3SmhXaldpTms3NEVGUWJITG1Jc0lQK2hmWCtKOWZUOUgvRjJHU3pXUzBhR2ROOTB6aE1ZeW1uRmJOSlJUbXZjWTBoMkxnUVZGSXNlNDBUYVpnRjg2ejkxQ1NrcWFUWHlaQ0p4bFJoLy9qQi9MODIxaDhBREFmZHpVdm56dndWWSt6NXVxNHBxa2JZeHo0RElTSHRDSlNDWGovanlWZTJHR3gyU0RJRmlhUnlFRlJybGlNRm1aSWtRcENveVBRTHJhaTI5UzRLYmlPV3BXQ3NOUVd5bFRnTDdSTFp1TVdpVWtUcC94RHdVb0tJbGc5SEQ2WjRZNUZLM3F5TWUzMWVGTVZUMTY1MUwxeTgvTWw1YmRYMm1UV0VFQkhFYUsxcWpKMi85ZmJyLzZ5cXFzVVcyZ2todk5hYXNpemJKbjBEYTYzdzNpLzJGbW95R1RkYm0xdXJnZVJURzJmT3JGMDZkK0dsSzVjdWo3NzM2bmZmY3d0UjR2ZFBwLzVvNEJXTGQwbUlmNjRJL0trTmtKLy94QlBjMngveDhHQWlhbU9sYzE2R0ZzYlFabzQrTUFRNkY5Y0duend6NlA1Q0ttV1NONEdkQnlPbVJYVDJMYXZZbEZmekd0c1loSXVRY2luRjhvRFI2bHFGY0dMQnRpaXRJcHN3SVUwVFJLSTUzaW1hYW1LKzR1UHNYVjQ1di9YcDlaWEJyMWFOeWEweG9weFgySEJ5aFNKaHNKb3dIQ1prUGNWbi9zUlZ6bDlmQXlYUXVjSXBCVElhVGtvOGVSSVBlTEF1YnVPRGl5YWdJbmFYaXlBT0JCSXBDRjYwWldFckZsRlpmQk1JcmFqQ1l1Z2daSlFoY2lHS1R4ZEhsU2hIaFpSQ0ZxWDF2eDFDcUFWaDlzSUxMNzVzMEJ2ZExHVmpmWVh4WkNxVVFNeG44MjVSVmQrOWMrZldvMFg1SklUd1daYUh2L0UzL2daZitjcHZzN2F5d1hRMlJpeHVHUkRPT2ZIZWpmZHVCaTlkWThLejY1c2IyNWN2WEhyaGlhdlhKdS9lZU9mbXZKZ2JmaFRvL00rZFJ2eGpDQU0rU2dGeWFYT0YzM256THJPeUZtVnRwUE1uV1lNNHlPa0R2UXNiZzB1ZnVMTDFKemFIblMvMU84azFyYlhNc3dSbEErKzhzOC91b3luVnZNWVpnelVSYXhWY3BOS3FWaFJOeUNqNUV3aXQ2OUhDU3lMZS9FbWlvbmxPcWpFTmpQYkxSOTc1L3piQVZDdlZlZnJhaFQrbmxYckZHQ085TmJpNlJJWkEybHFOOWJZNm5IMWl5TXBxajJjL3RjMjFsODVnZ2tBbEVoSkowbFVNc2dRUkFsSkxPanFTdHJTU0pFcVNLQjNOTGdQTHFWb2dMSjJabkEvWTJrWkRHUmNJdFNjWUcxSElBb0wxSkNvS3JtbXBrVUxHaWRuY01yby9BaUh1bE5iL0Z0QThlUFJvK3NrWFh6eTdjZWJjQzhaWXVYMW1sYnF4V0dzSnh1ZlQyZnorRzIrKzlsb0lvV2tEeEo0L2Z5NGtTY3FiYjc3QmJEN2gwdG5MVkUwbHZQUExucUtxcStiTzdSdHZ6U2ZGdmJweEY4OXNiMTIvZVBIaXA1OTcrcmx1TVorOWV2L2gvZUtQSTVQOFVUeCtLZ05rcFpzenJ4cFJOVmFjeWhvNTBBUDZ3MjYyOVlWbkx2elNjeGMyL25mYnE3Mi8xTW5TSjVWV1dpZlJIVXByaGJlZTBhaGdQR3FvNXpaeVAxcjFqSVhoZmR3T0xneGxXaVppTzlJTnhPQlFrVVdFUnpIYXJhd3Q3SzhGK08wQWZudHo3ZnpGczJmK0pRSGJQbmlDTXhBTWVRSlpLZ2g1d3ZVdlhtTDc2anJibDFZNC84d2FUcXNvK0pCSXNvNGl6VFRkVEpPbUVxMmlLbUEvVmZRU0hmY1ZXcE1vdlNRemVSRTM4akdEeE43RUZRN1JBRzNRMGNKY0hBSVJZcGtxaVg2Sm1nVHJIRTFwT2I0eklvU3dXem4vNnlIRUxiTTF6ZXk1NTE3OHJBbHF1RHJvTVJqMG1NNEtKQ2hqak4zWmZmaXR3NlBER1NjK2ZtRmxaU1ZzYlczeDRNRUR0amUyTWRaUU4vVUNhQk9BWUt5eER4N2RlVzl5ZFBUR2RGcDFmUkFYejJ4dWZYRmo0Mnp2L29ONzN4eU5qOHZITXNuSEFmTGpBeVNqaUpsRG5zb2NQU0VZZlBLSnN5OSs1dHJadjdhOTB2dlhsQlRQR091U2hmaG45UEdUN2JoUmtpb1ozYUFxaDJraU1IQngrRnRZVk1SVHRZekJCWHBXQ0VoMFZBbjNJdGJ4czJORE5UV3ZpY2lKT0FUQ2xRdmJMMnl1RGYrYzk2NGpCQWhuRUFJNm5SU3RGTDByUTU3ODRnVlcxek82cXdtaXEzR3Q0TE5LQldpRnloUnBLc2tUd1NEVFpGcXdraVVNczV5a05jWE1kYmJFaVduWmxrd0NVdGxhNTBpSlNHSm1jRzNRUzlXV1hrU3JaUm9JRm1vZkozMnV0aHpjR2VFYWM3OXgvTG9QWVM2RThJZUhoNU5QZnVJVFR3L1h6andOSVd5ZFdSZnplWWwzbHJwczhxUHg2UHMzYnI1N1h3aGhRd2kyYVJwMysvYXRjUDM2ZGU3Y3VjUEc2Z2JXMlFqdGo1cWdwek1EeCtQRDNkdTMzdm5xZER4L2ZUNHYwcVpxK2p1N0QvN3B3ZUgrNlBHLysxT0I4L3RwREpCSHg3TUZzSEJCaXVwY1A3ZCs4ZVdyVzcrNm1xZi9valh1Q1dPc1hEZ3FMOHpyZzQxekhTR2dseVdzRDNwb0tlZ21jL1ltSlZVVGhlU1VCcWRCNUNEYnlWQ3J6dC9LLzRDUXNURnVHcWptbm1EWWswTDhmUlBDM1FXY3FaT25sNVdTUTZYakJDa2tDdG5OU2JSbVV0V2MrK3haVnM5bXlOcGpoRVFrS2tKNGxjQ0tTQ3NkS0VFbkVheW1DVjJ0c042UWhPaTlucW9NNTJQWDdVUDhTWldRYUN1UndaT25BaDhrVGtkUkhPMUJXTkZPd2dKQ0JLWXppNjhDTWdoY0RRRVp6VFo5aUdVZW92S3haREloQkY5V2xYdm5uVGQvNit6Rko3NDRudWkxdXE3cDk3dlVaUmxXVjFjMnQ4OXN2NUlreWJlTU1RbWd2UGV5MiszNm82T2pBUER1blhmWVdGbW4xK21IRUlLdjZuS0IyMXEwQlVuVlZQVjNYLzM2Zi8vZXU2OS9iWDExSTNsMDhQRFJqNE9aL00vOStLbmJnL3lyUC84UzFua1JUaFFvMDI2cWg4OWRXUC9YejY0UC95OHFUYThMS1dWQUx0MVFvK0szcGFxYTJHZTB1Q2N0QloxT3pvV3RkYTV0cjNLbWw1RUtnVE5RbHpDZndtd1dxT3NXZXQ2Q2ZheURvb1RwS0RBYkJYd2RHT3JrSU12eW00c1BVU3NsVTYwdUt5bVVraExkbW1OMk96bHBrakM4Mk9YczAwTTZTUndsSjVsRzZ6aEZraTBCTzBrRXlJRFNrR3FMRWsxc3ZOdnpsQ1NTTklrN2tTeE5rRW91eFNTRWg2SVNlQ2RiMXlTSkZMSENVaUZnNm5iTEhnSk5hU2tienp6QXZERVlhM0hHb1dNNTFwelNsYWlCK3AvKzlqLzU5dEhCN3F2enN1WjROR1ZsMkVlbGllajN1K3JxbFNkK2JtUGp6RVo3Y1NVaEJGblh0VmpJNndBTUJ1dk1paWw1bmdXdDllbGxYdFV1OEVxZ21SU1QvZHNQYjkycm03bzVOZkw5T0VCK3I4ZkdzTHNZdFM2VVhKSitucDdmMngvOTRydDNkam9xU1VLbjExa3l4N3h0WWVBbUxpMUV1L256UUpZcWVubEtKODlZSGZhNXZMWEs1ZlVlcTZsRUE5WkNXVUl4ZzNJV2c2WXFvSmhDT1EwMEZTZ2ZHNTljc05sTjlMbjJReFJacWp1ZFBEMG5wUXFKVmtFSjBFcVFaUW5XT0ZhdUQraXZKR0NpTjBYU2VnT21TcUMxSU5GUkhVWHBhQllqb3JNMGlXNTFuVktGa3RCSkZVbTdSRXpUQktsMDlDeUpKaWJ0SmtTY2JObmF4V2NFYlVLdUpaMUJBZ3E4akdKMVRXMXA1azE3a1loWW1aMWFzdTN0SHh3L3VuLzdXeks0NHZCb2lsS0tQTS9SZWNicXlzclZWejc1NlpjWGw1Y0FGVUlRQndjSHl4L2g5djMzS0t1Q0VBS0QvaUFvcWJ5U3lwLytIbTJ3MUFKeEd1b2VmdHF5eUU5ZGdIejczUWVvaUNWWkxwdjZlWHEyTVg3ajV0MGRYbnZybHBnV05ZbFdxTmJTTExSNnVOWjVadk9LMmF6QUdvc1NnbDZxeWJWQ1MwbWFKR3lzOUxsMFpzajVZY2FLbHVnUXg2ZXVBVlBHTDlmRVAxTkVUbWNpSUFRMzFNSmZFQ0tpdHZyZC9GdzN6eTVERUZJaXZMTlJwRG1BUzZCM05rTVI4Q2E2SHVXcElGT0NYRWRKVTkreUhpc3JLS3huYWdOS0oyU0pJRTJpWFhQQXRSejJnQXVXeG5ta2xORW5VU1pVVmxJWVFkVXlFS1dNMlVUSTZGZ2xrNGc0MEVrTVNPbWpKMGhkTnBqU1lob1hFQlNudHRCTHlNYlh2LzYxcjV0cWR2ZDRPbWMwbmpJYzlKRktoZFdWWWYvSmEwOTlmamdjOW9Ha0hhS29odzhmL3Nobk9ScVBPRG8rNHYvd21iOUtJblVBdkJUU1NTR3RFTUlJSVl5UXdpaWxuRkxLSzZVV0dlZmpBUGx4ajIrOGZYOUJWMTBFaU01VGZSWkJKcVRnNGU0KzMzMzlYZTd0SGlHMEpNOVRrbFNScGhHc0IxRkMwMWpiR2tWNlpQQmtLanJQS2lFWmRMcWMzVmpseXBraGwxWTdiUGN5aHBrbWFUVnFFM0V5TnRNbnlCOHRDU3RDUml4U25pWmJTb28xU2Z4QmZTc2dYVlVOTWhOc2IyWWt4cU9rUU1uSVQxZkNrNGhBcWxzZ1pWdlRLY0FFeWNnNDZoRHd3cU8wSjlGRXdVMFJzNHp6eEo1RXBsUkJNM2VTaVFWRDdFV1UxQ0FVUGtTd1k3UmFpNmxXSzRIMDBmTXZCb2NOd1RqdlBYZkNDUzlqQVVNM3I3NytnOXUzYnJ6OTFlQzkyenNZMGU5MVNOSk1kSHM5dWJWNTVvWExGNitlYlFjb2lmZCtxU1B4d2dzdi9NaG4rbmQvOSsrM21FN0kweXlrT3ZHcFRyeEFlTys5ZDg1NTUxeHd6aTFvSmg4SHlPK3pDMTBzUWhXZ015VXZTU0VTMWQ2UVZWMXorLzRPUDd6MWlJUHhESUVnVVFxbFl4K1FwZ25KUW5MU1dKUUlkQkpGcXVXeUZFbTBwdCtMZ1hMdDNBYlBYTmpreWJPcmJQWXljaVdXSUtGRnd2YytTR3RjWnhHNHZXNW5QUVJrbkhGRmVMc2d5bVBLTkRESUpOckZQaWhSQWlVQ0NRRWxCRG9SWkxscUhaTWlYMTBoSVVRc2xoQVNqNGNXWWhJVlZPTEdmVzRGNHlZd2QyQ0ZCQlhmaytBbFpSTzU3Y1pCWXlJZXpiZTdIUUVJSFkxamJHV0FJRUtnYWJ5N0ZVSXdqMldSQ2loZmYvMzdYdzIyR2grTjUwc1hYSjJsckF5SFR6ejExTE12bitwRFZBaEI1bm5PRzIrOHdlT0h2TEkxcHZXbER5SDhualdVYys3akFQbUQ3VUtYTkV0Wk5uYnFRbkN5RlNNT0xXZmk4SGpNMjdjZjhkYWRIUTdHQmM3RlFNa1QzWUwxTkowOFhjcS81SWtpMFJJUmFFbEowWklzeXpJRy9SN2I2NnYwZWwxcTl5TWlyU0dFWUsxMTQvYUtrNmxXQXgrODlDMUdhZ0V2OWo2ZzB6aU9sUzRnMndWZm9nUmhMbW5HOGY4cEZYdUhwbFZ5RjBLUXFvUk9rcEdxRkMwVUJJK1NHdWRoV2pWTUNzZitwT0Z3VmxOVkRtR2hFeVFxU0Z3Vm1FMDk0eG9tQmdvcnFLekFXVUZ3QXU5ak1EclROdTgrQk8vOGJnamM1NFI4ZExvWGFYN3dnMWZmZlhUL3p0ZWF4bkEwbnRMdmQ1RmFNMXdaRHA2NGN1MFh6cHpaWG1sQmh6cUVJSVVROHQvOEcvL203L25KbGsxRmJXcHEwK0NENTZmOThkT001aFV0M2tnTmUvbEd2NXNyaUFZMmNzRzhDd0ZyTFVlakNlL2VmY2lEdldPTTk1Z29KNEtXaWxUcnBaR0tGSkFwUlpyRWNpd0dXMlFiMHZMV3RSQTRZck92eGJKckZBRnE0LzFlQzRZSzFqcmp2US9PT3VHOWIvV1g0cmc0NjJsRWlHamlSSVNsY3Z6UmpackRCeE5jNjQ2clpjU0QxYzdUT0ljTG5reW45TE1oaXBUZ1U5YTZ6OU5VWFhiMngrd2ZUTm5ibjNKMFdEQWZWMVF6UXpHenpHYU8wZ2xxQlBNNk1DOEM1ZHd4cTZFdUExVVRKM01JaVNrc01vQ3JyZkErM0RjKzdQRitPdXN5U0E2UFI4ZjM3dHo0YWwwVms3M0RFVm1XMHV0MjZYUTdiRzV1dm5EMTZyWHpRQ0tFU0lRUTBsb3JidDIrSmZnSVBmUlBiMnpFTGV4S0ordWF1bjVSNTZuT093bkhvM2xzQWtSY2hBa2ZvUmQxN2JuN2NKK0Rvd21EUVkrTjFSNnFtOGRhdnozd0NrV2VLNVIxMU1ZU2hJeWFXU0dtOWdDVWRZTWdHdE1UVG40U0Q3dE5XSkxidkxHMkRpRUVZMnp3UVlpV1JvZFdrcXlqRVI2RWpUd1NsWUtaZXc1dlRCbStvQWhDa0xSTFNoc252VlNOeFNRcHRZQ2Q2WVJ4VVRLZDF6ai9WZXJhUkNTQTljZ1FFRTVnZ285VTRqYmhSbC9FV0ZKNTUvRW1ZQlI0b1FuR2dnMTRMMmhtQnVzOTlienh6dm0zakE4alRqamVpeVhkY3VUNzlXOSs3WHZQdmZqS202Tko3L1BUZWNIS3lvRHBaQkkyTjlhM243cis5R2UvKzkxLzlyWnpMZ01xNTV6OWpkLzREVjU1NVpXUEErVC9YdzhQcG01c1Badk5vMW1MMGhSMVE5SXFkL3RUVlpsem52R2s0SGhTc3JzL1puMjF6N210VlhxZGhEeVBISW15Tm5qdlNMV0tBU1lsV2tmeVVsRldsR1dOV3NqenRGMG9VcEFQOC9HMHNxT29DRUVJM21sdm5aQTZXcWtSRm9MWDBROHh1RmFSVVVlOGNIWEhVNDhya3M0YWVKWmI4aUJpUTEwM2dXUHJtTGc1VlZXMXJyVVM2NHVvRkdrRDBrTWlCRjVHSTU3RytWTis1ZTJ5MUhrOEFSS0o4SkVUN3gyNHh1RnFSek90OEhpYXdveWNDMjk2N3hjYVY2ZUZFNWE4OFZ1Mzcrdzh2SGZybi9iWHRqLzVhT2N3Zi9yNkpaSTBwZFBwNkNldlBmWEYxZFgxZjN4NHVEOWZsRm1qMGNqUFpyUHdVUWtRK2RNZEcvaEpXYzhjNFFmT09qTVpGZGphMGUxMHFKR1VMdmJ6c2xValVRcWtFZ2dDUmRsd2UrZUk3NzU5bjdmdjdITTRLYWlNSmRHUlNLUjFKQnNwZFlLUXJhcm95d0hRSUpBNk52cEtTemF2ckE3V3QzdTl4YnhlRUZ4UlJFMnBMTkdjSEZIQmZHeWlWM2dyeDRNUlRCODRsSlFrYVI2aEgwb1FKUFFTZ2ZEUVZJSGpTYzIwdERST1lLM0FXWkErTWxJWHlQQ0Z3U1hPSTMyVUhmSXR5Y3UzTWtlK2NVam5VZDVISC9VUUNFSlFITXhibXJIRE5mNWhFL2poS1V6VmFlbi8welRXK3F0ZisrM2ZLV2JqTy92SEUwS0E0Y3BBNUoxY3JLK3VYWC9sazUrNnNwaG10YzI2Y003eGk3LzRTeDhIeUI5emw5NEtvQWM3YSt4clFzcDZBVitmVFVvU0JHbWFVQWRCN1ZyL2p4Wm9TSXZFRFFIbWRjUE5SMGQ4NjgyN2ZQUE5PN3o3NElES2VvYjlIbXVyUS9Jc1F4QTlCNHVxanZLaUxaQXhYWEN0T3duOXpieWI1YXEzQ0Z6cnc5d1k0MjFycDR5UUxmWklJSVNraWxvUU1SUE5GZVdvWm5XdGo4Z2tRUXFVOVhTMUpKVXlTdmJMcU9OVVd4UDF2QWdFRWZ1U0VDTDhSVXBRS3FDRkk1V2daSVM4NjlZZTJacG9YUzBoNm1WWmovZlJGOFNXaHZsUmdWY0NaN3d6bFh1ajluNzNWTGJ3UUZCU0J2RStJWGVhOTI2OGUrL1IvVnRmcit2RzdSMGVoN1cxRldTUzBCLzB6MXk3K3VUbjBqVHR0aE10TFlRUW01dWI0dU1NOHNjWkhTZllIUXU0VVdGdU5TNTgyNE1sUkwrL3FtekFPRktsc0ZKU0lxTmNaOHNKWCtwTmg4V28wYkV6bXZQYW5WMSs1ODI3dkhiekVVZlRBcTBqbmRVN1IxVTNOQ0Y2N3lYdGlGaEt3ZXJaUGpLUnp0WjJZWWJrbEpTMm0yZWhLbXVNc1V0YnNoQTg5ZHhTbE5GSXgzdndFOG02bEt6ME5USUxwSWxrUVJvMkxsb3FLQm5vNVRvNjdnSkNTVUxMMFUxU1RaSkY5RyszbytsM05TdjlsRlFMTWhuN21hVGx6K1BiQ1YwTDJ3OCtZSzJuR2xWTUp5VzFzWmpLRmJWenZ4TkNXS0J5bDh5K0p5OWRJTTh5VHIzL1ZWblZ4WnV2Zi84MzU5UFJ6cVBkSTZHVm90UHQwTzEyMHUwejIxKzZldlg2bWNYSUYxQ2owVWk4OXRxci9NMi8rVGMvN2tIK3VHS2tWZWt6Z0puWDVpQlYyWC9hNjNTdTJhSzZzbkNpclJ1SHNKNGswNlNkbE5JNGpMSG9Wa1BxTkxOL29ROFZmR0JXMXJ6MVlKK2JPMGVzci9SWTczZHd4bERWYlRuaVBIazdLdWl0NUt5ZUc2Q0VRRVhDdndPb3JSdmxXZElVVmRNdHE1bzhUMEZJNnNiZzU0Smk1cEE5UmVvRmVtNFJwYUdXZ283TVVGb2hFblhpa1dFRG5WVFN5Vm9kWUNmb0p4bldOMlJhMGMvN1RNb2phbU13VnVDdHBxYzNlVGplWTE3TWNSNThpSjRuMGV3bm5PeEF2TWRWanRIK0ZHTU1LbGVZeHIxV051NzFVMW5DQ1NGQ2xEZEs2SFE2VkUwVFFnakxNdXM3My9sbk56N3poVjk0OVhpNGRxRnFEQnNiYTh3bVU3YTN0NjgrL2VRelQ3L3p6bHYzaEJCSkNFRlphOTFrTWdsNW5vZVBNOGdmOGVOWFAvTU1UNTNiV05oUytBWDhZZGpyTkdjM0I2cmJ5MmhPK1c1WUh5aEtRMWthT2xxU3BJcENDc3BUWXhuUCs0RStVVmtRYXV0NGNEamhqYnQ3M053YjRaeW5JNkllcmhUUnFxaC9wb3ZLRk43NXVxbnNmSEhibHJYWk15NGNab2xtUGkrcGpVT3FCR3NOeGFSazlLaUlTOERTVWR3ZlU1UjFoTGw3Z1V3a3N1MkJ0SkowT2ltRFRrSS9sYXgwVWphSFhUWlhlcHhiNzdNeDFHUkpSVDhYRER1YWJnWksxOHpzRVE2TGxTS3F5N2N3ZmR2Q1NYUzBsc1UxbnFQN3g4eU9abEV4UllpaXR2NS9xcDNiYXcrL2pSQVFRaTlMZ0VEWjJBZ0ZQbm4vbS9GME9ycnozZysvVmxmbCtOSE9BYjFlaHlUTFFyL2ZYN3Q4OGNyUDkzcTlmZ2lodFRiME1vUkEwOWlQUzZ3L3JoSkxTL20raVVyZE5FZWpVVEZSQ1BKRVlzU0pXR3dERk5aeFBHOW9yRWZMcURObHhmczcwTWU5L1JZRFpSOENydFhtVFlqcThBZ1luc2xKaHhybkhkNzZuZW1rWGdpUjJjYTRVV1BkQ0NHQ0ZJVHhlQTRpQWdsdFl6bDZVRkRYSHYvSU1IazRwN0tXdWpEVTkwck1Ub1diMjBqR1VZSTBWK1NKcEpOQVB4T3NkaFhyZ3k1UGJEM0RTcmREb21yeXhMUFdHM0IrNVJ6ZEZCd1RncWhJRlNSZEZiVTBXemRYYjMzRWx4blBaSGZLNk1Fb051NUNFQkQzUzJQZTR1VHRpKzV3SVlMSzNyNTVDeUVFaWRLaEZhUjJpN2Y1SzEvOUo5K1lqUTdmZkxoN2hQZUJYcjhuc2p3VGx5OWQrZlRXbWJNTFNaL1dNRXJJYjM3ekcrTGpBUGxqZUR5eHZZS0owNlNsQ2RPOGNmdEYxZHdleld1a0VQU1V3SXRUbnpCeDlEazNuc0pFWHdqTmlWYm1hWTd5NHlLd3AyM0tRb0FnQkwyMWxNNWFDbEtFNElPWnpacnZ6d3N6WGdSSVVkWGp1akc3VWdpUmFnWGUwVmhQRUJyckhVY1BaMHlPR3FvRGcyc2lDN0NjRnh4KzlZQjcvK0FoZC83TEI5ei9IM1k0L3Y0SWU5Q1FLRW1xQllNTVZ2S0VUaUxwWnBwQnAwZWVhUUtlY1huSXBOcUxJRVlSWW5ESVFLSkRGSGZ3Y1J5c0lqWUdNMjhvOXVmNHhxR2tRQ3BKZ0FlVC9XTGh2MkVBSjVVazY2ZkxocTJZVDdsOCtUSlptckY0YTRVUTljT2RSM3NQNzkzOFJsbVU5bWcwWVh0cmd5VFBXVjBaYm4veTVVODlmN29QY2M2S2IzN3pHL3hiLzlhSHV3LzVxV01VdnYzd2tKdTdvNFV6MEFLUGxUVFd5YlZCWjJWV204OFd6cWVPYUJvdnhTazl5Vk1yeHRQbUVvOWJrWGsrV0FnMnlnWkMwazlZT1pPanRDYkpFcUVTT2Q3Zm1mK240NlBxVm52ek9oK0NXQi8ydG9mZC9EUE9CKzI5cDZvYmdwQ1VSWWx6bmpUUmRCcUZLUjJOc3hTMWllTmdDL1c0b2Q1dm1OK2NNN2s5WStWS241WDFsRVFLdWxtSEVHcU1IZFBZZ3NxVVdHZXd6bUtjd2RnVGdUelR0R2FsdGNjMG5nem9wd0xiT01aN0JiUDlPZDQ2QXA2c214b1grSjkyYjQrK1Jpdm1MQVJHYWVtSDZ4Mk9qNHJsZS9IY3M4OHhHbzJJc3FETHQxQXJRWG50eVdkK1J1cHM4K0w1TTB4bWMxeGowcWEyN3VidDk3NDluOCtLTnFCY251ZSthV3J1M3IzM2NRYjVJOStsQ3hCQ2hCYjVZUUV6cVpxM0VPTElCV2dDRkM2aW9Qb3lhZ0NkUHZ5UCsvczliaVp6T21nV21VUzEyKzFCVjZOYXFIZ1FnYXF5Yng4ZGxPK2VMamRDQ0UxUm16ZDg0REJSMFVWVmlRaGIwVHFsS21xTzc4MEpCanl0Wm5DclBvS01MOHEwRVAzcG80TDNmdk1SMDNsRGpXVm1KdGhRVTl1RzJ0blloTGRDd2NGSHhSVVpJcWNsWUFuT0lheEQrb0F4anFieGxMT0d5ZUVNVXpXRUVQc1NwTmdiSDVSZkp5d05jS3lRMGc4Mk9qeXVDR210cFNpTGNFcS95Z0ROcTY5OS8vYWpCM2Uvdm44NGN2T2lZbTF0aGF6VEVSdHI2ODlzYm14ZE9MVVRrZlA1WEg3akc5OWtaYmp5Y1lEOFVUL2l1SGJoMUJFVHdyeTJEOU91L3ZYK2F0WWdvOTVSN1Z2NWVoRlJjK3F4Z0hoY1F4L2VMdy8rL3FDTWVDcVZSTVVUSHp4Qml0QVkvOE5pMWt4T2xTVUdNRWVUWWtmbzlFR1N4dVkyMFRyYVNNdm8wVDQ5THFJcGo0QXMwUzFvTWlyQmFhVmFZcGhBS2NYa1ZzR05yeDZ5YzJQQzBjR01zcXB4UWlCVWlsZXg1MnA4ZE1VMUpxQkRuMVRtS05rS3libUFyUXpGekhCd1dIRzBQNmVZRkZobjZDWmQ4cnhEWS95ckJ3OG03NTNxN1FJaGhHcldoS05IMC9lOUY5LzY5cmVXcUZ4eGFsalNXRmZjdWZYT04rZlR5ZDd1M2pIcmE2dWtlY2JHNXZyNXA2NC85WW0yekZvMDYwSWdSS0tUajhlOGZ6ek4rc25TVUFpQzhiNzgxSmZQdmZ2c3l4djJqZThmcHE5OVk1ZnhRWWtEcW5BU0FNbGpaZGJqRHJIaXNReXpNSjlvZkNDVkFxbWpBSUxRRXFGVlkwcHp3MWwvT2pnRVlBNUgwNE41MWJ5M091aDhTbXV0cElvYjljWVlwTlpVamFOcFlqT2VhazB2RDZSdHR2RkNVQnVESjBRZWh3dmMvcTBkN245ZDBGdkpHR3htOUZZNlNDWHcwa1BxVVFPSjZFcENwZ2xhRUVpUVVpQ0N3emNlVjN0czVTam1GZE9qQWxNYXZBOGtPc01xTzUrTTVsODNsVDFOYnczZUI4cHA4NEh2ZjlNMGk0L2hmWXZEcjN6bHQxNTk3c1ZQZmVmdW96Ti83dkxGTGRIdDllZ1BoNTFyVjYvLzNOcmErdjkwSEdzMURVam5uVDhhSFlXUEErU1BxZEk2M1VZSWdkamM3bHc5ZDdtZmIxN3FoMnZQcm9udmZYV0hkMTQvcEp5ZGZNanVBMHFvRDNKOVBSMG9nVmkyWlZJZzI0bVFURFZKTnpHaXRPV3BRN1Y0T2dQTUgrNGRmU1ZMenY2SzBObWFkSlpFSnlSSlNxL3J3RnE4OTVIOUtBUzlMTVU2dDRTektDbXgxbUtDSlU4U3NrU2poY1NNUFh1SGMzRFRPSnFWQXEwbExnUklRSzlvOHZVNTZYcUc3VmxxQzFYcEtPYUcrYXhoY2x3d1BaaVJOdEZIYUZxTThLbjY0ZVNnZlBNREVBcy9DYkxCQXMxa05oKy84OVlQdnJKeDd2SXZIbzJtL2UydERhYmpNWmN2WFg3aDBvWExsNCtQai9ZV0xWMnI5Qzc0S1JSaytGQTI2WStkNGRNYXZQM0JTcmIrMlMrZi85VjhrRjRQUWpCY1NjV2xheXVzYi9Wb2FrOWRPNXoxeXl1UER5aXZPUFZwaGNlYWV3MTBjOGxnbzBkUUV0Rko2SzEyeS9taytjM0RoOU1ibkxJN1h2d1RKV1JZWHhsOFBzRFpxQ2FpOGQ2MUVwK0NRYjRRYTRzU29NczlqSkNrYmRtMUVBY1dSTW5VSkZHa1dlU2w2elJ1NkVXMHY4STJIak4xRkxzbHMvc3ppZ2NWOXFEQlRDelRjY2xrVW5KME1DYXJCSmZ5SVQyWmtuaUphcWd6TDVzUXVGZFpkOFNKWDRiL0NUOFRCU1IxWFRUUFBmdkNwL0x1NE56VnkyYzVIazJDOENJZGo2Y1BYMy96MWU4TElSYjltdnV3QnNkUGU0QXNWRTBXZ25HOTU1L2QvTVNMbjkvNlYzd3FCMElJWVcwVW1PNnRaSnk3dXNMMmxUV1NYR050d0RZUjZpRitUSkJ3YWdTOGFOb3pvTmRQR1c2czBBaEhOc3pwRHZKaWVsVDlrNk9IMDl1Y1dCOHZObUM2Ymt5enR0SS9seVhKWjR5MUNDbUZWaEc2RXJ3bk9NZmU0WlNqYWNueHRHUmNOQlNsb1dnY1JkVzA0R0N4Rk05V1VpQmxoS3k0RUNkVjFubHNpOXdWTFdaTHFxaDAwdFVwZnVaUWMwdmZDSHBPTWtSemFUaGtwWnZUeVJKNmFVb3ZTVmNIbmZTVmJwYWF2VW54clJEQ1R4b2c0cVJWRThsNE5Hb3VYYm95R0s1dGZmYk01cnBTU29waVhpaG5YZmpoTzI5K2F6NmZUZmxSR1AzSEFmSkhtRDBXaW9wZG9QZlUrYTFyUC85emwvK04vc1hrZVNlRnBGVmZ0ellxbTdnQUt0Y01ON3Vzbk9tU3BRcGhvZ2xtYUhteVFYeHdmU0VYWHdJNlE0M1BBekxUZElkZDBrNGlpdVB5K3djUHB6ODh0VnhiZW9PM1RMcEpucVhQU3luUGVPK2xEeUNsUWl1QnJXdXNpU0JHYXgyTnRkVEdVbFFOMDdKbVdqWVV0WTArSm8zRitXaElFOXJnUUFpVWtpZ3RFZUxFekRsSm9pbzh4S3dscEFRZnlLVm1rR1RMVjZlRUlORXFJcGVsMEZWajd6OGN6YjhhUWlnNFpjajVoOGtpcThOQk9Idmg2dWNHZytIYXBZdmJqTVlUZ3ZXZG5kMmROKzdldTMzNzlLN2w0d0Q1NHltdGNtQ3d1VGJZK3ZJcjEvNk5jOC8wL296YUVObzRsbndMWnlNdzBRVXdGcXJHZzVBa1dwSnBnWmFXTEE5ME9wbzhrVWdaRDZCb1I4bWNhdTZWRnZUWEV0SThJY2xTZERjbHpaUWUzWjgwby8zaW15SHVEdDVuNVFXSWFWSE9KdlBpVlhBdVNlVlRBcEdHRmhOcnF3cnZJeE55Y2JpWEJ6MHNscE1DNndMenFtWldOb3huTVhDcXhsTFZNYUFxNDVhSzlGRm9HNHkxMUhVVFJhdHRWSC8zZUl5UEY3YVdKOHhMWTUyNHRYTzBkL3RnL1ArYUczdUh4eHhyLzRBSCtMUmhydDdaZVZRLzkreHpXM2x2OWFVckY3ZGxZd3ltYVRyeldYSDh2VmQvOXp1ODMvZjhReGtnK3FjMFFCWmkxVjJnKzdPdlhQK1ZsV0h5Sy9TRFFzcmx4dGk3UVBUZmpFMjFwMFhCQm8rVUN0c3FOMmxpazB3STVEWVNpTHdGWTMzMEFBbFJaaWZKRkRwWENCVWJZMG5FTkNWNThxbFV5eWNxNngrY3FzeE9pNjNOWjBWMTA5am1QMTdka2hkbDVuNTVOckVvRTZKWlQ1UjFZR0ZYNXJ6REI0OW9QVDFpMytLWFF3VVhBbVZ0bUpjTjNyZktLRnBHa3h3VkpZeWltbVJBaWtBblMxc0oxYkFzMWJ6MzdXUkRMWTJDdGxaNzVxQTBockxKMnN2bk5GbnFEOUpJdjY5WnI1dG05c1lQdnZjNzV5NDkrV2YzRGtaYncrR0E0MjVIWEx4dzRaVW5yajU1N3VhdGR5ZnQ1MWgvV0J0MTlWTWFITXZTNnNXbkxqNzkvTlV6LzBlZCtNdTk2d2xXZ1RjaWlnKzRnTEV4UUl3TDFFMEU3VmtYdmN2TDBrUTdBT3RRUWtTZWVHdHhJRlJVTk14elJaSkQxcFdrSFkzU0dwMG8wQXFkS1BxOU5BVHZ4ZUhENmJjYTQ5L2xSQnJIUGJhSEZNNEZsM2VUNC9XejNlZEl3NGFaTjdqS3hwS3BSUk11TE5ha1VFaWlobTZNM1pZVUpZak15WmFMRWtKYzJybmdhYXhsVmxTTWl6blRlY254dkdCZU44d3JTMUhiWmEvaVEwRExPRTZPSnFBUm85WE5rLzZnazI2VXRYMXZWcHNqZnJ3ditSOTBzcGhNSjZQNm1hZGZlRzY0dG5IOTZ1V3pZVHllQ2hGQzcrRHc0TTMzYnJ6em5oRGlmWHlUandQa2o2WXh6NERlMXNid3pNOS8rcW0vcXJ6N3NzNkR6cDlJTUI1Y0haMXN2WTlvM3VqbkViMElHeE93TG1MZHZmRklEOTQ2WkV2ZVh2QkZwSWgyWlF1QW4yZ0YxN0lrUldnVi9UdTBvdHZObUU5cXYzOXY4bTFqL1p1YzRDUHRZd0VTQURFNnJrWlN5Mkoxby91aW1vVitQVGNJRVphc3hZVm1wR3lGRzBSTFdoRnR2U2VWT3JFMzhCNHBGMldZYjB1ekVLVjdYSVAzamhBa3puaXF4akFyR3laRnphU3NtRmVXc3JITDl5ZCtmeWs2aWJxNDJzc3ZWTmIvWUZyV2s4ZUM1Q2VkYU9teXFzTDYycG8rYy9iaXoxMjZlQzVwZWZyNjhPQmc4djNYdnZ1dFUrL1hUNlcwNkljcFFKYlpRd2g2UVBkZitMbVgvc3lGemVGZks2ZXpmcElKc2dzYWk4RGJRR2dEeFBzbzhZOFVtTnJUTkM3K1BvQnNENGFQVEtxb1hrS0lKWXM0OFFVUk1pcWNLQ1hSYVlwdXVScFpsakxvZDhYaHprU1VSL1dkMnZwdmh4QVdvMTY3ZklySFhzTjRWQjNrWHNxT2s1OFVIclVvclh5STBwK2h0WWdPL3RUWVY2a29MS0ZVTENHZGY5K3pXdWNSSXNUQUN0SGVRQWxOb3BMb3M5aUt4SVgyRW9pRGdKcDUxVkEybHRxR0dERE9pMVRKY3l1ZDdLTHovdTF4MlJ3OEZpRGhKN2pNRkpBRTc4eWxLMC8rek1ibTV2Ylo3UTF4ZkR3V3VORDU0VHMvL05aNE1qbzgxYXgvNkxLSSttbk5IdHViSzJlLzlNcFQvM3RyN0ROVldRV3RwRWcyTkQ0RFYwY0hXK2Zqb1l1VFVrbFZPNnFtaGJzVFVMU0NDTFhCV1k4SVVkNW5hYk8yY0pXVkVxMDFTaXVranBuRUEzbVdrbWpKNGIyUmRITXpxNXovSjk2SEdkQUlnZDFjSFhwQTJKUERIRjlEUVBXRjNreTEvaHhDNU1GN3NjZ1FyalUrOU43SGJiMlV5L0xjdDF3T1Fkc0RTUm1kYk5zU1RTd01QMXVCNjRXUGVnaVJKcXlFakJiV2JTdXQyNkNUUXVJOTFNWXhLMnZHczBvYVk2OTQ2L05wYmI3aDRzajNKMjJtRjJXV0hrL0c5dno1eTJ0bnpweDc1ZnExUzNwV2xIaHJ1NVBKOU43Yjc3ejE1b2Q1bWlWL3lqTElZbnFWdlBEaytSYzZXZkpjV2RYVWpSVjE0YkRUc0RUNGNHMnY0WHpiY3pqZittZElNaVVZNXRGM1E2ZUt0Sk9TWmdsYXErVk5IaER0WkNrZU1xbGtGTDRtc3ZQaXB4OFlIMCtaSEJaSUlWS0IwS2ZXSm1KZTFtSjdiUmlrRktmaFhSNElPOVBpN2VPaSt0Yk9lQloyNXpWNzA1SjU3UkJTUmJhRWFBdWZsa1FmeDlFK2ZzSGlMK0M5eFhuYlRyOWlvSVRnWTArRndEc1hTeTBmbHRyQVVROHNOdlNKVGxxWWUwREllRGw0NzZtYVJ0Uk5jMVZMTVRqMW1uNlN4NkpacjUxejFXdmYvOVpYNzk2N2QvZDROR0ZqZlpWdXY1ODllZTJwejYwTVZ6YzQ0WWtvL25CdXR2L0xEWkEwVGQ5M0d5MDI1OWN1Ym4xZUN0YXFxcWF4Rm1zYzlaN0YyOFhaQ1RUVzB4aS81SDdySk42dTFrYXRXeXNpcmlyTE5YbW1sMlZNTkhac2hSSGEzbUNoSE9KYWxSQ0Z3QnJMd2FNWjlheEJLcFVuV2kyWXVESUVSRkhWSEkxbjdlMysvZ2IyOHBuaG1hdG5CcGNIbVpMemVjWCt2T2J1dU9EbThaejcwNXJEMmpKdDR2aTJNVkg0V3JSQmU3cHBENEF4WmpuNWFrelRxcVZJbEZJeG83VCtpaEhDRXRvcDFnbWNaUUhDOUsyR21GQXhTSXgxMDhaNTg0YzR1RC9pVVg3anZYZHVQN2gzOTl2M0h1ejZicmREcDlmbDhxVkx6ejc3elBQWE9PR0pMTTlidjkvL09FRCt3S2tqMWgvTG12YksrWTB6Sy8zdTh3R2htc1lTZk1CNFQvR293ZTg1WERpUjlMUXVCc29DcloyMHRnREd4Y21sVUJIU2tlVVplWmEzQjZxRmRyVGpVaW5qcWpCUlNXdXhISis3bUZZY1A1ekdVazNLVkVyUk9iVlhGQUMxc1NJUVJHaDFoSUZrcFpmM3IyNnUvR1d0NUhOckxYVjJMZGRrQ3B4MXpDckQvclRpL3FUZzl2R2N1K09DblhuTllWRnpQQ3VvR3JNUWNHd0hDUEZuWEU2MmZJaEk0eFlqc3hDbkNONi9MeUdMdGtIeS9nU0pGZ1BQNDV3TENQSEluYUFDZnRMSDZRQnBqRFd6MTEvN3pqOTU4R0RuT0NBWURBZXNycTl2UGZ2VXM1OFRRaXk4MFRVZ2hSQWl2dWNmNzBIK01EMklmdnJLMlN0NWxsdzMxb0VRVkkxRmE4VmtXcFBlMGVobk5PN1Vhc3NhajNOUmdVUzBzMUZqUEtFVmd0WlpFcEdJdWFCdW1sZzgyVGgrRlNGV1JVb201RHFuOWxVMHg3U093NTA1OWN6UVRST1Vrc051bG01T2kwcWVEcEtxTWVHVXFXMEtwSmZXQjYrWXhueW1ObzBnd05wS2oxNHZwMm9hcXRwaVhLQXhqc1k0YXU4eDFsUFpobEhWYnI1VlRTZFJkSFIwdjFVaFJERnVFV0lUM3dheDk2NmRhTG5XUktmTktESm1GRTVsRGlFVy84YTMvejQ0Ri94dUNIOW9LTWpwTE5JQXpadHZ2dmI2clpzM2Z2ZjRFOC85eVkyTlZZNE9EdFgxNjAvK3d2bHpGLy9oZzRmM3BtMFdhWVFRZmphYjhXSG9SLzVuRCtQMkpoRzBaRDRoME92RC9qT3AxcXZXZWRJc3d6Z2ZpVURXY3ZoZ2pybnRjRTNzUllLTlhJakdSTmNrWnozV1IzS1NjM0hNRzBUQWF3ZzZrR1VKU3Nlc2tpWlJERnRKUVFpV3hwV3RWcS9qY0hmT2FLOUNTWWxPTkFLeG1pYkpwVFlRbG4xSWVIL3ZsRzZ2OUxaeUdmN0M0ZkYwbzZ3aTJTbjRnSmFhYnBheE51aHlkbTNBcFRPclhObGU1ZXJtZ0V0clBjNE5jbFl6VFNJRXhscEdSYzJqU2NtZDQ0TGJvNUxieDNNZWpFc09Dc09vYUdKcFpsMGNXNStTVjRWMmp5SmxOUGkwRHVkc0ZKVUxjVHJtck1QNllHb2I5aUg4ODB5WGxsbEVDTkhNNTlQUnpmZmUvc3F0Mi9mS2JyY2orc01CVzF2Ymw2NWZlK3JaRCtwRC92YmYvdHNmWjVEZjcyR01XU0xQQStnczBXbWVKOWVGRXRvNkY2UVVRZ2hCMlZpVUZKVFRDdnVPWjdQcEl6WVZkbUhmN0FLTmRPRGJraUlFdEJKb0t4SEVmaVNvZ0U0Vm1VOWFJR0hBQkdKOTcyTVdNajR3T2E2WkgxdVMwQktkSkNCRW9vVThzNUMyNGYwczNzWG1QMW5ySkMrVlpmWHBzcWlFbElvMFN4ZHFJakdxVkx1cGI5MTRoWXltbjZMVkNhNGJRMk1NeGpwcTQySWd1R2lCVURuUGNXWGloazZLNWJnNkVZRk1PVEtuNktScE8rR0szdSsrTGFsQ3EwSnZuWVVnYU8rUStnUDJPVC9wd3dPMkJUL1dyNzc2blc5LytqT2ZlK09wcDY1K1ptVjFHSWFySzkybnJqLzEyYTk4N2JkK20yaTlwZ0dqbFBwUTdFUitXa3FzcGRYQm1mWGg2dXBLOTVMM0hxVVVXWnFoazRUWmRFNDNUekhlY1RBcEtOKzJyQi8zNkc0cXlpemdoTWNGRVFrUUhyeXhjUkZJdEJxUVNxQlRpVUFoUTRJMWxpWTRrS0xkWUF2S3NtRjhiS2xuRHUyakludUVpRWlFRUlsVTZwSldLalhXbm1idGhrV0FETHBaVHhHK1ZKZjFpbk0rQ3JiVkRVckZaamw0b3RKOFZCZHBBNlFGSXlxTmtoR2gyOG5pSWZldGV2MEp5TkZSTm83S2Vhd1AxRGFjRXA3d3lNcVNTa01xbzlWYmxtaTZXVXFhYUlKM1dHdVJVc1lNNHB4eElTeGtqTncvUjVuRjZWN2s3dDJiRDI3ZGVQZDNkbDU4N3BQWG5yaWNkSHBkOGVUMUp6OTErZExWQzNmdjNSNHRzdS82K3ZySFBjZ2ZzRUUvZlF1TGxVRjNJOC9TQzg0Rm9hUWt6Vko2dlM2SHh4T29UYnl5UEJ4TkM4YXpndldERHAyVmxIU1lVUGZBeWRCNmlndW9BMDQ1TkZIY1FTbEpVQUxYTHRSODYvRG5qS2VhT1lxcHd6YnRBRUMwUzZJV25oTExRYkdtbGN5TWZYK2p2Z2p1WVpac21zYStPQzl0Mng2ZkRJWjhxNHRxRjV5UUVGQXR6RVRKdUg5WjJLZEZUa2lLbFBHQ1NKTkFIdUlFS2poUGJVeWM3RmxQN1R5VmRYSFU3V09XS2R2aktpcUxuamVSZHhLWEwzUXk1WFZndjdIK29ZZDkvam05eVNOdzBpOHB1VUQxMWEvOTVtOTk2WXRmL05NWEw1eDlKbEdTTE90ZWZPbkZUejUvOTk3dE54ZnZWZXRwR0Q0T2tKOXM2VVNhNko1V3FoLzlQQVJLU3JJOEo4OHpack9DVHBaR2tLSDMxTll5M2ExSTlpVjVsaUE3S2VrZ0pSdHFra1JnYmN3c1drdDBFSEhwNXR1eGp4V0VNakFmVytZelMxVzZwY3R0cTZLNC9QeThqOUFVSmVYWmJwNnRsM1h6Z0I5bDhHS00zUnhiZDM3ZVN1K0kxcDVOdXRNdk1weENFc2ZuZDhLaHZJOExRT0xpVDJ0RGttcDBra1RBb29yd2Rwa29ra1JqWGJzemFmM0lRNGgyRUUxYmx0VTJ3a3lNRDVSTnM1enl6WXdUV2FKZkMxNzhBK1BjZmY0NXZjbWxsTUU1dndRd0NpSHFlL2Z1M0x4MTg5MnZuOXZlZW1vOG5YSHZ3YzVReWV6SjA5OGpoTURmK1R0LzUrTU04Z2RwMHAxenl6NUVLNWtxSVZYY2NxdW8rYVExcXlzcnpHWWxzM2xGM3NueHpsTkhwQ0plT09aVmpUdUdUT3Q0d0JLSjBndUhXSllOclcwY2RkMVFWSmE2Y3BTTlBSSHdYYzZhVzdWMElMaEFyNXVpdFk3N2JTRVU3d2ZzTFIrenlnaENVTTNqcVNXY05DeW51M3NWQlU0UWhQYlhzWGNBY05aZ2pDR0VraEJpOWx1TWU1V0t2WVdVRXAwbUNCLzVJWmtRREx1ZE9HaUlQbzgwMWxGYlE5bnVYSXdMS0NtZjlWcUZ1aXpMeDBxbG4vZ1JwNGNLSDdFeGhrRFZOSTM4MWplLzhkOEVwNzVZTnVhWkIzZnZWYVBEZzN2dHRHc1pqSC9yYi8wdC91MS8rOS8rT0VCK2trelNOTmI2RUh4b044d0IwRXFTWkNrYkcyczhlTGhMTXkzSTBsaXpMeHlpcEZRSUhDNDRyREZVVFlURE8rdmFXdDVIcHFFTGl6YmxSMDVHTk9acEViUnhZRStXcFdqZEx1TUl0WXVMTmZFQjQwNDg0VERBTFE4dnQ0Wlc3K1BIaHc5SU80dmdFYTQxUHhTTFlBcEllL0x2VEN1R1IxditMY2xlclRhWWxKR3FtNlF0eFRmNGxteWxHV1FaSzUwOHlnL0Y2ZGY1b3JGL29rUjgzNSs2MVA4d2dmS2xMLzBTMy83MjEwTFR1QUM0UUtnQitWdGYrYzN2NyswZC9Udjlidi9QZVd0dTdoM3UvdmY4LzlvNzB4N0pyck9PLzU1ejdyMjE5VExkTTU2eFRTWTRtVGdrSWdzUUNSRUp4QWZnTy9BbCtCckFPelpGU0VqaEZSQkZrVmhlSUJHRWt4amlFRENUeElvZHgrUEpiRDNUZXkyMzd0a2VYcHhiM2JkcmVwTFlEbllQcmpNcTFlMnFidldkNnZNL3ovNy9keVlNTDEyNjlGUzBuSHpnQU9rSVBrcmVKeG9WU2NZSXRLZGdyOWVqYkFLOXdaRHRLNWZaZWJpSE9rOWxMUWxCVFN2T2FTMnhyVy9RY1VHMDFjOVk2SFdjNS95ZTVHNWI4R1Q2VFV0aDdVbUd5eGJsU2YvdE9iV0ExSVQwNE1ybTZDKzIrdVVmUERvWXZ6aDI4Y3cwMHZMdmpUdytLMzhDbUtWclBmT1pkZTQ1NVpnTHpWcnh0dkh0YU81cGdWREkxdFJZeWJYSHd0Z1U5RmZLd282YUVKVDMxUDZobWYwa0Yxb1dOUkZVTmQ1ODdidi9XR0svN29rTGJmUUZFMnhxQ2VsV0FQazVBSExtajlNcnk2S3FTdU5jcHF4WjVQWjdaVUhvVmZUN1E1NTVSdGpiM2FOdVBGWFpDb0cwWVhGb3dZRElpZDhka3RMMkNENzJXSTYyRTdtQnNESkNZU1czYkVRaHhraUUya2MvWC9MYkYwRnVzTmJVTjY1dVB0OHpQR2VTVTdkZnl6VHFZeWtmV2RyMFozaUNsOTZYYzM1bWtUWkxTOFVZRXRpVUxaR1k5bnRUaTE4Znp3QlRqUkZURnNKNzVKZis1amUvemtsdnpHbC8xdUtqdEo0NDd4d2lpOVo2blU2bks0Qzh1NndJUmtSTVVaUzVoYVJ0UXJUVzB1dFZEQWVSRUJNYm01ZW81L01jUWZ2NWFTZXM1SlBUbU95dWhGYkFMemZyQ1NHckx1ZG1LajFMSmljaWxNWmdGL0p1S2VXZ1BpVzhENUE0RGlIVjU3Z2pDUWhHcExtOWMzQ3RNS3FpcW0yU2FpRWhLT2NCWmZsYWxzQzdES0xGOTNTSEsvU2NsRnBLcCtEblBHQ3F4aENpZncvMWo4ZE4ydW50aEE1K3U2K2YxRnVNTVhyUjQ0K0xtTVVTWThSV2hTR0lVdVVXRDF6amNUNGZURVdyYjE2V0pWWGR3emxQakQzY3ZNWTNUV3NwRnVLY2dvckZGcG45dkRRRjRoeGhVWUh1QU1NQ2hZQWhaZVZ6MVRaelpWc1JtcENBZXo2YzRjZzZVY0lDbkEvUlBqaXV2eVRDdHczOERzcW5ESHdVMkZKWWlHWEllYXlQWGFCd3p2dXl0Tm1YMFpuT0FkeXk5WkVPbUN3a1RjbnhpNTNSZUpJM2VlYTJOYStWQlhrM01jajZhTEJaV0d2enpIYk8zbFM5SG1zaUdHUHhQaktySGQ3SGxsdXFKQmhEU2xtYnRxZ1VhdzN6cGdFWHNFVkJNM2NrNS9DTncvbHdJbVp2VzJDWTdra29lZFo3TVkrQlFJcEpTZElFSDk2SUtUVThYbmxPZ0cvbG9tK2o3RVI0R2JnczhER0Jqd3Q4QnZobDRFVURhOXI1N0ZQSG05S2ZBaEE5eC9VNnp4cnhCS3R6U2h0QmlLbzNBeHp6ZjBQTDh6T3RVci9mWno2ZnJ3RHlqdE8rd3JxbVpHRFJRaTZJSktxeXBDcksvRnpWakNjMXptZVd3cFFpYThNaGMrZXo0cElQVkwwK1ZaV3loTElxdGlpSktsbDNNR2JkdmdYVnp6bjNnTFRkczRKZ2JTSEcyb2xMNlVISGwwNENhcTBsNU9oL1VVMm00NHRQRmU0cnZBSjhEZGdXdUE3Y0VQaXN3TWNWbmpPd0pqQTR4N0pvMStyb3oxTklXbkxUNU5SM1RRa21rbVhYL2ozQVh3UHZsdnJuUFIrS1R3TTRMbVNhMS92QWVOYlE2MWNaSEtiZEhlMm1IZlFyRktVc0xFZmpHWTFyRldGandockQrbWlFTVphcXlvVEo4OFl4bmM2WVRhWWNIWTF4SVE5Ym1UYnpwZTJPTWkxNVcwNHRaMnNseHBMNWRoVmp6VkhJcWt3TGp5YUpFUjMxZTh6bWpZWVlrNTZleG9GTyt6dW52VnBIQ3JjVnZnMThGYmpTdW1DZlVQaWs1T3VQQ0Z3UktGcTM2WXpYMVhHbDVKMGMyUmFTaVB4ZFVQMVg0STBFOXprbHdudXEyUTgvVEFEUmFkMGM3UjlONDFZYm1JZVlRQTFpVG9uVXFxSkEreUFNbU5hZXV2RTVGa2tSSHlMenBtWTJteEpDRHE1ZDQvRE9JU2xSeUtLT2tGdmhwYzBNTEVaVEFjUzJMT3hDTzVjQnh0akR1WnNkZEdJT1RVa0pNV2haV0hKbU9jV1lUdVFDcEpNa3M1MUgwUUhPWVlLM3lPN1lVR0FiZUY3Z293cWZCRjRBTGdPYndFakEySFlzK1R3cjBmMTZrUnc0aVk1VmJTRlNCM2kxNWZlYXRRQjVwL1NqSzRCOGtDdjRrSGIzRG5qdzZJRG5yMTFoYzJPRXNmbm9URzJGVzhrRnNsNVZvcGlXeGRCU0ZKYkc1V3ROZWY2N2NaNnFLdkd1b3FvcW5ITm9USVRnMm1NNFQ5Y3RndlZGYTFqdWlEVnRzNk5WVTVoZDUvemt4TDFxSjNkLzQ4VWJmT2YxTi9tMTY5ZjA1dDJIV2QvdjFOUHBLcjkxR3h5N2dGbFltR09GWGVCTlBXME43NU5Cc3lsd1NUTklyaXJjTVBCcys5NVZ6ZHpGQldBTnJRSkRhMjA2OTdLanFtKzM0Smh5eW9uMVRvampWZ0I1LzlPNlo3S2Zha21WK3JsVXhuRDM5bDMyTjliNHlQTlg2VmNWRWlPZUhIZGthZks4a2EzSm11bUwwVk5wNVpoSkJWVlZaYjZvRUxMaWEzc2RRaUNHekZhb0tlRmJMdDJVRXQ3bDkxdEtlYlhXeEtTODFiWjB0eGtzVVZCZXV2a2FBSy9kM3lYRU13ZXh0cldLUlJ5eHJQaG1saDVkQzlOOWZzUnB6ZEMwNE9uRmJIRTJnZWZJNEJrSXJDdGNWbmcyNWRkNndGemdiWUdYZ3VxL2NHbzlGdFJGSzNBOEJSYmtoUFRBaFRBVFZSMldobUVwVEtiSDNMazF4L1NHYkt5dnNiNDJ5UG9hTFRCNlZZRkloSkJuSHFxeXlBVzNsRWdtWWRJcCs0Y3hPVlpKTVJKVHdubFBEQkZyRENNUmZNeFVuakhWV0RTekZTWVZZNjJiaHZDbXR2SnI3ZU5NNW1nOGR6L1AvNUdsekJkUHNEQmQwSngzM2UxU2VXM3gvbUxzdHdWUjFmN01uSnl0cW1tN2JWblFGdVdTa0s3OHE0dHRRYnFNSUhvOGFmWlVtU3N5U2trcHJNRm9aSGF3eDhIZVBxYnNzYkd4enVYdERjcktZcXloc0phbXJSUXJtZ0dVWW1zVkZHUDFwSGtQSWpGRmlqTFQvTlQxbktLd0RIcDlKdE1wUGtSNmd4N0I1YmtKZzJJTHU5L1V6ZHQwU05hTWlBNzdQY2IxazdNeDhiMEJadmxoT3RmMkhBc2tTOWV5VktkWk1FS2V0SHNzWm9Sbkt4eGNYSUNrbE9qOElWTklPbEgwd0lWNE9hYXMzZ3JrSnJ5azdCOGZNcDBjTXprK3B1ejEyZHhZcDkvdlpVdGlCR3N5eVZwS0JXWE1ZNm1sYW01bGI4VnN5c0tjNkFVYTZlTkR3QVdIc1liUmFNaThubE8zbzZuR0dwd1BiODJiNW42N3NZSUl5VnFqV3h1am53cVFkMkZGenl0L1BDbVRleDV3bGg5MHMyN2RCRU1iSU9uS3QzcDZYS3dFNkxodWRtZU52MTJWeFExamhLSW9KTVo0UXR1NVBoeFNTS0tRZ0srUDJXK21sTDArWmRrRE1hU1c2NnF3QnF6RkZrcndudEMyb21TUUZFaE1oS2duVENER1dQcjlndUJEUytiVzdrU0RxMTN6OHF4eCs5M1RWMFFZejVyMzQzTjU3UHFjTksrY0E2SW5aWUcxazkybVhtSGdxUUZJQkdJOTk5TnA3WFpIdlFwcmJjdFkzazRFbGdWaWxhb3dqSWI5bHAxUThENVNOeE9jQzdpNElKSURFWnRySXIyU3Npd3diVER2bktOdTVzUVlzZFl3N1Bjd1ltamFCa25UM3BHcUVvSi91L1orUWVYdnlPVHI2bnpRWWEvM1FYOW01MTJmZFdHWHJydnh4aXIyZUFvQVlvelJsUHV5RStCZGlLNEo2VC9MWHZWNzF0alJvRisyOVlvc2toTmp5dGFCUE83cGZlYk5xb29zQzJCY0lObk1sZFUwRGZVOE1CbG5MWTJncldDbVFGbGFSc1BoQ1NHMGQ0SGdBekZHcHBNcGsrbFVOZnFBa1g4N3J2MmJkT2d6UlZBandzRjQ4b0VqNDUwdXk2b3ErRFNtZWJVVEFQdWptYnMxOTNHM1Y4aG9NVWtYMnduQzB0cnNGclVNaVRHMUxPalNFanBiaTRoU1N1YTFMYW9DNXh6U0NEWXBLYnBNMTZrbDArRHpwR0hJcWQrVUlpRjQ2bGxObkR1eHBkMmJCUDFHU2pxbW8rbW5la3F4YzlHWC9vS0E5V0ZkSHpoNXRiVTJFenFmWm1lSzhXeXUxNjl1ZlVhRUd5TElzTmNqaE1oODdqRWlqR2MxeDAyTlZoRkhwSW1CdWdsTUc0ZDM0WVQxM2Zsd0luL1dLeXlsTlJTbVpSTnB3eDRoWVNRbkF3UWxlSWQzSGsyUkpQTFNzVXQvazFTUDIyUlBZMFRTOXFpdjA4YXZkcy9LZ3J6dmgxMEEvTHp4Ky9jZUhmM3pDODl0ZjNIdllMSlIrNGIraGtXMkFySVpXUytGOWUwUi9XRkI5SW02amt3bmtiRkxCSVIrYVdBYXNmdkM0WjdEZVVXc0ljV0V6aU91em16dlZaNHpid2Q3SWNUV212aUl3dDQ4cEgvd01SMTI0bzlrUkxRb1pMVnpWZ0I1ZjlaQ3JKNnpZdlhOMnp2Ny8zRnBmZkQ5UjBmSFgvejRMMTNpYzcvOUxMWm9wd01URk1iZ1hVSU45RXJEOXRZYVkyT29pMENsaW0wQ2NWWnhMWXp3WXBrRlpUeDFsUFBJL0xEaDZOR002YU1hZHh5b1RDdUlxWXIzZ1JoU0UwVytNb25wWlhKaHJkT3pwTHB6dE1yOXJGeXNEekFzQWN5ODhXRThxZjM2TC9VL2NlMmptMXVYTmdwWld5OXl6R0lFRlNnbFR3MWF3QlFWYzRTNUR4UlJLWHpDQmlFbHlmTWlJbFNsWmRnckdJeEtOaTRQdUhSMXlHaXp4SWZBMFZHTm13ZWF1dEdvK3ExcDRzOWQ0aDY1TmFOdUFhSkpZVkRZVnJscHRWWUFlWCtCMFgwMk0rZnZYWDF1YlhicHl1Z0wwMWtjYkc2V2xKVWxTcjd0RkJMcWN4eHo3QndQRHhzR0E1czcvYnhTcGlyemEycGtmN2ZPRENBdGJZa2dWS1ZoZmExaXNGWnc1ODQrT3pzempPck51ZktIZGRRZmRzRGhCVkpoUkpPeUFzY0tJQmNpOFpMbHpBN211OXZQREs0Rk1aK2VUb0pzYnZkUTI4cXdOVEdyM1lyaGU5L2IwMGJoOGxaZkRBa2JFc2xIRWtxVFlPZnVoR3BVMEI4V2tESlBibGxZbXRyejl1czc3RDBjNzgxbWVpdkNYODRTTDdWQitheU5QNklJMm10bjJsZHJCWkNMWUVrQWlDSEZadWJ2YjE4Yi9mcXNqczlNNjhCd1ZHRkRJalM1VjJveWovRTczMzd3NkprWE5tMi9aMHVaUjJnaU1RZmJCRFc2YzMrYTFyYjZaamdvS2NRZ0N0UGpSdC82L24xNWRPZGdiOTdvbjB4cS9WT3Z2QXFNNldpaUMyaGhSS1dsL2wydEZVQXUwakt6aVp2MmUwVzl0bDU5Ym5iWWpBNGZ6ckFKK3Uza3c3MzcwNGUzZmpMKzhZMVBiei9mRXltTVMwU2ZpQUZVRFNFbC82UFg5bVpiMTBaVldWaHBKZzMzZnJUSDdlL2RrOE9IeDRlTjU2LzJqOUxYWW1LSDNQazY2NEFqV2NtdDY4MnE5THdDeUFWMHR4U1FnOTNaM2JXMU1xNk5xcy9NeDAxdmYyY3F2a21xMXVxci83WHp5dHJWdGZMNjlmV1A5Wk9TWENJbHBhUkhvUU5jN2Nldi9XRG53WlhuMXpjUDd4L2JIMy8zTm51M2QvRk52RGYzZk9uUlh2eUtEN3JiV280VHR3cUloVURQNURIZHVOb3ZLNEJjd0ZnRVd2S1RnOTM2MW1pOTB0R2wvcThhb1RjWk4vTGczbVR2MWx0SEwxMTVkdlI1RFhGci9Hakc0YU1KZXcvR0hPN08yTGx6d08wZlA5eTljMmY4aHB2VTEvZHZQU3pEMUtIS25abVhQM3U0SDc4YWdoNENreTQ0akVFSEEwTy9iL1N6bFhLcldXMldEK01xTHZqOUxXajFCVERPUlg3d1B3Ky8vS25QWDVzOSs4emc5MUY5N3NGUERsNE9QaDBlM05xN3N2dUdhNXRXRXRHSExCVWRFbzNUeVhUQ3EwY1B3aGMyK2xJRmxXOGUxK25MQjhmK2xaUTRic0ZSdDc4ckdDTnFCQjBOTFlPQjRWcy9XZG1PbFFXNWFKRzZQR1pKRkVneHF0dTVPNzVabGVZT3BMV0hPL1hmYm0zMVh5d0lYL1F1U0VxcUlTYUpJWkZpWnFvU2ExNmZPZjUrVVBCcE1mS052YkgrOGVFNC9iY3FreVZ3UkFHMXhxZ0N2VjVPQzQ4bks0Q3NMTWhGODY4VXJNMGtoREZxNklJRThLLy9jUCtmUnNQaXBndmFiRy8zZjlPN3VBODZFS1VrYWY2WEtjNm5LWm52eEJCL05HMzRvK041ZXIyZTZ3Nm5naStMSnNRb2dvcEJVMHhzWEZsamIzZXkyaUVmOG5XaG00cCs2M2Mvd2l2ZnVFdU0yaDAxUGRFREJFb1I2YSt0RlpjdDZRVnI5Ym8xUEJ1ak5qSEhGZk9VMkprSGVjdDVQZUtVeVNOMG5oY3NKZHJ5WDVOVzJhclZlaG9BTWhpV3hKQnc3cVRidHp0aTJ1V1g2aXFvTHVheWx4bkZ1OEJZdkw2d1NBQXFzcHBCWGEybkNDQS80NTY3VEI5RjUyR1czTEhZc1JRTDB1bkUrVFBncTdWYVR6MUF1dmU5VEY3UWxXYnV5b0NrcGE5WHdGaXQvOWNBZVJKWW5oanpyMEN4V3U5bS9TOVpoWlpJQ1Zma1F3QUFBRXAwUlZoMFkyOXRiV1Z1ZEFCR2FXeGxJSE52ZFhKalpUb2dhSFIwY0RvdkwyVnVMbmRwYTJsd1pXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9sUk5UbFJTWVhCb1lXVnNNakF4TWk1d2JtZWtiWC9IQUFBQUpYUkZXSFJrWVhSbE9tTnlaV0YwWlFBeU1ERTFMVEF6TFRBM1ZESXpPalV3T2pRMkt6QXdPakF3cFRicE1nQUFBQ1YwUlZoMFpHRjBaVHB0YjJScFpua0FNakF4TlMwd015MHdOMVF5TXpvMU1EbzBOaXN3TURvd01OUnJVWTRBQUFCR2RFVllkSE52Wm5SM1lYSmxBRWx0WVdkbFRXRm5hV05ySURZdU5pNDVMVGNnTWpBeE5DMHdNeTB3TmlCUk1UWWdhSFIwY0RvdkwzZDNkeTVwYldGblpXMWhaMmxqYXk1dmNtZUIwN1BEQUFBQUdIUkZXSFJVYUhWdFlqbzZSRzlqZFcxbGJuUTZPbEJoWjJWekFER24vN3N2QUFBQUdIUkZXSFJVYUhWdFlqbzZTVzFoWjJVNk9taGxhV2RvZEFBek5UUkpVa3pTQUFBQUYzUkZXSFJVYUhWdFlqbzZTVzFoWjJVNk9sZHBaSFJvQURJNE1WSDQvNm9BQUFBWmRFVllkRlJvZFcxaU9qcE5hVzFsZEhsd1pRQnBiV0ZuWlM5d2JtYy9zbFpPQUFBQUYzUkZXSFJVYUhWdFlqbzZUVlJwYldVQU1UUXlOVGMzTWpJME5yZEQ3ME1BQUFBU2RFVllkRlJvZFcxaU9qcFRhWHBsQURFMU5FdENRczRNVnRzQUFBQXpkRVZZZEZSb2RXMWlPanBWVWtrQVptbHNaVG92THk5MGJYQXZiRzlqWVd4amIzQjVYMlJtWmpVd1pERTBPVE5rWmkweExuQnVaL1pYRW8wQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL3JhcGhhZWwucG5nXG4gKiogbW9kdWxlIGlkID0gMzA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoJy4vX2lzSG9zdE9iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==